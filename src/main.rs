// Module declarations
pub mod encoding;
pub mod telnet;
pub mod spell;
pub mod input;
pub mod util;
pub mod websocket;
pub mod ansi_music;

// Re-export commonly used types from modules
pub use encoding::{Encoding, Theme, WorldSwitchMode, convert_discord_emojis, is_visually_empty, is_ansi_only_line, strip_non_sgr_sequences};
pub use telnet::{
    WriteCommand, StreamReader, StreamWriter, AutoConnectType, KeepAliveType,
    process_telnet, find_safe_split_point,
    TELNET_IAC, TELNET_NOP, TELNET_GA,
};
pub use spell::{SpellChecker, SpellState};
pub use input::InputArea;
pub use util::{get_binary_name, strip_ansi_codes, visual_line_count, get_current_time_12hr, strip_mud_tag, truncate_str, convert_temperatures};
pub use websocket::{
    WsMessage, WorldStateMsg, WorldSettingsMsg, GlobalSettingsMsg, TimestampedLine,
    WsClientInfo, WebSocketServer,
    hash_password, is_ip_in_allow_list, start_websocket_server,
};

use std::collections::{HashMap, HashSet};
use std::io::{self, stdout, BufRead, Write as IoWrite};
use std::os::unix::io::{AsRawFd, FromRawFd, RawFd};
use std::os::unix::fs::PermissionsExt;
use std::path::PathBuf;
use std::sync::atomic::{AtomicPtr, AtomicU32, Ordering};
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use aes_gcm::{
    aead::{Aead, KeyInit},
    Aes256Gcm, Nonce,
};
use base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};
use bytes::BytesMut;
use crossterm::{
    cursor,
    event::{Event, EventStream, KeyCode, KeyEvent, KeyModifiers},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen, Clear, ClearType},
};
use futures::StreamExt;
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Color, Modifier, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph},
    Frame, Terminal,
};
use regex::RegexBuilder;
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::{TcpListener, TcpStream},
    sync::mpsc,
    signal::unix::{signal, SignalKind},
};
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

// Rustls danger module for accepting invalid certificates (MUD servers often have self-signed certs)
#[cfg(feature = "rustls-backend")]
mod danger {
    use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
    use rustls::pki_types::{CertificateDer, ServerName, UnixTime};
    use rustls::{DigitallySignedStruct, Error, SignatureScheme};

    #[derive(Debug)]
    pub struct NoCertificateVerification;

    impl NoCertificateVerification {
        pub fn new() -> Self {
            Self
        }
    }

    impl ServerCertVerifier for NoCertificateVerification {
        fn verify_server_cert(
            &self,
            _end_entity: &CertificateDer<'_>,
            _intermediates: &[CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            _now: UnixTime,
        ) -> Result<ServerCertVerified, Error> {
            Ok(ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            _message: &[u8],
            _cert: &CertificateDer<'_>,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn verify_tls13_signature(
            &self,
            _message: &[u8],
            _cert: &CertificateDer<'_>,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            vec![
                SignatureScheme::RSA_PKCS1_SHA256,
                SignatureScheme::RSA_PKCS1_SHA384,
                SignatureScheme::RSA_PKCS1_SHA512,
                SignatureScheme::ECDSA_NISTP256_SHA256,
                SignatureScheme::ECDSA_NISTP384_SHA384,
                SignatureScheme::ECDSA_NISTP521_SHA512,
                SignatureScheme::RSA_PSS_SHA256,
                SignatureScheme::RSA_PSS_SHA384,
                SignatureScheme::RSA_PSS_SHA512,
                SignatureScheme::ED25519,
            ]
        }
    }
}

// ============================================================================
// HTTPS Web Interface Server
// ============================================================================

/// HTTPS server state for the web interface
#[cfg(feature = "native-tls-backend")]
struct HttpsServer {
    running: Arc<RwLock<bool>>,
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
    port: u16,
}

#[cfg(feature = "native-tls-backend")]
impl HttpsServer {
    fn new(port: u16) -> Self {
        Self {
            running: Arc::new(RwLock::new(false)),
            shutdown_tx: None,
            port,
        }
    }
}

/// Embedded HTML for the web interface
#[cfg(feature = "native-tls-backend")]
const WEB_INDEX_HTML: &str = include_str!("web/index.html");

/// Embedded CSS for the web interface
#[cfg(feature = "native-tls-backend")]
const WEB_STYLE_CSS: &str = include_str!("web/style.css");

/// Embedded JavaScript for the web interface
#[cfg(feature = "native-tls-backend")]
const WEB_APP_JS: &str = include_str!("web/app.js");

/// Embedded clay.png for the web interface menu icon
#[cfg(feature = "native-tls-backend")]
const WEB_CLAY_PNG: &[u8] = include_bytes!("../clay.png");

/// Parse an HTTP request line and return the method and path
#[cfg(feature = "native-tls-backend")]
fn parse_http_request(request: &str) -> Option<(&str, &str)> {
    let first_line = request.lines().next()?;
    let mut parts = first_line.split_whitespace();
    let method = parts.next()?;
    let path = parts.next()?;
    Some((method, path))
}

/// Build an HTTP response with the given status, content type, and body
#[cfg(feature = "native-tls-backend")]
fn build_http_response(status: u16, status_text: &str, content_type: &str, body: &str) -> Vec<u8> {
    format!(
        "HTTP/1.1 {} {}\r\n\
         Content-Type: {}; charset=utf-8\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\
         \r\n\
         {}",
        status, status_text, content_type, body.len(), body
    ).into_bytes()
}

/// Build an HTTP response with binary body (for images)
#[cfg(feature = "native-tls-backend")]
fn build_http_response_binary(status: u16, status_text: &str, content_type: &str, body: &[u8]) -> Vec<u8> {
    let header = format!(
        "HTTP/1.1 {} {}\r\n\
         Content-Type: {}\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\
         \r\n",
        status, status_text, content_type, body.len()
    );
    let mut response = header.into_bytes();
    response.extend_from_slice(body);
    response
}

/// Handle an HTTPS connection
#[cfg(feature = "native-tls-backend")]
async fn handle_https_client(
    mut stream: tokio_native_tls::TlsStream<TcpStream>,
    ws_port: u16,
    ws_use_tls: bool,
) {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let mut buf = [0u8; 4096];
    let n = match stream.read(&mut buf).await {
        Ok(n) if n > 0 => n,
        _ => return,
    };

    let request = String::from_utf8_lossy(&buf[..n]);

    if let Some((method, path)) = parse_http_request(&request) {
        if method != "GET" {
            let response = build_http_response(405, "Method Not Allowed", "text/plain", "Method Not Allowed");
            let _ = stream.write_all(&response).await;
            return;
        }

        let response = match path {
            "/" | "/index.html" => {
                // Inject WebSocket configuration into the HTML
                let html = WEB_INDEX_HTML
                    .replace("{{WS_PORT}}", &ws_port.to_string())
                    .replace("{{WS_PROTOCOL}}", if ws_use_tls { "wss" } else { "ws" });
                build_http_response(200, "OK", "text/html", &html)
            }
            "/style.css" => {
                build_http_response(200, "OK", "text/css", WEB_STYLE_CSS)
            }
            "/app.js" => {
                build_http_response(200, "OK", "application/javascript", WEB_APP_JS)
            }
            "/clay.png" => {
                build_http_response_binary(200, "OK", "image/png", WEB_CLAY_PNG)
            }
            _ => {
                build_http_response(404, "Not Found", "text/plain", "Not Found")
            }
        };

        let _ = stream.write_all(&response).await;
    }
}

/// Start the HTTPS server
#[cfg(feature = "native-tls-backend")]
async fn start_https_server(
    server: &mut HttpsServer,
    cert_file: &str,
    key_file: &str,
    ws_port: u16,
    ws_use_tls: bool,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    use std::fs::File;
    use std::io::Read;

    // Read certificate and key
    let mut cert_data = Vec::new();
    File::open(cert_file)?.read_to_end(&mut cert_data)?;

    let mut key_data = Vec::new();
    File::open(key_file)?.read_to_end(&mut key_data)?;

    // Create identity from PEM files (same as WebSocket TLS)
    let identity = native_tls::Identity::from_pkcs8(&cert_data, &key_data)?;
    let tls_acceptor = native_tls::TlsAcceptor::new(identity)?;
    let tls_acceptor = tokio_native_tls::TlsAcceptor::from(tls_acceptor);
    let tls_acceptor = Arc::new(tls_acceptor);

    let addr = format!("0.0.0.0:{}", server.port);
    let listener = TcpListener::bind(&addr).await?;

    let (shutdown_tx, mut shutdown_rx) = tokio::sync::oneshot::channel::<()>();
    server.shutdown_tx = Some(shutdown_tx);

    let running = Arc::clone(&server.running);
    *running.write().await = true;

    tokio::spawn(async move {
        loop {
            tokio::select! {
                result = listener.accept() => {
                    match result {
                        Ok((stream, _addr)) => {
                            // Disable Nagle's algorithm for lower latency
                            let _ = stream.set_nodelay(true);
                            let tls_acceptor = tls_acceptor.clone();
                            tokio::spawn(async move {
                                if let Ok(tls_stream) = tls_acceptor.accept(stream).await {
                                    handle_https_client(tls_stream, ws_port, ws_use_tls).await;
                                }
                            });
                        }
                        Err(_) => break,
                    }
                }
                _ = &mut shutdown_rx => {
                    break;
                }
            }
        }
        *running.write().await = false;
    });

    Ok(())
}

// ============================================================================
// HTTPS Server implementation for rustls-backend
// ============================================================================

/// HTTPS server state for the web interface (rustls version)
#[cfg(feature = "rustls-backend")]
struct HttpsServer {
    running: Arc<RwLock<bool>>,
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
    port: u16,
}

#[cfg(feature = "rustls-backend")]
impl HttpsServer {
    fn new(port: u16) -> Self {
        Self {
            running: Arc::new(RwLock::new(false)),
            shutdown_tx: None,
            port,
        }
    }
}

/// Embedded HTML for the web interface (rustls version)
#[cfg(feature = "rustls-backend")]
const WEB_INDEX_HTML: &str = include_str!("web/index.html");

/// Embedded CSS for the web interface (rustls version)
#[cfg(feature = "rustls-backend")]
const WEB_STYLE_CSS: &str = include_str!("web/style.css");

/// Embedded JavaScript for the web interface (rustls version)
#[cfg(feature = "rustls-backend")]
const WEB_APP_JS: &str = include_str!("web/app.js");

/// Embedded clay.png for the web interface menu icon (rustls version)
#[cfg(feature = "rustls-backend")]
const WEB_CLAY_PNG: &[u8] = include_bytes!("../clay.png");

/// Parse an HTTP request line and return the method and path (rustls version)
#[cfg(feature = "rustls-backend")]
fn parse_http_request(request: &str) -> Option<(&str, &str)> {
    let first_line = request.lines().next()?;
    let mut parts = first_line.split_whitespace();
    let method = parts.next()?;
    let path = parts.next()?;
    Some((method, path))
}

/// Build an HTTP response with the given status, content type, and body (rustls version)
#[cfg(feature = "rustls-backend")]
fn build_http_response(status: u16, status_text: &str, content_type: &str, body: &str) -> Vec<u8> {
    format!(
        "HTTP/1.1 {} {}\r\n\
         Content-Type: {}; charset=utf-8\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\
         \r\n\
         {}",
        status, status_text, content_type, body.len(), body
    ).into_bytes()
}

/// Build an HTTP response with binary body (for images) (rustls version)
#[cfg(feature = "rustls-backend")]
fn build_http_response_binary(status: u16, status_text: &str, content_type: &str, body: &[u8]) -> Vec<u8> {
    let header = format!(
        "HTTP/1.1 {} {}\r\n\
         Content-Type: {}\r\n\
         Content-Length: {}\r\n\
         Connection: close\r\n\
         \r\n",
        status, status_text, content_type, body.len()
    );
    let mut response = header.into_bytes();
    response.extend_from_slice(body);
    response
}

/// Handle an HTTPS connection (rustls version)
#[cfg(feature = "rustls-backend")]
async fn handle_https_client(
    mut stream: tokio_rustls::server::TlsStream<TcpStream>,
    ws_port: u16,
    ws_use_tls: bool,
) {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    let mut buf = [0u8; 4096];
    let n = match stream.read(&mut buf).await {
        Ok(n) if n > 0 => n,
        _ => return,
    };

    let request = String::from_utf8_lossy(&buf[..n]);

    if let Some((method, path)) = parse_http_request(&request) {
        if method != "GET" {
            let response = build_http_response(405, "Method Not Allowed", "text/plain", "Method Not Allowed");
            let _ = stream.write_all(&response).await;
            return;
        }

        let response = match path {
            "/" | "/index.html" => {
                // Inject WebSocket configuration into the HTML
                let html = WEB_INDEX_HTML
                    .replace("{{WS_PORT}}", &ws_port.to_string())
                    .replace("{{WS_PROTOCOL}}", if ws_use_tls { "wss" } else { "ws" });
                build_http_response(200, "OK", "text/html", &html)
            }
            "/style.css" => {
                build_http_response(200, "OK", "text/css", WEB_STYLE_CSS)
            }
            "/app.js" => {
                build_http_response(200, "OK", "application/javascript", WEB_APP_JS)
            }
            "/clay.png" => {
                build_http_response_binary(200, "OK", "image/png", WEB_CLAY_PNG)
            }
            _ => {
                build_http_response(404, "Not Found", "text/plain", "Not Found")
            }
        };

        let _ = stream.write_all(&response).await;
    }
}

/// Start the HTTPS server (rustls version)
#[cfg(feature = "rustls-backend")]
async fn start_https_server(
    server: &mut HttpsServer,
    cert_file: &str,
    key_file: &str,
    ws_port: u16,
    ws_use_tls: bool,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    use std::fs::File;
    use std::io::BufReader;
    use rustls_pemfile::{certs, private_key};

    // Read certificate chain
    let cert_file_handle = File::open(cert_file)
        .map_err(|e| format!("Failed to open cert file '{}': {}", cert_file, e))?;
    let mut cert_reader = BufReader::new(cert_file_handle);
    let certs: Vec<rustls::pki_types::CertificateDer<'static>> = certs(&mut cert_reader)
        .filter_map(|r| r.ok())
        .collect();

    if certs.is_empty() {
        return Err(format!("No certificates found in cert file '{}'", cert_file).into());
    }

    // Read private key
    let key_file_handle = File::open(key_file)
        .map_err(|e| format!("Failed to open key file '{}': {}", key_file, e))?;
    let mut key_reader = BufReader::new(key_file_handle);
    let key = private_key(&mut key_reader)
        .map_err(|e| format!("Failed to parse key file '{}': {}", key_file, e))?
        .ok_or_else(|| format!("No private key found in key file '{}'", key_file))?;

    // Build TLS config
    let config = rustls::ServerConfig::builder()
        .with_no_client_auth()
        .with_single_cert(certs, key)
        .map_err(|e| format!("Failed to build TLS config: {}", e))?;

    let tls_acceptor = tokio_rustls::TlsAcceptor::from(Arc::new(config));

    let addr = format!("0.0.0.0:{}", server.port);
    let listener = TcpListener::bind(&addr).await
        .map_err(|e| format!("Failed to bind to port {}: {}", server.port, e))?;

    let (shutdown_tx, mut shutdown_rx) = tokio::sync::oneshot::channel::<()>();
    server.shutdown_tx = Some(shutdown_tx);

    let running = Arc::clone(&server.running);
    *running.write().await = true;

    tokio::spawn(async move {
        loop {
            tokio::select! {
                result = listener.accept() => {
                    match result {
                        Ok((stream, _addr)) => {
                            // Disable Nagle's algorithm for lower latency
                            let _ = stream.set_nodelay(true);
                            let tls_acceptor = tls_acceptor.clone();
                            tokio::spawn(async move {
                                if let Ok(tls_stream) = tls_acceptor.accept(stream).await {
                                    handle_https_client(tls_stream, ws_port, ws_use_tls).await;
                                }
                            });
                        }
                        Err(_) => break,
                    }
                }
                _ = &mut shutdown_rx => {
                    break;
                }
            }
        }
        *running.write().await = false;
    });

    Ok(())
}

// ============================================================================
// Ban List for HTTP/WebSocket security
// ============================================================================

/// Tracks violations and bans for IP addresses
#[derive(Clone)]
pub struct BanList {
    /// Permanently banned IPs (saved to .dat file)
    permanent_bans: Arc<std::sync::RwLock<HashSet<String>>>,
    /// Temporary bans: IP -> expiration time (Unix timestamp)
    temp_bans: Arc<std::sync::RwLock<HashMap<String, u64>>>,
    /// Violation tracking: IP -> list of violation timestamps
    violations: Arc<std::sync::RwLock<HashMap<String, Vec<u64>>>>,
    /// Ban reasons: IP -> last URL/reason that caused the ban
    ban_reasons: Arc<std::sync::RwLock<HashMap<String, String>>>,
}

impl BanList {
    pub fn new() -> Self {
        Self {
            permanent_bans: Arc::new(std::sync::RwLock::new(HashSet::new())),
            temp_bans: Arc::new(std::sync::RwLock::new(HashMap::new())),
            violations: Arc::new(std::sync::RwLock::new(HashMap::new())),
            ban_reasons: Arc::new(std::sync::RwLock::new(HashMap::new())),
        }
    }

    /// Check if an IP is currently banned (permanent or temporary)
    pub fn is_banned(&self, ip: &str) -> bool {
        // Check permanent bans
        if self.permanent_bans.read().unwrap().contains(ip) {
            return true;
        }
        // Check temporary bans
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        if let Some(&expiry) = self.temp_bans.read().unwrap().get(ip) {
            if now < expiry {
                return true;
            }
        }
        false
    }

    /// Record a violation for an IP address with a reason (URL or description)
    /// Returns true if the IP should be banned (5+ violations in 1 hour = permanent)
    pub fn record_violation(&self, ip: &str, reason: &str) -> bool {
        // Never ban localhost
        if ip == "127.0.0.1" || ip == "::1" || ip == "localhost" {
            return false;
        }

        // Store the reason for this violation
        self.ban_reasons.write().unwrap().insert(ip.to_string(), reason.to_string());

        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        let one_hour_ago = now.saturating_sub(3600);

        let mut violations = self.violations.write().unwrap();
        let ip_violations = violations.entry(ip.to_string()).or_default();

        // Remove old violations (older than 1 hour)
        ip_violations.retain(|&ts| ts > one_hour_ago);

        // Add new violation
        ip_violations.push(now);

        let violation_count = ip_violations.len();

        if violation_count >= 5 {
            // Permanent ban
            self.permanent_bans.write().unwrap().insert(ip.to_string());
            violations.remove(ip); // Clear violations since permanently banned
            true
        } else if violation_count >= 3 {
            // Temporary ban (5 minutes) after 3+ violations
            self.temp_bans.write().unwrap().insert(ip.to_string(), now + 300);
            true
        } else {
            false
        }
    }

    /// Add a permanent ban directly
    pub fn add_permanent_ban(&self, ip: &str) {
        self.permanent_bans.write().unwrap().insert(ip.to_string());
    }

    /// Get all permanent bans (for saving to .dat file)
    pub fn get_permanent_bans(&self) -> Vec<String> {
        self.permanent_bans.read().unwrap().iter().cloned().collect()
    }

    /// Clean up expired temporary bans
    pub fn cleanup_expired(&self) {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        self.temp_bans.write().unwrap().retain(|_, &mut expiry| expiry > now);
    }

    /// Remove a ban (both permanent and temporary) for an IP
    /// Returns true if a ban was removed
    pub fn remove_ban(&self, ip: &str) -> bool {
        let removed_perm = self.permanent_bans.write().unwrap().remove(ip);
        let removed_temp = self.temp_bans.write().unwrap().remove(ip).is_some();
        // Also clear violations and reason
        self.violations.write().unwrap().remove(ip);
        self.ban_reasons.write().unwrap().remove(ip);
        removed_perm || removed_temp
    }

    /// Get all current bans with their reasons
    /// Returns Vec of (ip, ban_type, reason) where ban_type is "permanent" or "temporary"
    pub fn get_ban_info(&self) -> Vec<(String, String, String)> {
        let mut result = Vec::new();
        let reasons = self.ban_reasons.read().unwrap();

        // Get permanent bans
        for ip in self.permanent_bans.read().unwrap().iter() {
            let reason = reasons.get(ip).cloned().unwrap_or_default();
            result.push((ip.clone(), "permanent".to_string(), reason));
        }

        // Get active temporary bans
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs();
        for (ip, expiry) in self.temp_bans.read().unwrap().iter() {
            if *expiry > now {
                let reason = reasons.get(ip).cloned().unwrap_or_default();
                result.push((ip.clone(), "temporary".to_string(), reason));
            }
        }

        result
    }
}

impl Default for BanList {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// HTTP Web Interface Server (no TLS)
// ============================================================================

/// HTTP server state for the web interface (no TLS)
struct HttpServer {
    running: Arc<RwLock<bool>>,
    shutdown_tx: Option<tokio::sync::oneshot::Sender<()>>,
    port: u16,
}

impl HttpServer {
    fn new(port: u16) -> Self {
        Self {
            running: Arc::new(RwLock::new(false)),
            shutdown_tx: None,
            port,
        }
    }
}

/// Handle an HTTP connection (plain TCP, no TLS)
/// Returns true if a violation occurred (404 access)
async fn handle_http_client(
    mut stream: TcpStream,
    ws_port: u16,
    ws_use_tls: bool,
    ban_list: BanList,
    client_ip: String,
) {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};

    // Check if IP is banned
    if ban_list.is_banned(&client_ip) {
        // Send minimal response and close
        let _ = stream.write_all(b"HTTP/1.1 403 Forbidden\r\nContent-Length: 7\r\nConnection: close\r\n\r\nBanned\n").await;
        return;
    }

    let mut buf = [0u8; 4096];
    let n = match stream.read(&mut buf).await {
        Ok(n) if n > 0 => n,
        _ => return,
    };

    let request = String::from_utf8_lossy(&buf[..n]);

    // Reuse the parse function from either TLS backend
    fn parse_request(request: &str) -> Option<(&str, &str)> {
        let first_line = request.lines().next()?;
        let mut parts = first_line.split_whitespace();
        let method = parts.next()?;
        let path = parts.next()?;
        Some((method, path))
    }

    fn build_response(status: u16, status_text: &str, content_type: &str, body: &str) -> Vec<u8> {
        format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: {}; charset=utf-8\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n\
             {}",
            status, status_text, content_type, body.len(), body
        ).into_bytes()
    }

    fn build_response_binary(status: u16, status_text: &str, content_type: &str, body: &[u8]) -> Vec<u8> {
        let header = format!(
            "HTTP/1.1 {} {}\r\n\
             Content-Type: {}\r\n\
             Content-Length: {}\r\n\
             Connection: close\r\n\
             \r\n",
            status, status_text, content_type, body.len()
        );
        let mut response = header.into_bytes();
        response.extend_from_slice(body);
        response
    }

    if let Some((method, path)) = parse_request(&request) {
        if method != "GET" {
            let response = build_response(405, "Method Not Allowed", "text/plain", "Method Not Allowed");
            let _ = stream.write_all(&response).await;
            return;
        }

        // Read embedded files at compile time
        const HTTP_INDEX_HTML: &str = include_str!("web/index.html");
        const HTTP_STYLE_CSS: &str = include_str!("web/style.css");
        const HTTP_APP_JS: &str = include_str!("web/app.js");
        const HTTP_CLAY_PNG: &[u8] = include_bytes!("../clay.png");

        let response = match path {
            "/" | "/index.html" => {
                // Inject WebSocket configuration into the HTML
                let html = HTTP_INDEX_HTML
                    .replace("{{WS_PORT}}", &ws_port.to_string())
                    .replace("{{WS_PROTOCOL}}", if ws_use_tls { "wss" } else { "ws" });
                build_response(200, "OK", "text/html", &html)
            }
            "/style.css" => {
                build_response(200, "OK", "text/css", HTTP_STYLE_CSS)
            }
            "/app.js" => {
                build_response(200, "OK", "application/javascript", HTTP_APP_JS)
            }
            "/clay.png" => {
                build_response_binary(200, "OK", "image/png", HTTP_CLAY_PNG)
            }
            _ => {
                // Record violation for accessing non-existent page
                ban_list.record_violation(&client_ip, path);
                build_response(404, "Not Found", "text/plain", "Not Found")
            }
        };

        let _ = stream.write_all(&response).await;
    }
}

/// Start the HTTP server (plain TCP, no TLS)
async fn start_http_server(
    server: &mut HttpServer,
    ws_port: u16,
    ws_use_tls: bool,
    ban_list: BanList,
) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    let addr = format!("0.0.0.0:{}", server.port);
    let listener = TcpListener::bind(&addr).await
        .map_err(|e| format!("Failed to bind HTTP to port {}: {}", server.port, e))?;

    let (shutdown_tx, mut shutdown_rx) = tokio::sync::oneshot::channel::<()>();
    server.shutdown_tx = Some(shutdown_tx);

    let running = Arc::clone(&server.running);
    *running.write().await = true;

    tokio::spawn(async move {
        loop {
            tokio::select! {
                result = listener.accept() => {
                    match result {
                        Ok((mut stream, addr)) => {
                            let client_ip = addr.ip().to_string();
                            // Check if banned before processing
                            if ban_list.is_banned(&client_ip) {
                                // Send minimal response and close
                                let _ = stream.write_all(b"HTTP/1.1 403 Forbidden\r\nContent-Length: 7\r\nConnection: close\r\n\r\nBanned\n").await;
                                continue;
                            }
                            // Disable Nagle's algorithm for lower latency
                            let _ = stream.set_nodelay(true);
                            let ban_list_clone = ban_list.clone();
                            tokio::spawn(async move {
                                handle_http_client(stream, ws_port, ws_use_tls, ban_list_clone, client_ip).await;
                            });
                        }
                        Err(_) => break,
                    }
                }
                _ = &mut shutdown_rx => {
                    break;
                }
            }
        }
        *running.write().await = false;
    });

    Ok(())
}


#[derive(Clone, Copy, PartialEq)]
enum SettingsField {
    // World-specific fields
    WorldName,
    WorldType,      // Mud, Slack, or Discord
    // MUD-specific fields
    Hostname,
    Port,
    User,
    Password,
    UseSsl,
    LogFile,
    Encoding,
    AutoConnect,
    KeepAlive,
    KeepAliveCmd,
    // Slack-specific fields
    SlackToken,
    SlackChannel,
    SlackWorkspace,
    // Discord-specific fields
    DiscordToken,
    DiscordGuild,
    DiscordChannel,
    DiscordDmUser,
    // Buttons
    Connect,
    SaveWorld,
    CancelWorld,
    DeleteWorld,
    // Global settings (setup menu)
    MoreMode,
    SpellCheck,
    WorldSwitching,
    Debug,
    ShowTags,
    InputHeight,
    GuiTheme,       // GUI theme
    TLSProxy,       // TLS proxy for connection preservation over hot reload
    SaveSetup,
    CancelSetup,
}

impl SettingsField {
    fn is_text_field(&self) -> bool {
        matches!(
            self,
            SettingsField::WorldName
                | SettingsField::Hostname
                | SettingsField::Port
                | SettingsField::User
                | SettingsField::Password
                | SettingsField::KeepAliveCmd
                | SettingsField::SlackToken
                | SettingsField::SlackChannel
                | SettingsField::SlackWorkspace
                | SettingsField::DiscordToken
                | SettingsField::DiscordGuild
                | SettingsField::DiscordChannel
                | SettingsField::DiscordDmUser
        )
    }

    fn is_button(&self) -> bool {
        matches!(self, SettingsField::Connect | SettingsField::SaveWorld | SettingsField::CancelWorld | SettingsField::DeleteWorld | SettingsField::SaveSetup | SettingsField::CancelSetup)
    }

    /// Next field for world settings popup
    /// world_type determines which fields are visible
    /// skip_keep_alive_cmd is true if keep_alive_type is not Custom
    fn next_world(&self, world_type: &WorldType, skip_keep_alive_cmd: bool) -> Self {
        match world_type {
            WorldType::Mud => match self {
                SettingsField::WorldName => SettingsField::WorldType,
                SettingsField::WorldType => SettingsField::Hostname,
                SettingsField::Hostname => SettingsField::Port,
                SettingsField::Port => SettingsField::User,
                SettingsField::User => SettingsField::Password,
                SettingsField::Password => SettingsField::UseSsl,
                SettingsField::UseSsl => SettingsField::LogFile,
                SettingsField::LogFile => SettingsField::Encoding,
                SettingsField::Encoding => SettingsField::AutoConnect,
                SettingsField::AutoConnect => SettingsField::KeepAlive,
                SettingsField::KeepAlive => {
                    if skip_keep_alive_cmd {
                        SettingsField::SaveWorld
                    } else {
                        SettingsField::KeepAliveCmd
                    }
                }
                SettingsField::KeepAliveCmd => SettingsField::SaveWorld,
                SettingsField::SaveWorld => SettingsField::CancelWorld,
                SettingsField::CancelWorld => SettingsField::DeleteWorld,
                SettingsField::DeleteWorld => SettingsField::Connect,
                SettingsField::Connect => SettingsField::WorldName,
                _ => SettingsField::WorldName,
            },
            WorldType::Slack => match self {
                SettingsField::WorldName => SettingsField::WorldType,
                SettingsField::WorldType => SettingsField::SlackToken,
                SettingsField::SlackToken => SettingsField::SlackChannel,
                SettingsField::SlackChannel => SettingsField::SlackWorkspace,
                SettingsField::SlackWorkspace => SettingsField::LogFile,
                SettingsField::LogFile => SettingsField::SaveWorld,
                SettingsField::SaveWorld => SettingsField::CancelWorld,
                SettingsField::CancelWorld => SettingsField::DeleteWorld,
                SettingsField::DeleteWorld => SettingsField::Connect,
                SettingsField::Connect => SettingsField::WorldName,
                _ => SettingsField::WorldName,
            },
            WorldType::Discord => match self {
                SettingsField::WorldName => SettingsField::WorldType,
                SettingsField::WorldType => SettingsField::DiscordToken,
                SettingsField::DiscordToken => SettingsField::DiscordGuild,
                SettingsField::DiscordGuild => SettingsField::DiscordChannel,
                SettingsField::DiscordChannel => SettingsField::DiscordDmUser,
                SettingsField::DiscordDmUser => SettingsField::LogFile,
                SettingsField::LogFile => SettingsField::SaveWorld,
                SettingsField::SaveWorld => SettingsField::CancelWorld,
                SettingsField::CancelWorld => SettingsField::DeleteWorld,
                SettingsField::DeleteWorld => SettingsField::Connect,
                SettingsField::Connect => SettingsField::WorldName,
                _ => SettingsField::WorldName,
            },
        }
    }

    /// Previous field for world settings popup
    /// world_type determines which fields are visible
    /// skip_keep_alive_cmd is true if keep_alive_type is not Custom
    fn prev_world(&self, world_type: &WorldType, skip_keep_alive_cmd: bool) -> Self {
        match world_type {
            WorldType::Mud => match self {
                SettingsField::WorldName => SettingsField::Connect,
                SettingsField::WorldType => SettingsField::WorldName,
                SettingsField::Hostname => SettingsField::WorldType,
                SettingsField::Port => SettingsField::Hostname,
                SettingsField::User => SettingsField::Port,
                SettingsField::Password => SettingsField::User,
                SettingsField::UseSsl => SettingsField::Password,
                SettingsField::LogFile => SettingsField::UseSsl,
                SettingsField::Encoding => SettingsField::LogFile,
                SettingsField::AutoConnect => SettingsField::Encoding,
                SettingsField::KeepAlive => SettingsField::AutoConnect,
                SettingsField::KeepAliveCmd => SettingsField::KeepAlive,
                SettingsField::SaveWorld => {
                    if skip_keep_alive_cmd {
                        SettingsField::KeepAlive
                    } else {
                        SettingsField::KeepAliveCmd
                    }
                }
                SettingsField::CancelWorld => SettingsField::SaveWorld,
                SettingsField::DeleteWorld => SettingsField::CancelWorld,
                SettingsField::Connect => SettingsField::DeleteWorld,
                _ => SettingsField::Connect,
            },
            WorldType::Slack => match self {
                SettingsField::WorldName => SettingsField::Connect,
                SettingsField::WorldType => SettingsField::WorldName,
                SettingsField::SlackToken => SettingsField::WorldType,
                SettingsField::SlackChannel => SettingsField::SlackToken,
                SettingsField::SlackWorkspace => SettingsField::SlackChannel,
                SettingsField::LogFile => SettingsField::SlackWorkspace,
                SettingsField::SaveWorld => SettingsField::LogFile,
                SettingsField::CancelWorld => SettingsField::SaveWorld,
                SettingsField::DeleteWorld => SettingsField::CancelWorld,
                SettingsField::Connect => SettingsField::DeleteWorld,
                _ => SettingsField::Connect,
            },
            WorldType::Discord => match self {
                SettingsField::WorldName => SettingsField::Connect,
                SettingsField::WorldType => SettingsField::WorldName,
                SettingsField::DiscordToken => SettingsField::WorldType,
                SettingsField::DiscordGuild => SettingsField::DiscordToken,
                SettingsField::DiscordChannel => SettingsField::DiscordGuild,
                SettingsField::DiscordDmUser => SettingsField::DiscordChannel,
                SettingsField::LogFile => SettingsField::DiscordDmUser,
                SettingsField::SaveWorld => SettingsField::LogFile,
                SettingsField::CancelWorld => SettingsField::SaveWorld,
                SettingsField::DeleteWorld => SettingsField::CancelWorld,
                SettingsField::Connect => SettingsField::DeleteWorld,
                _ => SettingsField::Connect,
            },
        }
    }

    /// Next field for setup (global) menu
    fn next_setup(&self) -> Self {
        match self {
            SettingsField::MoreMode => SettingsField::SpellCheck,
            SettingsField::SpellCheck => SettingsField::WorldSwitching,
            SettingsField::WorldSwitching => SettingsField::Debug,
            SettingsField::Debug => SettingsField::ShowTags,
            SettingsField::ShowTags => SettingsField::InputHeight,
            SettingsField::InputHeight => SettingsField::GuiTheme,
            SettingsField::GuiTheme => SettingsField::TLSProxy,
            SettingsField::TLSProxy => SettingsField::SaveSetup,
            SettingsField::SaveSetup => SettingsField::CancelSetup,
            SettingsField::CancelSetup => SettingsField::MoreMode,
            // World fields wrap to global fields
            _ => SettingsField::MoreMode,
        }
    }

    /// Previous field for setup (global) menu
    fn prev_setup(&self) -> Self {
        match self {
            SettingsField::MoreMode => SettingsField::CancelSetup,
            SettingsField::SpellCheck => SettingsField::MoreMode,
            SettingsField::WorldSwitching => SettingsField::SpellCheck,
            SettingsField::Debug => SettingsField::WorldSwitching,
            SettingsField::ShowTags => SettingsField::Debug,
            SettingsField::InputHeight => SettingsField::ShowTags,
            SettingsField::GuiTheme => SettingsField::InputHeight,
            SettingsField::TLSProxy => SettingsField::GuiTheme,
            SettingsField::SaveSetup => SettingsField::TLSProxy,
            SettingsField::CancelSetup => SettingsField::SaveSetup,
            // World fields wrap to global fields
            _ => SettingsField::CancelSetup,
        }
    }
}

struct SettingsPopup {
    visible: bool,
    selected_field: SettingsField,
    editing: bool,
    edit_buffer: String,
    edit_cursor: usize,
    edit_scroll_offset: usize, // Horizontal scroll offset for long text fields
    setup_mode: bool, // True for /setup (global only), false for /worlds (all settings)
    editing_world_index: Option<usize>, // Which world is being edited (None for setup mode)
    // Temp values for world-specific fields
    temp_world_name: String,
    temp_world_type: WorldType,
    // MUD settings
    temp_hostname: String,
    temp_port: String,
    temp_user: String,
    temp_password: String,
    temp_use_ssl: bool,
    temp_log_enabled: bool,
    temp_encoding: Encoding,
    temp_auto_connect_type: AutoConnectType,
    temp_keep_alive_type: KeepAliveType,
    temp_keep_alive_cmd: String,
    // Slack settings
    temp_slack_token: String,
    temp_slack_channel: String,
    temp_slack_workspace: String,
    // Discord settings
    temp_discord_token: String,
    temp_discord_guild: String,
    temp_discord_channel: String,
    temp_discord_dm_user: String,
    // Temp values for global settings
    temp_more_mode: bool,
    temp_spell_check: bool,
    temp_world_switch_mode: WorldSwitchMode,
    temp_debug_enabled: bool,
    temp_show_tags: bool,
    temp_input_height: u16,
    temp_theme: Theme,
    temp_gui_theme: Theme,
    temp_tls_proxy_enabled: bool,
}

impl SettingsPopup {
    fn new() -> Self {
        Self {
            visible: false,
            selected_field: SettingsField::WorldName,
            editing: false,
            edit_buffer: String::new(),
            edit_cursor: 0,
            edit_scroll_offset: 0,
            setup_mode: false,
            editing_world_index: None,
            temp_world_name: String::new(),
            temp_world_type: WorldType::Mud,
            temp_hostname: String::new(),
            temp_port: String::new(),
            temp_user: String::new(),
            temp_password: String::new(),
            temp_use_ssl: false,
            temp_log_enabled: false,
            temp_encoding: Encoding::Utf8,
            temp_auto_connect_type: AutoConnectType::Connect,
            temp_keep_alive_type: KeepAliveType::Nop,
            temp_keep_alive_cmd: String::new(),
            temp_slack_token: String::new(),
            temp_slack_channel: String::new(),
            temp_slack_workspace: String::new(),
            temp_discord_token: String::new(),
            temp_discord_guild: String::new(),
            temp_discord_channel: String::new(),
            temp_discord_dm_user: String::new(),
            temp_more_mode: true,
            temp_spell_check: true,
            temp_world_switch_mode: WorldSwitchMode::UnseenFirst,
            temp_debug_enabled: false,
            temp_show_tags: false,
            temp_input_height: 3,
            temp_theme: Theme::Dark,
            temp_gui_theme: Theme::Dark,
            temp_tls_proxy_enabled: false,
        }
    }

    fn open(&mut self, settings: &Settings, world: &World, world_index: usize, input_height: u16, show_tags: bool) {
        self.visible = true;
        self.setup_mode = false;
        self.editing_world_index = Some(world_index);
        self.selected_field = SettingsField::WorldName;
        self.editing = false;
        // Load from world settings
        self.temp_world_name = world.name.clone();
        self.temp_world_type = world.settings.world_type.clone();
        // MUD settings
        self.temp_hostname = world.settings.hostname.clone();
        self.temp_port = world.settings.port.clone();
        self.temp_user = world.settings.user.clone();
        self.temp_password = world.settings.password.clone();
        self.temp_use_ssl = world.settings.use_ssl;
        self.temp_log_enabled = world.settings.log_enabled;
        self.temp_encoding = world.settings.encoding;
        self.temp_auto_connect_type = world.settings.auto_connect_type;
        self.temp_keep_alive_type = world.settings.keep_alive_type;
        self.temp_keep_alive_cmd = world.settings.keep_alive_cmd.clone();
        // Slack settings
        self.temp_slack_token = world.settings.slack_token.clone();
        self.temp_slack_channel = world.settings.slack_channel.clone();
        self.temp_slack_workspace = world.settings.slack_workspace.clone();
        // Discord settings
        self.temp_discord_token = world.settings.discord_token.clone();
        self.temp_discord_guild = world.settings.discord_guild.clone();
        self.temp_discord_channel = world.settings.discord_channel.clone();
        self.temp_discord_dm_user = world.settings.discord_dm_user.clone();
        // Load from global settings
        self.temp_more_mode = settings.more_mode_enabled;
        self.temp_spell_check = settings.spell_check_enabled;
        self.temp_world_switch_mode = settings.world_switch_mode;
        self.temp_show_tags = show_tags;
        self.temp_input_height = input_height;
    }

    fn open_setup(&mut self, settings: &Settings, input_height: u16, show_tags: bool) {
        self.visible = true;
        self.setup_mode = true;
        self.editing_world_index = None;
        self.selected_field = SettingsField::MoreMode;
        self.editing = false;
        // Load from global settings only
        self.temp_more_mode = settings.more_mode_enabled;
        self.temp_spell_check = settings.spell_check_enabled;
        self.temp_world_switch_mode = settings.world_switch_mode;
        self.temp_debug_enabled = settings.debug_enabled;
        self.temp_show_tags = show_tags;
        self.temp_input_height = input_height;
        self.temp_theme = settings.theme;
        self.temp_gui_theme = settings.gui_theme;
        self.temp_tls_proxy_enabled = settings.tls_proxy_enabled;
    }

    fn close(&mut self) {
        self.visible = false;
        self.editing = false;
    }

    fn next_field(&mut self) {
        if self.setup_mode {
            self.selected_field = self.selected_field.next_setup();
        } else {
            let skip_cmd = self.temp_keep_alive_type != KeepAliveType::Custom;
            self.selected_field = self.selected_field.next_world(&self.temp_world_type, skip_cmd);
        }
    }

    fn prev_field(&mut self) {
        if self.setup_mode {
            self.selected_field = self.selected_field.prev_setup();
        } else {
            let skip_cmd = self.temp_keep_alive_type != KeepAliveType::Custom;
            self.selected_field = self.selected_field.prev_world(&self.temp_world_type, skip_cmd);
        }
    }

    fn start_edit(&mut self) {
        self.editing = true;
        self.edit_buffer = match self.selected_field {
            SettingsField::WorldName => self.temp_world_name.clone(),
            SettingsField::Hostname => self.temp_hostname.clone(),
            SettingsField::Port => self.temp_port.clone(),
            SettingsField::User => self.temp_user.clone(),
            SettingsField::Password => self.temp_password.clone(),
            SettingsField::KeepAliveCmd => self.temp_keep_alive_cmd.clone(),
            SettingsField::SlackToken => self.temp_slack_token.clone(),
            SettingsField::SlackChannel => self.temp_slack_channel.clone(),
            SettingsField::SlackWorkspace => self.temp_slack_workspace.clone(),
            SettingsField::DiscordToken => self.temp_discord_token.clone(),
            SettingsField::DiscordGuild => self.temp_discord_guild.clone(),
            SettingsField::DiscordChannel => self.temp_discord_channel.clone(),
            SettingsField::DiscordDmUser => self.temp_discord_dm_user.clone(),
            _ => String::new(),
        };
        self.edit_cursor = self.edit_buffer.len();
        self.edit_scroll_offset = 0; // Reset scroll when starting edit
    }

    /// Adjust scroll offset to keep cursor visible within given visible width
    fn adjust_scroll(&mut self, visible_width: usize) {
        if visible_width == 0 {
            return;
        }
        // Keep cursor visible with some margin
        let margin = 2.min(visible_width / 4);
        if self.edit_cursor < self.edit_scroll_offset + margin {
            // Cursor is before visible area, scroll left
            self.edit_scroll_offset = self.edit_cursor.saturating_sub(margin);
        } else if self.edit_cursor >= self.edit_scroll_offset + visible_width - margin {
            // Cursor is after visible area, scroll right
            self.edit_scroll_offset = self.edit_cursor.saturating_sub(visible_width - margin - 1);
        }
    }

    fn commit_edit(&mut self) {
        match self.selected_field {
            SettingsField::WorldName => self.temp_world_name = self.edit_buffer.clone(),
            SettingsField::Hostname => self.temp_hostname = self.edit_buffer.clone(),
            SettingsField::Port => self.temp_port = self.edit_buffer.clone(),
            SettingsField::User => self.temp_user = self.edit_buffer.clone(),
            SettingsField::Password => self.temp_password = self.edit_buffer.clone(),
            SettingsField::KeepAliveCmd => self.temp_keep_alive_cmd = self.edit_buffer.clone(),
            SettingsField::SlackToken => self.temp_slack_token = self.edit_buffer.clone(),
            SettingsField::SlackChannel => self.temp_slack_channel = self.edit_buffer.clone(),
            SettingsField::SlackWorkspace => self.temp_slack_workspace = self.edit_buffer.clone(),
            SettingsField::DiscordToken => self.temp_discord_token = self.edit_buffer.clone(),
            SettingsField::DiscordGuild => self.temp_discord_guild = self.edit_buffer.clone(),
            SettingsField::DiscordChannel => self.temp_discord_channel = self.edit_buffer.clone(),
            SettingsField::DiscordDmUser => self.temp_discord_dm_user = self.edit_buffer.clone(),
            _ => {}
        }
        self.editing = false;
    }

    fn cancel_edit(&mut self) {
        self.editing = false;
    }

    fn toggle_or_cycle(&mut self) {
        match self.selected_field {
            SettingsField::WorldType => {
                self.temp_world_type = self.temp_world_type.cycle_next();
            }
            SettingsField::UseSsl => self.temp_use_ssl = !self.temp_use_ssl,
            SettingsField::LogFile => self.temp_log_enabled = !self.temp_log_enabled,
            SettingsField::MoreMode => self.temp_more_mode = !self.temp_more_mode,
            SettingsField::SpellCheck => self.temp_spell_check = !self.temp_spell_check,
            SettingsField::WorldSwitching => self.temp_world_switch_mode = self.temp_world_switch_mode.next(),
            SettingsField::Debug => self.temp_debug_enabled = !self.temp_debug_enabled,
            SettingsField::ShowTags => self.temp_show_tags = !self.temp_show_tags,
            SettingsField::InputHeight => {
                // Cycle through 1-15
                self.temp_input_height = if self.temp_input_height >= 15 {
                    1
                } else {
                    self.temp_input_height + 1
                };
            }
            SettingsField::GuiTheme => {
                self.temp_gui_theme = self.temp_gui_theme.next();
            }
            SettingsField::TLSProxy => self.temp_tls_proxy_enabled = !self.temp_tls_proxy_enabled,
            SettingsField::Encoding => {
                self.temp_encoding = match self.temp_encoding {
                    Encoding::Utf8 => Encoding::Latin1,
                    Encoding::Latin1 => Encoding::Fansi,
                    Encoding::Fansi => Encoding::Utf8,
                };
            }
            SettingsField::AutoConnect => {
                self.temp_auto_connect_type = self.temp_auto_connect_type.next();
            }
            SettingsField::KeepAlive => {
                self.temp_keep_alive_type = self.temp_keep_alive_type.next();
            }
            _ => {}
        }
    }

    /// Apply settings and return (input_height, show_tags)
    fn apply(&self, settings: &mut Settings, world: &mut World) -> (u16, bool) {
        // Apply global settings
        settings.more_mode_enabled = self.temp_more_mode;
        settings.spell_check_enabled = self.temp_spell_check;
        settings.world_switch_mode = self.temp_world_switch_mode;
        settings.theme = self.temp_theme;
        // Apply world-specific settings (only in world mode)
        if !self.setup_mode {
            world.name = self.temp_world_name.clone();
            world.settings.world_type = self.temp_world_type.clone();
            // MUD settings
            world.settings.hostname = self.temp_hostname.clone();
            world.settings.port = self.temp_port.clone();
            world.settings.user = self.temp_user.clone();
            world.settings.password = self.temp_password.clone();
            world.settings.use_ssl = self.temp_use_ssl;
            world.settings.log_enabled = self.temp_log_enabled;
            world.settings.encoding = self.temp_encoding;
            world.settings.auto_connect_type = self.temp_auto_connect_type;
            world.settings.keep_alive_type = self.temp_keep_alive_type;
            world.settings.keep_alive_cmd = self.temp_keep_alive_cmd.clone();
            // Slack settings
            world.settings.slack_token = self.temp_slack_token.clone();
            world.settings.slack_channel = self.temp_slack_channel.clone();
            world.settings.slack_workspace = self.temp_slack_workspace.clone();
            // Discord settings
            world.settings.discord_token = self.temp_discord_token.clone();
            world.settings.discord_guild = self.temp_discord_guild.clone();
            world.settings.discord_channel = self.temp_discord_channel.clone();
            world.settings.discord_dm_user = self.temp_discord_dm_user.clone();
        }
        (self.temp_input_height, self.temp_show_tags)
    }

    fn apply_global(&self, settings: &mut Settings) -> (u16, bool) {
        // Apply only global settings (for setup mode)
        settings.more_mode_enabled = self.temp_more_mode;
        settings.spell_check_enabled = self.temp_spell_check;
        settings.world_switch_mode = self.temp_world_switch_mode;
        settings.debug_enabled = self.temp_debug_enabled;
        settings.theme = self.temp_theme;
        settings.gui_theme = self.temp_gui_theme;
        settings.tls_proxy_enabled = self.temp_tls_proxy_enabled;
        (self.temp_input_height, self.temp_show_tags)
    }
}

// ============================================================================
// Web Settings Popup (/web command)
// ============================================================================

#[derive(Clone, Copy, PartialEq, Debug)]
enum WebField {
    // Protocol selection (Secure/Non-Secure)
    Protocol,
    // HTTP/HTTPS server
    HttpEnabled,
    HttpPort,
    // WebSocket server
    WsEnabled,
    WsPort,
    WsPassword,
    WsAllowList,
    // TLS settings (only shown when Protocol is Secure)
    WsCertFile,
    WsKeyFile,
    // Buttons
    SaveWeb,
    CancelWeb,
}

impl WebField {
    fn is_text_field(&self) -> bool {
        matches!(
            self,
            WebField::HttpPort
                | WebField::WsPort
                | WebField::WsPassword
                | WebField::WsAllowList
                | WebField::WsCertFile
                | WebField::WsKeyFile
        )
    }

    fn is_button(&self) -> bool {
        matches!(self, WebField::SaveWeb | WebField::CancelWeb)
    }

    /// Get next field, skipping TLS fields when not secure
    fn next(&self, secure: bool) -> Self {
        match self {
            WebField::Protocol => WebField::HttpEnabled,
            WebField::HttpEnabled => WebField::HttpPort,
            WebField::HttpPort => WebField::WsEnabled,
            WebField::WsEnabled => WebField::WsPort,
            WebField::WsPort => WebField::WsPassword,
            WebField::WsPassword => WebField::WsAllowList,
            WebField::WsAllowList => {
                if secure { WebField::WsCertFile } else { WebField::SaveWeb }
            }
            WebField::WsCertFile => WebField::WsKeyFile,
            WebField::WsKeyFile => WebField::SaveWeb,
            WebField::SaveWeb => WebField::CancelWeb,
            WebField::CancelWeb => WebField::Protocol,
        }
    }

    /// Get previous field, skipping TLS fields when not secure
    fn prev(&self, secure: bool) -> Self {
        match self {
            WebField::Protocol => WebField::CancelWeb,
            WebField::HttpEnabled => WebField::Protocol,
            WebField::HttpPort => WebField::HttpEnabled,
            WebField::WsEnabled => WebField::HttpPort,
            WebField::WsPort => WebField::WsEnabled,
            WebField::WsPassword => WebField::WsPort,
            WebField::WsAllowList => WebField::WsPassword,
            WebField::WsCertFile => WebField::WsAllowList,
            WebField::WsKeyFile => WebField::WsCertFile,
            WebField::SaveWeb => {
                if secure { WebField::WsKeyFile } else { WebField::WsAllowList }
            }
            WebField::CancelWeb => WebField::SaveWeb,
        }
    }
}

struct WebPopup {
    visible: bool,
    selected_field: WebField,
    editing: bool,
    edit_buffer: String,
    edit_cursor: usize,
    edit_scroll_offset: usize,
    // Temp values for web settings (consolidated)
    temp_web_secure: bool,     // Protocol: true=Secure, false=Non-Secure
    temp_http_enabled: bool,
    temp_http_port: String,
    temp_ws_enabled: bool,
    temp_ws_port: String,
    temp_ws_password: String,
    temp_ws_allow_list: String,
    temp_ws_cert_file: String,
    temp_ws_key_file: String,
}

impl WebPopup {
    fn new() -> Self {
        Self {
            visible: false,
            selected_field: WebField::Protocol,
            editing: false,
            edit_buffer: String::new(),
            edit_cursor: 0,
            edit_scroll_offset: 0,
            temp_web_secure: false,
            temp_http_enabled: false,
            temp_http_port: "9000".to_string(),
            temp_ws_enabled: false,
            temp_ws_port: "9001".to_string(),
            temp_ws_password: String::new(),
            temp_ws_allow_list: String::new(),
            temp_ws_cert_file: String::new(),
            temp_ws_key_file: String::new(),
        }
    }

    fn open(&mut self, settings: &Settings) {
        self.visible = true;
        self.selected_field = WebField::Protocol;
        self.editing = false;
        // Load from settings
        self.temp_web_secure = settings.web_secure;
        self.temp_http_enabled = settings.http_enabled;
        self.temp_http_port = settings.http_port.to_string();
        self.temp_ws_enabled = settings.ws_enabled;
        self.temp_ws_port = settings.ws_port.to_string();
        self.temp_ws_password = settings.websocket_password.clone();
        self.temp_ws_allow_list = settings.websocket_allow_list.clone();
        self.temp_ws_cert_file = settings.websocket_cert_file.clone();
        self.temp_ws_key_file = settings.websocket_key_file.clone();
    }

    fn close(&mut self) {
        self.visible = false;
        self.editing = false;
    }

    fn next_field(&mut self) {
        self.selected_field = self.selected_field.next(self.temp_web_secure);
    }

    fn prev_field(&mut self) {
        self.selected_field = self.selected_field.prev(self.temp_web_secure);
    }

    fn start_edit(&mut self) {
        self.editing = true;
        self.edit_buffer = match self.selected_field {
            WebField::HttpPort => self.temp_http_port.clone(),
            WebField::WsPort => self.temp_ws_port.clone(),
            WebField::WsPassword => self.temp_ws_password.clone(),
            WebField::WsAllowList => self.temp_ws_allow_list.clone(),
            WebField::WsCertFile => self.temp_ws_cert_file.clone(),
            WebField::WsKeyFile => self.temp_ws_key_file.clone(),
            _ => String::new(),
        };
        self.edit_cursor = self.edit_buffer.len();
        self.edit_scroll_offset = 0;
    }

    fn commit_edit(&mut self) {
        match self.selected_field {
            WebField::HttpPort => self.temp_http_port = self.edit_buffer.clone(),
            WebField::WsPort => self.temp_ws_port = self.edit_buffer.clone(),
            WebField::WsPassword => self.temp_ws_password = self.edit_buffer.clone(),
            WebField::WsAllowList => self.temp_ws_allow_list = self.edit_buffer.clone(),
            WebField::WsCertFile => self.temp_ws_cert_file = self.edit_buffer.clone(),
            WebField::WsKeyFile => self.temp_ws_key_file = self.edit_buffer.clone(),
            _ => {}
        }
        self.editing = false;
    }

    fn cancel_edit(&mut self) {
        self.editing = false;
    }

    fn toggle_option(&mut self) {
        match self.selected_field {
            WebField::Protocol => self.temp_web_secure = !self.temp_web_secure,
            WebField::HttpEnabled => self.temp_http_enabled = !self.temp_http_enabled,
            WebField::WsEnabled => self.temp_ws_enabled = !self.temp_ws_enabled,
            _ => {}
        }
    }

    /// Adjust scroll offset to keep cursor visible within given visible width
    fn adjust_scroll(&mut self, visible_width: usize) {
        if visible_width == 0 {
            return;
        }
        let margin = 2.min(visible_width / 4);
        if self.edit_cursor < self.edit_scroll_offset + margin {
            self.edit_scroll_offset = self.edit_cursor.saturating_sub(margin);
        } else if self.edit_cursor >= self.edit_scroll_offset + visible_width - margin {
            self.edit_scroll_offset = self.edit_cursor.saturating_sub(visible_width - margin - 1);
        }
    }

    fn apply(&self, settings: &mut Settings) {
        settings.web_secure = self.temp_web_secure;
        settings.http_enabled = self.temp_http_enabled;
        if let Ok(port) = self.temp_http_port.parse::<u16>() {
            settings.http_port = port;
        }
        settings.ws_enabled = self.temp_ws_enabled;
        if let Ok(port) = self.temp_ws_port.parse::<u16>() {
            settings.ws_port = port;
        }
        settings.websocket_password = self.temp_ws_password.clone();
        settings.websocket_allow_list = self.temp_ws_allow_list.clone();
        settings.websocket_cert_file = self.temp_ws_cert_file.clone();
        settings.websocket_key_file = self.temp_ws_key_file.clone();
    }
}

#[derive(Clone, Copy, PartialEq)]
enum WorldSelectorFocus {
    List,
    AddButton,
    EditButton,
    DeleteButton,
    ConnectButton,
    CancelButton,
}

struct WorldSelectorPopup {
    visible: bool,
    selected_index: usize,
    filter: String,
    filter_cursor: usize,
    editing_filter: bool,
    focus: WorldSelectorFocus,
    confirm_delete: bool,           // True when showing delete confirmation
    confirm_delete_selected: bool,  // True = Yes, False = No
}

impl WorldSelectorPopup {
    fn new() -> Self {
        Self {
            visible: false,
            selected_index: 0,
            filter: String::new(),
            filter_cursor: 0,
            editing_filter: false,
            focus: WorldSelectorFocus::List,
            confirm_delete: false,
            confirm_delete_selected: false,
        }
    }

    fn open(&mut self, current_world_index: usize) {
        self.visible = true;
        self.selected_index = current_world_index;
        self.filter.clear();
        self.filter_cursor = 0;
        self.editing_filter = false;
        self.focus = WorldSelectorFocus::List;
        self.confirm_delete = false;
        self.confirm_delete_selected = false;
    }

    fn close(&mut self) {
        self.visible = false;
        self.editing_filter = false;
        self.confirm_delete = false;
    }

    fn next_focus(&mut self) {
        self.focus = match self.focus {
            WorldSelectorFocus::List => WorldSelectorFocus::AddButton,
            WorldSelectorFocus::AddButton => WorldSelectorFocus::EditButton,
            WorldSelectorFocus::EditButton => WorldSelectorFocus::DeleteButton,
            WorldSelectorFocus::DeleteButton => WorldSelectorFocus::ConnectButton,
            WorldSelectorFocus::ConnectButton => WorldSelectorFocus::CancelButton,
            WorldSelectorFocus::CancelButton => WorldSelectorFocus::List,
        };
    }

    fn prev_focus(&mut self) {
        self.focus = match self.focus {
            WorldSelectorFocus::List => WorldSelectorFocus::CancelButton,
            WorldSelectorFocus::AddButton => WorldSelectorFocus::List,
            WorldSelectorFocus::EditButton => WorldSelectorFocus::AddButton,
            WorldSelectorFocus::DeleteButton => WorldSelectorFocus::EditButton,
            WorldSelectorFocus::ConnectButton => WorldSelectorFocus::DeleteButton,
            WorldSelectorFocus::CancelButton => WorldSelectorFocus::ConnectButton,
        };
    }

    /// Get indices of worlds matching the filter
    fn filtered_indices(&self, worlds: &[World]) -> Vec<usize> {
        if self.filter.is_empty() {
            (0..worlds.len()).collect()
        } else {
            let filter_lower = self.filter.to_lowercase();
            worlds
                .iter()
                .enumerate()
                .filter(|(_, w)| {
                    w.name.to_lowercase().contains(&filter_lower)
                        || w.settings.hostname.to_lowercase().contains(&filter_lower)
                        || w.settings.user.to_lowercase().contains(&filter_lower)
                })
                .map(|(i, _)| i)
                .collect()
        }
    }

    /// Move up in the list. Returns true if at top (should go to buttons).
    fn move_up(&mut self, worlds: &[World]) -> bool {
        let indices = self.filtered_indices(worlds);
        if indices.is_empty() {
            return true;
        }
        // Find current position in filtered list
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos > 0 {
                self.selected_index = indices[pos - 1];
                false
            } else {
                true // At top, signal to go to buttons
            }
        } else if !indices.is_empty() {
            self.selected_index = indices[0];
            false
        } else {
            true
        }
    }

    /// Move down in the list. Returns true if at bottom (should go to buttons).
    fn move_down(&mut self, worlds: &[World]) -> bool {
        let indices = self.filtered_indices(worlds);
        if indices.is_empty() {
            return true;
        }
        // Find current position in filtered list
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos < indices.len() - 1 {
                self.selected_index = indices[pos + 1];
                false
            } else {
                true // At bottom, signal to go to buttons
            }
        } else if !indices.is_empty() {
            self.selected_index = indices[0];
            false
        } else {
            true
        }
    }

    /// Move to the last item in the filtered list
    fn move_to_last(&mut self, worlds: &[World]) {
        let indices = self.filtered_indices(worlds);
        if !indices.is_empty() {
            self.selected_index = indices[indices.len() - 1];
        }
    }

    /// Move to the first item in the filtered list
    fn move_to_first(&mut self, worlds: &[World]) {
        let indices = self.filtered_indices(worlds);
        if !indices.is_empty() {
            self.selected_index = indices[0];
        }
    }

    fn start_filter_edit(&mut self) {
        self.editing_filter = true;
        self.filter_cursor = self.filter.len();
    }

    fn stop_filter_edit(&mut self) {
        self.editing_filter = false;
    }
}

struct ConfirmDialog {
    visible: bool,
    message: String,
    yes_selected: bool,
    action: ConfirmAction,
}

#[derive(Clone, Copy, PartialEq)]
enum ConfirmAction {
    None,
    DeleteWorld(usize), // world index to delete
}

impl ConfirmDialog {
    fn new() -> Self {
        Self {
            visible: false,
            message: String::new(),
            yes_selected: false,
            action: ConfirmAction::None,
        }
    }

    fn show_delete_world(&mut self, world_name: &str, world_index: usize) {
        self.visible = true;
        self.message = format!("Delete world '{}'?", world_name);
        self.yes_selected = false; // Default to No for safety
        self.action = ConfirmAction::DeleteWorld(world_index);
    }

    fn close(&mut self) {
        self.visible = false;
        self.action = ConfirmAction::None;
    }
}

/// Popup to display connected worlds status (from /connections command)
struct WorldsPopup {
    visible: bool,
    lines: Vec<String>,
}

impl WorldsPopup {
    fn new() -> Self {
        Self {
            visible: false,
            lines: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn show(&mut self, worlds: &[World], current_world_index: usize, screen_width: u16) {
        self.visible = true;
        self.lines.clear();

        // Helper to format elapsed time
        fn format_elapsed(instant: Option<std::time::Instant>) -> String {
            match instant {
                None => "-".to_string(),
                Some(t) => {
                    let secs = t.elapsed().as_secs();
                    if secs < 60 {
                        format!("{}s", secs)
                    } else if secs < 3600 {
                        format!("{}m", secs / 60)
                    } else if secs < 86400 {
                        format!("{}h", secs / 3600)
                    } else {
                        format!("{}d", secs / 86400)
                    }
                }
            }
        }

        // Helper to format time until next NOP
        fn format_next_nop(last_send_time: Option<std::time::Instant>, last_receive_time: Option<std::time::Instant>) -> String {
            const KEEPALIVE_SECS: u64 = 5 * 60;
            let last_activity = match (last_send_time, last_receive_time) {
                (Some(s), Some(r)) => Some(s.max(r)),
                (Some(s), None) => Some(s),
                (None, Some(r)) => Some(r),
                (None, None) => None,
            };
            let elapsed = last_activity.map(|t| t.elapsed().as_secs()).unwrap_or(KEEPALIVE_SECS);
            let remaining = KEEPALIVE_SECS.saturating_sub(elapsed);
            if remaining < 60 {
                format!("{}s", remaining)
            } else {
                format!("{}m", remaining / 60)
            }
        }

        // Collect connected world info
        let connected_info: Vec<_> = worlds.iter().enumerate()
            .filter(|(_, w)| w.connected)
            .map(|(i, w)| {
                (
                    if i == current_world_index { "*" } else { " " },
                    w.name.clone(),
                    if w.unseen_lines > 0 { w.unseen_lines.to_string() } else { String::new() },
                    format_elapsed(w.last_user_command_time),
                    format_elapsed(w.last_receive_time),
                    w.settings.keep_alive_type.name().to_string(),
                    format_elapsed(w.last_nop_time),
                    format_next_nop(w.last_send_time, w.last_receive_time),
                )
            })
            .collect();

        if connected_info.is_empty() {
            self.lines.push("No worlds connected.".to_string());
        } else {
            // Calculate column widths
            let name_width = connected_info.iter().map(|(_, n, _, _, _, _, _, _)| n.len()).max().unwrap_or(5).max(5);
            let unseen_width = connected_info.iter().map(|(_, _, u, _, _, _, _, _)| u.len()).max().unwrap_or(6).max(6);
            let send_width = connected_info.iter().map(|(_, _, _, s, _, _, _, _)| s.len()).max().unwrap_or(8).max(8);
            let recv_width = connected_info.iter().map(|(_, _, _, _, r, _, _, _)| r.len()).max().unwrap_or(8).max(8);
            let ka_width = connected_info.iter().map(|(_, _, _, _, _, k, _, _)| k.len()).max().unwrap_or(9).max(9);
            let nop_width = connected_info.iter().map(|(_, _, _, _, _, _, n, _)| n.len()).max().unwrap_or(6).max(6);
            let next_width = connected_info.iter().map(|(_, _, _, _, _, _, _, p)| p.len()).max().unwrap_or(6).max(6);

            // Calculate combined column widths
            let send_recv_combined_width = connected_info.iter()
                .map(|(_, _, _, s, r, _, _, _)| format!("{}/{}", s, r).len())
                .max().unwrap_or(9).max(9);
            let ka_next_combined_width = connected_info.iter()
                .map(|(_, _, _, _, _, _, lk, nk)| format!("{}/{}", lk, nk).len())
                .max().unwrap_or(7).max(7);

            // Calculate total widths for different layouts
            // Layout 1: All columns separate
            let width_full = 2 + name_width + 2 + unseen_width + 2 + send_width + 2 + recv_width + 2 + ka_width + 2 + nop_width + 2 + next_width;
            // Layout 2: Combine Send/Recv AND LastKA/NextKA
            let width_combined_both = 2 + name_width + 2 + unseen_width + 2 + send_recv_combined_width + 2 + ka_width + 2 + ka_next_combined_width;
            // Layout 3: Remove KeepAlive column
            let width_no_ka_type = 2 + name_width + 2 + unseen_width + 2 + send_recv_combined_width + 2 + ka_next_combined_width;
            // Layout 4: Remove LastKA/NextKA columns entirely
            let _width_minimal = 2 + name_width + 2 + unseen_width + 2 + send_recv_combined_width;

            let available = screen_width as usize;

            // Determine which layout to use
            let layout = if available >= width_full {
                1  // Full layout
            } else if available >= width_combined_both {
                2  // Combined Send/Recv and LastKA/NextKA
            } else if available >= width_no_ka_type {
                3  // Remove KeepAlive type column
            } else {
                4  // Remove KA columns entirely (or fallback to minimal)
            };

            // Generate header and data based on layout
            match layout {
                1 => {
                    // Full layout: all columns separate
                    self.lines.push(format!(
                        "  {:name_width$}  {:>unseen_width$}  {:>send_width$}  {:>recv_width$}  {:ka_width$}  {:>nop_width$}  {:>next_width$}",
                        "World", "Unseen", "LastSend", "LastRecv", "KeepAlive", "LastKA", "NextKA",
                    ));
                    for (current, name, unseen, send, recv, ka_type, last_ka, next_ka) in &connected_info {
                        self.lines.push(format!(
                            "{} {:name_width$}  {:>unseen_width$}  {:>send_width$}  {:>recv_width$}  {:ka_width$}  {:>nop_width$}  {:>next_width$}",
                            current, name, unseen, send, recv, ka_type, last_ka, next_ka,
                        ));
                    }
                }
                2 => {
                    // Combined Send/Recv and LastKA/NextKA
                    self.lines.push(format!(
                        "  {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}  {:ka_width$}  {:>ka_next_combined_width$}",
                        "World", "Unseen", "Send/Recv", "KeepAlive", "KA/Next",
                    ));
                    for (current, name, unseen, send, recv, ka_type, last_ka, next_ka) in &connected_info {
                        let sr = format!("{}/{}", send, recv);
                        let kn = format!("{}/{}", last_ka, next_ka);
                        self.lines.push(format!(
                            "{} {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}  {:ka_width$}  {:>ka_next_combined_width$}",
                            current, name, unseen, sr, ka_type, kn,
                        ));
                    }
                }
                3 => {
                    // Remove KeepAlive type column
                    self.lines.push(format!(
                        "  {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}  {:>ka_next_combined_width$}",
                        "World", "Unseen", "Send/Recv", "KA/Next",
                    ));
                    for (current, name, unseen, send, recv, _ka_type, last_ka, next_ka) in &connected_info {
                        let sr = format!("{}/{}", send, recv);
                        let kn = format!("{}/{}", last_ka, next_ka);
                        self.lines.push(format!(
                            "{} {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}  {:>ka_next_combined_width$}",
                            current, name, unseen, sr, kn,
                        ));
                    }
                }
                _ => {
                    // Minimal: Remove KA columns entirely
                    self.lines.push(format!(
                        "  {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}",
                        "World", "Unseen", "Send/Recv",
                    ));
                    for (current, name, unseen, send, recv, _ka_type, _last_ka, _next_ka) in &connected_info {
                        let sr = format!("{}/{}", send, recv);
                        self.lines.push(format!(
                            "{} {:name_width$}  {:>unseen_width$}  {:>send_recv_combined_width$}",
                            current, name, unseen, sr,
                        ));
                    }
                }
            }
        }
    }

    fn close(&mut self) {
        self.visible = false;
        self.lines.clear();
    }
}

struct FilterPopup {
    visible: bool,
    filter_text: String,
    cursor: usize,
    filtered_indices: Vec<usize>,  // Indices of matching lines in output_lines
    scroll_offset: usize,          // Scroll position within filtered results
}

impl FilterPopup {
    fn new() -> Self {
        Self {
            visible: false,
            filter_text: String::new(),
            cursor: 0,
            filtered_indices: Vec::new(),
            scroll_offset: 0,
        }
    }

    fn open(&mut self) {
        self.visible = true;
        self.filter_text.clear();
        self.cursor = 0;
        self.filtered_indices.clear();
        self.scroll_offset = 0;
    }

    fn close(&mut self) {
        self.visible = false;
        self.filter_text.clear();
        self.filtered_indices.clear();
        self.scroll_offset = 0;
    }

    fn update_filter(&mut self, output_lines: &[OutputLine]) {
        if self.filter_text.is_empty() {
            self.filtered_indices = (0..output_lines.len()).collect();
        } else {
            let filter_lower = self.filter_text.to_lowercase();
            self.filtered_indices = output_lines
                .iter()
                .enumerate()
                .filter(|(_, line)| {
                    // Strip ANSI codes for matching
                    let plain = strip_ansi_codes(&line.text);
                    plain.to_lowercase().contains(&filter_lower)
                })
                .map(|(i, _)| i)
                .collect();
        }
        // Reset scroll to end (most recent matches)
        self.scroll_offset = self.filtered_indices.len().saturating_sub(1);
    }
}

struct HelpPopup {
    visible: bool,
    scroll_offset: usize,
    lines: Vec<&'static str>,
}

impl HelpPopup {
    fn new() -> Self {
        Self {
            visible: false,
            scroll_offset: 0,
            lines: vec![
                "Commands:",
                "  /help                      Show this help",
                "  /disconnect (or /dc)       Disconnect from server",
                "  /connect [host port [ssl]] Connect to server",
                "  /send [-W] [-w<world>] [-n] <text>",
                "                             Send text to world(s)",
                "  /worlds                    Open world selector",
                "  /worlds <name>             Connect to or create world",
                "  /worlds -e [name]          Edit world settings",
                "  /worlds -l <name>          Connect without auto-login",
                "  /connections (or /l)       List connected worlds",
                "  /keepalive                 Show keepalive settings",
                "  /actions [world]           Open actions editor",
                "  /gag <pattern>             Gag lines matching pattern",
                "  /setup                     Open global settings",
                "  /web                       Open web/WebSocket settings",
                "  /menu                      Open menu popup",
                "  /flush                     Clear output buffer",
                "  /reload                    Hot reload binary",
                "  /quit                      Exit client",
                "",
                "World Switching:",
                "  Up/Down                    Switch worlds",
                "",
                "Input:",
                "  Left/Right, Ctrl+B/F       Move cursor",
                "  Ctrl+Up/Down               Resize input area",
                "  Ctrl+U                     Clear input",
                "  Ctrl+W                     Delete word",
                "  Ctrl+P/N                   Command history",
                "  Ctrl+Q                     Spell suggestions",
                "  Home/End                   Jump to start/end",
                "",
                "Output:",
                "  PageUp/PageDown            Scroll output",
                "  Tab                        Release one screenful",
                "  Alt+j                      Jump to end",
                "  Alt+w                      Switch to oldest pending world",
                "  F4                         Filter output",
                "",
                "General:",
                "  F1                         Show this help",
                "  F2                         Toggle MUD tag display",
                "  F8                         Toggle action highlighting",
                "  Ctrl+L                     Redraw screen",
                "  Ctrl+R                     Hot reload",
                "  Ctrl+C (x2)                Quit",
            ],
        }
    }

    fn open(&mut self) {
        self.visible = true;
        self.scroll_offset = 0;
    }

    fn close(&mut self) {
        self.visible = false;
    }

    fn scroll_up(&mut self) {
        self.scroll_offset = self.scroll_offset.saturating_sub(1);
    }

    fn scroll_down(&mut self, visible_height: usize) {
        let max_offset = self.lines.len().saturating_sub(visible_height);
        if self.scroll_offset < max_offset {
            self.scroll_offset += 1;
        }
    }
}

/// Menu item for the menu popup
#[derive(Clone, Copy, PartialEq)]
enum MenuItem {
    Help,
    Setup,
    WebSettings,
    Actions,
    WorldSelector,
    ConnectedWorlds,
}

impl MenuItem {
    fn all() -> &'static [MenuItem] {
        &[
            MenuItem::Help,
            MenuItem::Setup,
            MenuItem::WebSettings,
            MenuItem::Actions,
            MenuItem::WorldSelector,
            MenuItem::ConnectedWorlds,
        ]
    }

    fn label(&self) -> &'static str {
        match self {
            MenuItem::Help => "Help",
            MenuItem::Setup => "Setup",
            MenuItem::WebSettings => "Web Settings",
            MenuItem::Actions => "Actions",
            MenuItem::WorldSelector => "World Selector",
            MenuItem::ConnectedWorlds => "Connected Worlds",
        }
    }

    fn command(&self) -> &'static str {
        match self {
            MenuItem::Help => "/help",
            MenuItem::Setup => "/setup",
            MenuItem::WebSettings => "/web",
            MenuItem::Actions => "/actions",
            MenuItem::WorldSelector => "/worlds",
            MenuItem::ConnectedWorlds => "/connections",
        }
    }
}

/// Popup for selecting windows/popups
struct MenuPopup {
    visible: bool,
    selected: usize,
}

impl MenuPopup {
    fn new() -> Self {
        Self {
            visible: false,
            selected: 0,
        }
    }

    fn open(&mut self) {
        self.visible = true;
        self.selected = 0;
    }

    fn close(&mut self) {
        self.visible = false;
    }

    fn move_up(&mut self) {
        let items = MenuItem::all();
        if self.selected > 0 {
            self.selected -= 1;
        } else {
            self.selected = items.len() - 1;
        }
    }

    fn move_down(&mut self) {
        let items = MenuItem::all();
        if self.selected < items.len() - 1 {
            self.selected += 1;
        } else {
            self.selected = 0;
        }
    }

    fn selected_item(&self) -> MenuItem {
        MenuItem::all()[self.selected]
    }
}

/// Which view the actions popup is showing
#[derive(Clone, Copy, PartialEq)]
enum ActionsView {
    List,           // List of actions with Add/Edit/Delete/Cancel
    Editor,         // Editing a single action
    ConfirmDelete,  // Confirming deletion
}

/// Which field in the action list view is focused
#[derive(Clone, Copy, PartialEq)]
enum ActionListField {
    List,           // Action list (selecting which action)
    AddButton,
    EditButton,
    DeleteButton,
    CancelButton,
}

/// Which field in the action editor is focused
#[derive(Clone, Copy, PartialEq)]
enum ActionEditorField {
    Name,
    World,
    MatchType,
    Pattern,
    Command,
    SaveButton,
    CancelButton,
}

/// Popup for editing actions/triggers
struct ActionsPopup {
    visible: bool,
    view: ActionsView,              // Current view mode
    actions: Vec<Action>,           // Working copy of actions
    selected_index: usize,          // Currently selected action in list
    editing_index: Option<usize>,   // Index being edited (None = new action)
    list_field: ActionListField,    // Current field in list view
    editor_field: ActionEditorField, // Current field in editor view
    confirm_selected: bool,         // Yes (true) or No (false) in confirm dialog
    scroll_offset: usize,           // Scroll offset for action list
    // Filter state
    filter: String,                 // Filter text for action list
    filter_cursor: usize,           // Cursor position in filter
    filter_editing: bool,           // True when actively editing filter
    world_filter: String,           // Pre-set world filter from /actions <world>
    // Editing state for current action
    edit_name: String,
    edit_world: String,
    edit_match_type: MatchType,     // Pattern match type (Regexp or Wildcard)
    edit_pattern: String,
    edit_command: String,
    cursor_pos: usize,              // Cursor position in current text field
    edit_scroll_offset: usize,      // Horizontal scroll offset for long text fields
    error_message: Option<String>,  // Validation error message
    command_expanded: bool,         // Whether command field is expanded to show all lines
    command_scroll_row: usize,      // Vertical scroll offset for command mini-editor (first visible row)
}

impl ActionsPopup {
    fn new() -> Self {
        Self {
            visible: false,
            view: ActionsView::List,
            actions: Vec::new(),
            selected_index: 0,
            editing_index: None,
            list_field: ActionListField::List,
            editor_field: ActionEditorField::Name,
            confirm_selected: false,
            scroll_offset: 0,
            filter: String::new(),
            filter_cursor: 0,
            filter_editing: false,
            world_filter: String::new(),
            edit_name: String::new(),
            edit_world: String::new(),
            edit_match_type: MatchType::Regexp,
            edit_pattern: String::new(),
            edit_command: String::new(),
            cursor_pos: 0,
            edit_scroll_offset: 0,
            error_message: None,
            command_expanded: false,
            command_scroll_row: 0,
        }
    }

    fn open(&mut self, actions: &[Action]) {
        self.visible = true;
        self.view = ActionsView::List;
        self.actions = actions.to_vec();
        self.selected_index = 0;
        self.editing_index = None;
        self.list_field = ActionListField::List;
        self.scroll_offset = 0;
        self.filter.clear();
        self.filter_cursor = 0;
        self.filter_editing = false;
        self.world_filter.clear();
        self.error_message = None;
        self.command_expanded = false;
    }

    fn open_with_world_filter(&mut self, actions: &[Action], world: &str) {
        self.open(actions);
        self.world_filter = world.to_string();
        // Select first matching action
        let indices = self.filtered_indices();
        if !indices.is_empty() {
            self.selected_index = indices[0];
        }
    }

    fn close(&mut self) {
        self.visible = false;
        self.view = ActionsView::List;
        self.filter.clear();
        self.filter_cursor = 0;
        self.filter_editing = false;
        self.world_filter.clear();
        self.error_message = None;
    }

    /// Get indices of actions matching the filter
    fn filtered_indices(&self) -> Vec<usize> {
        let filter_lower = self.filter.to_lowercase();
        let world_filter_lower = self.world_filter.to_lowercase();

        self.actions.iter().enumerate()
            .filter(|(_, action)| {
                // World filter (from /actions <world>)
                if !world_filter_lower.is_empty()
                    && !action.world.to_lowercase().contains(&world_filter_lower)
                {
                    return false;
                }
                // Text filter (from filter input)
                if !filter_lower.is_empty() {
                    let name_match = action.name.to_lowercase().contains(&filter_lower);
                    let world_match = action.world.to_lowercase().contains(&filter_lower);
                    let pattern_match = action.pattern.to_lowercase().contains(&filter_lower);
                    if !name_match && !world_match && !pattern_match {
                        return false;
                    }
                }
                true
            })
            .map(|(i, _)| i)
            .collect()
    }

    fn start_filter_edit(&mut self) {
        self.filter_editing = true;
        self.list_field = ActionListField::List;
    }

    fn stop_filter_edit(&mut self) {
        self.filter_editing = false;
    }

    fn open_editor(&mut self, index: Option<usize>) {
        self.view = ActionsView::Editor;
        self.editing_index = index;
        self.editor_field = ActionEditorField::Name;
        self.error_message = None;
        self.cursor_pos = 0;
        self.edit_scroll_offset = 0;
        self.command_expanded = false;
        self.command_scroll_row = 0;

        if let Some(idx) = index {
            if let Some(action) = self.actions.get(idx) {
                self.edit_name = action.name.clone();
                self.edit_world = action.world.clone();
                self.edit_match_type = action.match_type;
                self.edit_pattern = action.pattern.clone();
                self.edit_command = action.command.clone();
            }
        } else {
            // New action
            self.edit_name.clear();
            self.edit_world.clear();
            self.edit_match_type = MatchType::Regexp;
            self.edit_pattern.clear();
            self.edit_command.clear();
        }
    }

    fn close_editor(&mut self) {
        self.view = ActionsView::List;
        self.error_message = None;
    }

    fn open_confirm_delete(&mut self) {
        if self.selected_index < self.actions.len() {
            self.view = ActionsView::ConfirmDelete;
            self.confirm_selected = false; // Default to No
        }
    }

    fn close_confirm_delete(&mut self) {
        self.view = ActionsView::List;
    }

    fn save_current_action(&mut self) -> bool {
        // Validate name
        let name = self.edit_name.trim();
        if name.is_empty() {
            self.error_message = Some("Name is required".to_string());
            return false;
        }
        if is_internal_command(name) {
            self.error_message = Some(format!("'{}' is a reserved command name", name));
            return false;
        }
        // Check for duplicate names (excluding current action if editing)
        let editing_idx = self.editing_index;
        for (i, action) in self.actions.iter().enumerate() {
            if Some(i) != editing_idx && action.name.eq_ignore_ascii_case(name) {
                self.error_message = Some(format!("Action '{}' already exists", name));
                return false;
            }
        }

        // Update or create action
        let action = Action {
            name: name.to_string(),
            world: self.edit_world.trim().to_string(),
            match_type: self.edit_match_type,
            pattern: self.edit_pattern.clone(),
            command: self.edit_command.clone(),
            owner: None,
        };

        if let Some(idx) = self.editing_index {
            // Update existing
            if idx < self.actions.len() {
                self.actions[idx] = action;
            }
        } else {
            // New action
            self.actions.push(action);
            self.selected_index = self.actions.len() - 1;
        }

        self.error_message = None;
        true
    }

    fn delete_selected_action(&mut self) {
        if self.selected_index < self.actions.len() && !self.actions.is_empty() {
            self.actions.remove(self.selected_index);
            if self.selected_index >= self.actions.len() && !self.actions.is_empty() {
                self.selected_index = self.actions.len() - 1;
            }
        }
    }

    fn current_field_text(&self) -> &str {
        match self.editor_field {
            ActionEditorField::Name => &self.edit_name,
            ActionEditorField::World => &self.edit_world,
            ActionEditorField::Pattern => &self.edit_pattern,
            ActionEditorField::Command => &self.edit_command,
            _ => "",
        }
    }

    fn insert_char(&mut self, c: char) {
        let cursor = self.cursor_pos;
        let text = match self.editor_field {
            ActionEditorField::Name => &mut self.edit_name,
            ActionEditorField::World => &mut self.edit_world,
            ActionEditorField::Pattern => &mut self.edit_pattern,
            ActionEditorField::Command => &mut self.edit_command,
            _ => return,
        };
        if cursor <= text.len() {
            text.insert(cursor, c);
            self.cursor_pos += c.len_utf8();
        }
    }

    fn delete_char(&mut self) {
        let cursor = self.cursor_pos;
        if cursor == 0 {
            return;
        }
        let text = match self.editor_field {
            ActionEditorField::Name => &mut self.edit_name,
            ActionEditorField::World => &mut self.edit_world,
            ActionEditorField::Pattern => &mut self.edit_pattern,
            ActionEditorField::Command => &mut self.edit_command,
            _ => return,
        };
        // Find the character boundary before cursor
        let mut new_pos = cursor - 1;
        while new_pos > 0 && !text.is_char_boundary(new_pos) {
            new_pos -= 1;
        }
        text.remove(new_pos);
        self.cursor_pos = new_pos;
    }

    fn move_cursor_left(&mut self) {
        if self.cursor_pos > 0 {
            let text = self.current_field_text();
            let mut new_pos = self.cursor_pos - 1;
            while new_pos > 0 && !text.is_char_boundary(new_pos) {
                new_pos -= 1;
            }
            self.cursor_pos = new_pos;
        }
    }

    fn move_cursor_right(&mut self) {
        let text = self.current_field_text();
        if self.cursor_pos < text.len() {
            let mut new_pos = self.cursor_pos + 1;
            while new_pos < text.len() && !text.is_char_boundary(new_pos) {
                new_pos += 1;
            }
            self.cursor_pos = new_pos;
        }
    }

    fn move_cursor_home(&mut self) {
        self.cursor_pos = 0;
    }

    fn move_cursor_end(&mut self) {
        self.cursor_pos = self.current_field_text().len();
    }

    /// Adjust scroll offset to keep cursor visible within given visible width
    fn adjust_scroll(&mut self, visible_width: usize) {
        if visible_width == 0 {
            return;
        }
        // Convert cursor byte position to character position
        let text = self.current_field_text();
        let cursor_char_pos = text[..self.cursor_pos.min(text.len())].chars().count();

        // Keep cursor visible with some margin
        let margin = 2.min(visible_width / 4);
        if cursor_char_pos < self.edit_scroll_offset + margin {
            // Cursor is before visible area, scroll left
            self.edit_scroll_offset = cursor_char_pos.saturating_sub(margin);
        } else if cursor_char_pos >= self.edit_scroll_offset + visible_width - margin {
            // Cursor is after visible area, scroll right
            self.edit_scroll_offset = cursor_char_pos.saturating_sub(visible_width - margin - 1);
        }
    }

    // List view field navigation
    fn next_list_field(&mut self) {
        self.list_field = match self.list_field {
            ActionListField::List => ActionListField::AddButton,
            ActionListField::AddButton => ActionListField::EditButton,
            ActionListField::EditButton => ActionListField::DeleteButton,
            ActionListField::DeleteButton => ActionListField::CancelButton,
            ActionListField::CancelButton => ActionListField::List,
        };
    }

    fn prev_list_field(&mut self) {
        self.list_field = match self.list_field {
            ActionListField::List => ActionListField::CancelButton,
            ActionListField::AddButton => ActionListField::List,
            ActionListField::EditButton => ActionListField::AddButton,
            ActionListField::DeleteButton => ActionListField::EditButton,
            ActionListField::CancelButton => ActionListField::DeleteButton,
        };
    }

    // Editor view field navigation
    fn next_editor_field(&mut self) {
        self.editor_field = match self.editor_field {
            ActionEditorField::Name => ActionEditorField::World,
            ActionEditorField::World => ActionEditorField::MatchType,
            ActionEditorField::MatchType => ActionEditorField::Pattern,
            ActionEditorField::Pattern => ActionEditorField::Command,
            ActionEditorField::Command => ActionEditorField::SaveButton,
            ActionEditorField::SaveButton => ActionEditorField::CancelButton,
            ActionEditorField::CancelButton => ActionEditorField::Name,
        };
        self.cursor_pos = self.current_field_text().len();
        self.edit_scroll_offset = 0; // Reset scroll when switching fields
    }

    fn prev_editor_field(&mut self) {
        self.editor_field = match self.editor_field {
            ActionEditorField::Name => ActionEditorField::CancelButton,
            ActionEditorField::World => ActionEditorField::Name,
            ActionEditorField::MatchType => ActionEditorField::World,
            ActionEditorField::Pattern => ActionEditorField::MatchType,
            ActionEditorField::Command => ActionEditorField::Pattern,
            ActionEditorField::SaveButton => ActionEditorField::Command,
            ActionEditorField::CancelButton => ActionEditorField::SaveButton,
        };
        self.cursor_pos = self.current_field_text().len();
        self.edit_scroll_offset = 0; // Reset scroll when switching fields
    }

    fn select_prev_action(&mut self) {
        let indices = self.filtered_indices();
        if indices.is_empty() {
            return;
        }
        // Find current position in filtered list
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos > 0 {
                self.selected_index = indices[pos - 1];
            }
        } else if !indices.is_empty() {
            // Not in filtered list, select last item
            self.selected_index = indices[indices.len() - 1];
        }
        // Update scroll offset to keep selection visible
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos < self.scroll_offset {
                self.scroll_offset = pos;
            }
        }
    }

    fn select_next_action(&mut self) {
        let indices = self.filtered_indices();
        if indices.is_empty() {
            return;
        }
        // Find current position in filtered list
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos + 1 < indices.len() {
                self.selected_index = indices[pos + 1];
            }
        } else if !indices.is_empty() {
            // Not in filtered list, select first item
            self.selected_index = indices[0];
        }
        // Update scroll offset to keep selection visible (assuming 5 visible items)
        let visible_items = 5;
        if let Some(pos) = indices.iter().position(|&i| i == self.selected_index) {
            if pos >= self.scroll_offset + visible_items {
                self.scroll_offset = pos - visible_items + 1;
            }
        }
    }

    /// Wrap command text into lines of given width
    fn wrap_command_lines(&self, width: usize) -> Vec<String> {
        if width == 0 {
            return vec![self.edit_command.clone()];
        }
        let mut lines = Vec::new();
        let mut current_line = String::new();
        let mut char_count = 0;

        for c in self.edit_command.chars() {
            if c == '\n' {
                lines.push(current_line);
                current_line = String::new();
                char_count = 0;
            } else {
                current_line.push(c);
                char_count += 1;
                if char_count >= width {
                    lines.push(current_line);
                    current_line = String::new();
                    char_count = 0;
                }
            }
        }
        lines.push(current_line);
        lines
    }

    /// Get row and column from cursor position in wrapped command text
    fn get_command_cursor_row_col(&self, width: usize) -> (usize, usize) {
        if width == 0 {
            return (0, self.cursor_pos);
        }
        let mut row = 0;
        let mut col = 0;
        let mut byte_pos = 0;

        for c in self.edit_command.chars() {
            if byte_pos >= self.cursor_pos {
                break;
            }
            if c == '\n' {
                row += 1;
                col = 0;
            } else {
                col += 1;
                if col >= width {
                    row += 1;
                    col = 0;
                }
            }
            byte_pos += c.len_utf8();
        }
        (row, col)
    }

    /// Adjust command scroll to keep cursor visible (5 visible rows)
    fn adjust_command_scroll(&mut self, width: usize) {
        let (row, _col) = self.get_command_cursor_row_col(width);
        let visible_rows = 5;

        if row < self.command_scroll_row {
            self.command_scroll_row = row;
        } else if row >= self.command_scroll_row + visible_rows {
            self.command_scroll_row = row - visible_rows + 1;
        }
    }

    /// Move cursor up one row in wrapped command text
    fn move_command_cursor_up(&mut self, width: usize) {
        if width == 0 {
            return;
        }
        let (row, col) = self.get_command_cursor_row_col(width);
        if row == 0 {
            return; // Already at top
        }

        // Find position at same column in previous row
        let lines = self.wrap_command_lines(width);
        let target_row = row - 1;
        let target_col = col.min(lines.get(target_row).map(|l| l.chars().count()).unwrap_or(0));

        // Calculate byte position
        let mut byte_pos = 0;
        let mut current_row = 0;
        let mut current_col = 0;

        for c in self.edit_command.chars() {
            if current_row == target_row && current_col == target_col {
                break;
            }
            if c == '\n' {
                current_row += 1;
                current_col = 0;
            } else {
                current_col += 1;
                if current_col >= width {
                    current_row += 1;
                    current_col = 0;
                }
            }
            byte_pos += c.len_utf8();
        }
        self.cursor_pos = byte_pos;
    }

    /// Move cursor down one row in wrapped command text
    fn move_command_cursor_down(&mut self, width: usize) {
        if width == 0 {
            return;
        }
        let (row, col) = self.get_command_cursor_row_col(width);
        let lines = self.wrap_command_lines(width);
        if row >= lines.len() - 1 {
            return; // Already at bottom
        }

        // Find position at same column in next row
        let target_row = row + 1;
        let target_col = col.min(lines.get(target_row).map(|l| l.chars().count()).unwrap_or(0));

        // Calculate byte position
        let mut byte_pos = 0;
        let mut current_row = 0;
        let mut current_col = 0;

        for c in self.edit_command.chars() {
            if current_row == target_row && current_col == target_col {
                break;
            }
            if c == '\n' {
                current_row += 1;
                current_col = 0;
            } else {
                current_col += 1;
                if current_col >= width {
                    current_row += 1;
                    current_col = 0;
                }
            }
            byte_pos += c.len_utf8();
        }
        self.cursor_pos = byte_pos.min(self.edit_command.len());
    }
}

#[derive(Clone)]
struct Settings {
    more_mode_enabled: bool,
    spell_check_enabled: bool,
    world_switch_mode: WorldSwitchMode,
    debug_enabled: bool,    // Debug logging to clay.debug.log
    ansi_music_enabled: bool, // Enable ANSI music playback (web/GUI only)
    theme: Theme,           // Console theme
    gui_theme: Theme,       // GUI theme (separate from console)
    gui_transparency: f32,  // GUI window transparency (0.0-1.0)
    // Remote GUI font settings
    font_name: String,
    font_size: f32,
    // Web server settings (consolidated)
    web_secure: bool,              // Protocol: true=Secure (https/wss), false=Non-Secure (http/ws)
    http_enabled: bool,            // Enable HTTP/HTTPS web server (name depends on web_secure)
    http_port: u16,                // Port for HTTP/HTTPS web interface
    ws_enabled: bool,              // Enable WS/WSS server (name depends on web_secure)
    ws_port: u16,                  // Port for WS/WSS server
    websocket_password: String,
    websocket_allow_list: String,  // CSV list of hosts that can be whitelisted
    websocket_whitelisted_host: Option<String>,  // Currently whitelisted host (authenticated from allow list)
    websocket_cert_file: String,   // Path to TLS certificate file (PEM) - only used when web_secure=true
    websocket_key_file: String,    // Path to TLS private key file (PEM) - only used when web_secure=true
    // User-defined actions/triggers
    actions: Vec<Action>,
    // TLS proxy for connection preservation over hot reload
    tls_proxy_enabled: bool,
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            more_mode_enabled: true,
            spell_check_enabled: true,
            world_switch_mode: WorldSwitchMode::UnseenFirst,
            debug_enabled: false,
            ansi_music_enabled: true,  // ANSI music enabled by default
            theme: Theme::Dark,
            gui_theme: Theme::Dark,
            gui_transparency: 1.0,
            font_name: String::new(),  // Empty means use system default
            font_size: 14.0,
            web_secure: false,         // Default to non-secure
            http_enabled: false,
            http_port: 9000,
            ws_enabled: false,
            ws_port: 9001,
            websocket_password: String::new(),
            websocket_allow_list: String::new(),
            websocket_whitelisted_host: None,
            websocket_cert_file: String::new(),
            websocket_key_file: String::new(),
            actions: Vec::new(),
            tls_proxy_enabled: false,
        }
    }
}

/// Type of world connection
#[derive(Clone, Debug, PartialEq, Default)]
enum WorldType {
    #[default]
    Mud,
    Slack,
    Discord,
}

impl WorldType {
    fn name(&self) -> &'static str {
        match self {
            WorldType::Mud => "mud",
            WorldType::Slack => "slack",
            WorldType::Discord => "discord",
        }
    }

    fn from_name(name: &str) -> Self {
        match name.to_lowercase().as_str() {
            "slack" => WorldType::Slack,
            "discord" => WorldType::Discord,
            _ => WorldType::Mud,
        }
    }

    fn cycle_next(&self) -> Self {
        match self {
            WorldType::Mud => WorldType::Slack,
            WorldType::Slack => WorldType::Discord,
            WorldType::Discord => WorldType::Mud,
        }
    }
}

#[derive(Clone)]
struct WorldSettings {
    world_type: WorldType,
    // MUD settings
    hostname: String,
    port: String,
    user: String,
    password: String,
    use_ssl: bool,
    log_enabled: bool,
    encoding: Encoding,
    auto_connect_type: AutoConnectType,
    keep_alive_type: KeepAliveType,
    keep_alive_cmd: String,
    // Slack settings
    slack_token: String,
    slack_channel: String,
    slack_workspace: String,
    // Discord settings
    discord_token: String,
    discord_guild: String,
    discord_channel: String,
    discord_dm_user: String, // User ID for DM (creates DM channel on connect)
}

impl Default for WorldSettings {
    fn default() -> Self {
        Self {
            world_type: WorldType::Mud,
            hostname: String::new(),
            port: String::new(),
            user: String::new(),
            password: String::new(),
            use_ssl: false,
            log_enabled: false,
            encoding: Encoding::Utf8,
            auto_connect_type: AutoConnectType::Connect,
            keep_alive_type: KeepAliveType::Nop,
            keep_alive_cmd: String::new(),
            slack_token: String::new(),
            slack_channel: String::new(),
            slack_workspace: String::new(),
            discord_token: String::new(),
            discord_guild: String::new(),
            discord_channel: String::new(),
            discord_dm_user: String::new(),
        }
    }
}

impl WorldSettings {
    /// Check if this world has enough settings to attempt a connection
    fn has_connection_settings(&self) -> bool {
        match self.world_type {
            WorldType::Mud => !self.hostname.is_empty() && !self.port.is_empty(),
            WorldType::Slack => !self.slack_token.is_empty(),
            WorldType::Discord => !self.discord_token.is_empty(),
        }
    }
}

/// Match type for action patterns
#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize, Default)]
pub enum MatchType {
    #[default]
    Regexp,     // Regular expression matching
    Wildcard,   // Glob/wildcard matching (* and ?)
}

impl MatchType {
    fn next(self) -> Self {
        match self {
            MatchType::Regexp => MatchType::Wildcard,
            MatchType::Wildcard => MatchType::Regexp,
        }
    }

    fn as_str(self) -> &'static str {
        match self {
            MatchType::Regexp => "Regexp",
            MatchType::Wildcard => "Wildcard",
        }
    }

    fn from_str(s: &str) -> Self {
        match s.to_lowercase().as_str() {
            "wildcard" => MatchType::Wildcard,
            _ => MatchType::Regexp,
        }
    }
}

/// User account for multiuser mode
#[derive(Clone, Debug)]
pub struct User {
    pub name: String,
    pub password: String,  // Stored encrypted in file, decrypted in memory
}

impl User {
    fn new(name: &str, password: &str) -> Self {
        Self {
            name: name.to_string(),
            password: password.to_string(),
        }
    }
}

/// User-defined action/trigger
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Action {
    pub name: String,           // Unique name (also used as /name command if no pattern)
    pub world: String,          // World name to match (empty = all worlds)
    #[serde(default)]
    pub match_type: MatchType,  // How to interpret pattern (regexp or wildcard)
    pub pattern: String,        // Pattern to match output (empty = manual /name only)
    pub command: String,        // Command(s) to execute, semicolon-separated
    #[serde(default)]
    pub owner: Option<String>,  // Username who owns this action (multiuser mode)
}

impl Action {
    fn new() -> Self {
        Self {
            name: String::new(),
            world: String::new(),
            match_type: MatchType::Regexp,
            pattern: String::new(),
            command: String::new(),
            owner: None,
        }
    }
}

/// List of internal commands that cannot be overridden by actions
const INTERNAL_COMMANDS: &[&str] = &[
    "help", "disconnect", "dc", "setup", "worlds", "connections", "l",
    "keepalive", "reload", "quit", "actions", "gag", "web", "send",
];

fn is_internal_command(name: &str) -> bool {
    INTERNAL_COMMANDS.contains(&name.to_lowercase().as_str())
}

// ============================================================================
// Shared Command Parsing
// ============================================================================

/// Parsed command representation - shared across console, GUI, and web interfaces
#[derive(Debug, Clone, PartialEq)]
#[allow(clippy::enum_variant_names)]
enum Command {
    /// /help - show help popup
    Help,
    /// /quit - exit application
    Quit,
    /// /reload - hot reload binary
    Reload,
    /// /setup - show global settings popup
    Setup,
    /// /web - show web settings popup
    Web,
    /// /actions [world] - show actions popup, optionally filtered by world
    Actions { world: Option<String> },
    /// /connections or /l - show connected worlds list
    WorldsList,
    /// /worlds (no args) - show world selector
    WorldSelector,
    /// /worlds -e [name] - edit world settings
    WorldEdit { name: Option<String> },
    /// /worlds -l <name> - connect without auto-login
    WorldConnectNoLogin { name: String },
    /// /worlds <name> - switch to or connect to named world
    WorldSwitch { name: String },
    /// /connect [host port [ssl]] - connect to server
    Connect { host: Option<String>, port: Option<String>, ssl: bool },
    /// /disconnect or /dc - disconnect current world
    Disconnect,
    /// /flush - clear output buffer for current world
    Flush,
    /// /menu - show menu popup to select windows/popups
    Menu,
    /// /send [-W] [-w<world>] [-n] <text> - send text
    Send { text: String, all_worlds: bool, target_world: Option<String>, no_newline: bool },
    /// /keepalive - show keepalive settings
    Keepalive,
    /// /gag <pattern> - gag lines matching pattern
    Gag { pattern: String },
    /// /ban - show banned hosts
    BanList,
    /// /unban <host> - remove ban for host
    Unban { host: String },
    /// /testmusic - play a test ANSI music sequence
    TestMusic,
    /// /<action_name> [args] - execute action
    ActionCommand { name: String, args: String },
    /// Not a command (regular text to send to MUD)
    NotACommand { text: String },
    /// Unknown/invalid command
    Unknown { cmd: String },
}

/// Parse a command string into a Command enum
fn parse_command(input: &str) -> Command {
    let trimmed = input.trim();

    // Not a command if doesn't start with /
    if !trimmed.starts_with('/') {
        return Command::NotACommand { text: trimmed.to_string() };
    }

    let parts: Vec<&str> = trimmed.split_whitespace().collect();
    if parts.is_empty() {
        return Command::NotACommand { text: trimmed.to_string() };
    }

    let cmd = parts[0].to_lowercase();
    let args = &parts[1..];

    match cmd.as_str() {
        "/help" => Command::Help,
        "/quit" => Command::Quit,
        "/reload" => Command::Reload,
        "/setup" => Command::Setup,
        "/web" => Command::Web,
        "/actions" => {
            let world = if args.is_empty() {
                None
            } else {
                Some(args.join(" "))
            };
            Command::Actions { world }
        }
        "/connections" | "/l" => Command::WorldsList,
        "/worlds" => parse_world_command(args),
        "/connect" => parse_connect_command(args),  // Internal use only (Connect buttons)
        "/disconnect" | "/dc" => Command::Disconnect,
        "/flush" => Command::Flush,
        "/menu" => Command::Menu,
        "/send" => parse_send_command(args, trimmed),
        "/keepalive" => Command::Keepalive,
        "/gag" => {
            if args.is_empty() {
                Command::Unknown { cmd: trimmed.to_string() }
            } else {
                Command::Gag { pattern: args.join(" ") }
            }
        }
        "/ban" => Command::BanList,
        "/unban" => {
            if args.is_empty() {
                Command::Unknown { cmd: trimmed.to_string() }
            } else {
                Command::Unban { host: args[0].to_string() }
            }
        }
        "/testmusic" => Command::TestMusic,
        _ => {
            // Check if it's an action command (starts with / but not a known command)
            let action_name = cmd.trim_start_matches('/');
            if !action_name.is_empty() {
                Command::ActionCommand {
                    name: action_name.to_string(),
                    args: args.join(" "),
                }
            } else {
                Command::Unknown { cmd: trimmed.to_string() }
            }
        }
    }
}

/// Parse /worlds command with its various forms
fn parse_world_command(args: &[&str]) -> Command {
    if args.is_empty() {
        return Command::WorldSelector;
    }

    match args[0] {
        "-e" => {
            // /worlds -e [name] - edit world
            let name = if args.len() > 1 {
                Some(args[1..].join(" "))
            } else {
                None
            };
            Command::WorldEdit { name }
        }
        "-l" => {
            // /worlds -l <name> - connect without auto-login
            if args.len() > 1 {
                Command::WorldConnectNoLogin { name: args[1..].join(" ") }
            } else {
                Command::Unknown { cmd: "/worlds -l".to_string() }
            }
        }
        _ => {
            // /worlds <name> - switch to or connect to named world
            Command::WorldSwitch { name: args.join(" ") }
        }
    }
}

/// Parse /connect command
fn parse_connect_command(args: &[&str]) -> Command {
    if args.is_empty() {
        return Command::Connect { host: None, port: None, ssl: false };
    }

    let host = Some(args[0].to_string());
    let port = args.get(1).map(|s| s.to_string());
    let ssl = args.get(2).map(|s| s.to_lowercase() == "ssl").unwrap_or(false);

    Command::Connect { host, port, ssl }
}

/// Parse /send command with flags
fn parse_send_command(args: &[&str], full_cmd: &str) -> Command {
    let mut all_worlds = false;
    let mut target_world: Option<String> = None;
    let mut no_newline = false;
    let mut text_start = 0;

    for (i, arg) in args.iter().enumerate() {
        if *arg == "-W" {
            all_worlds = true;
            text_start = i + 1;
        } else if let Some(world) = arg.strip_prefix("-w") {
            target_world = Some(world.to_string());
            text_start = i + 1;
        } else if *arg == "-n" {
            no_newline = true;
            text_start = i + 1;
        } else {
            break;
        }
    }

    // Get the text after flags - use original string to preserve spacing
    let text = if text_start < args.len() {
        // Find position of first non-flag argument in original string
        let mut pos = 0;
        let mut found_flags = 0;
        for c in full_cmd.chars() {
            if found_flags > text_start { // +1 for /send itself
                break;
            }
            if c.is_whitespace() && pos > 0 {
                // Check if we just finished a word
                let prev_nonws = full_cmd[..pos].chars().rev().find(|c| !c.is_whitespace());
                if prev_nonws.is_some() {
                    found_flags += 1;
                }
            }
            pos += c.len_utf8();
        }
        // Skip whitespace after last flag
        while pos < full_cmd.len() && full_cmd[pos..].starts_with(char::is_whitespace) {
            pos += 1;
        }
        full_cmd[pos..].to_string()
    } else {
        String::new()
    };

    Command::Send { text, all_worlds, target_world, no_newline }
}

/// Split action command string by semicolons, handling escaped semicolons (\;)
fn split_action_commands(command: &str) -> Vec<String> {
    let mut result = Vec::new();
    let mut current = String::new();
    let mut chars = command.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '\\' && chars.peek() == Some(&';') {
            // Escaped semicolon - add literal semicolon
            chars.next(); // consume the semicolon
            current.push(';');
        } else if c == ';' {
            // Command separator
            let trimmed = current.trim().to_string();
            if !trimmed.is_empty() {
                result.push(trimmed);
            }
            current.clear();
        } else {
            current.push(c);
        }
    }

    // Don't forget the last command
    let trimmed = current.trim().to_string();
    if !trimmed.is_empty() {
        result.push(trimmed);
    }

    result
}

/// Substitute action arguments ($1-$9, $*) in a command string
/// args_str is the space-separated arguments passed to the action
fn substitute_action_args(command: &str, args_str: &str) -> String {
    // Split args into words
    let args: Vec<&str> = args_str.split_whitespace().collect();

    let mut result = String::with_capacity(command.len() + args_str.len());
    let mut chars = command.chars().peekable();

    while let Some(c) = chars.next() {
        if c == '$' {
            if let Some(&next) = chars.peek() {
                if next == '*' {
                    // $* - all arguments
                    chars.next();
                    result.push_str(args_str);
                } else if next.is_ascii_digit() && next != '0' {
                    // $1-$9
                    chars.next();
                    let idx = (next as usize) - ('1' as usize);
                    if idx < args.len() {
                        result.push_str(args[idx]);
                    }
                    // If arg doesn't exist, substitute with nothing
                } else {
                    // Not a substitution pattern, keep the $
                    result.push(c);
                }
            } else {
                // $ at end of string
                result.push(c);
            }
        } else {
            result.push(c);
        }
    }

    result
}

/// Result of checking action triggers on a line
struct ActionTriggerResult {
    should_gag: bool,           // If true, suppress the line from output
    commands: Vec<String>,      // Commands to execute
}

/// Convert a wildcard pattern (* and ?) to a regex pattern
fn wildcard_to_regex(pattern: &str) -> String {
    let mut regex = String::with_capacity(pattern.len() * 2);
    for c in pattern.chars() {
        match c {
            '*' => regex.push_str(".*"),
            '?' => regex.push('.'),
            // Escape regex special characters
            '.' | '+' | '^' | '$' | '|' | '\\' | '(' | ')' | '[' | ']' | '{' | '}' => {
                regex.push('\\');
                regex.push(c);
            }
            _ => regex.push(c),
        }
    }
    regex
}

/// Check if a line matches any action triggers
/// Returns None if no match, Some(result) if matched
fn check_action_triggers(
    line: &str,
    world_name: &str,
    actions: &[Action],
) -> Option<ActionTriggerResult> {
    // Strip ANSI codes for pattern matching
    let plain_line = strip_ansi_codes(line);

    for action in actions {
        // Skip actions without patterns (those are manual /name only)
        if action.pattern.is_empty() {
            continue;
        }

        // Check if world matches (empty = all worlds, case-insensitive)
        if !action.world.is_empty() && !action.world.eq_ignore_ascii_case(world_name) {
            continue;
        }

        // Convert pattern based on match type
        let regex_pattern = match action.match_type {
            MatchType::Wildcard => wildcard_to_regex(&action.pattern),
            MatchType::Regexp => action.pattern.clone(),
        };

        // Try to compile and match the regex (case-insensitive)
        if let Ok(regex) = RegexBuilder::new(&regex_pattern)
            .case_insensitive(true)
            .build()
        {
            if regex.is_match(&plain_line) {
                let commands = split_action_commands(&action.command);
                let should_gag = commands.iter().any(|cmd|
                    cmd.eq_ignore_ascii_case("/gag") || cmd.to_lowercase().starts_with("/gag ")
                );

                // Filter out /gag from the commands to execute
                let filtered_commands: Vec<String> = commands.into_iter()
                    .filter(|cmd| !cmd.eq_ignore_ascii_case("/gag") && !cmd.to_lowercase().starts_with("/gag "))
                    .collect();

                return Some(ActionTriggerResult {
                    should_gag,
                    commands: filtered_commands,
                });
            }
        }
    }

    None
}

/// Check if a line matches any action pattern for the given world (for highlighting)
/// Returns true if the line matches any action's pattern
fn line_matches_action(
    line: &str,
    world_name: &str,
    actions: &[Action],
) -> bool {
    // Strip ANSI codes for pattern matching
    let plain_line = strip_ansi_codes(line);

    for action in actions {
        // Skip actions without patterns (those are manual /name only)
        if action.pattern.is_empty() {
            continue;
        }

        // Check if world matches (empty = all worlds)
        if !action.world.is_empty() && !action.world.eq_ignore_ascii_case(world_name) {
            continue;
        }

        // Convert pattern based on match type
        let regex_pattern = match action.match_type {
            MatchType::Wildcard => wildcard_to_regex(&action.pattern),
            MatchType::Regexp => action.pattern.clone(),
        };

        // Try to compile and match the regex (case-insensitive)
        if let Ok(regex) = RegexBuilder::new(&regex_pattern)
            .case_insensitive(true)
            .build()
        {
            if regex.is_match(&plain_line) {
                return true;
            }
        }
    }

    false
}

const RELOAD_FDS_ENV: &str = "CLAY_RELOAD_FDS";
const CRASH_COUNT_ENV: &str = "CLAY_CRASH_COUNT";
const MAX_CRASH_RESTARTS: u32 = 2;

// Static pointer to App for crash recovery - set when app is running
static APP_PTR: AtomicPtr<App> = AtomicPtr::new(std::ptr::null_mut());
// Track current crash count to avoid re-reading env var
static CRASH_COUNT: AtomicU32 = AtomicU32::new(0);

fn get_reload_state_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".clay.reload")
}

/// Get the current crash count from environment variable
fn get_crash_count() -> u32 {
    std::env::var(CRASH_COUNT_ENV)
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(0)
}

/// Clear the crash count (called after successful operation)
fn clear_crash_count() {
    std::env::remove_var(CRASH_COUNT_ENV);
    CRASH_COUNT.store(0, Ordering::SeqCst);
}

/// Set the global app pointer for crash recovery
fn set_app_ptr(app: *mut App) {
    APP_PTR.store(app, Ordering::SeqCst);
}

/// Get the global app pointer
fn get_app_ptr() -> *mut App {
    APP_PTR.load(Ordering::SeqCst)
}

/// Attempt to restart after a crash
fn crash_restart() {
    let crash_count = CRASH_COUNT.load(Ordering::SeqCst);
    if crash_count >= MAX_CRASH_RESTARTS {
        // Already crashed too many times, don't restart
        eprintln!("Maximum crash restarts ({}) reached, not restarting.", MAX_CRASH_RESTARTS);
        return;
    }

    // Try to save state from the app pointer
    let app_ptr = get_app_ptr();
    if !app_ptr.is_null() {
        // SAFETY: We set this pointer in run_app and it remains valid until run_app returns
        let app = unsafe { &*app_ptr };

        // Try to save state
        if let Err(e) = save_reload_state(app) {
            eprintln!("Failed to save state during crash: {}", e);
        }

        // Clear CLOEXEC on socket fds so they survive exec
        for world in &app.worlds {
            if let Some(fd) = world.socket_fd {
                let _ = clear_cloexec(fd);
            }
        }

        // Pass fd list via environment
        let fds_str: String = app.worlds
            .iter()
            .filter_map(|w| w.socket_fd)
            .map(|fd| fd.to_string())
            .collect::<Vec<_>>()
            .join(",");
        std::env::set_var(RELOAD_FDS_ENV, &fds_str);
    }

    // Increment crash count in env
    let new_count = crash_count + 1;
    std::env::set_var(CRASH_COUNT_ENV, new_count.to_string());

    // Try to exec the binary
    if let Ok((exe, _)) = get_executable_path() {
        use std::os::unix::process::CommandExt;
        let mut args: Vec<String> = std::env::args()
            .skip(1)
            .filter(|a| a != "--reload" && a != "--crash")
            .collect();
        args.push("--crash".to_string());

        // This replaces the current process if successful
        let _ = std::process::Command::new(&exe).args(&args).exec();
    }
}

/// Set up the crash handler (panic hook)
fn setup_crash_handler() {
    let default_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        // Restore terminal first to ensure output is visible
        let _ = disable_raw_mode();
        let _ = execute!(std::io::stdout(), LeaveAlternateScreen);

        // Print the panic info using the default handler
        eprintln!("\n\nClay crashed! Attempting to restart...\n");
        default_hook(panic_info);

        // Attempt to restart
        crash_restart();

        // If we get here, restart failed - exit normally
    }));
}

/// Get current time as seconds since Unix epoch (for WebSocket timestamps)
fn current_timestamp_secs() -> u64 {
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs()
}

/// Output line with timestamp for F2/show tags feature
#[derive(Clone)]
struct OutputLine {
    text: String,
    timestamp: SystemTime,
    from_server: bool,  // true if from MUD server, false if client-generated
    gagged: bool,       // true if line was gagged by an action (only shown with F2)
}

/// Maximum characters per output line (prevents performance issues with extremely long lines)
const MAX_LINE_LENGTH: usize = 10_000;

impl OutputLine {
    /// Truncate text if it exceeds MAX_LINE_LENGTH to prevent performance issues
    fn truncate_if_needed(text: String) -> String {
        if text.len() > MAX_LINE_LENGTH {
            // Find a safe truncation point (don't split UTF-8 or ANSI sequences)
            let mut truncate_at = MAX_LINE_LENGTH;
            // Walk back to find a safe character boundary
            while truncate_at > 0 && !text.is_char_boundary(truncate_at) {
                truncate_at -= 1;
            }
            // Also avoid truncating in the middle of an ANSI escape sequence
            // Look for incomplete escape: \x1b[ without terminating letter
            let prefix = &text[..truncate_at];
            if let Some(last_esc) = prefix.rfind('\x1b') {
                // Check if there's a terminating letter after the escape
                let after_esc = &prefix[last_esc..];
                let has_terminator = after_esc.chars().skip(1).any(|c| c.is_ascii_alphabetic());
                if !has_terminator {
                    // Truncate before the incomplete escape sequence
                    truncate_at = last_esc;
                }
            }
            let mut result = text[..truncate_at].to_string();
            result.push_str("\x1b[0m\x1b[33m... [truncated]\x1b[0m");
            result
        } else {
            text
        }
    }

    fn new(text: String) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: true,  // Default to server output
            gagged: false,
        }
    }

    fn new_client(text: String) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: false,
            gagged: false,
        }
    }

    fn new_gagged(text: String) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: true,
            gagged: true,
        }
    }

    fn new_with_timestamp(text: String, timestamp: SystemTime) -> Self {
        Self { text: Self::truncate_if_needed(text), timestamp, from_server: true, gagged: false }
    }

    /// Format timestamp for display based on whether it's from today
    /// Same day: HH:MM>
    /// Previous days: DD/MM HH:MM>
    fn format_timestamp(&self) -> String {
        self.format_timestamp_with_now(&CachedNow::new())
    }

    /// Format timestamp using a pre-computed "now" value for batch rendering
    fn format_timestamp_with_now(&self, now: &CachedNow) -> String {
        let ts_secs = self.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs() as libc::time_t;

        let mut ts_tm: libc::tm = unsafe { std::mem::zeroed() };
        unsafe {
            libc::localtime_r(&ts_secs, &mut ts_tm);
        }

        // Check if same day (year, day of year match)
        let same_day = ts_tm.tm_yday == now.yday && ts_tm.tm_year == now.year;

        if same_day {
            format!("{:02}:{:02}>", ts_tm.tm_hour, ts_tm.tm_min)
        } else {
            format!("{:02}/{:02} {:02}:{:02}>", ts_tm.tm_mday, ts_tm.tm_mon + 1, ts_tm.tm_hour, ts_tm.tm_min)
        }
    }
}

/// Cached "now" time for batch timestamp formatting
/// Computing localtime_r once per frame instead of once per line
struct CachedNow {
    year: i32,
    yday: i32,
}

impl CachedNow {
    fn new() -> Self {
        let now_secs = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs() as libc::time_t;

        let mut now_tm: libc::tm = unsafe { std::mem::zeroed() };
        unsafe {
            libc::localtime_r(&now_secs, &mut now_tm);
        }

        Self {
            year: now_tm.tm_year,
            yday: now_tm.tm_yday,
        }
    }
}

struct World {
    name: String,
    output_lines: Vec<OutputLine>,
    scroll_offset: usize,
    connected: bool,
    command_tx: Option<mpsc::Sender<WriteCommand>>,
    unseen_lines: usize,
    paused: bool,
    pending_lines: Vec<OutputLine>,
    lines_since_pause: usize,
    settings: WorldSettings,
    log_handle: Option<std::sync::Arc<std::sync::Mutex<std::fs::File>>>,
    log_date: Option<String>,    // Current log file date (MMDDYY) for day rollover detection
    socket_fd: Option<RawFd>,    // Store fd for hot reload (plain TCP only)
    is_tls: bool,                // Track if using TLS
    telnet_mode: bool,           // True if telnet negotiation detected
    prompt: String,              // Current prompt detected via telnet GA
    prompt_count: usize,         // Number of prompts received since connect (for auto-login)
    last_send_time: Option<std::time::Instant>, // For keepalive timing
    last_receive_time: Option<std::time::Instant>, // Last time server data was received
    last_nop_time: Option<std::time::Instant>,     // Last time NOP keepalive was sent
    last_user_command_time: Option<std::time::Instant>, // Last time user sent a command
    partial_line: String,        // Buffer for incomplete lines (no trailing newline)
    partial_in_pending: bool,    // True if partial_line is in pending_lines (vs output_lines)
    trigger_partial_line: String, // Buffer for incomplete lines for action trigger checking
    just_filtered_idler: bool,   // True if we just filtered an idler message (for filtering trailing newline)
    wont_echo_time: Option<std::time::Instant>, // When WONT ECHO was seen (for timeout-based prompt detection)
    uses_wont_echo_prompt: bool, // True if this world uses WONT ECHO for prompts (auto-detected)
    is_initial_world: bool,      // True for the auto-created world before first connection
    was_connected: bool,         // True if world has ever been connected (for world cycling)
    skip_auto_login: bool,       // True to skip auto-login on next connect (for /worlds -l)
    showing_splash: bool,        // True when showing startup splash (for centering)
    needs_redraw: bool,          // True when terminal needs full redraw (after splash clear)
    pending_since: Option<std::time::Instant>, // When pending output first appeared (for Alt-w)
    owner: Option<String>,       // Username who owns this world (multiuser mode)
    proxy_pid: Option<u32>,      // PID of TLS proxy process (if using TLS proxy)
    proxy_socket_path: Option<std::path::PathBuf>, // Unix socket path for TLS proxy
}

impl World {
    fn new(name: &str) -> Self {
        Self::new_with_splash(name, false)
    }

    fn new_with_splash(name: &str, show_splash: bool) -> Self {
        let output_lines = if show_splash {
            Self::generate_splash_lines()
        } else {
            Vec::new()
        };
        let scroll_offset = output_lines.len().saturating_sub(1);
        Self {
            name: name.to_string(),
            output_lines,
            scroll_offset,
            connected: false,
            command_tx: None,
            unseen_lines: 0,
            paused: false,
            pending_lines: Vec::new(),
            lines_since_pause: 0,
            settings: WorldSettings::default(),
            log_handle: None,
            log_date: None,
            socket_fd: None,
            is_tls: false,
            telnet_mode: false,
            prompt: String::new(),
            prompt_count: 0,
            last_send_time: None,
            last_receive_time: None,
            last_nop_time: None,
            last_user_command_time: None,
            partial_line: String::new(),
            partial_in_pending: false,
            trigger_partial_line: String::new(),
            just_filtered_idler: false,
            wont_echo_time: None,
            uses_wont_echo_prompt: false,
            is_initial_world: false,
            was_connected: false,
            skip_auto_login: false,
            showing_splash: show_splash,
            needs_redraw: false,
            pending_since: None,
            owner: None,
            proxy_pid: None,
            proxy_socket_path: None,
        }
    }

    /// Get the current date as MMDDYY string for log file naming
    fn get_current_date_string() -> String {
        let now_secs = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs() as libc::time_t;

        let mut tm: libc::tm = unsafe { std::mem::zeroed() };
        unsafe {
            libc::localtime_r(&now_secs, &mut tm);
        }

        format!("{:02}{:02}{:02}", tm.tm_mon + 1, tm.tm_mday, (tm.tm_year + 1900) % 100)
    }

    /// Get the path to the logs directory, creating it if needed
    fn get_logs_dir() -> std::path::PathBuf {
        let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let logs_dir = std::path::PathBuf::from(home).join(".clay").join("logs");
        if !logs_dir.exists() {
            let _ = std::fs::create_dir_all(&logs_dir);
        }
        logs_dir
    }

    /// Get the full path to this world's log file for the current date
    fn get_log_path(&self) -> std::path::PathBuf {
        let date_str = Self::get_current_date_string();
        // Sanitize world name for use in filename (replace invalid chars with _)
        let safe_name: String = self.name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
            .collect();
        Self::get_logs_dir().join(format!("{}.{}.log", safe_name, date_str))
    }

    /// Open the log file for this world (creates logs directory if needed)
    fn open_log_file(&mut self) -> bool {
        if !self.settings.log_enabled {
            return false;
        }

        let date_str = Self::get_current_date_string();
        let log_path = self.get_log_path();

        match std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&log_path)
        {
            Ok(file) => {
                self.log_handle = Some(std::sync::Arc::new(std::sync::Mutex::new(file)));
                self.log_date = Some(date_str);
                true
            }
            Err(_) => false,
        }
    }

    /// Close the log file
    fn close_log_file(&mut self) {
        self.log_handle = None;
        self.log_date = None;
    }

    /// Write a line to the log file with timestamp prefix
    /// Handles day rollover (opens new file if date changed)
    fn write_log_line(&mut self, line: &str) {
        if !self.settings.log_enabled {
            return;
        }

        // Check for day rollover
        let current_date = Self::get_current_date_string();
        if self.log_date.as_ref() != Some(&current_date) {
            // Date changed, close old file and open new one
            self.close_log_file();
            if !self.open_log_file() {
                return;
            }
        }

        if let Some(ref handle) = self.log_handle {
            if let Ok(mut file) = handle.lock() {
                // Get current time for timestamp
                let now_secs = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs() as libc::time_t;

                let mut tm: libc::tm = unsafe { std::mem::zeroed() };
                unsafe {
                    libc::localtime_r(&now_secs, &mut tm);
                }

                // Format: [HH:MM:SS] line
                let _ = writeln!(file, "[{:02}:{:02}:{:02}] {}",
                    tm.tm_hour, tm.tm_min, tm.tm_sec, line);
            }
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn add_output(
        &mut self,
        text: &str,
        is_current: bool,
        settings: &Settings,
        output_height: u16,
        output_width: u16,
        clear_splash: bool,
        from_server: bool,
    ) {

        // Clear splash mode when MUD data is received (not for client messages)
        if clear_splash && self.showing_splash {
            self.showing_splash = false;
            self.needs_redraw = true; // Signal terminal needs full redraw
            // Clear splash content from output_lines so MUD data starts fresh
            self.output_lines.clear();
            self.scroll_offset = 0;
        }
        let max_lines = (output_height as usize).saturating_sub(2);

        // If we have a partial line from before, combine it with new text
        let had_partial = !self.partial_line.is_empty();
        let partial_was_in_pending = self.partial_in_pending;
        let combined = if had_partial {
            let mut s = std::mem::take(&mut self.partial_line);
            s.push_str(text);
            self.partial_in_pending = false;
            s
        } else {
            text.to_string()
        };

        // Check if text ends with newline (all lines complete) or not (last line is partial)
        let ends_with_newline = combined.ends_with('\n');

        // Collect lines
        let lines: Vec<&str> = combined.lines().collect();
        if lines.is_empty() {
            return;
        }

        // If we had a partial line, update it in the correct list
        let start_idx = if had_partial {
            let completed_line = lines[0];
            // Check if the completed line should be filtered
            let should_filter = (completed_line.contains("###_idler_message_") && completed_line.contains("_###"))
                || is_visually_empty(completed_line);

            if should_filter {
                // Remove the partial line instead of updating it
                if partial_was_in_pending {
                    self.pending_lines.pop();
                } else {
                    self.output_lines.pop();
                }
            } else {
                // Update the partial line with complete content
                if partial_was_in_pending {
                    if let Some(last) = self.pending_lines.last_mut() {
                        last.text = completed_line.to_string();
                    }
                } else {
                    if let Some(last) = self.output_lines.last_mut() {
                        last.text = completed_line.to_string();
                    }
                }
            }
            1 // Skip first line since we handled it
        } else {
            0
        };

        // Process remaining lines
        let line_count = lines.len();
        for (i, line) in lines.iter().enumerate().skip(start_idx) {
            let is_last = i == line_count - 1;
            let is_partial = is_last && !ends_with_newline;

            // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
            let uses_idler_keepalive = matches!(
                self.settings.keep_alive_type,
                KeepAliveType::Custom | KeepAliveType::Generic
            );
            if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                continue;
            }

            // Write to log file if enabled (only for complete lines)
            if !is_partial {
                self.write_log_line(line);
            }

            // Track if this line goes to pending (for partial tracking)
            let goes_to_pending = self.paused && settings.more_mode_enabled;
            let triggers_pause = !goes_to_pending
                && settings.more_mode_enabled
                && self.lines_since_pause >= max_lines
                && self.output_lines.len() >= max_lines;

            // Create OutputLine with appropriate from_server flag
            let new_line = if from_server {
                OutputLine::new(line.to_string())
            } else {
                OutputLine::new_client(line.to_string())
            };

            if goes_to_pending {
                // Track when pending output first appeared
                if self.pending_lines.is_empty() {
                    self.pending_since = Some(std::time::Instant::now());
                }
                self.pending_lines.push(new_line);
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = true;
                }
            } else if triggers_pause {
                // Scroll to show lines added before pause, then pause
                self.scroll_to_bottom();
                self.paused = true;
                // Track when pending output first appeared
                if self.pending_lines.is_empty() {
                    self.pending_since = Some(std::time::Instant::now());
                }
                self.pending_lines.push(new_line);
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = true;
                }
            } else {
                self.output_lines.push(new_line);
                // Count visual lines (accounting for word wrap) instead of logical lines
                let visual_lines = visual_line_count(line, output_width as usize);
                self.lines_since_pause += visual_lines;
                if !is_current {
                    self.unseen_lines += 1;
                }
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = false;
                }
            }
        }
        // If more mode is off, always unpause, release pending, and scroll to bottom
        if !settings.more_mode_enabled {
            self.paused = false;
            // Release any pending lines immediately
            if !self.pending_lines.is_empty() {
                self.output_lines.append(&mut self.pending_lines);
            }
        }
        // Always scroll to bottom unless paused (and more mode is on)
        if !self.paused {
            self.scroll_to_bottom();
        }
    }

    fn scroll_to_bottom(&mut self) {
        self.scroll_offset = self.output_lines.len().saturating_sub(1);
    }

    fn mark_seen(&mut self) {
        self.unseen_lines = 0;
    }

    /// Returns true if this world has activity (unseen lines or pending output)
    fn has_activity(&self) -> bool {
        self.unseen_lines > 0 || !self.pending_lines.is_empty()
    }

    fn release_pending(&mut self, count: usize) {
        let to_release: Vec<OutputLine> = self
            .pending_lines
            .drain(..count.min(self.pending_lines.len()))
            .collect();
        for line in to_release {
            self.output_lines.push(line);
        }
        if self.pending_lines.is_empty() {
            self.paused = false;
            self.lines_since_pause = 0;
            // If partial was in pending, it's now in output
            if self.partial_in_pending {
                self.partial_in_pending = false;
            }
        } else {
            // Reset counter for next batch
            self.lines_since_pause = 0;
        }
        self.scroll_to_bottom();
    }

    fn release_all_pending(&mut self) {
        self.output_lines.append(&mut self.pending_lines);
        self.paused = false;
        self.lines_since_pause = 0;
        self.pending_since = None; // Clear pending timestamp
        // If partial was in pending, it's now in output
        if self.partial_in_pending {
            self.partial_in_pending = false;
        }
        self.scroll_to_bottom();
    }

    /// Filter output to only keep lines from the MUD server (remove client-generated lines)
    fn filter_to_server_output(&mut self) {
        self.output_lines.retain(|line| line.from_server);
        self.pending_lines.retain(|line| line.from_server);
        // Adjust scroll offset if it's now past the end
        if self.scroll_offset > 0 && self.scroll_offset >= self.output_lines.len() {
            self.scroll_offset = self.output_lines.len().saturating_sub(1);
        }
    }

    fn is_at_bottom(&self) -> bool {
        self.scroll_offset >= self.output_lines.len().saturating_sub(1)
    }

    fn lines_from_bottom(&self) -> usize {
        self.output_lines
            .len()
            .saturating_sub(1)
            .saturating_sub(self.scroll_offset)
    }

    fn generate_splash_lines() -> Vec<OutputLine> {
        // Splash content without centering - will be centered at render time
        // Dog art:
        //           (\/\__o
        //   __      `-/ `_/
        //  `--\______/  |
        //     /        /
        //  -`/_------'\_.
        let now = SystemTime::now();
        vec![
            OutputLine::new_with_timestamp("".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;180m          (\\/\\__o     \x1b[38;5;209m           \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;180m  __      `-/ `_/     \x1b[38;5;208m      \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;180m `--\\______/  |       \x1b[38;5;215m            \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;180m    /        /        \x1b[38;5;216m              \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;180m -`/_------'\\_.       \x1b[38;5;217m        \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;218m                               \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;213m A 90dies mud client written today \x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("".to_string(), now),
            OutputLine::new_with_timestamp("\x1b[38;5;244m/help for how to use clay\x1b[0m".to_string(), now),
            OutputLine::new_with_timestamp("".to_string(), now),
        ]
    }
}

struct App {
    worlds: Vec<World>,
    current_world_index: usize,
    previous_world_index: Option<usize>, // For Alt+w fallback when no unseen/pending
    input: InputArea,
    input_height: u16,
    output_height: u16,
    output_width: u16,
    spell_checker: SpellChecker,
    spell_state: SpellState,
    last_input_was_delete: bool, // Track if last input action was backspace/delete (for spell check)
    cached_misspelled: Vec<(usize, usize)>, // Cached misspelled word ranges (char positions)
    suggestion_message: Option<String>,
    settings: Settings,
    settings_popup: SettingsPopup,
    world_selector: WorldSelectorPopup,
    confirm_dialog: ConfirmDialog,
    worlds_popup: WorldsPopup,
    filter_popup: FilterPopup,
    help_popup: HelpPopup,
    menu_popup: MenuPopup,
    actions_popup: ActionsPopup,
    web_popup: WebPopup,
    last_ctrl_c: Option<std::time::Instant>,
    last_escape: Option<std::time::Instant>, // For Escape+key sequences (Alt emulation)
    show_tags: bool, // F2 toggles - false = hide tags (default), true = show tags
    highlight_actions: bool, // F8 toggles - highlight lines matching action patterns
    // WebSocket server (ws:// or wss:// depending on web_secure setting)
    ws_server: Option<WebSocketServer>,
    // HTTP web interface server (no TLS)
    http_server: Option<HttpServer>,
    // HTTPS web interface server
    #[cfg(feature = "native-tls-backend")]
    https_server: Option<HttpsServer>,
    #[cfg(feature = "rustls-backend")]
    https_server: Option<HttpsServer>,
    // Track if popup was visible last frame (for terminal clear on transition)
    popup_was_visible: bool,
    /// Cache of which world each WS client is viewing (for activity indicator)
    /// Maps client_id -> current_world_index
    ws_client_worlds: std::collections::HashMap<u64, usize>,
    /// True if this is the master client (runs WS server or WS disabled).
    /// Only master should save settings or initiate connections.
    is_master: bool,
    /// True if this session started from a hot reload (suppress server startup messages)
    is_reload: bool,
    /// True if the output area needs to be redrawn (optimization to avoid unnecessary redraws)
    needs_output_redraw: bool,
    /// True if running in multiuser mode (--multiuser flag)
    multiuser_mode: bool,
    /// User accounts (multiuser mode only)
    users: Vec<User>,
    /// Ban list for HTTP/WebSocket security
    ban_list: BanList,
    /// Per-user connections in multiuser mode: (world_index, username) -> UserConnection
    user_connections: std::collections::HashMap<(usize, String), UserConnection>,
}

impl App {
    fn new() -> Self {
        Self {
            worlds: Vec::new(),
            current_world_index: 0,
            previous_world_index: None,
            input: InputArea::new(3),
            input_height: 3,
            output_height: 20, // Will be updated by ui()
            output_width: 80,  // Will be updated by ui()
            spell_checker: SpellChecker::new(),
            spell_state: SpellState::new(),
            last_input_was_delete: false,
            cached_misspelled: Vec::new(),
            suggestion_message: None,
            settings: Settings::default(),
            settings_popup: SettingsPopup::new(),
            world_selector: WorldSelectorPopup::new(),
            confirm_dialog: ConfirmDialog::new(),
            worlds_popup: WorldsPopup::new(),
            filter_popup: FilterPopup::new(),
            help_popup: HelpPopup::new(),
            menu_popup: MenuPopup::new(),
            actions_popup: ActionsPopup::new(),
            web_popup: WebPopup::new(),
            last_ctrl_c: None,
            last_escape: None,
            show_tags: false, // Default: hide tags
            highlight_actions: false, // Default: don't highlight action matches
            ws_server: None,
            http_server: None,
            #[cfg(feature = "native-tls-backend")]
            https_server: None,
            #[cfg(feature = "rustls-backend")]
            https_server: None,
            popup_was_visible: false,
            ws_client_worlds: std::collections::HashMap::new(),
            is_master: true, // Console app is always master (remote GUI is separate execution path)
            is_reload: false, // Set to true in run_app if started from hot reload
            needs_output_redraw: true, // Start with true to ensure initial render
            multiuser_mode: false, // Set to true in main if started with --multiuser
            users: Vec::new(),
            ban_list: BanList::new(),
            user_connections: std::collections::HashMap::new(),
        }
        // Note: No initial world created here - it will be created after load_settings()
        // if no worlds are configured
    }

    /// Ensure there's at least one world (creates initial world if needed)
    /// Also adds splash screen to current world if it has no output
    fn ensure_has_world(&mut self) {
        if self.worlds.is_empty() {
            let mut initial_world = World::new_with_splash(&get_binary_name(), true);
            initial_world.is_initial_world = true;
            self.worlds.push(initial_world);
        } else {
            // Add splash to current world if it has no output yet
            let current = &mut self.worlds[self.current_world_index];
            if current.output_lines.is_empty() && !current.connected {
                current.output_lines = World::generate_splash_lines();
                current.showing_splash = true;
                current.scroll_offset = current.output_lines.len().saturating_sub(1);
            }
        }
    }

    fn current_world(&self) -> &World {
        // Safety: clamp index to valid range to prevent panic
        let idx = if self.worlds.is_empty() {
            0  // Will panic below, but ensure_has_world() should prevent this
        } else {
            self.current_world_index.min(self.worlds.len() - 1)
        };
        &self.worlds[idx]
    }

    fn current_world_mut(&mut self) -> &mut World {
        // Safety: clamp index to valid range to prevent panic
        let idx = if self.worlds.is_empty() {
            0  // Will panic below, but ensure_has_world() should prevent this
        } else {
            self.current_world_index.min(self.worlds.len() - 1)
        };
        &mut self.worlds[idx]
    }

    /// Find world index by name (case-insensitive)
    fn find_world_index(&self, name: &str) -> Option<usize> {
        self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name))
    }

    fn switch_world(&mut self, index: usize) {
        if index < self.worlds.len() && index != self.current_world_index {
            // Track previous world for Alt+w fallback
            self.previous_world_index = Some(self.current_world_index);
            self.current_world_index = index;
            self.worlds[index].mark_seen();
            // Broadcast to WebSocket clients that this world's unseen count is cleared
            self.ws_broadcast(WsMessage::UnseenCleared { world_index: index });
            // Mark output for redraw since we switched worlds
            self.needs_output_redraw = true;
        }
    }

    /// Switch to a world with activity (Alt-w)
    /// Priority: 1) oldest pending output, 2) any unseen output, 3) previous world
    /// Returns true if switched, false if nowhere to switch
    fn switch_to_oldest_pending(&mut self) -> bool {
        // First, check for worlds with pending output (paused lines)
        let mut oldest_idx: Option<usize> = None;
        let mut oldest_time: Option<std::time::Instant> = None;

        for (idx, world) in self.worlds.iter().enumerate() {
            // Skip current world and worlds without pending output
            if idx == self.current_world_index || world.pending_lines.is_empty() {
                continue;
            }
            if let Some(pending_time) = world.pending_since {
                if oldest_time.is_none() || pending_time < oldest_time.unwrap() {
                    oldest_time = Some(pending_time);
                    oldest_idx = Some(idx);
                }
            }
        }

        if let Some(idx) = oldest_idx {
            self.switch_world(idx);
            return true;
        }

        // Second, check for worlds with unseen output (activity indicator)
        for (idx, world) in self.worlds.iter().enumerate() {
            if idx != self.current_world_index && world.unseen_lines > 0 {
                self.switch_world(idx);
                return true;
            }
        }

        // Third, fall back to previous world if it exists and is different
        if let Some(prev_idx) = self.previous_world_index {
            if prev_idx < self.worlds.len() && prev_idx != self.current_world_index {
                self.switch_world(prev_idx);
                return true;
            }
        }

        false
    }

    /// Get sorted list of world indices for cycling (alphabetically by name, case-insensitive)
    fn get_sorted_world_indices(&self) -> Vec<usize> {
        let mut indices: Vec<usize> = (0..self.worlds.len()).collect();
        indices.sort_by(|&a, &b| {
            self.worlds[a]
                .name
                .to_lowercase()
                .cmp(&self.worlds[b].name.to_lowercase())
        });
        indices
    }

    fn next_world(&mut self) {
        // Build world info for shared function
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
            })
            .collect();

        if let Some(next_idx) = crate::util::calculate_next_world(
            &world_info,
            self.current_world_index,
            self.settings.world_switch_mode,
        ) {
            self.switch_world(next_idx);
        }
    }

    fn prev_world(&mut self) {
        // Build world info for shared function
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
            })
            .collect();

        if let Some(prev_idx) = crate::util::calculate_prev_world(
            &world_info,
            self.current_world_index,
            self.settings.world_switch_mode,
        ) {
            self.switch_world(prev_idx);
        }
    }

    fn next_world_all(&mut self) {
        // Cycle through all worlds that have ever been connected (alphabetically)
        let sorted = self.get_sorted_world_indices();
        if sorted.is_empty() {
            return;
        }
        let current_pos = sorted.iter().position(|&i| i == self.current_world_index).unwrap_or(0);
        let len = sorted.len();

        for i in 1..=len {
            let sorted_idx = (current_pos + i) % len;
            let world_idx = sorted[sorted_idx];
            if self.worlds[world_idx].was_connected {
                self.switch_world(world_idx);
                return;
            }
        }
        // No worlds that were connected, stay on current
    }

    fn prev_world_all(&mut self) {
        // Cycle through all worlds that have ever been connected (alphabetically)
        let sorted = self.get_sorted_world_indices();
        if sorted.is_empty() {
            return;
        }
        let current_pos = sorted.iter().position(|&i| i == self.current_world_index).unwrap_or(0);
        let len = sorted.len();

        for i in 1..=len {
            let sorted_idx = if current_pos >= i {
                current_pos - i
            } else {
                len - (i - current_pos)
            };
            let world_idx = sorted[sorted_idx];
            if self.worlds[world_idx].was_connected {
                self.switch_world(world_idx);
                return;
            }
        }
        // No worlds that were connected, stay on current
    }

    fn find_world(&self, name: &str) -> Option<usize> {
        self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name))
    }

    fn find_or_create_world(&mut self, name: &str) -> usize {
        if let Some(idx) = self.find_world(name) {
            idx
        } else {
            self.worlds.push(World::new(name));
            self.worlds.len() - 1
        }
    }

    fn activity_count(&self) -> usize {
        self.worlds
            .iter()
            .enumerate()
            .filter(|(i, w)| *i != self.current_world_index && w.has_activity())
            .count()
    }

    /// Discard the initial "fake" world if it exists and is not connected.
    /// Called after first successful connection to a real world.
    fn discard_initial_world(&mut self) {
        // Find index of initial world that's not connected
        if let Some(idx) = self.worlds.iter().position(|w| w.is_initial_world && !w.connected) {
            // Don't discard if it's the only world or if it's the current world
            if self.worlds.len() > 1 && idx != self.current_world_index {
                self.worlds.remove(idx);
                // Adjust current_world_index if needed
                if self.current_world_index > idx {
                    self.current_world_index -= 1;
                }
            }
        }
    }

    fn add_output(&mut self, text: &str) {
        let is_current = true;
        let settings = self.settings.clone();
        let output_height = self.output_height;
        let output_width = self.output_width;
        // Ensure client-generated messages are complete lines (end with newline)
        let text_with_newline = if text.ends_with('\n') || text.is_empty() {
            text.to_string()
        } else {
            format!("{}\n", text)
        };
        self.current_world_mut()
            .add_output(&text_with_newline, is_current, &settings, output_height, output_width, false, false);
        // Mark output for redraw since we added content
        self.needs_output_redraw = true;
    }

    /// Broadcast a message to all authenticated WebSocket clients
    fn ws_broadcast(&self, msg: WsMessage) {
        // Broadcast to secure WebSocket server (wss://)
        if let Some(ref server) = self.ws_server {
            let clients = server.clients.clone();
            let msg_clone = msg.clone();
            tokio::spawn(async move {
                let clients_guard = clients.read().await;
                if let Ok(json) = serde_json::to_string(&msg_clone) {
                    for client in clients_guard.values() {
                        if client.authenticated {
                            let _ = client.tx.send(msg_clone.clone());
                        }
                    }
                    drop(json); // Used to validate serialization works
                }
            });
        }
    }

    /// Send a message to a specific WebSocket client
    fn ws_send_to_client(&self, client_id: u64, msg: WsMessage) {
        if let Some(ref server) = self.ws_server {
            let clients = server.clients.clone();
            tokio::spawn(async move {
                let clients_guard = clients.read().await;
                if let Some(client) = clients_guard.get(&client_id) {
                    let _ = client.tx.send(msg);
                }
            });
        }
    }

    /// Check if any WS client is currently viewing a specific world
    fn ws_client_viewing(&self, world_index: usize) -> bool {
        self.ws_client_worlds.values().any(|&w| w == world_index)
    }

    /// Build initial state message for a newly authenticated client
    fn build_initial_state(&self) -> WsMessage {
        let worlds: Vec<WorldStateMsg> = self.worlds.iter().enumerate().map(|(idx, world)| {
            // Strip carriage returns from output/pending lines for web clients
            let clean_output: Vec<String> = world.output_lines.iter()
                .map(|s| s.text.replace('\r', ""))
                .collect();
            let clean_pending: Vec<String> = world.pending_lines.iter()
                .map(|s| s.text.replace('\r', ""))
                .collect();
            // Create timestamped versions (add %% prefix and red color for client-generated messages)
            let output_lines_ts: Vec<TimestampedLine> = world.output_lines.iter()
                .map(|s| {
                    let text = s.text.replace('\r', "");
                    let text = if !s.from_server {
                        format!("\x1b[31m%% {}\x1b[0m", text)
                    } else {
                        text
                    };
                    TimestampedLine {
                        text,
                        ts: s.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                    }
                })
                .collect();
            let pending_lines_ts: Vec<TimestampedLine> = world.pending_lines.iter()
                .map(|s| {
                    let text = s.text.replace('\r', "");
                    let text = if !s.from_server {
                        format!("\x1b[31m%% {}\x1b[0m", text)
                    } else {
                        text
                    };
                    TimestampedLine {
                        text,
                        ts: s.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                    }
                })
                .collect();
            WorldStateMsg {
                index: idx,
                name: world.name.clone(),
                connected: world.connected,
                output_lines: clean_output,
                pending_lines: clean_pending,
                output_lines_ts,
                pending_lines_ts,
                prompt: world.prompt.replace('\r', ""),
                scroll_offset: world.scroll_offset,
                paused: world.paused,
                unseen_lines: world.unseen_lines,
                settings: WorldSettingsMsg {
                    hostname: world.settings.hostname.clone(),
                    port: world.settings.port.clone(),
                    user: world.settings.user.clone(),
                    password: world.settings.password.clone(),
                    use_ssl: world.settings.use_ssl,
                    log_enabled: world.settings.log_enabled,
                    encoding: world.settings.encoding.name().to_string(),
                    auto_connect_type: world.settings.auto_connect_type.name().to_string(),
                    keep_alive_type: world.settings.keep_alive_type.name().to_string(),
                    keep_alive_cmd: world.settings.keep_alive_cmd.clone(),
                },
                last_send_secs: world.last_send_time.map(|t| t.elapsed().as_secs()),
                last_recv_secs: world.last_receive_time.map(|t| t.elapsed().as_secs()),
                last_nop_secs: world.last_nop_time.map(|t| t.elapsed().as_secs()),
                keep_alive_type: world.settings.keep_alive_type.name().to_string(),
            }
        }).collect();

        let settings = GlobalSettingsMsg {
            more_mode_enabled: self.settings.more_mode_enabled,
            spell_check_enabled: self.settings.spell_check_enabled,
            world_switch_mode: self.settings.world_switch_mode.name().to_string(),
            debug_enabled: self.settings.debug_enabled,
            show_tags: self.show_tags,
            ansi_music_enabled: self.settings.ansi_music_enabled,
            console_theme: self.settings.theme.name().to_string(),
            gui_theme: self.settings.gui_theme.name().to_string(),
            gui_transparency: self.settings.gui_transparency,
            input_height: self.input_height,
            font_name: self.settings.font_name.clone(),
            font_size: self.settings.font_size,
            ws_allow_list: self.settings.websocket_allow_list.clone(),
            web_secure: self.settings.web_secure,
            http_enabled: self.settings.http_enabled,
            http_port: self.settings.http_port,
            ws_enabled: self.settings.ws_enabled,
            ws_port: self.settings.ws_port,
            ws_cert_file: self.settings.websocket_cert_file.clone(),
            ws_key_file: self.settings.websocket_key_file.clone(),
            tls_proxy_enabled: self.settings.tls_proxy_enabled,
        };

        WsMessage::InitialState {
            worlds,
            settings,
            current_world_index: self.current_world_index,
            actions: self.settings.actions.clone(),
            splash_lines: Vec::new(),
        }
    }

    fn increase_input_height(&mut self) {
        if self.input_height < 15 {
            self.input_height += 1;
            self.input.visible_height = self.input_height;
        }
    }

    fn decrease_input_height(&mut self) {
        if self.input_height > 1 {
            self.input_height -= 1;
            self.input.visible_height = self.input_height;
            self.input.adjust_viewport();
        }
    }

    fn handle_spell_check(&mut self) {
        if !self.spell_state.showing_suggestions {
            if let Some((start, end, word)) = self.input.current_word() {
                if !self.spell_checker.is_valid(&word) {
                    let mut suggestions = self.spell_checker.suggestions(&word, 6);
                    if !suggestions.is_empty() {
                        // Store original word and add it to the end for cycling
                        self.spell_state.original_word = word.clone();
                        suggestions.push(word);  // Add original word at the end

                        // Output suggestions to the output area (excluding the original word)
                        let display_suggestions: Vec<_> = suggestions[..suggestions.len()-1].to_vec();
                        self.add_output(&format!(
                            "Suggestions for '{}': {}",
                            self.spell_state.original_word,
                            display_suggestions.join(", ")
                        ));

                        self.spell_state.suggestions = suggestions;
                        self.spell_state.suggestion_index = 0;
                        self.spell_state.word_start = start;
                        self.spell_state.word_end = end;
                        self.spell_state.showing_suggestions = true;
                        self.suggestion_message = Some(format!(
                            "Press Ctrl+Q to cycle: {}",
                            self.spell_state.suggestions[0]
                        ));
                    }
                    // If no suggestions found or word is correctly spelled, do nothing
                }
                // If word is spelled correctly, do nothing
            }
            // If no word at cursor, do nothing
        } else if !self.spell_state.suggestions.is_empty() {
            // Cycle through suggestions (including original word at the end)
            let replacement = self.spell_state.suggestions[self.spell_state.suggestion_index].clone();
            self.input.replace_word(
                self.spell_state.word_start,
                self.spell_state.word_end,
                &replacement,
            );
            self.spell_state.word_end = self.spell_state.word_start + replacement.chars().count();
            self.spell_state.suggestion_index =
                (self.spell_state.suggestion_index + 1) % self.spell_state.suggestions.len();

            let next_word = &self.spell_state.suggestions[self.spell_state.suggestion_index];
            if next_word == &self.spell_state.original_word {
                self.suggestion_message = Some(format!(
                    "Applied '{}'. Next: '{}' (original)",
                    replacement, next_word
                ));
            } else {
                self.suggestion_message = Some(format!(
                    "Applied '{}'. Next: '{}'",
                    replacement, next_word
                ));
            }
        }
    }

    fn check_word_ended(&mut self) {
        if self.spell_state.showing_suggestions {
            // Convert byte cursor to character position for comparison
            let cursor_char_pos = self.input.buffer[..self.input.cursor_position].chars().count();
            let chars: Vec<char> = self.input.buffer.chars().collect();

            // Allow cursor to be one position past the word if there's a non-word character there
            // This handles "thiss |" where user typed a space after the misspelled word
            let effective_word_end = if self.spell_state.word_end < chars.len()
                && !chars[self.spell_state.word_end].is_alphabetic()
            {
                self.spell_state.word_end + 1
            } else {
                self.spell_state.word_end
            };

            if cursor_char_pos < self.spell_state.word_start || cursor_char_pos > effective_word_end {
                self.spell_state.reset();
                self.suggestion_message = None;
            }
        }
    }

    fn find_misspelled_words(&mut self) -> Vec<(usize, usize)> {
        let mut misspelled = Vec::new();
        let chars: Vec<char> = self.input.buffer.chars().collect();
        let mut i = 0;

        // Helper to check if a character at position is part of a word
        // (alphabetic, or apostrophe between alphabetic characters)
        let is_word_char = |pos: usize| -> bool {
            if pos >= chars.len() {
                return false;
            }
            let c = chars[pos];
            if c.is_alphabetic() {
                return true;
            }
            // Include apostrophe if between alphabetic characters (contractions)
            if c == '\'' {
                let has_alpha_before = pos > 0 && chars[pos - 1].is_alphabetic();
                let has_alpha_after = pos + 1 < chars.len() && chars[pos + 1].is_alphabetic();
                return has_alpha_before && has_alpha_after;
            }
            false
        };

        // Convert byte cursor to character position
        let cursor_char_pos = self.input.buffer[..self.input.cursor_position].chars().count();
        let cached = &self.cached_misspelled;

        // Helper to check if a word overlaps with any cached misspelled range
        let is_cached_misspelled = |start: usize, end: usize| -> bool {
            cached.iter().any(|(cs, ce)| start < *ce && end > *cs)
        };

        // Helper to check if followed by separator
        let has_separator = |end_pos: usize| -> bool {
            if end_pos >= chars.len() {
                return false;
            }
            let next_char = chars[end_pos];
            next_char.is_whitespace() || matches!(next_char, '.' | ',' | '!' | '?' | ';' | ':' | ')' | ']' | '}' | '"' | '%' | '@' | '#' | '$' | '^' | '&' | '*' | '(' | '[' | '{')
        };

        while i < chars.len() {
            // Skip non-word characters
            while i < chars.len() && !chars[i].is_alphabetic() {
                i += 1;
            }
            if i >= chars.len() {
                break;
            }

            let start = i;
            // Continue while we have word characters (including internal apostrophes)
            while i < chars.len() && is_word_char(i) {
                i += 1;
            }
            let end = i;

            let word: String = chars[start..end].iter().collect();
            // Don't check if cursor is inside the word (actively typing)
            let cursor_in_word = cursor_char_pos >= start && cursor_char_pos < end;

            if cursor_in_word {
                // Cursor inside word - don't flag
                continue;
            }

            let at_end_of_input = end >= chars.len();
            let cursor_at_word_end = cursor_char_pos == end;

            if at_end_of_input && cursor_at_word_end {
                // Word at end of input with cursor right at the end
                // Use cached state - if word overlaps with cached misspelled, keep it flagged
                // This keeps words flagged while typing/backspacing until completed again
                if is_cached_misspelled(start, end) {
                    misspelled.push((start, end));
                }
                // If not in cache, don't flag - user is typing a fresh word
            } else if at_end_of_input {
                // Word at end of input but cursor moved away - check spelling
                if !self.spell_checker.is_valid(&word) {
                    misspelled.push((start, end));
                }
            } else if has_separator(end) {
                // Word followed by separator - check spelling
                if !self.spell_checker.is_valid(&word) {
                    misspelled.push((start, end));
                }
            }
            // else: word not followed by separator and not at end - don't check
        }

        // Update cache with current result
        self.cached_misspelled = misspelled.clone();
        misspelled
    }

    fn scroll_output_up(&mut self) {
        let more_mode = self.settings.more_mode_enabled;
        let target_visual_lines = (self.output_height as usize).saturating_sub(2).max(1);
        let visible_height = (self.output_height as usize).max(1);
        let width = (self.output_width as usize).max(1);
        let world = self.current_world_mut();

        // Calculate the minimum scroll_offset where line 0 is at the top
        // This is where all content from line 0 to scroll_offset fits in visible_height
        let mut min_offset = 0usize;
        let mut visual_lines = 0usize;
        for (idx, line) in world.output_lines.iter().enumerate() {
            visual_lines += visual_line_count(&line.text, width);
            if visual_lines >= visible_height {
                min_offset = idx;
                break;
            }
            min_offset = idx;
        }

        // If already at or past the minimum, don't scroll further
        if world.scroll_offset <= min_offset {
            // Still enable pause mode if more_mode is on
            if more_mode && !world.paused {
                world.paused = true;
            }
            return;
        }

        // Count lines being scrolled off (from scroll_offset going backwards)
        // These are the lines that will disappear from the bottom
        let mut visual_lines_moved = 0;
        let mut new_offset = world.scroll_offset;

        while visual_lines_moved < target_visual_lines {
            visual_lines_moved += visual_line_count(&world.output_lines[new_offset].text, width);
            if new_offset == 0 {
                break;
            }
            new_offset -= 1;
        }

        // Clamp to minimum offset
        world.scroll_offset = new_offset.max(min_offset);
        if more_mode && !world.paused {
            world.paused = true;
        }
        // Mark output for redraw
        self.needs_output_redraw = true;
    }

    fn scroll_output_down(&mut self) {
        let target_visual_lines = (self.output_height as usize).saturating_sub(2).max(1);
        let width = (self.output_width as usize).max(1);
        let world = self.current_world_mut();
        let max_scroll = world.output_lines.len().saturating_sub(1);

        if world.scroll_offset >= max_scroll {
            return; // Already at bottom
        }

        // Count lines being scrolled in (from scroll_offset+1 going forwards)
        // These are the lines that will appear at the bottom
        let mut visual_lines_moved = 0;
        let mut new_offset = world.scroll_offset + 1;

        while new_offset <= max_scroll && visual_lines_moved < target_visual_lines {
            visual_lines_moved += visual_line_count(&world.output_lines[new_offset].text, width);
            new_offset += 1;
        }

        // new_offset is one past the last line counted, so subtract 1
        world.scroll_offset = (new_offset - 1).min(max_scroll);

        // If we've scrolled to bottom, unpause
        if world.is_at_bottom() {
            world.paused = false;
        }
        // Mark output for redraw
        self.needs_output_redraw = true;
    }
}

pub enum AppEvent {
    ServerData(String, Vec<u8>),  // world_name, raw bytes
    Disconnected(String),         // world_name
    TelnetDetected(String),       // world_name - telnet negotiation detected
    Prompt(String, Vec<u8>),      // world_name, prompt bytes (from telnet GA)
    WontEchoSeen(String),         // world_name - IAC WONT ECHO detected (for timeout-based prompts)
    SystemMessage(String),       // message to display in current world's output
    // WebSocket events
    WsClientConnected(u64),                    // client_id
    WsClientDisconnected(u64),                 // client_id
    WsClientMessage(u64, Box<WsMessage>),      // client_id, message
    // Multiuser mode events (include username for per-user connection isolation)
    ConnectWorldRequest(usize, String),  // world_index, requesting username
    MultiuserServerData(usize, String, Vec<u8>),  // world_index, username, raw bytes
    MultiuserDisconnected(usize, String),         // world_index, username
    MultiuserTelnetDetected(usize, String),       // world_index, username
    MultiuserPrompt(usize, String, Vec<u8>),      // world_index, username, prompt bytes
    // Slack/Discord events
    SlackMessage(String, String), // world_name, formatted message
    DiscordMessage(String, String), // world_name, formatted message
}

/// Per-user connection state for multiuser mode
/// Each user has their own independent connection to each world
#[derive(Clone)]
pub struct UserConnection {
    pub connected: bool,
    pub command_tx: Option<mpsc::Sender<WriteCommand>>,
    pub output_lines: Vec<OutputLine>,
    pub pending_lines: Vec<OutputLine>,
    pub scroll_offset: usize,
    pub unseen_lines: usize,
    pub paused: bool,
    pub lines_since_pause: usize,
    pub telnet_mode: bool,
    pub prompt: String,
    pub prompt_count: usize,
    pub last_send_time: Option<std::time::Instant>,
    pub last_receive_time: Option<std::time::Instant>,
    pub partial_line: String,
    pub partial_in_pending: bool,
}

impl UserConnection {
    pub fn new() -> Self {
        Self {
            connected: false,
            command_tx: None,
            output_lines: Vec::new(),
            pending_lines: Vec::new(),
            scroll_offset: 0,
            unseen_lines: 0,
            paused: false,
            lines_since_pause: 0,
            telnet_mode: false,
            prompt: String::new(),
            prompt_count: 0,
            last_send_time: None,
            last_receive_time: None,
            partial_line: String::new(),
            partial_in_pending: false,
        }
    }
}

fn get_settings_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".clay.dat")
}

fn get_multiuser_settings_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join(".clay.multiuser.dat")
}

fn get_debug_log_path() -> PathBuf {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    PathBuf::from(home).join("clay.debug.log")
}

/// Write a debug message to clay.debug.log if debug is enabled
fn debug_log(debug_enabled: bool, message: &str) {
    if !debug_enabled {
        return;
    }
    use std::io::Write;
    let path = get_debug_log_path();
    match std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&path)
    {
        Ok(mut file) => {
            // Get local time using libc
            let timestamp = unsafe {
                let mut now: libc::time_t = 0;
                libc::time(&mut now);
                let tm = libc::localtime(&now);
                if tm.is_null() {
                    "????-??-?? ??:??:??".to_string()
                } else {
                    format!(
                        "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                        (*tm).tm_year + 1900,
                        (*tm).tm_mon + 1,
                        (*tm).tm_mday,
                        (*tm).tm_hour,
                        (*tm).tm_min,
                        (*tm).tm_sec
                    )
                }
            };
            let _ = writeln!(file, "[{}] {}", timestamp, message);
        }
        Err(e) => {
            eprintln!("Failed to open debug log {:?}: {}", path, e);
        }
    }
}

/// Log keepalive being sent
fn debug_log_keepalive(debug_enabled: bool, world_name: &str, keepalive_type: &str, data_sent: &str) {
    // Log the command and its bytes for debugging
    let bytes: Vec<u8> = data_sent.bytes().collect();
    debug_log(debug_enabled, &format!("KEEPALIVE world='{}' type={} sent='{}' bytes={:?}", world_name, keepalive_type, data_sent, bytes));
}

/// Encryption key for password storage (padded to 32 bytes for AES-256)
const PASSWORD_ENCRYPTION_KEY: &[u8; 32] = b"nonsupersecretpassword#\0\0\0\0\0\0\0\0\0";

/// Encrypt a password using AES-256-GCM and return base64-encoded result
fn encrypt_password(password: &str) -> String {
    if password.is_empty() {
        return String::new();
    }

    let cipher = Aes256Gcm::new(PASSWORD_ENCRYPTION_KEY.into());

    // Use a fixed nonce derived from the password length (not cryptographically ideal,
    // but acceptable for this obfuscation use case with a known key)
    let mut nonce_bytes = [0u8; 12];
    nonce_bytes[0] = (password.len() & 0xFF) as u8;
    nonce_bytes[1] = ((password.len() >> 8) & 0xFF) as u8;
    // Add some variation based on first few chars
    for (i, b) in password.bytes().take(10).enumerate() {
        nonce_bytes[2 + i] = b;
    }
    let nonce = Nonce::from_slice(&nonce_bytes);

    match cipher.encrypt(nonce, password.as_bytes()) {
        Ok(ciphertext) => {
            // Prepend nonce to ciphertext and base64 encode
            let mut combined = nonce_bytes.to_vec();
            combined.extend(ciphertext);
            format!("ENC:{}", BASE64.encode(&combined))
        }
        Err(_) => {
            // Fallback to plain (shouldn't happen)
            password.to_string()
        }
    }
}

/// Decrypt a password. Returns the original string if it's not encrypted or decryption fails.
fn decrypt_password(stored: &str) -> String {
    if stored.is_empty() {
        return String::new();
    }

    // Check if it's an encrypted password
    if !stored.starts_with("ENC:") {
        // Not encrypted, return as-is (legacy plain password)
        return stored.to_string();
    }

    let encoded = &stored[4..]; // Skip "ENC:" prefix

    let combined = match BASE64.decode(encoded) {
        Ok(data) => data,
        Err(_) => return stored.to_string(), // Invalid base64, treat as plain
    };

    if combined.len() < 12 {
        // Too short to contain nonce, treat as plain
        return stored.to_string();
    }

    let (nonce_bytes, ciphertext) = combined.split_at(12);
    let nonce = Nonce::from_slice(nonce_bytes);
    let cipher = Aes256Gcm::new(PASSWORD_ENCRYPTION_KEY.into());

    match cipher.decrypt(nonce, ciphertext) {
        Ok(plaintext) => String::from_utf8_lossy(&plaintext).to_string(),
        Err(_) => {
            // Decryption failed - might be a plain password that happens to start with "ENC:"
            // This is unlikely but we handle it gracefully
            stored.to_string()
        }
    }
}

fn save_settings(app: &App) -> io::Result<()> {
    // Only master client should save settings
    if !app.is_master {
        return Ok(());
    }
    let path = get_settings_path();
    let mut file = std::fs::File::create(&path)?;

    // Save global settings
    writeln!(file, "[global]")?;
    writeln!(file, "more_mode={}", app.settings.more_mode_enabled)?;
    writeln!(file, "spell_check={}", app.settings.spell_check_enabled)?;
    writeln!(file, "world_switch_mode={}", app.settings.world_switch_mode.name())?;
    writeln!(file, "debug_enabled={}", app.settings.debug_enabled)?;
    writeln!(file, "ansi_music_enabled={}", app.settings.ansi_music_enabled)?;
    writeln!(file, "input_height={}", app.input_height)?;
    writeln!(file, "theme={}", app.settings.theme.name())?;
    writeln!(file, "gui_theme={}", app.settings.gui_theme.name())?;
    writeln!(file, "gui_transparency={}", app.settings.gui_transparency)?;
    writeln!(file, "font_name={}", app.settings.font_name)?;
    writeln!(file, "font_size={}", app.settings.font_size)?;
    writeln!(file, "web_secure={}", app.settings.web_secure)?;
    writeln!(file, "http_enabled={}", app.settings.http_enabled)?;
    writeln!(file, "http_port={}", app.settings.http_port)?;
    writeln!(file, "ws_enabled={}", app.settings.ws_enabled)?;
    writeln!(file, "ws_port={}", app.settings.ws_port)?;
    if !app.settings.websocket_password.is_empty() {
        writeln!(file, "websocket_password={}", encrypt_password(&app.settings.websocket_password))?;
    }
    if !app.settings.websocket_allow_list.is_empty() {
        writeln!(file, "websocket_allow_list={}", app.settings.websocket_allow_list)?;
    }
    if !app.settings.websocket_cert_file.is_empty() {
        writeln!(file, "websocket_cert_file={}", app.settings.websocket_cert_file)?;
    }
    if !app.settings.websocket_key_file.is_empty() {
        writeln!(file, "websocket_key_file={}", app.settings.websocket_key_file)?;
    }
    writeln!(file, "tls_proxy_enabled={}", app.settings.tls_proxy_enabled)?;

    // Save each world's settings
    for world in &app.worlds {
        writeln!(file)?;
        writeln!(file, "[world:{}]", world.name)?;
        writeln!(file, "world_type={}", world.settings.world_type.name())?;
        // MUD settings
        writeln!(file, "hostname={}", world.settings.hostname)?;
        writeln!(file, "port={}", world.settings.port)?;
        writeln!(file, "user={}", world.settings.user)?;
        writeln!(file, "password={}", encrypt_password(&world.settings.password))?;
        writeln!(file, "use_ssl={}", world.settings.use_ssl)?;
        writeln!(file, "encoding={}", world.settings.encoding.name())?;
        writeln!(file, "auto_connect_type={}", world.settings.auto_connect_type.name())?;
        writeln!(file, "keep_alive_type={}", world.settings.keep_alive_type.name())?;
        if !world.settings.keep_alive_cmd.is_empty() {
            writeln!(file, "keep_alive_cmd={}", world.settings.keep_alive_cmd)?;
        }
        if world.settings.log_enabled {
            writeln!(file, "log_enabled=true")?;
        }
        // Slack settings
        if !world.settings.slack_token.is_empty() {
            writeln!(file, "slack_token={}", encrypt_password(&world.settings.slack_token))?;
        }
        if !world.settings.slack_channel.is_empty() {
            writeln!(file, "slack_channel={}", world.settings.slack_channel)?;
        }
        if !world.settings.slack_workspace.is_empty() {
            writeln!(file, "slack_workspace={}", world.settings.slack_workspace)?;
        }
        // Discord settings
        if !world.settings.discord_token.is_empty() {
            writeln!(file, "discord_token={}", encrypt_password(&world.settings.discord_token))?;
        }
        if !world.settings.discord_guild.is_empty() {
            writeln!(file, "discord_guild={}", world.settings.discord_guild)?;
        }
        if !world.settings.discord_channel.is_empty() {
            writeln!(file, "discord_channel={}", world.settings.discord_channel)?;
        }
        if !world.settings.discord_dm_user.is_empty() {
            writeln!(file, "discord_dm_user={}", world.settings.discord_dm_user)?;
        }
    }

    // Save actions (by name, escaping special characters)
    for action in app.settings.actions.iter() {
        writeln!(file)?;
        // Escape special chars in name for section header: ] [ = \
        let escaped_name = action.name
            .replace('\\', "\\\\")
            .replace(']', "\\]")
            .replace('[', "\\[")
            .replace('=', "\\e");
        writeln!(file, "[action:{}]", escaped_name)?;
        if !action.world.is_empty() {
            writeln!(file, "world={}", action.world)?;
        }
        // Only save match_type if not the default (regexp)
        if action.match_type != MatchType::Regexp {
            writeln!(file, "match_type={}", action.match_type.as_str().to_lowercase())?;
        }
        if !action.pattern.is_empty() {
            // Escape newlines and equals signs in pattern
            writeln!(file, "pattern={}", action.pattern.replace('\\', "\\\\").replace('=', "\\e").replace('\n', "\\n"))?;
        }
        if !action.command.is_empty() {
            // Escape newlines and equals signs in command
            writeln!(file, "command={}", action.command.replace('\\', "\\\\").replace('=', "\\e").replace('\n', "\\n"))?;
        }
    }

    // Save permanent bans
    let permanent_bans = app.ban_list.get_permanent_bans();
    if !permanent_bans.is_empty() {
        writeln!(file)?;
        writeln!(file, "[banned_hosts]")?;
        for ip in permanent_bans {
            writeln!(file, "ip={}", ip)?;
        }
    }

    Ok(())
}

fn load_settings(app: &mut App) -> io::Result<()> {
    let path = get_settings_path();
    if !path.exists() {
        return Ok(());
    }

    let file = std::fs::File::open(&path)?;
    let reader = std::io::BufReader::new(file);

    let mut current_world: Option<String> = None;
    let mut current_action: Option<usize> = None;
    let mut in_banned_hosts = false;

    for line in reader.lines() {
        let line = line?;
        let line = line.trim();

        if line.is_empty() {
            continue;
        }

        if line.starts_with("[global]") {
            current_world = None;
            current_action = None;
            in_banned_hosts = false;
            continue;
        }

        if line.starts_with("[banned_hosts]") {
            current_world = None;
            current_action = None;
            in_banned_hosts = true;
            continue;
        }

        if line.starts_with("[world:") && line.ends_with(']') {
            let name = &line[7..line.len() - 1];
            // Find or create world
            let idx = app.find_or_create_world(name);
            current_world = Some(app.worlds[idx].name.clone());
            current_action = None;
            in_banned_hosts = false;
            continue;
        }

        if line.starts_with("[action:") && line.ends_with(']') {
            // Parse action section - supports both old format [action:NUMBER] and new format [action:NAME]
            current_world = None;
            in_banned_hosts = false;
            let section_content = &line[8..line.len() - 1]; // Extract between "[action:" and "]"

            // Unescape the section content (for new format names with special chars)
            let unescaped = section_content
                .replace("\\]", "]")
                .replace("\\[", "[")
                .replace("\\e", "=")
                .replace("\\\\", "\\");

            // Check if it's old format (pure number) or new format (name)
            let is_old_format = unescaped.chars().all(|c| c.is_ascii_digit());

            if is_old_format {
                // Old format: create new action, will get name from name= field
                app.settings.actions.push(Action::new());
                current_action = Some(app.settings.actions.len() - 1);
            } else {
                // New format: look for existing action with this name or create new
                let action_name = unescaped;
                if let Some(idx) = app.settings.actions.iter().position(|a| a.name == action_name) {
                    current_action = Some(idx);
                } else {
                    let mut new_action = Action::new();
                    new_action.name = action_name;
                    app.settings.actions.push(new_action);
                    current_action = Some(app.settings.actions.len() - 1);
                }
            }
            continue;
        }

        if let Some(eq_pos) = line.find('=') {
            let key = &line[..eq_pos];
            let value = &line[eq_pos + 1..];

            // Check for banned hosts section
            if in_banned_hosts {
                if key == "ip" && !value.is_empty() {
                    app.ban_list.add_permanent_ban(value);
                }
                continue;
            }

            // Check for action settings first (current_action takes priority)
            if let Some(action_idx) = current_action {
                // Action settings
                if let Some(action) = app.settings.actions.get_mut(action_idx) {
                    // Helper to unescape saved strings
                    fn unescape_action_value(s: &str) -> String {
                        s.replace("\\n", "\n").replace("\\e", "=").replace("\\\\", "\\")
                    }
                    match key {
                        "name" => action.name = value.to_string(),
                        "world" => action.world = value.to_string(),
                        "match_type" => action.match_type = MatchType::from_str(value),
                        "pattern" => action.pattern = unescape_action_value(value),
                        "command" => action.command = unescape_action_value(value),
                        _ => {}
                    }
                }
            } else if current_world.is_none() {
                // Global settings
                match key {
                    "more_mode" => {
                        app.settings.more_mode_enabled = value == "true";
                    }
                    "spell_check" => {
                        app.settings.spell_check_enabled = value == "true";
                    }
                    "pending_first" => {
                        // Backward compatibility: pending_first=true -> UnseenFirst
                        app.settings.world_switch_mode = if value == "true" {
                            WorldSwitchMode::UnseenFirst
                        } else {
                            WorldSwitchMode::Alphabetical
                        };
                    }
                    "world_switch_mode" => {
                        app.settings.world_switch_mode = WorldSwitchMode::from_name(value);
                    }
                    "debug_enabled" => {
                        app.settings.debug_enabled = value == "true";
                    }
                    "ansi_music_enabled" => {
                        app.settings.ansi_music_enabled = value == "true";
                    }
                    "input_height" => {
                        if let Ok(h) = value.parse::<u16>() {
                            app.input_height = h.clamp(1, 15);
                            app.input.visible_height = app.input_height;
                        }
                    }
                    "theme" => {
                        app.settings.theme = Theme::from_name(value);
                    }
                    "gui_theme" => {
                        app.settings.gui_theme = Theme::from_name(value);
                    }
                    "font_name" => {
                        app.settings.font_name = value.to_string();
                    }
                    "font_size" => {
                        if let Ok(s) = value.parse::<f32>() {
                            app.settings.font_size = s.clamp(8.0, 48.0);
                        }
                    }
                    "gui_transparency" => {
                        if let Ok(t) = value.parse::<f32>() {
                            app.settings.gui_transparency = t.clamp(0.3, 1.0);
                        }
                    }
                    "web_secure" => {
                        app.settings.web_secure = value == "true";
                    }
                    "ws_enabled" => {
                        app.settings.ws_enabled = value == "true";
                    }
                    "ws_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.ws_port = p;
                        }
                    }
                    // Legacy: websocket_enabled maps to ws_enabled
                    "websocket_enabled" => {
                        app.settings.ws_enabled = value == "true";
                    }
                    // Legacy: websocket_port maps to ws_port
                    "websocket_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.ws_port = p;
                        }
                    }
                    // Legacy: websocket_use_tls maps to web_secure
                    "websocket_use_tls" => {
                        app.settings.web_secure = value == "true";
                    }
                    "websocket_password" => {
                        app.settings.websocket_password = decrypt_password(value);
                    }
                    "websocket_allow_list" => {
                        app.settings.websocket_allow_list = value.to_string();
                    }
                    "websocket_cert_file" => {
                        app.settings.websocket_cert_file = value.to_string();
                    }
                    "websocket_key_file" => {
                        app.settings.websocket_key_file = value.to_string();
                    }
                    "http_enabled" => {
                        app.settings.http_enabled = value == "true";
                    }
                    "http_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.http_port = p;
                        }
                    }
                    // Legacy fields - map https to http when web_secure, ws_nonsecure to ws when !web_secure
                    "https_enabled" => {
                        // If https was enabled in old config, set http_enabled and web_secure
                        if value == "true" {
                            app.settings.http_enabled = true;
                            app.settings.web_secure = true;
                        }
                    }
                    "https_port" => {
                        // Legacy: https_port was separate, now http_port is used for both
                        if let Ok(p) = value.parse::<u16>() {
                            // Only use https_port if web_secure is set
                            if app.settings.web_secure {
                                app.settings.http_port = p;
                            }
                        }
                    }
                    "ws_nonsecure_enabled" => {
                        // Legacy: ws_nonsecure maps to ws_enabled when not secure
                        if value == "true" && !app.settings.web_secure {
                            app.settings.ws_enabled = true;
                        }
                    }
                    "ws_nonsecure_port" => {
                        // Legacy: ws_nonsecure_port was separate, now ws_port is used for both
                        if let Ok(p) = value.parse::<u16>() {
                            if !app.settings.web_secure {
                                app.settings.ws_port = p;
                            }
                        }
                    }
                    // Legacy: ignore global encoding, it's now per-world
                    "encoding" => {}
                    "tls_proxy_enabled" => {
                        app.settings.tls_proxy_enabled = value == "true";
                    }
                    _ => {}
                }
            } else if let Some(ref world_name) = current_world {
                // Find the world and update its settings
                if let Some(world) = app.worlds.iter_mut().find(|w| &w.name == world_name) {
                    match key {
                        "world_type" => world.settings.world_type = WorldType::from_name(value),
                        "hostname" => world.settings.hostname = value.to_string(),
                        "port" => world.settings.port = value.to_string(),
                        "user" => world.settings.user = value.to_string(),
                        "password" => world.settings.password = decrypt_password(value),
                        "use_ssl" => world.settings.use_ssl = value == "true",
                        "log_enabled" => world.settings.log_enabled = value == "true",
                        "log_file" => world.settings.log_enabled = true, // Backward compat: old log_file setting enables logging
                        "encoding" => {
                            world.settings.encoding = match value {
                                "latin1" => Encoding::Latin1,
                                "fansi" => Encoding::Fansi,
                                _ => Encoding::Utf8,
                            };
                        }
                        "auto_connect_type" => {
                            world.settings.auto_connect_type = AutoConnectType::from_name(value);
                        }
                        "keep_alive_type" => {
                            world.settings.keep_alive_type = KeepAliveType::from_name(value);
                        }
                        "keep_alive_cmd" => {
                            world.settings.keep_alive_cmd = value.to_string();
                        }
                        // Slack settings
                        "slack_token" => world.settings.slack_token = decrypt_password(value),
                        "slack_channel" => world.settings.slack_channel = value.to_string(),
                        "slack_workspace" => world.settings.slack_workspace = value.to_string(),
                        // Discord settings
                        "discord_token" => world.settings.discord_token = decrypt_password(value),
                        "discord_guild" => world.settings.discord_guild = value.to_string(),
                        "discord_channel" => world.settings.discord_channel = value.to_string(),
                        "discord_dm_user" => world.settings.discord_dm_user = value.to_string(),
                        _ => {}
                    }
                }
            }
        }
    }

    Ok(())
}

/// Load settings for multiuser mode from ~/.clay.multiuser.dat
fn load_multiuser_settings(app: &mut App) -> io::Result<()> {
    let path = get_multiuser_settings_path();
    if !path.exists() {
        return Err(io::Error::new(io::ErrorKind::NotFound, "Multiuser settings file not found"));
    }

    let file = std::fs::File::open(&path)?;
    let reader = std::io::BufReader::new(file);

    let mut current_world: Option<String> = None;
    let mut current_action: Option<usize> = None;
    let mut current_user: Option<String> = None;
    let mut in_banned_hosts = false;

    for line in reader.lines() {
        let line = line?;
        let line = line.trim();

        if line.is_empty() {
            continue;
        }

        if line.starts_with("[global]") {
            current_world = None;
            current_action = None;
            current_user = None;
            in_banned_hosts = false;
            continue;
        }

        if line.starts_with("[banned_hosts]") {
            current_world = None;
            current_action = None;
            current_user = None;
            in_banned_hosts = true;
            continue;
        }

        // Parse [user:NAME] sections
        if line.starts_with("[user:") && line.ends_with(']') {
            let name = &line[6..line.len() - 1];
            // Unescape the name
            let unescaped = name
                .replace("\\]", "]")
                .replace("\\[", "[")
                .replace("\\e", "=")
                .replace("\\\\", "\\");

            // Create new user or find existing
            if !app.users.iter().any(|u| u.name == unescaped) {
                app.users.push(User::new(&unescaped, ""));
            }
            current_user = Some(unescaped);
            current_world = None;
            current_action = None;
            in_banned_hosts = false;
            continue;
        }

        // Parse [world:NAME:OWNER] sections
        if line.starts_with("[world:") && line.ends_with(']') {
            let content = &line[7..line.len() - 1];
            // Find the last colon to split name:owner
            if let Some(last_colon) = content.rfind(':') {
                let name = &content[..last_colon];
                let owner = &content[last_colon + 1..];

                // Unescape both
                let name_unescaped = name
                    .replace("\\:", ":")
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");
                let owner_unescaped = owner
                    .replace("\\:", ":")
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");

                // Find or create world
                let idx = app.find_or_create_world(&name_unescaped);
                app.worlds[idx].owner = Some(owner_unescaped);
                current_world = Some(app.worlds[idx].name.clone());
            } else {
                // No owner specified - this will fail validation later
                let name_unescaped = content
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");
                let idx = app.find_or_create_world(&name_unescaped);
                current_world = Some(app.worlds[idx].name.clone());
            }
            current_action = None;
            current_user = None;
            in_banned_hosts = false;
            continue;
        }

        // Parse [action:NAME:OWNER] sections
        if line.starts_with("[action:") && line.ends_with(']') {
            let content = &line[8..line.len() - 1];
            // Find the last colon to split name:owner
            if let Some(last_colon) = content.rfind(':') {
                let name = &content[..last_colon];
                let owner = &content[last_colon + 1..];

                // Unescape both
                let name_unescaped = name
                    .replace("\\:", ":")
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");
                let owner_unescaped = owner
                    .replace("\\:", ":")
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");

                // Find or create action
                if let Some(idx) = app.settings.actions.iter().position(|a| a.name == name_unescaped) {
                    app.settings.actions[idx].owner = Some(owner_unescaped);
                    current_action = Some(idx);
                } else {
                    let mut new_action = Action::new();
                    new_action.name = name_unescaped;
                    new_action.owner = Some(owner_unescaped);
                    app.settings.actions.push(new_action);
                    current_action = Some(app.settings.actions.len() - 1);
                }
            } else {
                // No owner specified - this will fail validation later
                let name_unescaped = content
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");

                if let Some(idx) = app.settings.actions.iter().position(|a| a.name == name_unescaped) {
                    current_action = Some(idx);
                } else {
                    let mut new_action = Action::new();
                    new_action.name = name_unescaped;
                    app.settings.actions.push(new_action);
                    current_action = Some(app.settings.actions.len() - 1);
                }
            }
            current_world = None;
            current_user = None;
            in_banned_hosts = false;
            continue;
        }

        if let Some(eq_pos) = line.find('=') {
            let key = &line[..eq_pos];
            let value = &line[eq_pos + 1..];

            // Banned hosts section
            if in_banned_hosts {
                if key == "ip" && !value.is_empty() {
                    app.ban_list.add_permanent_ban(value);
                }
                continue;
            }

            // User settings
            if let Some(ref user_name) = current_user {
                if let Some(user) = app.users.iter_mut().find(|u| &u.name == user_name) {
                    if key == "password" {
                        user.password = decrypt_password(value);
                    }
                }
            }
            // Action settings
            else if let Some(action_idx) = current_action {
                if let Some(action) = app.settings.actions.get_mut(action_idx) {
                    fn unescape_action_value(s: &str) -> String {
                        s.replace("\\n", "\n").replace("\\e", "=").replace("\\\\", "\\")
                    }
                    match key {
                        "name" => action.name = value.to_string(),
                        "world" => action.world = value.to_string(),
                        "match_type" => action.match_type = MatchType::from_str(value),
                        "pattern" => action.pattern = unescape_action_value(value),
                        "command" => action.command = unescape_action_value(value),
                        _ => {}
                    }
                }
            }
            // World settings
            else if let Some(ref world_name) = current_world {
                if let Some(world) = app.worlds.iter_mut().find(|w| &w.name == world_name) {
                    match key {
                        "world_type" => world.settings.world_type = WorldType::from_name(value),
                        "hostname" => world.settings.hostname = value.to_string(),
                        "port" => world.settings.port = value.to_string(),
                        "user" => world.settings.user = value.to_string(),
                        "password" => world.settings.password = decrypt_password(value),
                        "use_ssl" => world.settings.use_ssl = value == "true",
                        "log_enabled" => world.settings.log_enabled = value == "true",
                        "encoding" => {
                            world.settings.encoding = match value {
                                "latin1" => Encoding::Latin1,
                                "fansi" => Encoding::Fansi,
                                _ => Encoding::Utf8,
                            };
                        }
                        "auto_connect_type" => {
                            world.settings.auto_connect_type = AutoConnectType::from_name(value);
                        }
                        "keep_alive_type" => {
                            world.settings.keep_alive_type = KeepAliveType::from_name(value);
                        }
                        "keep_alive_cmd" => {
                            world.settings.keep_alive_cmd = value.to_string();
                        }
                        _ => {}
                    }
                }
            }
            // Global settings
            else {
                match key {
                    "ws_enabled" => app.settings.ws_enabled = value == "true",
                    "ws_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.ws_port = p;
                        }
                    }
                    "websocket_password" => app.settings.websocket_password = decrypt_password(value),
                    "websocket_allow_list" => app.settings.websocket_allow_list = value.to_string(),
                    "websocket_cert_file" => app.settings.websocket_cert_file = value.to_string(),
                    "websocket_key_file" => app.settings.websocket_key_file = value.to_string(),
                    "web_secure" => app.settings.web_secure = value == "true",
                    "http_enabled" => app.settings.http_enabled = value == "true",
                    "http_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.http_port = p;
                        }
                    }
                    _ => {}
                }
            }
        }
    }

    Ok(())
}

/// Save settings for multiuser mode to ~/.clay.multiuser.dat
fn save_multiuser_settings(app: &App) -> io::Result<()> {
    let path = get_multiuser_settings_path();
    let mut file = std::fs::File::create(&path)?;

    // [global] section
    writeln!(file, "[global]")?;
    writeln!(file, "ws_enabled={}", app.settings.ws_enabled)?;
    writeln!(file, "ws_port={}", app.settings.ws_port)?;
    if !app.settings.websocket_password.is_empty() {
        writeln!(file, "websocket_password={}", encrypt_password(&app.settings.websocket_password))?;
    }
    if !app.settings.websocket_allow_list.is_empty() {
        writeln!(file, "websocket_allow_list={}", app.settings.websocket_allow_list)?;
    }
    if !app.settings.websocket_cert_file.is_empty() {
        writeln!(file, "websocket_cert_file={}", app.settings.websocket_cert_file)?;
    }
    if !app.settings.websocket_key_file.is_empty() {
        writeln!(file, "websocket_key_file={}", app.settings.websocket_key_file)?;
    }
    writeln!(file, "web_secure={}", app.settings.web_secure)?;
    writeln!(file, "http_enabled={}", app.settings.http_enabled)?;
    writeln!(file, "http_port={}", app.settings.http_port)?;

    // [user:NAME] sections
    for user in &app.users {
        writeln!(file)?;
        let escaped_name = user.name
            .replace('\\', "\\\\")
            .replace(']', "\\]")
            .replace('[', "\\[")
            .replace('=', "\\e")
            .replace(':', "\\:");
        writeln!(file, "[user:{}]", escaped_name)?;
        writeln!(file, "password={}", encrypt_password(&user.password))?;
    }

    // [world:NAME:OWNER] sections
    for world in &app.worlds {
        if let Some(ref owner) = world.owner {
            writeln!(file)?;
            let escaped_name = world.name
                .replace('\\', "\\\\")
                .replace(']', "\\]")
                .replace('[', "\\[")
                .replace('=', "\\e")
                .replace(':', "\\:");
            let escaped_owner = owner
                .replace('\\', "\\\\")
                .replace(']', "\\]")
                .replace('[', "\\[")
                .replace('=', "\\e")
                .replace(':', "\\:");
            writeln!(file, "[world:{}:{}]", escaped_name, escaped_owner)?;
            writeln!(file, "world_type={}", world.settings.world_type.name())?;
            writeln!(file, "hostname={}", world.settings.hostname)?;
            writeln!(file, "port={}", world.settings.port)?;
            if !world.settings.user.is_empty() {
                writeln!(file, "user={}", world.settings.user)?;
            }
            if !world.settings.password.is_empty() {
                writeln!(file, "password={}", encrypt_password(&world.settings.password))?;
            }
            writeln!(file, "use_ssl={}", world.settings.use_ssl)?;
            writeln!(file, "log_enabled={}", world.settings.log_enabled)?;
            writeln!(file, "encoding={}", world.settings.encoding.name())?;
            writeln!(file, "auto_connect_type={}", world.settings.auto_connect_type.name())?;
            writeln!(file, "keep_alive_type={}", world.settings.keep_alive_type.name())?;
            if !world.settings.keep_alive_cmd.is_empty() {
                writeln!(file, "keep_alive_cmd={}", world.settings.keep_alive_cmd)?;
            }
        }
    }

    // [action:NAME:OWNER] sections
    for action in &app.settings.actions {
        if let Some(ref owner) = action.owner {
            writeln!(file)?;
            let escaped_name = action.name
                .replace('\\', "\\\\")
                .replace(']', "\\]")
                .replace('[', "\\[")
                .replace('=', "\\e")
                .replace(':', "\\:");
            let escaped_owner = owner
                .replace('\\', "\\\\")
                .replace(']', "\\]")
                .replace('[', "\\[")
                .replace('=', "\\e")
                .replace(':', "\\:");
            writeln!(file, "[action:{}:{}]", escaped_name, escaped_owner)?;
            if !action.world.is_empty() {
                writeln!(file, "world={}", action.world)?;
            }
            writeln!(file, "match_type={}", action.match_type.as_str().to_lowercase())?;
            // Escape special chars in pattern and command
            let escaped_pattern = action.pattern
                .replace('\\', "\\\\")
                .replace('=', "\\e")
                .replace('\n', "\\n");
            let escaped_command = action.command
                .replace('\\', "\\\\")
                .replace('=', "\\e")
                .replace('\n', "\\n");
            writeln!(file, "pattern={}", escaped_pattern)?;
            writeln!(file, "command={}", escaped_command)?;
        }
    }

    // [banned_hosts] section
    let permanent_bans = app.ban_list.get_permanent_bans();
    if !permanent_bans.is_empty() {
        writeln!(file)?;
        writeln!(file, "[banned_hosts]")?;
        for ip in permanent_bans {
            writeln!(file, "ip={}", ip)?;
        }
    }

    Ok(())
}

fn save_reload_state(app: &App) -> io::Result<()> {
    let path = get_reload_state_path();
    let mut file = std::fs::File::create(&path)?;

    // Save global state
    writeln!(file, "[reload]")?;
    writeln!(file, "current_world_index={}", app.current_world_index)?;
    writeln!(file, "input_height={}", app.input_height)?;
    writeln!(file, "more_mode={}", app.settings.more_mode_enabled)?;
    writeln!(file, "spell_check={}", app.settings.spell_check_enabled)?;
    writeln!(file, "world_switch_mode={}", app.settings.world_switch_mode.name())?;
    writeln!(file, "debug_enabled={}", app.settings.debug_enabled)?;
    writeln!(file, "ansi_music_enabled={}", app.settings.ansi_music_enabled)?;
    writeln!(file, "show_tags={}", app.show_tags)?;
    writeln!(file, "theme={}", app.settings.theme.name())?;
    writeln!(file, "gui_theme={}", app.settings.gui_theme.name())?;
    writeln!(file, "gui_transparency={}", app.settings.gui_transparency)?;
    writeln!(file, "font_name={}", app.settings.font_name)?;
    writeln!(file, "font_size={}", app.settings.font_size)?;
    writeln!(file, "web_secure={}", app.settings.web_secure)?;
    writeln!(file, "http_enabled={}", app.settings.http_enabled)?;
    writeln!(file, "http_port={}", app.settings.http_port)?;
    writeln!(file, "ws_enabled={}", app.settings.ws_enabled)?;
    writeln!(file, "ws_port={}", app.settings.ws_port)?;
    if !app.settings.websocket_password.is_empty() {
        writeln!(file, "websocket_password={}", encrypt_password(&app.settings.websocket_password))?;
    }
    if !app.settings.websocket_allow_list.is_empty() {
        writeln!(file, "websocket_allow_list={}", app.settings.websocket_allow_list)?;
    }
    // Get whitelisted_host from running server, or from settings
    let whitelisted_host = if let Some(ref server) = app.ws_server {
        server.get_whitelisted_host()
    } else {
        app.settings.websocket_whitelisted_host.clone()
    };
    if let Some(ref host) = whitelisted_host {
        writeln!(file, "websocket_whitelisted_host={}", host)?;
    }
    if !app.settings.websocket_cert_file.is_empty() {
        writeln!(file, "websocket_cert_file={}", app.settings.websocket_cert_file)?;
    }
    if !app.settings.websocket_key_file.is_empty() {
        writeln!(file, "websocket_key_file={}", app.settings.websocket_key_file)?;
    }

    // Save input history (base64 encode each line to handle special chars)
    writeln!(file, "history_count={}", app.input.history.len())?;
    for (i, hist) in app.input.history.iter().enumerate() {
        // Simple escape: replace newlines and = with escape sequences
        let escaped = hist.replace('\\', "\\\\").replace('\n', "\\n").replace('=', "\\e");
        writeln!(file, "history_{}={}", i, escaped)?;
    }

    // Save each world's state
    writeln!(file, "world_count={}", app.worlds.len())?;
    for (idx, world) in app.worlds.iter().enumerate() {
        writeln!(file)?;
        writeln!(file, "[world_state:{}]", idx)?;
        writeln!(file, "name={}", world.name.replace('=', "\\e"))?;
        writeln!(file, "scroll_offset={}", world.scroll_offset)?;
        writeln!(file, "connected={}", world.connected)?;
        writeln!(file, "unseen_lines={}", world.unseen_lines)?;
        writeln!(file, "paused={}", world.paused)?;
        writeln!(file, "lines_since_pause={}", world.lines_since_pause)?;
        writeln!(file, "is_tls={}", world.is_tls)?;
        writeln!(file, "was_connected={}", world.was_connected)?;
        writeln!(file, "telnet_mode={}", world.telnet_mode)?;
        writeln!(file, "uses_wont_echo_prompt={}", world.uses_wont_echo_prompt)?;
        if !world.prompt.is_empty() {
            writeln!(file, "prompt={}", world.prompt.replace('=', "\\e"))?;
        }

        // Socket fd if connected (will be passed via env var separately)
        if let Some(fd) = world.socket_fd {
            writeln!(file, "socket_fd={}", fd)?;
        }

        // TLS proxy info (for connection preservation over hot reload)
        if let Some(proxy_pid) = world.proxy_pid {
            writeln!(file, "proxy_pid={}", proxy_pid)?;
        }
        if let Some(ref proxy_socket_path) = world.proxy_socket_path {
            writeln!(file, "proxy_socket_path={}", proxy_socket_path.display())?;
        }

        // World settings
        writeln!(file, "world_type={}", world.settings.world_type.name())?;
        writeln!(file, "hostname={}", world.settings.hostname)?;
        writeln!(file, "port={}", world.settings.port)?;
        writeln!(file, "user={}", world.settings.user.replace('=', "\\e"))?;
        writeln!(file, "password={}", world.settings.password.replace('=', "\\e"))?;
        writeln!(file, "use_ssl={}", world.settings.use_ssl)?;
        writeln!(file, "encoding={}", world.settings.encoding.name())?;
        writeln!(file, "auto_connect_type={}", world.settings.auto_connect_type.name())?;
        writeln!(file, "keep_alive_type={}", world.settings.keep_alive_type.name())?;
        if !world.settings.keep_alive_cmd.is_empty() {
            writeln!(file, "keep_alive_cmd={}", world.settings.keep_alive_cmd.replace('=', "\\e"))?;
        }
        if world.settings.log_enabled {
            writeln!(file, "log_enabled=true")?;
        }
        // Slack settings
        if !world.settings.slack_token.is_empty() {
            writeln!(file, "slack_token={}", world.settings.slack_token.replace('=', "\\e"))?;
        }
        if !world.settings.slack_channel.is_empty() {
            writeln!(file, "slack_channel={}", world.settings.slack_channel.replace('=', "\\e"))?;
        }
        if !world.settings.slack_workspace.is_empty() {
            writeln!(file, "slack_workspace={}", world.settings.slack_workspace.replace('=', "\\e"))?;
        }
        // Discord settings
        if !world.settings.discord_token.is_empty() {
            writeln!(file, "discord_token={}", world.settings.discord_token.replace('=', "\\e"))?;
        }
        if !world.settings.discord_guild.is_empty() {
            writeln!(file, "discord_guild={}", world.settings.discord_guild.replace('=', "\\e"))?;
        }
        if !world.settings.discord_channel.is_empty() {
            writeln!(file, "discord_channel={}", world.settings.discord_channel.replace('=', "\\e"))?;
        }
        if !world.settings.discord_dm_user.is_empty() {
            writeln!(file, "discord_dm_user={}", world.settings.discord_dm_user.replace('=', "\\e"))?;
        }

        // Output lines count (we'll save the actual lines separately due to size)
        writeln!(file, "output_count={}", world.output_lines.len())?;
        writeln!(file, "pending_count={}", world.pending_lines.len())?;
    }

    // Save output lines in a separate section (can be large)
    // Format: timestamp_secs|flags|escaped_text
    // Flags: s = from_server (omit if false), g = gagged (omit if false)
    for (idx, world) in app.worlds.iter().enumerate() {
        writeln!(file)?;
        writeln!(file, "[output:{}]", idx)?;
        for line in &world.output_lines {
            let ts_secs = line.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs();
            let mut flags = String::new();
            if line.from_server { flags.push('s'); }
            if line.gagged { flags.push('g'); }
            let escaped = line.text.replace('\\', "\\\\").replace('\n', "\\n");
            writeln!(file, "{}|{}|{}", ts_secs, flags, escaped)?;
        }
        writeln!(file, "[pending:{}]", idx)?;
        for line in &world.pending_lines {
            let ts_secs = line.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs();
            let mut flags = String::new();
            if line.from_server { flags.push('s'); }
            if line.gagged { flags.push('g'); }
            let escaped = line.text.replace('\\', "\\\\").replace('\n', "\\n");
            writeln!(file, "{}|{}|{}", ts_secs, flags, escaped)?;
        }
    }

    // Save actions (by name, escaping special characters)
    for action in app.settings.actions.iter() {
        writeln!(file)?;
        // Escape special chars in name for section header: ] [ = \
        let escaped_name = action.name
            .replace('\\', "\\\\")
            .replace(']', "\\]")
            .replace('[', "\\[")
            .replace('=', "\\e");
        writeln!(file, "[action:{}]", escaped_name)?;
        if !action.world.is_empty() {
            writeln!(file, "world={}", action.world)?;
        }
        // Only save match_type if not the default (regexp)
        if action.match_type != MatchType::Regexp {
            writeln!(file, "match_type={}", action.match_type.as_str().to_lowercase())?;
        }
        if !action.pattern.is_empty() {
            writeln!(file, "pattern={}", action.pattern.replace('\\', "\\\\").replace('=', "\\e").replace('\n', "\\n"))?;
        }
        if !action.command.is_empty() {
            writeln!(file, "command={}", action.command.replace('\\', "\\\\").replace('=', "\\e").replace('\n', "\\n"))?;
        }
    }

    Ok(())
}

fn unescape_string(s: &str) -> String {
    let mut result = String::new();
    let mut chars = s.chars().peekable();
    while let Some(c) = chars.next() {
        if c == '\\' {
            match chars.next() {
                Some('n') => result.push('\n'),
                Some('e') => result.push('='),
                Some('\\') => result.push('\\'),
                Some(other) => {
                    result.push('\\');
                    result.push(other);
                }
                None => result.push('\\'),
            }
        } else {
            result.push(c);
        }
    }
    result
}

fn load_reload_state(app: &mut App) -> io::Result<bool> {
    let path = get_reload_state_path();
    if !path.exists() {
        return Ok(false);
    }

    let content = std::fs::read_to_string(&path)?;
    let lines: Vec<&str> = content.lines().collect();

    // Parse the reload state
    let mut current_section = String::new();
    let mut current_world_idx: Option<usize> = None;
    let mut output_world_idx: Option<usize> = None;
    let mut pending_world_idx: Option<usize> = None;
    let mut current_action_idx: Option<usize> = None;

    // Temporary storage for world data
    struct TempWorld {
        name: String,
        output_lines: Vec<OutputLine>,
        scroll_offset: usize,
        connected: bool,
        socket_fd: Option<RawFd>,
        proxy_pid: Option<u32>,
        proxy_socket_path: Option<PathBuf>,
        unseen_lines: usize,
        paused: bool,
        pending_lines: Vec<OutputLine>,
        lines_since_pause: usize,
        is_tls: bool,
        was_connected: bool,
        telnet_mode: bool,
        uses_wont_echo_prompt: bool,
        prompt: String,
        settings: WorldSettings,
    }

    // Parse a saved output/pending line with timestamp
    // New format: timestamp_secs|flags|text (flags: s=from_server, g=gagged)
    // Old format: timestamp_secs|text (for backward compatibility)
    fn parse_timestamped_line(line: &str) -> OutputLine {
        let parts: Vec<&str> = line.splitn(3, '|').collect();

        if parts.len() >= 2 {
            if let Ok(ts_secs) = parts[0].parse::<u64>() {
                let timestamp = UNIX_EPOCH + Duration::from_secs(ts_secs);

                if parts.len() == 3 {
                    // New format: timestamp|flags|text
                    let flags = parts[1];
                    let text = unescape_string(parts[2]);
                    let from_server = flags.contains('s');
                    let gagged = flags.contains('g');
                    return OutputLine {
                        text,
                        timestamp,
                        from_server,
                        gagged,
                    };
                } else {
                    // Old format: timestamp|text (assume from_server=true for compatibility)
                    return OutputLine {
                        text: unescape_string(parts[1]),
                        timestamp,
                        from_server: true,
                        gagged: false,
                    };
                }
            }
        }
        // Fallback: no timestamp in old format, use current time
        OutputLine::new(unescape_string(line))
    }

    let mut temp_worlds: Vec<TempWorld> = Vec::new();

    for line in lines {
        // Check for section headers FIRST (before output/pending line handling)
        // This prevents section headers from being added as output lines
        let trimmed = line.trim();
        if trimmed.starts_with('[') && trimmed.ends_with(']') {
            let section = &trimmed[1..trimmed.len() - 1];
            if section == "reload" {
                current_section = "reload".to_string();
            } else if let Some(suffix) = section.strip_prefix("world_state:") {
                let idx: usize = suffix.parse().unwrap_or(0);
                current_section = "world_state".to_string();
                current_world_idx = Some(idx);
                // Ensure we have enough temp worlds
                while temp_worlds.len() <= idx {
                    temp_worlds.push(TempWorld {
                        name: String::new(),
                        output_lines: Vec::new(),
                        scroll_offset: 0,
                        connected: false,
                        socket_fd: None,
                        proxy_pid: None,
                        proxy_socket_path: None,
                        unseen_lines: 0,
                        paused: false,
                        pending_lines: Vec::new(),
                        lines_since_pause: 0,
                        is_tls: false,
                        was_connected: false,
                        telnet_mode: false,
                        uses_wont_echo_prompt: false,
                        prompt: String::new(),
                        settings: WorldSettings::default(),
                    });
                }
            } else if let Some(suffix) = section.strip_prefix("output:") {
                let idx: usize = suffix.parse().unwrap_or(0);
                current_section = "output".to_string();
                output_world_idx = Some(idx);
                pending_world_idx = None;
            } else if let Some(suffix) = section.strip_prefix("pending:") {
                let idx: usize = suffix.parse().unwrap_or(0);
                current_section = "pending".to_string();
                pending_world_idx = Some(idx);
                output_world_idx = None;
            } else if let Some(suffix) = section.strip_prefix("action:") {
                // Parse action section - supports both old format [action:NUMBER] and new format [action:NAME]
                current_section = "action".to_string();

                // Unescape the section content (for new format names with special chars)
                let unescaped = suffix
                    .replace("\\]", "]")
                    .replace("\\[", "[")
                    .replace("\\e", "=")
                    .replace("\\\\", "\\");

                // Check if it's old format (pure number) or new format (name)
                let is_old_format = unescaped.chars().all(|c| c.is_ascii_digit());

                if is_old_format {
                    // Old format: create new action, will get name from name= field
                    app.settings.actions.push(Action::new());
                    current_action_idx = Some(app.settings.actions.len() - 1);
                } else {
                    // New format: look for existing action with this name or create new
                    let action_name = unescaped;
                    if let Some(idx) = app.settings.actions.iter().position(|a| a.name == action_name) {
                        current_action_idx = Some(idx);
                    } else {
                        let mut new_action = Action::new();
                        new_action.name = action_name;
                        app.settings.actions.push(new_action);
                        current_action_idx = Some(app.settings.actions.len() - 1);
                    }
                }
            }
            continue;
        }

        // Handle output/pending lines without trimming to preserve leading spaces
        if current_section == "output" {
            if let Some(idx) = output_world_idx {
                if idx < temp_worlds.len() {
                    temp_worlds[idx].output_lines.push(parse_timestamped_line(line));
                }
            }
            continue;
        }
        if current_section == "pending" {
            if let Some(idx) = pending_world_idx {
                if idx < temp_worlds.len() {
                    temp_worlds[idx].pending_lines.push(parse_timestamped_line(line));
                }
            }
            continue;
        }

        // For non-output sections, trim whitespace
        let line = trimmed;
        if line.is_empty() {
            continue;
        }

        // Parse key=value
        if let Some(eq_pos) = line.find('=') {
            let key = &line[..eq_pos];
            let value = &line[eq_pos + 1..];

            if current_section == "reload" {
                match key {
                    "current_world_index" => {
                        app.current_world_index = value.parse().unwrap_or(0);
                    }
                    "input_height" => {
                        app.input_height = value.parse().unwrap_or(3);
                        app.input.visible_height = app.input_height;
                    }
                    "more_mode" => {
                        app.settings.more_mode_enabled = value == "true";
                    }
                    "spell_check" => {
                        app.settings.spell_check_enabled = value == "true";
                    }
                    "pending_first" => {
                        // Backward compatibility: pending_first=true -> UnseenFirst
                        app.settings.world_switch_mode = if value == "true" {
                            WorldSwitchMode::UnseenFirst
                        } else {
                            WorldSwitchMode::Alphabetical
                        };
                    }
                    "world_switch_mode" => {
                        app.settings.world_switch_mode = WorldSwitchMode::from_name(value);
                    }
                    "debug_enabled" => {
                        app.settings.debug_enabled = value == "true";
                    }
                    "ansi_music_enabled" => {
                        app.settings.ansi_music_enabled = value == "true";
                    }
                    "show_tags" => {
                        app.show_tags = value == "true";
                    }
                    "theme" => {
                        app.settings.theme = Theme::from_name(value);
                    }
                    "gui_theme" => {
                        app.settings.gui_theme = Theme::from_name(value);
                    }
                    "font_name" => {
                        app.settings.font_name = value.to_string();
                    }
                    "font_size" => {
                        if let Ok(s) = value.parse::<f32>() {
                            app.settings.font_size = s.clamp(8.0, 48.0);
                        }
                    }
                    "gui_transparency" => {
                        if let Ok(t) = value.parse::<f32>() {
                            app.settings.gui_transparency = t.clamp(0.3, 1.0);
                        }
                    }
                    "web_secure" => {
                        app.settings.web_secure = value == "true";
                    }
                    "ws_enabled" => {
                        app.settings.ws_enabled = value == "true";
                    }
                    "ws_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.ws_port = p;
                        }
                    }
                    // Legacy: websocket_enabled maps to ws_enabled
                    "websocket_enabled" => {
                        app.settings.ws_enabled = value == "true";
                    }
                    // Legacy: websocket_port maps to ws_port
                    "websocket_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.ws_port = p;
                        }
                    }
                    // Legacy: websocket_use_tls maps to web_secure
                    "websocket_use_tls" => {
                        app.settings.web_secure = value == "true";
                    }
                    "websocket_password" => {
                        app.settings.websocket_password = decrypt_password(value);
                    }
                    "websocket_allow_list" => {
                        app.settings.websocket_allow_list = value.to_string();
                    }
                    "websocket_whitelisted_host" => {
                        app.settings.websocket_whitelisted_host = Some(value.to_string());
                    }
                    "websocket_cert_file" => {
                        app.settings.websocket_cert_file = value.to_string();
                    }
                    "websocket_key_file" => {
                        app.settings.websocket_key_file = value.to_string();
                    }
                    "http_enabled" => {
                        app.settings.http_enabled = value == "true";
                    }
                    "http_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            app.settings.http_port = p;
                        }
                    }
                    // Legacy fields
                    "https_enabled" => {
                        if value == "true" {
                            app.settings.http_enabled = true;
                            app.settings.web_secure = true;
                        }
                    }
                    "https_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            if app.settings.web_secure {
                                app.settings.http_port = p;
                            }
                        }
                    }
                    "ws_nonsecure_enabled" => {
                        if value == "true" && !app.settings.web_secure {
                            app.settings.ws_enabled = true;
                        }
                    }
                    "ws_nonsecure_port" => {
                        if let Ok(p) = value.parse::<u16>() {
                            if !app.settings.web_secure {
                                app.settings.ws_port = p;
                            }
                        }
                    }
                    // Legacy: ignore global encoding, it's now per-world
                    "encoding" => {}
                    "history_count" | "world_count" => {
                        // These are informational, not needed for parsing
                    }
                    k if k.starts_with("history_") => {
                        app.input.history.push(unescape_string(value));
                    }
                    _ => {}
                }
            } else if current_section == "world_state" {
                if let Some(idx) = current_world_idx {
                    if idx < temp_worlds.len() {
                        let tw = &mut temp_worlds[idx];
                        match key {
                            "name" => tw.name = unescape_string(value),
                            "scroll_offset" => tw.scroll_offset = value.parse().unwrap_or(0),
                            "connected" => tw.connected = value == "true",
                            "unseen_lines" => tw.unseen_lines = value.parse().unwrap_or(0),
                            "paused" => tw.paused = value == "true",
                            "lines_since_pause" => tw.lines_since_pause = value.parse().unwrap_or(0),
                            "is_tls" => tw.is_tls = value == "true",
                            "was_connected" => tw.was_connected = value == "true",
                            "telnet_mode" => tw.telnet_mode = value == "true",
                            "uses_wont_echo_prompt" => tw.uses_wont_echo_prompt = value == "true",
                            "prompt" => {
                                // Prompts always end with a single trailing space (normalized on receive)
                                // but trailing spaces are trimmed during file parsing, so add it back
                                let p = unescape_string(value);
                                tw.prompt = if p.is_empty() { p } else { format!("{} ", p.trim_end()) };
                            }
                            "socket_fd" => tw.socket_fd = value.parse().ok(),
                            "proxy_pid" => tw.proxy_pid = value.parse().ok(),
                            "proxy_socket_path" => tw.proxy_socket_path = Some(PathBuf::from(value)),
                            "world_type" => tw.settings.world_type = WorldType::from_name(value),
                            "hostname" => tw.settings.hostname = value.to_string(),
                            "port" => tw.settings.port = value.to_string(),
                            "user" => tw.settings.user = unescape_string(value),
                            "password" => tw.settings.password = unescape_string(value),
                            "use_ssl" => tw.settings.use_ssl = value == "true",
                            "log_enabled" => tw.settings.log_enabled = value == "true",
                            "log_file" => tw.settings.log_enabled = true, // Backward compat
                            "encoding" => {
                                tw.settings.encoding = match value {
                                    "latin1" => Encoding::Latin1,
                                    "fansi" => Encoding::Fansi,
                                    _ => Encoding::Utf8,
                                };
                            }
                            "auto_connect_type" => {
                                tw.settings.auto_connect_type = AutoConnectType::from_name(value);
                            }
                            "keep_alive_type" => {
                                tw.settings.keep_alive_type = KeepAliveType::from_name(value);
                            }
                            "keep_alive_cmd" => {
                                tw.settings.keep_alive_cmd = value.replace("\\e", "=");
                            }
                            // Slack settings
                            "slack_token" => tw.settings.slack_token = unescape_string(value),
                            "slack_channel" => tw.settings.slack_channel = unescape_string(value),
                            "slack_workspace" => tw.settings.slack_workspace = unescape_string(value),
                            // Discord settings
                            "discord_token" => tw.settings.discord_token = unescape_string(value),
                            "discord_guild" => tw.settings.discord_guild = unescape_string(value),
                            "discord_channel" => tw.settings.discord_channel = unescape_string(value),
                            "discord_dm_user" => tw.settings.discord_dm_user = unescape_string(value),
                            _ => {}
                        }
                    }
                }
            } else if current_section == "action" {
                // Action settings
                if let Some(action_idx) = current_action_idx {
                    if let Some(action) = app.settings.actions.get_mut(action_idx) {
                        // Helper to unescape saved strings
                        fn unescape_action_value(s: &str) -> String {
                            s.replace("\\n", "\n").replace("\\e", "=").replace("\\\\", "\\")
                        }
                        match key {
                            "name" => action.name = value.to_string(),
                            "world" => action.world = value.to_string(),
                            "match_type" => action.match_type = MatchType::from_str(value),
                            "pattern" => action.pattern = unescape_action_value(value),
                            "command" => action.command = unescape_action_value(value),
                            _ => {}
                        }
                    }
                }
            }
        }
    }

    // Convert temp worlds to real worlds
    app.worlds.clear();
    for tw in temp_worlds {
        let mut world = World::new(&tw.name);
        world.output_lines = tw.output_lines;
        world.scroll_offset = tw.scroll_offset;
        world.connected = tw.connected;
        world.unseen_lines = tw.unseen_lines;
        world.paused = tw.paused;
        world.pending_lines = tw.pending_lines;
        world.lines_since_pause = tw.lines_since_pause;
        world.is_tls = tw.is_tls;
        world.was_connected = tw.was_connected;
        world.telnet_mode = tw.telnet_mode;
        world.uses_wont_echo_prompt = tw.uses_wont_echo_prompt;
        world.prompt = tw.prompt;
        world.socket_fd = tw.socket_fd;
        world.proxy_pid = tw.proxy_pid;
        world.proxy_socket_path = tw.proxy_socket_path;
        world.settings = tw.settings;
        // Leave timing fields as None for connected worlds after reload
        // This triggers immediate keepalive since we don't know how long connection was idle
        app.worlds.push(world);
    }

    // Note: Don't create initial world here - let ensure_has_world() handle it after
    // settings are fully loaded, to avoid creating unnecessary "clay" world

    // Validate current_world_index
    if app.current_world_index >= app.worlds.len() {
        app.current_world_index = 0;
    }

    // Clean up the reload state file
    let _ = std::fs::remove_file(&path);

    Ok(true)
}

fn clear_cloexec(fd: RawFd) -> io::Result<()> {
    // Clear the FD_CLOEXEC flag so the fd survives exec
    unsafe {
        let flags = libc::fcntl(fd, libc::F_GETFD);
        if flags == -1 {
            return Err(io::Error::last_os_error());
        }
        let new_flags = flags & !libc::FD_CLOEXEC;
        if libc::fcntl(fd, libc::F_SETFD, new_flags) == -1 {
            return Err(io::Error::last_os_error());
        }
    }
    Ok(())
}

/// Check if a process with the given PID is still alive
fn is_process_alive(pid: u32) -> bool {
    // Use waitpid with WNOHANG to check without blocking
    // A return of 0 means the process is still running
    // A return of -1 with ECHILD means the process doesn't exist (not our child)
    // Use kill with signal 0 instead - this works for any process we can signal
    unsafe {
        libc::kill(pid as libc::pid_t, 0) == 0
    }
}

/// Generate a unique socket path for the TLS proxy
fn get_proxy_socket_path(world_name: &str) -> PathBuf {
    let sanitized_name = world_name
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
        .collect::<String>();
    PathBuf::from(format!(
        "/tmp/clay-tls-{}-{}.sock",
        std::process::id(),
        sanitized_name
    ))
}

/// Spawn a TLS proxy process for a world connection.
/// Returns (proxy_pid, socket_path) on success.
/// The proxy process handles the TLS connection to the MUD server and exposes
/// a Unix socket for the main client to connect to.
fn spawn_tls_proxy(
    world_name: &str,
    host: &str,
    port: &str,
) -> io::Result<(u32, PathBuf)> {
    use std::process::{Command, Stdio};

    let socket_path = get_proxy_socket_path(world_name);

    // Remove any existing socket file
    let _ = std::fs::remove_file(&socket_path);

    // Get the current executable path
    let exe_path = std::env::current_exe()?;

    // Spawn the proxy as a separate process using --tls-proxy argument
    // Format: --tls-proxy=host:port:socket_path
    let proxy_arg = format!(
        "--tls-proxy={}:{}:{}",
        host,
        port,
        socket_path.display()
    );

    let child = Command::new(&exe_path)
        .arg(&proxy_arg)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()?;

    let child_pid = child.id();

    // Wait up to 10 seconds for the socket to appear
    let start = std::time::Instant::now();
    let timeout = std::time::Duration::from_secs(10);

    while start.elapsed() < timeout {
        if socket_path.exists() {
            // Socket exists, proxy is ready
            return Ok((child_pid, socket_path));
        }

        // Check if child process died
        if !is_process_alive(child_pid) {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                "TLS proxy process exited unexpectedly",
            ));
        }

        std::thread::sleep(std::time::Duration::from_millis(50));
    }

    // Timeout - kill the child and return error
    unsafe {
        libc::kill(child_pid as libc::pid_t, libc::SIGTERM);
    }
    Err(io::Error::new(
        io::ErrorKind::TimedOut,
        "TLS proxy socket not created in time",
    ))
}

/// Async implementation of the TLS proxy main loop (runs in separate process via --tls-proxy)
async fn run_tls_proxy_async(host: &str, port: &str, socket_path: &PathBuf) {
    use tokio::io::{AsyncReadExt, AsyncWriteExt};
    use tokio::net::{TcpStream, UnixListener};

    // Step 1: Connect to the MUD server with TLS
    let tcp_stream = match TcpStream::connect(format!("{}:{}", host, port)).await {
        Ok(s) => s,
        Err(_) => return,
    };

    // Establish TLS connection
    #[cfg(feature = "rustls-backend")]
    let tls_stream = {
        use std::sync::Arc;
        use rustls::RootCertStore;
        use tokio_rustls::TlsConnector;
        use rustls::pki_types::ServerName;

        // Create a config that accepts invalid certs (common for MUD servers)
        let mut root_store = RootCertStore::empty();
        root_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());

        let config = match rustls::ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
            .with_no_client_auth()
            .try_into()
        {
            Ok(c) => c,
            Err(_) => return,
        };

        let connector = TlsConnector::from(Arc::new(config));
        let server_name = match ServerName::try_from(host.to_string()) {
            Ok(sn) => sn,
            Err(_) => return,
        };

        match connector.connect(server_name, tcp_stream).await {
            Ok(s) => s,
            Err(_) => return,
        }
    };

    #[cfg(feature = "native-tls-backend")]
    let tls_stream = {
        let connector = match native_tls::TlsConnector::builder()
            .danger_accept_invalid_certs(true)
            .build()
        {
            Ok(c) => c,
            Err(_) => return,
        };
        let connector = tokio_native_tls::TlsConnector::from(connector);

        match connector.connect(host, tcp_stream).await {
            Ok(s) => s,
            Err(_) => return,
        }
    };

    #[cfg(not(any(feature = "native-tls-backend", feature = "rustls-backend")))]
    {
        // No TLS backend available
        return;
    }

    // Step 2: Create Unix socket listener
    // Set socket permissions to owner-only (0600)
    // Step 2: Create Unix socket listener
    let listener = match UnixListener::bind(socket_path) {
        Ok(l) => l,
        Err(_) => return,
    };

    // Try to set restrictive permissions on the socket
    let _ = std::fs::set_permissions(socket_path, std::fs::Permissions::from_mode(0o600));

    // Step 3: Main loop - accept clients and relay data
    // Supports reconnection: when client disconnects, wait for new client (for hot reload)
    let (mut tls_read, mut tls_write) = tokio::io::split(tls_stream);

    loop {
        // Wait for client connection with timeout (60 seconds for reconnection)
        let client_stream = match tokio::time::timeout(
            std::time::Duration::from_secs(60),
            listener.accept()
        ).await {
            Ok(Ok((stream, _))) => stream,
            Ok(Err(_)) => break,
            Err(_) => break, // Timeout waiting for client
        };

        let (mut client_read, mut client_write) = client_stream.into_split();

        // Track why we exited the relay loop
        let mut tls_server_disconnected = false;

        // Relay data between client and TLS server
        let mut client_buf = [0u8; 8192];
        let mut tls_buf = [0u8; 8192];

        loop {
            tokio::select! {
                // Client -> TLS
                result = client_read.read(&mut client_buf) => {
                    match result {
                        Ok(0) => break, // Client disconnected, wait for new client
                        Ok(n) => {
                            if tls_write.write_all(&client_buf[..n]).await.is_err() {
                                tls_server_disconnected = true;
                                break;
                            }
                        }
                        Err(_) => break,
                    }
                }
                // TLS -> Client
                result = tls_read.read(&mut tls_buf) => {
                    match result {
                        Ok(0) => {
                            tls_server_disconnected = true;
                            break;
                        }
                        Ok(n) => {
                            if client_write.write_all(&tls_buf[..n]).await.is_err() {
                                break; // Client write failed, wait for new client
                            }
                        }
                        Err(_) => {
                            tls_server_disconnected = true;
                            break;
                        }
                    }
                }
            }
        }

        // If TLS server disconnected, exit the proxy
        if tls_server_disconnected {
            break;
        }

        // Otherwise, loop back to accept a new client (for hot reload)
    }

    // Clean up socket file
    let _ = std::fs::remove_file(socket_path);
}

/// Strip " (deleted)" suffix from a path string if present.
fn strip_deleted_suffix(path_str: &str) -> String {
    // Try common variations of the deleted marker
    for suffix in [" (deleted)", "(deleted)"] {
        if let Some(stripped) = path_str.strip_suffix(suffix) {
            return stripped.to_string();
        }
    }
    path_str.to_string()
}

/// Get the executable path, handling the case where binary was updated.
/// On Linux, if the binary was replaced, /proc/self/exe shows " (deleted)".
/// We strip that suffix to get the path to the new binary.
/// Returns (path, debug_info) for better error messages.
fn get_executable_path() -> io::Result<(PathBuf, String)> {
    let proc_exe = PathBuf::from("/proc/self/exe");
    let link_target = std::fs::read_link(&proc_exe)?;
    let target_str = link_target.to_string_lossy().to_string();
    let clean_path = strip_deleted_suffix(&target_str);
    let debug_info = format!(
        "raw='{}', cleaned='{}', exists={}",
        target_str,
        clean_path,
        PathBuf::from(&clean_path).exists()
    );
    Ok((PathBuf::from(clean_path), debug_info))
}

fn exec_reload(app: &App) -> io::Result<()> {
    // Save the current state
    save_reload_state(app)?;

    // Collect socket fds that need to survive exec
    let mut fds_to_keep: Vec<RawFd> = Vec::new();
    for world in &app.worlds {
        if let Some(fd) = world.socket_fd {
            clear_cloexec(fd)?;
            fds_to_keep.push(fd);
        }
    }

    // Get the executable path with debug info
    let (exe, debug_info) = get_executable_path()?;

    // Verify the executable exists
    if !exe.exists() {
        return Err(io::Error::other(format!(
            "Executable not found. Debug: {}",
            debug_info
        )));
    }

    // Pass fd list via environment (fds must survive exec)
    let fds_str: String = fds_to_keep
        .iter()
        .map(|fd| fd.to_string())
        .collect::<Vec<_>>()
        .join(",");
    std::env::set_var(RELOAD_FDS_ENV, &fds_str);

    // Execute the new binary with --reload argument
    use std::os::unix::process::CommandExt;
    let mut args: Vec<String> = std::env::args().skip(1).filter(|a| a != "--reload").collect();
    args.push("--reload".to_string());
    let err = std::process::Command::new(&exe)
        .args(&args)
        .exec();

    // If we get here, exec failed
    Err(io::Error::other(format!("exec failed: {} (path: {})", err, exe.display())))
}

// ============================================================================
// Remote GUI Client (feature = "remote-gui")
// ============================================================================

#[cfg(feature = "remote-gui")]
mod remote_gui {
    use super::*;
    use egui::{Color32, ScrollArea, TextEdit};
    use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};

    /// Cached "now" time for batch timestamp formatting in GUI
    struct GuiCachedNow {
        year: i32,
        yday: i32,
    }

    impl GuiCachedNow {
        fn new() -> Self {
            use std::time::{SystemTime, UNIX_EPOCH};
            let now_secs = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs() as libc::time_t;

            let mut now_tm: libc::tm = unsafe { std::mem::zeroed() };
            unsafe {
                libc::localtime_r(&now_secs, &mut now_tm);
            }

            Self {
                year: now_tm.tm_year,
                yday: now_tm.tm_yday,
            }
        }
    }

    /// World settings for remote GUI
    #[derive(Clone, Default)]
    pub struct RemoteWorldSettings {
        pub hostname: String,
        pub port: String,
        pub user: String,
        pub password: String,
        pub use_ssl: bool,
        pub log_enabled: bool,
        pub encoding: String,
        pub auto_login: String,
        pub keep_alive_type: String,
        pub keep_alive_cmd: String,
    }

    /// State for a remote world
    #[derive(Clone)]
    pub struct RemoteWorld {
        pub name: String,
        pub connected: bool,
        pub output_lines: Vec<TimestampedLine>,
        pub prompt: String,
        pub settings: RemoteWorldSettings,
        pub unseen_lines: usize,
        pub pending_count: usize,  // Count of pending lines (for pending_first sorting)
        // Timing info (seconds since event, None if never)
        pub last_send_secs: Option<u64>,
        pub last_recv_secs: Option<u64>,
        pub last_nop_secs: Option<u64>,
        // Partial line handling (for lines split across multiple WebSocket messages)
        pub partial_line: String,
    }

    /// Which popup is currently open
    #[derive(PartialEq, Clone)]
    enum PopupState {
        None,
        ConnectedWorlds,  // Combined world selector and connected worlds list
        WorldEditor(usize),  // world index being edited
        WorldConfirmDelete(usize),  // world index to delete
        Setup,
        Web,  // /web - web settings (HTTP/HTTPS/WS)
        Font,
        Help,
        Menu,  // /menu - popup to select windows
        ActionsList,           // Actions list (first window)
        ActionEditor(usize),   // Action editor (second window) - index of action being edited
        ActionConfirmDelete,   // Delete confirmation dialog
        DebugText,             // Debug popup showing raw ANSI codes
    }

    /// Remote GUI client application state
    /// GUI Theme - mirrors the TUI Theme but with egui colors
    #[derive(Clone, Copy, PartialEq)]
    enum GuiTheme {
        Dark,
        Light,
    }

    #[allow(dead_code)]
    impl GuiTheme {
        fn from_name(name: &str) -> Self {
            match name {
                "light" => GuiTheme::Light,
                _ => GuiTheme::Dark,
            }
        }

        fn name(&self) -> &'static str {
            match self {
                GuiTheme::Dark => "Dark",
                GuiTheme::Light => "Light",
            }
        }

        fn next(&self) -> Self {
            match self {
                GuiTheme::Dark => GuiTheme::Light,
                GuiTheme::Light => GuiTheme::Dark,
            }
        }

        fn is_dark(&self) -> bool {
            matches!(self, GuiTheme::Dark)
        }

        fn to_string_value(&self) -> String {
            match self {
                GuiTheme::Dark => "dark".to_string(),
                GuiTheme::Light => "light".to_string(),
            }
        }

        // Background hierarchy (deep -> base -> surface -> elevated -> hover)
        fn bg_deep(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(8, 8, 10),
                GuiTheme::Light => Color32::from_rgb(255, 255, 255),
            }
        }

        fn bg(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(13, 17, 28),
                GuiTheme::Light => Color32::from_rgb(250, 250, 250),
            }
        }

        fn bg_surface(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(20, 20, 24),
                GuiTheme::Light => Color32::from_rgb(245, 245, 245),
            }
        }

        fn bg_elevated(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(26, 26, 31),
                GuiTheme::Light => Color32::from_rgb(240, 240, 240),
            }
        }

        fn bg_hover(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(34, 34, 40),
                GuiTheme::Light => Color32::from_rgb(230, 230, 230),
            }
        }

        // Text hierarchy (primary -> secondary -> muted -> dim)
        fn fg(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(228, 228, 231),
                GuiTheme::Light => Color32::BLACK,
            }
        }

        fn fg_secondary(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(161, 161, 170),
                GuiTheme::Light => Color32::from_rgb(80, 80, 80),
            }
        }

        fn fg_muted(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(113, 113, 122),
                GuiTheme::Light => Color32::from_rgb(120, 120, 120),
            }
        }

        fn fg_dim(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(82, 82, 91),
                GuiTheme::Light => Color32::DARK_GRAY,
            }
        }

        // Accent colors
        fn accent(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(34, 211, 238),  // Softer cyan
                GuiTheme::Light => Color32::from_rgb(0, 100, 180),
            }
        }

        fn accent_dim(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(8, 145, 178),
                GuiTheme::Light => Color32::from_rgb(0, 80, 140),
            }
        }

        fn highlight(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(251, 191, 36),  // Amber
                GuiTheme::Light => Color32::from_rgb(180, 100, 0),
            }
        }

        fn success(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(74, 222, 128),  // Softer green
                GuiTheme::Light => Color32::from_rgb(0, 128, 0),
            }
        }

        fn error(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(248, 113, 113),  // Softer red
                GuiTheme::Light => Color32::from_rgb(180, 0, 0),
            }
        }

        fn error_dim(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(239, 68, 68),
                GuiTheme::Light => Color32::from_rgb(200, 0, 0),
            }
        }

        // Borders
        fn border_subtle(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgba_unmultiplied(255, 255, 255, 15),
                GuiTheme::Light => Color32::from_rgba_unmultiplied(0, 0, 0, 15),
            }
        }

        fn border_medium(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgba_unmultiplied(255, 255, 255, 26),
                GuiTheme::Light => Color32::from_rgba_unmultiplied(0, 0, 0, 26),
            }
        }

        fn panel_bg(&self) -> Color32 {
            self.bg_surface()
        }

        fn button_bg(&self) -> Color32 {
            self.bg_hover()
        }

        fn selection_bg(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(0, 64, 128),
                GuiTheme::Light => Color32::from_rgb(180, 200, 230),
            }
        }

        fn prompt(&self) -> Color32 {
            self.accent()
        }

        fn link(&self) -> Color32 {
            match self {
                GuiTheme::Dark => Color32::from_rgb(100, 149, 237),
                GuiTheme::Light => Color32::from_rgb(0, 0, 238),
            }
        }
    }

    pub struct RemoteGuiApp {
        /// WebSocket URL
        ws_url: String,
        /// Password for authentication
        password: String,
        /// Whether we're connected to the server
        connected: bool,
        /// Whether we're authenticated
        authenticated: bool,
        /// Error message to display
        error_message: Option<String>,
        /// Worlds received from server
        worlds: Vec<RemoteWorld>,
        /// Currently selected world index
        current_world: usize,
        /// Input buffer for commands
        input_buffer: String,
        /// Command completion state - last partial command that was completed
        completion_prefix: String,
        /// Command completion state - index of last match used
        completion_index: usize,
        /// Channel for sending messages to WebSocket
        ws_tx: Option<mpsc::UnboundedSender<WsMessage>>,
        /// Channel for receiving messages from WebSocket
        ws_rx: Option<mpsc::UnboundedReceiver<WsMessage>>,
        /// Runtime handle for async operations
        runtime: tokio::runtime::Handle,
        /// Flag indicating password was submitted
        password_submitted: bool,
        /// Flag indicating we've attempted auto-connect for allow list
        auto_connect_attempted: bool,
        /// Time when connection was established (for allow list timeout)
        connect_time: Option<std::time::Instant>,
        /// Current popup state
        popup_state: PopupState,
        /// Selected item in menu popup
        menu_selected: usize,
        /// Selected world in world list popup
        world_list_selected: usize,
        /// Filter text for worlds popup
        connected_worlds_filter: String,
        /// Only show connected worlds toggle
        only_connected_worlds: bool,
        /// Temp fields for world editor
        edit_name: String,
        edit_hostname: String,
        edit_port: String,
        edit_user: String,
        edit_password: String,
        edit_ssl: bool,
        edit_log_enabled: bool,
        edit_encoding: Encoding,
        edit_auto_login: AutoConnectType,
        edit_keep_alive_type: KeepAliveType,
        edit_keep_alive_cmd: String,
        /// Input area height in lines
        input_height: u16,
        /// Console theme (for TUI on server)
        console_theme: GuiTheme,
        /// GUI theme (local)
        theme: GuiTheme,
        /// Font name (empty for system default)
        font_name: String,
        /// Font size in points
        font_size: f32,
        /// Temp field for font editor
        edit_font_name: String,
        /// Temp field for font size editor
        edit_font_size: String,
        /// Last loaded font name (to avoid reloading)
        loaded_font_name: String,
        /// Command history
        command_history: Vec<String>,
        /// Current position in command history (0 = current input, 1+ = history)
        history_index: usize,
        /// Saved input when browsing history
        saved_input: String,
        /// Manual scroll offset for output (None = auto-scroll to bottom)
        scroll_offset: Option<f32>,
        /// Maximum scroll offset (content height - viewport height)
        scroll_max_offset: f32,
        /// Show MUD tags
        show_tags: bool,
        /// Highlight lines matching action patterns
        highlight_actions: bool,
        /// More mode enabled (pause on overflow)
        more_mode: bool,
        /// Spell check enabled
        spell_check_enabled: bool,
        /// Filter text for output
        filter_text: String,
        /// Whether filter popup is open
        filter_active: bool,
        /// WebSocket allow list (CSV of hosts that can connect without password)
        ws_allow_list: String,
        /// Web secure protocol (true = https/wss, false = http/ws)
        web_secure: bool,
        /// HTTP/HTTPS server enabled
        http_enabled: bool,
        /// HTTP/HTTPS server port
        http_port: u16,
        /// WS/WSS server enabled
        ws_enabled: bool,
        /// WS/WSS server port
        ws_port: u16,
        /// TLS certificate file path
        ws_cert_file: String,
        /// TLS key file path
        ws_key_file: String,
        /// World switching mode (Unseen First or Alphabetical)
        world_switch_mode: WorldSwitchMode,
        /// Debug logging enabled (synced from server, not used locally)
        debug_enabled: bool,
        /// Spell checker for input validation
        spell_checker: SpellChecker,
        /// Spell check state (suggestions, current word, etc.)
        spell_state: SpellState,
        /// Message about spell suggestions
        suggestion_message: Option<String>,
        /// Actions synced from server
        actions: Vec<Action>,
        /// Selected action index in actions list
        actions_selected: usize,
        /// Filter text for actions list
        actions_list_filter: String,
        /// Action editor temp fields
        edit_action_name: String,
        edit_action_world: String,
        edit_action_match_type: MatchType,
        edit_action_pattern: String,
        edit_action_command: String,
        /// Action error message
        action_error: Option<String>,
        /// Debug text for showing raw ANSI codes
        debug_text: String,
        /// Window transparency (0.0 = fully transparent, 1.0 = fully opaque)
        transparency: f32,
        /// Original transparency when setup popup opened (for cancel/revert)
        original_transparency: Option<f32>,
        /// ANSI music enabled
        ansi_music_enabled: bool,
        /// TLS proxy enabled (for connection preservation over hot reload)
        tls_proxy_enabled: bool,
        /// Audio output stream (must stay alive for audio to play)
        #[cfg(feature = "rodio")]
        audio_stream: Option<rodio::OutputStream>,
        /// Audio output stream handle for playing sounds
        #[cfg(feature = "rodio")]
        audio_stream_handle: Option<rodio::OutputStreamHandle>,
    }

    /// Square wave audio source for ANSI music playback
    #[cfg(feature = "rodio")]
    struct SquareWaveSource {
        sample_rate: u32,
        frequency: f32,
        duration_samples: usize,
        current_sample: usize,
    }

    #[cfg(feature = "rodio")]
    impl SquareWaveSource {
        fn new(frequency: f32, duration_ms: u32, sample_rate: u32) -> Self {
            let duration_samples = (sample_rate as f32 * duration_ms as f32 / 1000.0) as usize;
            Self {
                sample_rate,
                frequency,
                duration_samples,
                current_sample: 0,
            }
        }
    }

    #[cfg(feature = "rodio")]
    impl Iterator for SquareWaveSource {
        type Item = f32;

        fn next(&mut self) -> Option<Self::Item> {
            if self.current_sample >= self.duration_samples {
                return None;
            }

            let t = self.current_sample as f32 / self.sample_rate as f32;
            let sample = if self.frequency > 0.0 {
                // Square wave: sign of sine wave
                let phase = (t * self.frequency * 2.0 * std::f32::consts::PI).sin();
                if phase >= 0.0 { 0.15 } else { -0.15 }  // Low volume to not be too loud
            } else {
                0.0  // Rest/silence
            };

            self.current_sample += 1;
            Some(sample)
        }
    }

    #[cfg(feature = "rodio")]
    impl rodio::Source for SquareWaveSource {
        fn current_frame_len(&self) -> Option<usize> {
            Some(self.duration_samples - self.current_sample)
        }

        fn channels(&self) -> u16 {
            1  // Mono
        }

        fn sample_rate(&self) -> u32 {
            self.sample_rate
        }

        fn total_duration(&self) -> Option<std::time::Duration> {
            Some(std::time::Duration::from_millis(
                (self.duration_samples as f32 / self.sample_rate as f32 * 1000.0) as u64
            ))
        }
    }

    /// Discord emoji segment for rendering
    #[derive(Debug, Clone)]
    enum DiscordSegment {
        Text(String),
        Emoji { name: String, id: String, animated: bool },
        ColoredSquare(egui::Color32),
    }

    impl RemoteGuiApp {
        pub fn new(ws_url: String, runtime: tokio::runtime::Handle) -> Self {
            Self {
                ws_url,
                password: String::new(),
                connected: false,
                authenticated: false,
                error_message: None,
                worlds: Vec::new(),
                current_world: 0,
                input_buffer: String::new(),
                completion_prefix: String::new(),
                completion_index: 0,
                ws_tx: None,
                ws_rx: None,
                runtime,
                password_submitted: false,
                auto_connect_attempted: false,
                connect_time: None,
                popup_state: PopupState::None,
                menu_selected: 0,
                world_list_selected: 0,
                connected_worlds_filter: String::new(),
                only_connected_worlds: false,
                edit_name: String::new(),
                edit_hostname: String::new(),
                edit_port: String::new(),
                edit_user: String::new(),
                edit_password: String::new(),
                edit_ssl: false,
                edit_log_enabled: false,
                edit_encoding: Encoding::Utf8,
                edit_auto_login: AutoConnectType::Connect,
                edit_keep_alive_type: KeepAliveType::Nop,
                edit_keep_alive_cmd: String::new(),
                input_height: 3,
                console_theme: GuiTheme::Dark,
                theme: GuiTheme::Dark,
                font_name: String::new(),
                font_size: 14.0,
                edit_font_name: String::new(),
                edit_font_size: String::from("14.0"),
                loaded_font_name: String::from("__uninitialized__"),
                command_history: Vec::new(),
                history_index: 0,
                saved_input: String::new(),
                scroll_offset: None,
                scroll_max_offset: 0.0,
                show_tags: false,
                highlight_actions: false,
                more_mode: true,
                spell_check_enabled: true,
                filter_text: String::new(),
                filter_active: false,
                ws_allow_list: String::new(),
                web_secure: false,
                http_enabled: false,
                http_port: 9000,
                ws_enabled: false,
                ws_port: 9001,
                ws_cert_file: String::new(),
                ws_key_file: String::new(),
                world_switch_mode: WorldSwitchMode::UnseenFirst,
                debug_enabled: false,
                spell_checker: SpellChecker::new(),
                spell_state: SpellState::new(),
                suggestion_message: None,
                actions: Vec::new(),
                actions_selected: 0,
                actions_list_filter: String::new(),
                edit_action_name: String::new(),
                edit_action_world: String::new(),
                edit_action_match_type: MatchType::Regexp,
                edit_action_pattern: String::new(),
                edit_action_command: String::new(),
                action_error: None,
                debug_text: String::new(),
                transparency: 1.0,
                original_transparency: None,
                ansi_music_enabled: true,
                tls_proxy_enabled: false,
                #[cfg(feature = "rodio")]
                audio_stream: None,
                #[cfg(feature = "rodio")]
                audio_stream_handle: None,
            }
        }

        /// Initialize audio output for ANSI music playback
        #[cfg(feature = "rodio")]
        fn init_audio(&mut self) {
            if self.audio_stream.is_none() {
                match rodio::OutputStream::try_default() {
                    Ok((stream, handle)) => {
                        self.audio_stream = Some(stream);
                        self.audio_stream_handle = Some(handle);
                    }
                    Err(_) => {
                        // Audio initialization failed - music will be silently disabled
                    }
                }
            }
        }

        /// Play ANSI music notes
        #[cfg(feature = "rodio")]
        fn play_ansi_music(&mut self, notes: &[crate::ansi_music::MusicNote]) {
            if !self.ansi_music_enabled || notes.is_empty() {
                return;
            }

            // Initialize audio if not already done
            self.init_audio();

            if let Some(handle) = &self.audio_stream_handle {
                // Create a sink for sequential playback
                if let Ok(sink) = rodio::Sink::try_new(handle) {
                    for note in notes {
                        let source = SquareWaveSource::new(note.frequency, note.duration_ms, 44100);
                        sink.append(source);
                    }
                    // Detach the sink so it plays in the background
                    sink.detach();
                }
            }
        }

        /// Play ANSI music notes (no-op when rodio is not available)
        #[cfg(not(feature = "rodio"))]
        fn play_ansi_music(&mut self, _notes: &[crate::ansi_music::MusicNote]) {
            // Audio playback disabled - rodio feature not enabled
        }

        /// Try to find a system font file by name
        fn find_system_font(font_name: &str) -> Option<Vec<u8>> {
            // Common font directories on Linux
            let font_dirs = [
                "/usr/share/fonts",
                "/usr/local/share/fonts",
                "~/.fonts",
                "~/.local/share/fonts",
            ];

            // Map font names to common file names
            let file_patterns: &[&str] = match font_name {
                "Monospace" => &["DejaVuSansMono.ttf", "LiberationMono-Regular.ttf", "UbuntuMono-R.ttf"],
                "DejaVu Sans Mono" => &["DejaVuSansMono.ttf"],
                "Liberation Mono" => &["LiberationMono-Regular.ttf"],
                "Ubuntu Mono" => &["UbuntuMono-R.ttf", "UbuntuMono-Regular.ttf"],
                "Fira Code" => &["FiraCode-Regular.ttf", "FiraCode-Retina.ttf"],
                "Source Code Pro" => &["SourceCodePro-Regular.ttf", "SourceCodePro-Regular.otf"],
                "JetBrains Mono" => &["JetBrainsMono-Regular.ttf", "JetBrainsMono[wght].ttf"],
                "Hack" => &["Hack-Regular.ttf"],
                "Inconsolata" => &["Inconsolata-Regular.ttf", "Inconsolata.ttf"],
                "Courier New" => &["cour.ttf", "CourierNew.ttf"],
                "Consolas" => &["consola.ttf", "Consolas.ttf"],
                _ => &[],
            };

            // Search for font files
            for dir in &font_dirs {
                let dir_path = if dir.starts_with('~') {
                    if let Some(home) = std::env::var_os("HOME") {
                        std::path::PathBuf::from(home).join(&dir[2..])
                    } else {
                        continue;
                    }
                } else {
                    std::path::PathBuf::from(dir)
                };

                if !dir_path.exists() {
                    continue;
                }

                // Recursively search for font files
                fn search_dir(dir: &std::path::Path, patterns: &[&str]) -> Option<Vec<u8>> {
                    if let Ok(entries) = std::fs::read_dir(dir) {
                        for entry in entries.flatten() {
                            let path = entry.path();
                            if path.is_dir() {
                                if let Some(data) = search_dir(&path, patterns) {
                                    return Some(data);
                                }
                            } else if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                                for pattern in patterns {
                                    if name.eq_ignore_ascii_case(pattern) {
                                        if let Ok(data) = std::fs::read(&path) {
                                            return Some(data);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    None
                }

                if let Some(data) = search_dir(&dir_path, file_patterns) {
                    return Some(data);
                }
            }

            None
        }

        fn connect_websocket(&mut self) {
            // Determine URL scheme - if ws_url starts with wss:// or ws://, use as-is
            // Otherwise, try wss:// (secure) by default
            let url = if self.ws_url.starts_with("ws://") || self.ws_url.starts_with("wss://") {
                self.ws_url.clone()
            } else {
                // Default to wss:// for security
                format!("wss://{}", self.ws_url)
            };

            let (tx, rx) = mpsc::unbounded_channel::<WsMessage>();
            let (out_tx, mut out_rx) = mpsc::unbounded_channel::<WsMessage>();

            self.ws_tx = Some(out_tx);
            self.ws_rx = Some(rx);

            let password_hash = hash_password(&self.password);
            let password_submitted = self.password_submitted;
            let ws_url_for_fallback = self.ws_url.clone();

            self.runtime.spawn(async move {
                // Try to connect - for wss:// we need to configure TLS
                #[cfg(feature = "native-tls-backend")]
                let connect_result = if url.starts_with("wss://") {
                    // Create a TLS connector that accepts self-signed certificates
                    let tls_connector = native_tls::TlsConnector::builder()
                        .danger_accept_invalid_certs(true)
                        .danger_accept_invalid_hostnames(true)
                        .build()
                        .map_err(|e| tokio_tungstenite::tungstenite::Error::Tls(
                            tokio_tungstenite::tungstenite::error::TlsError::Native(e)
                        ));

                    match tls_connector {
                        Ok(connector) => {
                            let connector = tokio_tungstenite::Connector::NativeTls(connector);
                            tokio_tungstenite::connect_async_tls_with_config(
                                &url,
                                None,
                                false,
                                Some(connector),
                            ).await.map(|(ws, resp)| (ws, resp))
                        }
                        Err(e) => Err(e),
                    }
                } else {
                    connect_async(&url).await
                };

                // Without native-tls, only ws:// is supported
                #[cfg(not(feature = "native-tls-backend"))]
                let connect_result = {
                    // For rustls backend, fall back to ws://
                    let ws_url = if url.starts_with("wss://") {
                        format!("ws://{}", ws_url_for_fallback)
                    } else {
                        url.clone()
                    };
                    connect_async(&ws_url).await
                };

                // If wss:// failed and we defaulted to it, try ws:// as fallback
                #[cfg(feature = "native-tls-backend")]
                let connect_result = match connect_result {
                    Ok(result) => Ok(result),
                    Err(_e) if url.starts_with("wss://") && !ws_url_for_fallback.starts_with("wss://") => {
                        // Try ws:// fallback
                        let fallback_url = format!("ws://{}", ws_url_for_fallback);
                        connect_async(&fallback_url).await
                    }
                    Err(e) => Err(e),
                };

                match connect_result {
                    Ok((ws_stream, _)) => {
                        use futures::SinkExt;
                        let (mut ws_sink, mut ws_source) = ws_stream.split();

                        // Send auth request if password was submitted
                        if password_submitted {
                            let auth_msg = WsMessage::AuthRequest { username: None, password_hash };
                            if let Ok(json) = serde_json::to_string(&auth_msg) {
                                let _ = ws_sink.send(WsRawMessage::Text(json.into())).await;
                            }
                        }

                        // Spawn sender task
                        let mut ws_sink = ws_sink;
                        tokio::spawn(async move {
                            while let Some(msg) = out_rx.recv().await {
                                if let Ok(json) = serde_json::to_string(&msg) {
                                    if ws_sink.send(WsRawMessage::Text(json.into())).await.is_err() {
                                        break;
                                    }
                                }
                            }
                        });

                        // Receive messages
                        while let Some(msg_result) = ws_source.next().await {
                            match msg_result {
                                Ok(WsRawMessage::Text(text)) => {
                                    if let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) {
                                        if tx.send(ws_msg).is_err() {
                                            break;
                                        }
                                    }
                                }
                                Ok(WsRawMessage::Close(_)) => break,
                                Err(_) => break,
                                _ => {}
                            }
                        }
                    }
                    Err(e) => {
                        let _ = tx.send(WsMessage::AuthResponse {
                            success: false,
                            error: Some(format!("Connection failed: {}", e)),
                            username: None,
                            multiuser_mode: false,
                        });
                    }
                }
            });

            self.connected = true;
            self.connect_time = Some(std::time::Instant::now());
        }

        /// Send authentication request with current password
        fn send_auth(&mut self) {
            if let Some(ref tx) = self.ws_tx {
                let password_hash = hash_password(&self.password);
                let _ = tx.send(WsMessage::AuthRequest { username: None, password_hash });
            }
        }

        fn process_messages(&mut self) {
            // Collect deferred actions to avoid borrow issues
            let mut deferred_switch: Option<usize> = None;
            let mut deferred_connect: Option<usize> = None;
            let mut deferred_edit: Option<usize> = None;
            let mut deferred_music: Vec<crate::ansi_music::MusicNote> = Vec::new();

            if let Some(ref mut rx) = self.ws_rx {
                while let Ok(msg) = rx.try_recv() {
                    match msg {
                        WsMessage::AuthResponse { success, error, .. } => {
                            if success {
                                self.authenticated = true;
                                self.error_message = None;
                            } else {
                                self.error_message = error;
                                self.authenticated = false;
                            }
                        }
                        WsMessage::InitialState { worlds, current_world_index, settings, actions, .. } => {
                            // Track if this is first InitialState or a resync
                            let is_resync = !self.worlds.is_empty();
                            self.worlds = worlds.into_iter().map(|w| {
                                // Calculate pending count before moving pending_lines
                                let pending_count = if !w.pending_lines_ts.is_empty() {
                                    w.pending_lines_ts.len()
                                } else {
                                    w.pending_lines.len()
                                };
                                RemoteWorld {
                                name: w.name,
                                connected: w.connected,
                                // Combine output_lines and pending_lines (each client handles more mode locally)
                                output_lines: {
                                    let mut lines = if !w.output_lines_ts.is_empty() {
                                        w.output_lines_ts
                                    } else {
                                        // Fallback for old protocol: use current time
                                        let now = current_timestamp_secs();
                                        w.output_lines.into_iter().map(|text| TimestampedLine { text, ts: now }).collect()
                                    };
                                    // Append pending lines (server's more mode shouldn't affect clients)
                                    if !w.pending_lines_ts.is_empty() {
                                        lines.extend(w.pending_lines_ts);
                                    } else {
                                        let now = current_timestamp_secs();
                                        lines.extend(w.pending_lines.into_iter().map(|text| TimestampedLine { text, ts: now }));
                                    }
                                    lines
                                },
                                prompt: w.prompt,
                                settings: RemoteWorldSettings {
                                    hostname: w.settings.hostname,
                                    port: w.settings.port,
                                    user: w.settings.user,
                                    password: decrypt_password(&w.settings.password),
                                    use_ssl: w.settings.use_ssl,
                                    log_enabled: w.settings.log_enabled,
                                    encoding: w.settings.encoding,
                                    auto_login: w.settings.auto_connect_type,
                                    keep_alive_type: w.keep_alive_type.clone(),
                                    keep_alive_cmd: w.settings.keep_alive_cmd.clone(),
                                },
                                unseen_lines: w.unseen_lines,  // Use server's centralized unseen tracking
                                pending_count,
                                last_send_secs: w.last_send_secs,
                                last_recv_secs: w.last_recv_secs,
                                last_nop_secs: w.last_nop_secs,
                                partial_line: String::new(),
                            }}).collect();
                            // On first InitialState, use server's world index
                            // On resync, preserve current world (bounded by new world count)
                            if !is_resync {
                                self.current_world = current_world_index;
                            } else if self.current_world >= self.worlds.len() {
                                self.current_world = self.worlds.len().saturating_sub(1);
                            }
                            self.console_theme = GuiTheme::from_name(&settings.console_theme);
                            self.theme = GuiTheme::from_name(&settings.gui_theme);
                            self.font_name = settings.font_name;
                            self.font_size = settings.font_size;
                            self.transparency = settings.gui_transparency;
                            self.ws_allow_list = settings.ws_allow_list;
                            self.web_secure = settings.web_secure;
                            self.http_enabled = settings.http_enabled;
                            self.http_port = settings.http_port;
                            self.ws_enabled = settings.ws_enabled;
                            self.ws_port = settings.ws_port;
                            self.ws_cert_file = settings.ws_cert_file;
                            self.ws_key_file = settings.ws_key_file;
                            self.world_switch_mode = WorldSwitchMode::from_name(&settings.world_switch_mode);
                            self.debug_enabled = settings.debug_enabled;
                            self.more_mode = settings.more_mode_enabled;
                            self.spell_check_enabled = settings.spell_check_enabled;
                            self.show_tags = settings.show_tags;
                            self.ansi_music_enabled = settings.ansi_music_enabled;
                            self.tls_proxy_enabled = settings.tls_proxy_enabled;
                            self.actions = actions;
                        }
                        WsMessage::ServerData { world_index, data, is_viewed: _, ts } => {
                            if world_index < self.worlds.len() {
                                let world = &mut self.worlds[world_index];

                                // Combine with any partial line from previous message
                                let combined = if world.partial_line.is_empty() {
                                    data.clone()
                                } else {
                                    let mut s = std::mem::take(&mut world.partial_line);
                                    s.push_str(&data);
                                    s
                                };

                                // Check if data ends with newline (complete line) or not (partial)
                                let ends_with_newline = combined.ends_with('\n');

                                // Split into lines
                                let lines: Vec<&str> = combined.lines().collect();
                                let line_count = lines.len();

                                for (i, line) in lines.into_iter().enumerate() {
                                    let is_last = i == line_count - 1;

                                    if is_last && !ends_with_newline {
                                        // Last line without trailing newline - it's a partial
                                        world.partial_line = line.to_string();
                                    } else {
                                        // Skip lines that are only ANSI codes (cursor control garbage)
                                        if is_ansi_only_line(line) {
                                            continue;
                                        }
                                        // Complete line - add to output
                                        // Truncate very long lines to prevent performance issues
                                        let text = if line.len() > MAX_LINE_LENGTH {
                                            let mut truncate_at = MAX_LINE_LENGTH;
                                            while truncate_at > 0 && !line.is_char_boundary(truncate_at) {
                                                truncate_at -= 1;
                                            }
                                            format!("{}\x1b[0m\x1b[33m... [truncated]\x1b[0m", &line[..truncate_at])
                                        } else {
                                            line.to_string()
                                        };
                                        world.output_lines.push(TimestampedLine { text, ts });
                                    }
                                }
                                // Note: Don't track unseen_lines locally - server handles centralized tracking
                                // and will broadcast UnseenUpdate/UnseenCleared when counts change
                            }
                        }
                        WsMessage::WorldConnected { world_index, name } => {
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].connected = true;
                                self.worlds[world_index].name = name;
                            }
                        }
                        WsMessage::WorldDisconnected { world_index } => {
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].connected = false;
                            }
                        }
                        WsMessage::WorldFlushed { world_index } => {
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].output_lines.clear();
                                self.worlds[world_index].pending_count = 0;
                            }
                        }
                        WsMessage::AnsiMusic { world_index: _, notes } => {
                            // Defer playing music to avoid borrow issues
                            deferred_music.extend(notes);
                        }
                        WsMessage::WorldRemoved { world_index } => {
                            if world_index < self.worlds.len() {
                                self.worlds.remove(world_index);
                                // Adjust current_world if needed
                                if self.current_world >= self.worlds.len() {
                                    self.current_world = self.worlds.len().saturating_sub(1);
                                } else if self.current_world > world_index {
                                    self.current_world -= 1;
                                }
                                // Adjust world_list_selected if needed
                                if self.world_list_selected >= self.worlds.len() {
                                    self.world_list_selected = self.worlds.len().saturating_sub(1);
                                } else if self.world_list_selected > world_index {
                                    self.world_list_selected -= 1;
                                }
                            }
                        }
                        WsMessage::WorldSwitched { new_index } => {
                            self.current_world = new_index;
                            // Mark seen when switching to a world
                            if new_index < self.worlds.len() {
                                self.worlds[new_index].unseen_lines = 0;
                            }
                        }
                        WsMessage::PromptUpdate { world_index, prompt } => {
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].prompt = prompt;
                            }
                        }
                        WsMessage::WorldSettingsUpdated { world_index, settings, name } => {
                            // Update local world settings from server confirmation
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].name = name;
                                self.worlds[world_index].settings.hostname = settings.hostname;
                                self.worlds[world_index].settings.port = settings.port;
                                self.worlds[world_index].settings.user = settings.user;
                                self.worlds[world_index].settings.use_ssl = settings.use_ssl;
                                self.worlds[world_index].settings.keep_alive_type = settings.keep_alive_type;
                                self.worlds[world_index].settings.keep_alive_cmd = settings.keep_alive_cmd;
                            }
                        }
                        WsMessage::GlobalSettingsUpdated { settings, input_height } => {
                            // Update local global settings from server confirmation
                            self.console_theme = GuiTheme::from_name(&settings.console_theme);
                            self.theme = GuiTheme::from_name(&settings.gui_theme);
                            self.input_height = input_height;
                            self.font_name = settings.font_name;
                            self.font_size = settings.font_size;
                            self.transparency = settings.gui_transparency;
                            self.ws_allow_list = settings.ws_allow_list;
                            self.web_secure = settings.web_secure;
                            self.http_enabled = settings.http_enabled;
                            self.http_port = settings.http_port;
                            self.ws_enabled = settings.ws_enabled;
                            self.ws_port = settings.ws_port;
                            self.ws_cert_file = settings.ws_cert_file;
                            self.ws_key_file = settings.ws_key_file;
                            self.world_switch_mode = WorldSwitchMode::from_name(&settings.world_switch_mode);
                            self.debug_enabled = settings.debug_enabled;
                            self.more_mode = settings.more_mode_enabled;
                            self.spell_check_enabled = settings.spell_check_enabled;
                            self.show_tags = settings.show_tags;
                            self.ansi_music_enabled = settings.ansi_music_enabled;
                            self.tls_proxy_enabled = settings.tls_proxy_enabled;
                        }
                        WsMessage::PendingLinesUpdate { world_index, count } => {
                            // Update pending count for world
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].pending_count = count;
                            }
                        }
                        WsMessage::PendingReleased { world_index, count: _ } => {
                            // Server/another client released pending lines
                            // GUI shows all data immediately, so just log for debugging
                            // pending_count update comes via PendingLinesUpdate
                            let _ = world_index; // suppress unused warning
                        }
                        WsMessage::ActionsUpdated { actions } => {
                            // Update local actions from server
                            self.actions = actions;
                        }
                        WsMessage::UnseenCleared { world_index } => {
                            // Another client (console or web) has viewed this world
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].unseen_lines = 0;
                            }
                        }
                        WsMessage::UnseenUpdate { world_index, count } => {
                            // Server's unseen count changed - update our copy
                            if world_index < self.worlds.len() {
                                self.worlds[world_index].unseen_lines = count;
                            }
                        }
                        WsMessage::ExecuteLocalCommand { command } => {
                            // Server wants us to execute a command locally (from action)
                            let parsed = parse_command(&command);
                            match parsed {
                                Command::WorldSelector => {
                                    self.popup_state = PopupState::ConnectedWorlds;
                                    self.world_list_selected = self.current_world;
                                    self.only_connected_worlds = false;
                                }
                                Command::WorldsList => {
                                    // Output connected worlds list as text
                                    let worlds_info: Vec<super::util::WorldListInfo> = self.worlds.iter().enumerate().map(|(idx, world)| {
                                        super::util::WorldListInfo {
                                            name: world.name.clone(),
                                            connected: world.connected,
                                            is_current: idx == self.current_world,
                                            unseen_lines: world.unseen_lines,
                                            last_send_secs: world.last_send_secs,
                                            last_recv_secs: world.last_recv_secs,
                                            last_nop_secs: world.last_nop_secs,
                                            next_nop_secs: None,
                                        }
                                    }).collect();
                                    let output = super::util::format_worlds_list(&worlds_info);
                                    let ts = super::current_timestamp_secs();
                                    if self.current_world < self.worlds.len() {
                                        for line in output.lines() {
                                            self.worlds[self.current_world].output_lines.push(TimestampedLine {
                                                text: line.to_string(),
                                                ts,
                                            });
                                        }
                                    }
                                }
                                Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                                    // Switch to world locally, connect if needed
                                    if let Some(idx) = self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                        self.current_world = idx;
                                        deferred_switch = Some(idx);
                                        if !self.worlds[idx].connected {
                                            deferred_connect = Some(idx);
                                        }
                                    }
                                    // If world not found, ignore (don't send to server to avoid console switch)
                                }
                                Command::WorldEdit { ref name } => {
                                    // Open editor for world (deferred to avoid borrow issues)
                                    if let Some(ref name) = name {
                                        if let Some(idx) = self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                            deferred_edit = Some(idx);
                                        }
                                    } else {
                                        // Edit current world
                                        deferred_edit = Some(self.current_world);
                                    }
                                }
                                Command::Help => {
                                    self.popup_state = PopupState::Help;
                                }
                                Command::Menu => {
                                    self.popup_state = PopupState::Menu;
                                    self.menu_selected = 0;
                                }
                                Command::Setup => {
                                    self.popup_state = PopupState::Setup;
                                }
                                Command::Actions { .. } => {
                                    self.popup_state = PopupState::ActionsList;
                                    self.actions_selected = 0;
                                }
                                Command::Disconnect => {
                                    // Send disconnect to server (this is safe, won't affect console's world)
                                    if let Some(ref tx) = self.ws_tx {
                                        let _ = tx.send(WsMessage::DisconnectWorld { world_index: self.current_world });
                                    }
                                }
                                Command::Connect { .. } => {
                                    // Connect current world
                                    deferred_connect = Some(self.current_world);
                                }
                                _ => {
                                    // For other commands (like /send), send to server
                                    // Be careful: some commands like WorldSwitch would switch console
                                    // so we handle those explicitly above
                                    if let Some(ref tx) = self.ws_tx {
                                        let _ = tx.send(WsMessage::SendCommand {
                                            world_index: self.current_world,
                                            command,
                                        });
                                    }
                                }
                            }
                        }
                        WsMessage::BanListResponse { .. } => {
                            // Ban list received - output is already displayed via ServerData
                        }
                        WsMessage::UnbanResult { .. } => {
                            // Unban result received - output is already displayed via ServerData
                        }
                        _ => {}
                    }
                }
            }

            // Execute deferred actions after the borrow is released
            if let Some(idx) = deferred_switch {
                self.switch_world(idx);
            }
            if let Some(idx) = deferred_connect {
                self.connect_world(idx);
            }
            if let Some(idx) = deferred_edit {
                self.open_world_editor(idx);
            }
            if !deferred_music.is_empty() {
                self.play_ansi_music(&deferred_music);
            }
        }

        fn send_command(&mut self, world_index: usize, command: String) {
            // Store in command history (avoid duplicates of last command)
            if !command.is_empty()
                && self.command_history.last().map(|s| s.as_str()) != Some(&command)
            {
                self.command_history.push(command.clone());
            }
            // Reset history navigation
            self.history_index = 0;
            self.saved_input.clear();

            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::SendCommand { world_index, command });
            }
        }

        fn switch_world(&mut self, world_index: usize) {
            // Only send MarkWorldSeen to clear unseen count on server
            // Don't send SwitchWorld - that would switch the console too
            // GUI switching is local only (same as web interface)
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::MarkWorldSeen { world_index });
            }
        }

        fn connect_world(&mut self, world_index: usize) {
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::ConnectWorld { world_index });
            }
        }

        fn disconnect_world(&mut self, world_index: usize) {
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::DisconnectWorld { world_index });
            }
        }

        /// Find all misspelled words in the input buffer (excluding word at cursor)
        fn find_misspelled_words(&self) -> Vec<(usize, usize)> {
            let mut misspelled = Vec::new();
            let chars: Vec<char> = self.input_buffer.chars().collect();
            let mut i = 0;

            // Helper to check if a character at position is part of a word
            // (alphabetic, or apostrophe between alphabetic characters)
            let is_word_char = |pos: usize| -> bool {
                if pos >= chars.len() {
                    return false;
                }
                let c = chars[pos];
                if c.is_alphabetic() {
                    return true;
                }
                // Include apostrophe if between alphabetic characters (contractions)
                if c == '\'' {
                    let has_alpha_before = pos > 0 && chars[pos - 1].is_alphabetic();
                    let has_alpha_after = pos + 1 < chars.len() && chars[pos + 1].is_alphabetic();
                    return has_alpha_before && has_alpha_after;
                }
                false
            };

            // Simple cursor position estimate (egui doesn't expose cursor position easily)
            // We'll just check all words since we can't know where the cursor is during input_mut
            let cursor_char_pos = chars.len(); // Assume cursor at end for now

            // Helper to check if a word is clearly finished (followed by space or clear punctuation)
            let is_word_complete = |end_pos: usize| -> bool {
                if end_pos >= chars.len() {
                    // Word at end of input - NOT complete if cursor is right at the end (still typing)
                    return cursor_char_pos != end_pos;
                }
                let next_char = chars[end_pos];
                // Word is complete if followed by whitespace or clear punctuation
                next_char.is_whitespace() || matches!(next_char, '.' | ',' | '!' | '?' | ';' | ':' | ')' | ']' | '}' | '"')
            };

            while i < chars.len() {
                // Skip non-word characters
                while i < chars.len() && !chars[i].is_alphabetic() {
                    i += 1;
                }
                if i >= chars.len() {
                    break;
                }

                let start = i;
                // Continue while we have word characters (including internal apostrophes)
                while i < chars.len() && is_word_char(i) {
                    i += 1;
                }
                let end = i;

                let word: String = chars[start..end].iter().collect();
                // Don't check if cursor is inside the word (actively typing)
                // Note: end is the first position after the word, so use < not <=
                let cursor_in_word = cursor_char_pos >= start && cursor_char_pos < end;
                // Only check words that are clearly complete (followed by separator or at end of input)
                let word_complete = is_word_complete(end);

                if !cursor_in_word && word_complete && !self.spell_checker.is_valid(&word) {
                    misspelled.push((start, end));
                }
            }

            misspelled
        }

        /// Get the word at or before the cursor position
        fn current_word(&self) -> Option<(usize, usize, String)> {
            let chars: Vec<char> = self.input_buffer.chars().collect();
            if chars.is_empty() {
                return None;
            }

            // Helper to check if a character at position is part of a word
            let is_word_char = |pos: usize| -> bool {
                if pos >= chars.len() {
                    return false;
                }
                let c = chars[pos];
                if c.is_alphabetic() {
                    return true;
                }
                // Include apostrophe if between alphabetic characters
                if c == '\'' {
                    let has_alpha_before = pos > 0 && chars[pos - 1].is_alphabetic();
                    let has_alpha_after = pos + 1 < chars.len() && chars[pos + 1].is_alphabetic();
                    return has_alpha_before && has_alpha_after;
                }
                false
            };

            // Assume cursor is at end of input (egui limitation)
            let cursor_pos = chars.len();
            if cursor_pos == 0 {
                return None;
            }

            // Find word boundaries around cursor
            let mut start = cursor_pos.saturating_sub(1);
            while start > 0 && is_word_char(start - 1) {
                start -= 1;
            }

            let mut end = cursor_pos;

            // If cursor is on a non-word character (e.g., space after word),
            // look backwards to find the previous word
            if !chars[start].is_alphabetic() {
                // Look back to find the last alphabetic character
                let mut prev_end = start;
                while prev_end > 0 && !chars[prev_end - 1].is_alphabetic() {
                    prev_end -= 1;
                }
                if prev_end == 0 && (chars.is_empty() || !chars[0].is_alphabetic()) {
                    return None;
                }
                // Now find the start of this word
                end = prev_end;
                start = prev_end;
                while start > 0 && is_word_char(start - 1) {
                    start -= 1;
                }
            } else {
                while end < chars.len() && is_word_char(end) {
                    end += 1;
                }
            }

            let word: String = chars[start..end].iter().collect();
            if word.is_empty() {
                return None;
            }

            Some((start, end, word))
        }

        /// Handle Ctrl+Q spell check
        fn handle_spell_check(&mut self) -> Option<String> {
            if !self.spell_state.showing_suggestions {
                // First press - find misspelled word and show suggestions
                if let Some((start, end, word)) = self.current_word() {
                    if !self.spell_checker.is_valid(&word) {
                        let mut suggestions = self.spell_checker.suggestions(&word, 6);
                        if !suggestions.is_empty() {
                            self.spell_state.original_word = word.clone();
                            suggestions.push(word); // Add original at end for cycling back

                            let display_suggestions: Vec<_> = suggestions[..suggestions.len()-1].to_vec();
                            let message = format!(
                                "Suggestions for '{}': {}",
                                self.spell_state.original_word,
                                display_suggestions.join(", ")
                            );

                            self.spell_state.suggestions = suggestions;
                            self.spell_state.suggestion_index = 0;
                            self.spell_state.word_start = start;
                            self.spell_state.word_end = end;
                            self.spell_state.showing_suggestions = true;
                            self.suggestion_message = Some(format!(
                                "Press Ctrl+Q to cycle: {}",
                                self.spell_state.suggestions[0]
                            ));
                            return Some(message);
                        }
                    }
                }
            } else if !self.spell_state.suggestions.is_empty() {
                // Subsequent press - cycle and apply suggestions
                let replacement = self.spell_state.suggestions[self.spell_state.suggestion_index].clone();

                // Replace word in input buffer
                let chars: Vec<char> = self.input_buffer.chars().collect();
                let before: String = chars[..self.spell_state.word_start].iter().collect();
                let after: String = if self.spell_state.word_end < chars.len() {
                    chars[self.spell_state.word_end..].iter().collect()
                } else {
                    String::new()
                };
                self.input_buffer = format!("{}{}{}", before, replacement, after);

                // Update word end position
                self.spell_state.word_end = self.spell_state.word_start + replacement.chars().count();
                self.spell_state.suggestion_index =
                    (self.spell_state.suggestion_index + 1) % self.spell_state.suggestions.len();

                let next_word = &self.spell_state.suggestions[self.spell_state.suggestion_index];
                if next_word == &self.spell_state.original_word {
                    self.suggestion_message = Some(format!(
                        "Applied '{}'. Next: '{}' (original)",
                        replacement, next_word
                    ));
                } else {
                    self.suggestion_message = Some(format!(
                        "Applied '{}'. Next: '{}'",
                        replacement, next_word
                    ));
                }
            }
            None
        }

        /// Reset spell state when cursor moves away from word
        fn reset_spell_state(&mut self) {
            self.spell_state.reset();
            self.suggestion_message = None;
        }

        fn update_world_settings(&mut self, world_index: usize) {
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::UpdateWorldSettings {
                    world_index,
                    name: self.edit_name.clone(),
                    hostname: self.edit_hostname.clone(),
                    port: self.edit_port.clone(),
                    user: self.edit_user.clone(),
                    password: self.edit_password.clone(),
                    use_ssl: self.edit_ssl,
                    log_enabled: self.edit_log_enabled,
                    encoding: self.edit_encoding.name().to_string(),
                    auto_login: self.edit_auto_login.name().to_string(),
                    keep_alive_type: self.edit_keep_alive_type.name().to_string(),
                    keep_alive_cmd: self.edit_keep_alive_cmd.clone(),
                });
            }
        }

        fn update_global_settings(&mut self) {
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::UpdateGlobalSettings {
                    more_mode_enabled: self.more_mode,
                    spell_check_enabled: self.spell_check_enabled,
                    world_switch_mode: self.world_switch_mode.name().to_string(),
                    show_tags: self.show_tags,
                    ansi_music_enabled: self.ansi_music_enabled,
                    console_theme: self.console_theme.to_string_value(),
                    gui_theme: self.theme.to_string_value(),
                    gui_transparency: self.transparency,
                    input_height: self.input_height,
                    font_name: self.font_name.clone(),
                    font_size: self.font_size,
                    ws_allow_list: self.ws_allow_list.clone(),
                    web_secure: self.web_secure,
                    http_enabled: self.http_enabled,
                    http_port: self.http_port,
                    ws_enabled: self.ws_enabled,
                    ws_port: self.ws_port,
                    ws_cert_file: self.ws_cert_file.clone(),
                    ws_key_file: self.ws_key_file.clone(),
                    tls_proxy_enabled: self.tls_proxy_enabled,
                });
            }
        }

        fn update_actions(&mut self) {
            if let Some(ref tx) = self.ws_tx {
                let _ = tx.send(WsMessage::UpdateActions {
                    actions: self.actions.clone(),
                });
            }
        }

        fn open_world_editor(&mut self, world_index: usize) {
            if let Some(world) = self.worlds.get(world_index) {
                self.edit_name = world.name.clone();
                self.edit_hostname = world.settings.hostname.clone();
                self.edit_port = world.settings.port.clone();
                self.edit_user = world.settings.user.clone();
                self.edit_password = world.settings.password.clone();
                self.edit_ssl = world.settings.use_ssl;
                self.edit_log_enabled = world.settings.log_enabled;
                self.edit_encoding = match world.settings.encoding.as_str() {
                    "latin1" => Encoding::Latin1,
                    "fansi" => Encoding::Fansi,
                    _ => Encoding::Utf8,
                };
                self.edit_auto_login = AutoConnectType::from_name(&world.settings.auto_login);
                self.edit_keep_alive_type = KeepAliveType::from_name(&world.settings.keep_alive_type);
                self.edit_keep_alive_cmd = world.settings.keep_alive_cmd.clone();
                self.popup_state = PopupState::WorldEditor(world_index);
            }
        }

        /// Strip ANSI escape codes for clipboard copy
        fn strip_ansi_for_copy(text: &str) -> String {
            let mut result = String::new();
            let mut chars = text.chars().peekable();

            while let Some(c) = chars.next() {
                if c == '\x1b' {
                    // Skip escape sequence
                    if chars.peek() == Some(&'[') {
                        chars.next(); // consume '['
                        // Skip until we hit a letter
                        while let Some(&sc) = chars.peek() {
                            chars.next();
                            if sc.is_ascii_alphabetic() {
                                break;
                            }
                        }
                    }
                } else {
                    result.push(c);
                }
            }

            result
        }

        /// Format timestamp for GUI display
        /// Same day: HH:MM>
        /// Previous days: DD/MM HH:MM>
        fn format_timestamp_gui(ts: u64) -> String {
            Self::format_timestamp_gui_cached(ts, &GuiCachedNow::new())
        }

        /// Format timestamp using cached "now" value for batch rendering
        fn format_timestamp_gui_cached(ts: u64, now: &GuiCachedNow) -> String {
            let ts_secs = ts as libc::time_t;

            let mut ts_tm: libc::tm = unsafe { std::mem::zeroed() };
            unsafe {
                libc::localtime_r(&ts_secs, &mut ts_tm);
            }

            // Check if same day (year, day of year match)
            let same_day = ts_tm.tm_yday == now.yday && ts_tm.tm_year == now.year;

            if same_day {
                format!("{:02}:{:02}>", ts_tm.tm_hour, ts_tm.tm_min)
            } else {
                format!("{:02}/{:02} {:02}:{:02}>", ts_tm.tm_mday, ts_tm.tm_mon + 1, ts_tm.tm_hour, ts_tm.tm_min)
            }
        }

        /// Strip MUD tags like [channel:] or [channel(player)] from start of line
        fn strip_mud_tags(text: &str) -> String {
            let trimmed = text.trim_start();
            if trimmed.starts_with('[') {
                // Find the closing bracket
                if let Some(end) = trimmed.find(']') {
                    let tag = &trimmed[1..end];
                    // Check if it looks like a MUD tag (contains : or parentheses)
                    if tag.contains(':') || tag.contains('(') {
                        // Return the rest of the line, preserving original leading whitespace
                        let leading_ws = text.len() - trimmed.len();
                        let after_tag = &trimmed[end + 1..];
                        // Trim one space after tag if present
                        let after_tag = after_tag.strip_prefix(' ').unwrap_or(after_tag);
                        return format!("{}{}", &text[..leading_ws], after_tag);
                    }
                }
            }
            text.to_string()
        }

        /// Strip MUD tags from ANSI text while preserving color codes
        fn strip_mud_tags_ansi(text: &str) -> String {
            // First, find any leading whitespace
            let trimmed = text.trim_start();
            let leading_ws_len = text.len() - trimmed.len();
            let leading_ws = &text[..leading_ws_len];

            // Check if line starts with [ (possibly after ANSI codes)
            // Need to skip ANSI codes to find the actual start
            let mut chars = trimmed.chars().peekable();
            let mut ansi_prefix = String::new();
            let mut in_ansi = false;

            while let Some(c) = chars.next() {
                if c == '\x1b' && chars.peek() == Some(&'[') {
                    ansi_prefix.push(c);
                    in_ansi = true;
                } else if in_ansi {
                    ansi_prefix.push(c);
                    if c.is_ascii_alphabetic() {
                        in_ansi = false;
                    }
                } else if c == '[' {
                    // Found the start of a potential tag
                    // Look for closing bracket
                    let rest: String = chars.collect();
                    if let Some(end) = rest.find(']') {
                        let tag = &rest[..end];
                        if tag.contains(':') || tag.contains('(') {
                            // It's a MUD tag, skip it
                            let after_tag = &rest[end + 1..];
                            let after_tag = after_tag.strip_prefix(' ').unwrap_or(after_tag);
                            return format!("{}{}{}", leading_ws, ansi_prefix, after_tag);
                        } else {
                            // Not a MUD tag, return original
                            return text.to_string();
                        }
                    } else {
                        return text.to_string();
                    }
                } else {
                    // Not a tag start, return original
                    return text.to_string();
                }
            }
            text.to_string()
        }

        /// Convert 256-color palette index to RGB
        fn color256_to_rgb(n: u8, is_light_theme: bool) -> (u8, u8, u8) {
            match n {
                // Standard colors (0-7) - classic ANSI
                0 => (0, 0, 0),         // Black
                1 => (205, 0, 0),       // Red
                2 => (0, 205, 0),       // Green
                3 => if is_light_theme { (160, 140, 0) } else { (205, 205, 0) },  // Yellow
                4 => (0, 0, 205),       // Blue
                5 => (205, 0, 205),     // Magenta
                6 => (0, 205, 205),     // Cyan
                7 => if is_light_theme { (80, 80, 80) } else { (192, 192, 192) }, // White
                // High-intensity colors (8-15) - bright ANSI
                8 => (128, 128, 128),   // Bright Black
                9 => (255, 0, 0),       // Bright Red
                10 => (0, 255, 0),      // Bright Green
                11 => if is_light_theme { (180, 160, 0) } else { (255, 255, 0) }, // Bright Yellow
                12 => (0, 0, 255),      // Bright Blue
                13 => (255, 0, 255),    // Bright Magenta
                14 => (0, 255, 255),    // Bright Cyan
                15 => if is_light_theme { (40, 40, 40) } else { (255, 255, 255) }, // Bright White
                // 216 colors (16-231): 6x6x6 color cube
                16..=231 => {
                    let n = n - 16;
                    let r = (n / 36) % 6;
                    let g = (n / 6) % 6;
                    let b = n % 6;
                    // Match web interface: v * 51 gives 0, 51, 102, 153, 204, 255
                    (r * 51, g * 51, b * 51)
                }
                // Grayscale (232-255): 24 shades
                232..=255 => {
                    let gray = 8 + (n - 232) * 10;
                    (gray, gray, gray)
                }
            }
        }

        /// Append ANSI-colored text to an existing LayoutJob
        fn append_ansi_to_job(text: &str, default_color: egui::Color32, font_id: egui::FontId, job: &mut egui::text::LayoutJob, is_light_theme: bool) {
            // Debug: log ANSI sequences and resulting colors
            static DEBUG_COUNT: std::sync::atomic::AtomicUsize = std::sync::atomic::AtomicUsize::new(0);
            let debug_this = DEBUG_COUNT.fetch_add(1, std::sync::atomic::Ordering::Relaxed) < 5 && text.contains('\x1b');

            let mut current_color = default_color;
            let mut current_bg = egui::Color32::TRANSPARENT;
            let mut bold = false;
            let mut chars = text.chars().peekable();
            let mut segment = String::new();

            while let Some(c) = chars.next() {
                if c == '\x1b' && chars.peek() == Some(&'[') {
                    // Flush current segment
                    if !segment.is_empty() {
                        // Don't brighten colors for bold - match web behavior
                        job.append(&segment, 0.0, egui::TextFormat {
                            font_id: font_id.clone(),
                            color: current_color,
                            background: current_bg,
                            ..Default::default()
                        });
                        segment.clear();
                    }

                    // Parse escape sequence
                    chars.next(); // consume '['
                    let mut code = String::new();
                    let mut terminator = ' ';
                    while let Some(&sc) = chars.peek() {
                        if sc.is_ascii_alphabetic() || sc == '@' || sc == '`' || sc == '~' {
                            terminator = sc;
                            chars.next();
                            break;
                        }
                        chars.next();
                        code.push(sc);
                    }

                    // Only parse SGR codes (sequences ending in 'm')
                    // Skip other CSI sequences (cursor movement, screen clearing, etc.)
                    if terminator != 'm' {
                        continue;
                    }

                    // Debug: log the SGR code
                    if debug_this {
                        use std::io::Write;
                        if let Ok(mut f) = std::fs::OpenOptions::new()
                            .create(true).append(true)
                            .open("/tmp/clay_gui_debug.log")
                        {
                            let _ = writeln!(f, "SGR code: [{}m", code);
                        }
                    }

                    // Parse SGR codes (semicolon-separated)
                    let parts: Vec<&str> = code.split(';').collect();
                    let mut i = 0;
                    while i < parts.len() {
                        match parts[i].parse::<u8>().unwrap_or(0) {
                            0 => { current_color = default_color; current_bg = egui::Color32::TRANSPARENT; bold = false; }
                            1 => bold = true,
                            22 => bold = false,
                            // Standard foreground colors (30-37) - classic ANSI colors
                            30 => current_color = egui::Color32::from_rgb(0, 0, 0),       // Black
                            31 => current_color = egui::Color32::from_rgb(205, 0, 0),     // Red
                            32 => current_color = egui::Color32::from_rgb(0, 205, 0),     // Green
                            33 => current_color = if is_light_theme {
                                egui::Color32::from_rgb(160, 140, 0)  // Darker gold for light theme
                            } else {
                                egui::Color32::from_rgb(205, 205, 0)  // Yellow
                            },
                            34 => current_color = if is_light_theme {
                                egui::Color32::from_rgb(0, 0, 205)       // Blue (standard for light theme)
                            } else {
                                egui::Color32::from_rgb(26, 26, 230)     // Blue (10% lighter for dark theme)
                            },
                            35 => current_color = egui::Color32::from_rgb(205, 0, 205),   // Magenta
                            36 => current_color = egui::Color32::from_rgb(0, 205, 205),   // Cyan
                            37 => current_color = if is_light_theme {
                                egui::Color32::from_rgb(80, 80, 80)  // Dark gray for light theme
                            } else {
                                egui::Color32::from_rgb(192, 192, 192)  // White (light gray)
                            },
                            39 => current_color = default_color,
                            // Bright/high-intensity foreground colors (90-97)
                            90 => current_color = egui::Color32::from_rgb(128, 128, 128), // Bright Black
                            91 => current_color = egui::Color32::from_rgb(255, 0, 0),     // Bright Red
                            92 => current_color = egui::Color32::from_rgb(0, 255, 0),     // Bright Green
                            93 => current_color = if is_light_theme {
                                egui::Color32::from_rgb(180, 160, 0)  // Darker gold for light theme
                            } else {
                                egui::Color32::from_rgb(255, 255, 0)  // Bright Yellow
                            },
                            94 => current_color = egui::Color32::from_rgb(0, 0, 255),     // Bright Blue
                            95 => current_color = egui::Color32::from_rgb(255, 0, 255),   // Bright Magenta
                            96 => current_color = egui::Color32::from_rgb(0, 255, 255),   // Bright Cyan
                            97 => current_color = if is_light_theme {
                                egui::Color32::from_rgb(40, 40, 40)  // Near black for light theme
                            } else {
                                egui::Color32::from_rgb(255, 255, 255)  // Bright White
                            },
                            // Extended foreground color modes
                            38 => {
                                // 38;5;n = 256-color, 38;2;r;g;b = 24-bit RGB
                                if i + 1 < parts.len() {
                                    match parts[i + 1].parse::<u8>().unwrap_or(0) {
                                        5 => {
                                            // 256-color mode: 38;5;n
                                            if i + 2 < parts.len() {
                                                if let Ok(n) = parts[i + 2].parse::<u8>() {
                                                    let (r, g, b) = Self::color256_to_rgb(n, is_light_theme);
                                                    current_color = egui::Color32::from_rgb(r, g, b);
                                                }
                                                i += 2;
                                            }
                                        }
                                        2 => {
                                            // 24-bit RGB mode: 38;2;r;g;b
                                            if i + 4 < parts.len() {
                                                let r = parts[i + 2].parse::<u8>().unwrap_or(0);
                                                let g = parts[i + 3].parse::<u8>().unwrap_or(0);
                                                let b = parts[i + 4].parse::<u8>().unwrap_or(0);
                                                current_color = egui::Color32::from_rgb(r, g, b);
                                                i += 4;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            // Standard background colors (40-47) - classic ANSI colors
                            40 => current_bg = egui::Color32::from_rgb(0, 0, 0),       // Black
                            41 => current_bg = egui::Color32::from_rgb(205, 0, 0),     // Red
                            42 => current_bg = egui::Color32::from_rgb(0, 205, 0),     // Green
                            43 => current_bg = egui::Color32::from_rgb(205, 205, 0),   // Yellow
                            44 => current_bg = egui::Color32::from_rgb(0, 0, 205),     // Blue
                            45 => current_bg = egui::Color32::from_rgb(205, 0, 205),   // Magenta
                            46 => current_bg = egui::Color32::from_rgb(0, 205, 205),   // Cyan
                            47 => current_bg = egui::Color32::from_rgb(192, 192, 192), // White (light gray)
                            49 => current_bg = egui::Color32::TRANSPARENT,             // Default background
                            // Extended background color modes
                            48 => {
                                // 48;5;n = 256-color, 48;2;r;g;b = 24-bit RGB
                                if i + 1 < parts.len() {
                                    match parts[i + 1].parse::<u8>().unwrap_or(0) {
                                        5 => {
                                            // 256-color mode: 48;5;n
                                            if i + 2 < parts.len() {
                                                if let Ok(n) = parts[i + 2].parse::<u8>() {
                                                    let (r, g, b) = Self::color256_to_rgb(n, is_light_theme);
                                                    current_bg = egui::Color32::from_rgb(r, g, b);
                                                }
                                                i += 2;
                                            }
                                        }
                                        2 => {
                                            // 24-bit RGB mode: 48;2;r;g;b
                                            if i + 4 < parts.len() {
                                                let r = parts[i + 2].parse::<u8>().unwrap_or(0);
                                                let g = parts[i + 3].parse::<u8>().unwrap_or(0);
                                                let b = parts[i + 4].parse::<u8>().unwrap_or(0);
                                                current_bg = egui::Color32::from_rgb(r, g, b);
                                                i += 4;
                                            }
                                        }
                                        _ => {}
                                    }
                                }
                            }
                            // Bright/high-intensity background colors (100-107)
                            100 => current_bg = egui::Color32::from_rgb(128, 128, 128), // Bright Black
                            101 => current_bg = egui::Color32::from_rgb(255, 0, 0),     // Bright Red
                            102 => current_bg = egui::Color32::from_rgb(0, 255, 0),     // Bright Green
                            103 => current_bg = egui::Color32::from_rgb(255, 255, 0),   // Bright Yellow
                            104 => current_bg = egui::Color32::from_rgb(0, 0, 255),     // Bright Blue
                            105 => current_bg = egui::Color32::from_rgb(255, 0, 255),   // Bright Magenta
                            106 => current_bg = egui::Color32::from_rgb(0, 255, 255),   // Bright Cyan
                            107 => current_bg = egui::Color32::from_rgb(255, 255, 255), // Bright White
                            _ => {}
                        }
                        i += 1;
                    }

                    // Debug: log resulting color after parsing all SGR codes
                    if debug_this {
                        use std::io::Write;
                        if let Ok(mut f) = std::fs::OpenOptions::new()
                            .create(true).append(true)
                            .open("/tmp/clay_gui_debug.log")
                        {
                            let _ = writeln!(f, "  -> color: rgb({},{},{}), bold: {}",
                                current_color.r(), current_color.g(), current_color.b(), bold);
                        }
                    }
                } else {
                    segment.push(c);
                }
            }

            // Flush remaining segment
            if !segment.is_empty() {
                // Don't brighten colors for bold - match web behavior
                job.append(&segment, 0.0, egui::TextFormat {
                    font_id: font_id.clone(),
                    color: current_color,
                    background: current_bg,
                    ..Default::default()
                });
            }
        }

        /// Find URLs in text and return their character positions (not byte positions)
        /// Returns (start_char_idx, end_char_idx, url_string)
        fn find_urls(text: &str) -> Vec<(usize, usize, String)> {
            let mut urls = Vec::new();
            let chars: Vec<char> = text.chars().collect();
            let mut i = 0;

            while i < chars.len() {
                // Look for http:// or https://
                let remaining: String = chars[i..].iter().collect();
                let http_pos = remaining.find("http://");
                let https_pos = remaining.find("https://");

                // Find earliest match (in bytes), then convert to char position
                let byte_pos = match (http_pos, https_pos) {
                    (Some(h), Some(hs)) => Some(h.min(hs)),
                    (Some(h), None) => Some(h),
                    (None, Some(hs)) => Some(hs),
                    (None, None) => None,
                };

                if let Some(byte_offset) = byte_pos {
                    // Convert byte offset to char offset within remaining
                    let char_offset = remaining[..byte_offset].chars().count();
                    let start = i + char_offset;

                    // Find end of URL (whitespace or certain punctuation)
                    let mut end = start;
                    while end < chars.len() {
                        let c = chars[end];
                        if c.is_whitespace() || c == '>' || c == '"' || c == '\'' || c == ')' || c == ']' {
                            break;
                        }
                        end += 1;
                    }

                    if end > start {
                        let url: String = chars[start..end].iter().collect();
                        urls.push((start, end, url));
                    }
                    i = end;
                } else {
                    break;
                }
            }
            urls
        }

        /// Open a URL in the default browser
        fn open_url(url: &str) {
            #[cfg(target_os = "linux")]
            {
                let _ = std::process::Command::new("xdg-open")
                    .arg(url)
                    .spawn();
            }
            #[cfg(target_os = "macos")]
            {
                let _ = std::process::Command::new("open")
                    .arg(url)
                    .spawn();
            }
            #[cfg(target_os = "windows")]
            {
                let _ = std::process::Command::new("cmd")
                    .args(["/C", "start", url])
                    .spawn();
            }
        }

        /// Get color for a colored square emoji, if it is one
        fn colored_square_color(c: char) -> Option<egui::Color32> {
            match c {
                '' => Some(egui::Color32::from_rgb(0xDD, 0x2E, 0x44)), // Red
                '' => Some(egui::Color32::from_rgb(0xF4, 0x90, 0x0C)), // Orange
                '' => Some(egui::Color32::from_rgb(0xFD, 0xCB, 0x58)), // Yellow
                '' => Some(egui::Color32::from_rgb(0x78, 0xB1, 0x59)), // Green
                '' => Some(egui::Color32::from_rgb(0x55, 0xAC, 0xEE)), // Blue
                '' => Some(egui::Color32::from_rgb(0xAA, 0x8E, 0xD6)), // Purple
                '' => Some(egui::Color32::from_rgb(0xA0, 0x6A, 0x42)), // Brown
                '' => Some(egui::Color32::from_rgb(0x31, 0x37, 0x3D)), // Black
                '' => Some(egui::Color32::from_rgb(0xE6, 0xE7, 0xE8)), // White
                _ => None,
            }
        }

        /// Check if text contains colored square emoji
        fn has_colored_squares(text: &str) -> bool {
            text.chars().any(|c| Self::colored_square_color(c).is_some())
        }

        /// Parse text into segments of plain text, Discord emojis, and colored squares
        fn parse_discord_segments(text: &str) -> Vec<DiscordSegment> {
            use regex::Regex;
            use std::sync::OnceLock;

            static RE: OnceLock<Regex> = OnceLock::new();
            let re = RE.get_or_init(|| {
                Regex::new(r"<(a?):([^:]+):(\d+)>").unwrap()
            });

            // First pass: handle Discord custom emoji
            let mut temp_segments: Vec<DiscordSegment> = Vec::new();
            let mut last_end = 0;

            for cap in re.captures_iter(text) {
                let m = cap.get(0).unwrap();
                if m.start() > last_end {
                    temp_segments.push(DiscordSegment::Text(text[last_end..m.start()].to_string()));
                }
                let animated = &cap[1] == "a";
                let name = cap[2].to_string();
                let id = cap[3].to_string();
                temp_segments.push(DiscordSegment::Emoji { name, id, animated });
                last_end = m.end();
            }

            if last_end < text.len() {
                temp_segments.push(DiscordSegment::Text(text[last_end..].to_string()));
            }

            if temp_segments.is_empty() {
                temp_segments.push(DiscordSegment::Text(text.to_string()));
            }

            // Second pass: split Text segments to extract colored square emoji
            let mut segments: Vec<DiscordSegment> = Vec::new();
            for seg in temp_segments {
                match seg {
                    DiscordSegment::Text(txt) => {
                        // Split text at colored square emoji
                        let mut current_text = String::new();
                        for c in txt.chars() {
                            if let Some(color) = Self::colored_square_color(c) {
                                if !current_text.is_empty() {
                                    segments.push(DiscordSegment::Text(current_text.clone()));
                                    current_text.clear();
                                }
                                segments.push(DiscordSegment::ColoredSquare(color));
                            } else {
                                current_text.push(c);
                            }
                        }
                        if !current_text.is_empty() {
                            segments.push(DiscordSegment::Text(current_text));
                        }
                    }
                    other => segments.push(other),
                }
            }

            if segments.is_empty() {
                segments.push(DiscordSegment::Text(String::new()));
            }

            segments
        }

        /// Check if text contains Discord custom emojis or colored squares
        fn has_discord_emojis(text: &str) -> bool {
            text.contains("<:") || text.contains("<a:") || Self::has_colored_squares(text)
        }

        /// Insert zero-width spaces after break characters in long words (>15 chars)
        /// Break characters: [ ] ( ) , \ / - & = ? and spaces
        /// Note: '.' is excluded because it breaks filenames (image.png) and domains awkwardly
        /// Skips ANSI escape sequences to avoid corrupting them
        fn insert_word_breaks(text: &str) -> String {
            const ZWSP: char = '\u{200B}'; // Zero-width space
            const BREAK_CHARS: &[char] = &['[', ']', '(', ')', ',', '\\', '/', '-', '&', '=', '?', '.', ';', ' '];
            const MIN_WORD_LEN: usize = 15;

            let mut result = String::with_capacity(text.len() * 2);
            let mut word_len = 0;
            let mut chars = text.chars().peekable();

            while let Some(c) = chars.next() {
                result.push(c);

                // Skip ANSI escape sequences entirely
                if c == '\x1b' && chars.peek() == Some(&'[') {
                    // Consume the '['
                    if let Some(bracket) = chars.next() {
                        result.push(bracket);
                    }
                    // Consume until we hit the terminator (alphabetic or ~)
                    while let Some(&sc) = chars.peek() {
                        result.push(chars.next().unwrap());
                        if sc.is_ascii_alphabetic() || sc == '~' {
                            break;
                        }
                    }
                    continue;
                }

                if c.is_whitespace() {
                    word_len = 0;
                } else {
                    word_len += 1;
                    // Insert break opportunity after break chars in long words
                    if word_len > MIN_WORD_LEN && BREAK_CHARS.contains(&c) {
                        result.push(ZWSP);
                    }
                }
            }

            result
        }

        /// Render a line with inline Discord emoji images and clickable URLs
        fn render_line_with_emojis(
            ui: &mut egui::Ui,
            text: &str,
            default_color: egui::Color32,
            font_id: &egui::FontId,
            is_light_theme: bool,
            link_color: egui::Color32,
        ) {
            let segments = Self::parse_discord_segments(text);
            let available_width = ui.available_width();

            // Use a vertical layout to allow text wrapping
            ui.horizontal_wrapped(|ui| {
                ui.spacing_mut().item_spacing.x = 0.0;
                for segment in segments {
                    match segment {
                        DiscordSegment::Text(txt) => {
                            // Check for URLs in this text segment
                            let urls = Self::find_urls(&txt);
                            if urls.is_empty() {
                                // No URLs, render as normal text with word breaks
                                let txt_with_breaks = Self::insert_word_breaks(&txt);
                                let mut job = egui::text::LayoutJob::default();
                                job.wrap = egui::text::TextWrapping {
                                    max_width: available_width,
                                    ..Default::default()
                                };
                                Self::append_ansi_to_job(&txt_with_breaks, default_color, font_id.clone(), &mut job, is_light_theme);
                                let galley = ui.fonts(|f| f.layout_job(job));
                                ui.label(galley);
                            } else {
                                // Has URLs, render text and URLs separately
                                let mut last_end = 0;
                                for (start, end, url) in urls {
                                    // Render text before URL
                                    if start > last_end {
                                        let before = Self::insert_word_breaks(&txt[last_end..start]);
                                        let mut job = egui::text::LayoutJob::default();
                                        job.wrap = egui::text::TextWrapping {
                                            max_width: available_width,
                                            ..Default::default()
                                        };
                                        Self::append_ansi_to_job(&before, default_color, font_id.clone(), &mut job, is_light_theme);
                                        let galley = ui.fonts(|f| f.layout_job(job));
                                        ui.label(galley);
                                    }
                                    // Render URL as clickable link with word breaks for long URLs
                                    let url_with_breaks = Self::insert_word_breaks(&url);
                                    let link = egui::Label::new(
                                        egui::RichText::new(&url_with_breaks)
                                            .font(font_id.clone())
                                            .color(link_color)
                                            .underline()
                                    ).sense(egui::Sense::click()).wrap();
                                    let response = ui.add(link);
                                    if response.clicked() {
                                        Self::open_url(&url);
                                    }
                                    if response.hovered() {
                                        ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                                    }
                                    last_end = end;
                                }
                                // Render text after last URL
                                if last_end < txt.len() {
                                    let after = Self::insert_word_breaks(&txt[last_end..]);
                                    let mut job = egui::text::LayoutJob::default();
                                    job.wrap = egui::text::TextWrapping {
                                        max_width: available_width,
                                        ..Default::default()
                                    };
                                    Self::append_ansi_to_job(&after, default_color, font_id.clone(), &mut job, is_light_theme);
                                    let galley = ui.fonts(|f| f.layout_job(job));
                                    ui.label(galley);
                                }
                            }
                        }
                        DiscordSegment::Emoji { name, id, animated } => {
                            let ext = if animated { "gif" } else { "png" };
                            let url = format!("https://cdn.discordapp.com/emojis/{}.{}", id, ext);
                            let image = egui::Image::from_uri(&url)
                                .fit_to_exact_size(egui::vec2(font_id.size * 1.2, font_id.size * 1.2));
                            ui.add(image).on_hover_text(format!(":{}:", name));
                        }
                        DiscordSegment::ColoredSquare(color) => {
                            // Draw a colored rectangle for square emoji
                            let size = font_id.size * 1.1;
                            let (rect, _response) = ui.allocate_exact_size(
                                egui::vec2(size, size),
                                egui::Sense::hover()
                            );
                            if ui.is_rect_visible(rect) {
                                ui.painter().rect_filled(rect, 2.0, color);
                            }
                        }
                    }
                }
            });
        }
    }

    impl eframe::App for RemoteGuiApp {
        fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
            // Process incoming WebSocket messages
            self.process_messages();

            // Apply theme to egui visuals
            let theme = self.theme;
            let mut visuals = if theme == GuiTheme::Dark {
                egui::Visuals::dark()
            } else {
                egui::Visuals::light()
            };

            // Customize based on our theme
            // NOTE: Do NOT set override_text_color as it overrides LayoutJob colors!
            visuals.override_text_color = None;
            // Apply transparency to panel and window fills
            let alpha = (self.transparency * 255.0) as u8;
            let panel_bg = theme.panel_bg();
            visuals.panel_fill = egui::Color32::from_rgba_unmultiplied(panel_bg.r(), panel_bg.g(), panel_bg.b(), alpha);
            visuals.window_fill = egui::Color32::from_rgba_unmultiplied(panel_bg.r(), panel_bg.g(), panel_bg.b(), alpha);
            visuals.widgets.noninteractive.bg_fill = theme.button_bg();
            visuals.widgets.inactive.bg_fill = theme.button_bg();
            visuals.widgets.hovered.bg_fill = theme.selection_bg();
            visuals.widgets.active.bg_fill = theme.selection_bg();
            visuals.selection.bg_fill = theme.selection_bg();
            // Set proper foreground strokes for buttons/widgets to be visible
            let fg_stroke = egui::Stroke::new(1.0, theme.fg());
            visuals.widgets.noninteractive.fg_stroke = fg_stroke;
            visuals.widgets.inactive.fg_stroke = fg_stroke;
            visuals.widgets.hovered.fg_stroke = fg_stroke;
            visuals.widgets.active.fg_stroke = fg_stroke;
            ctx.set_visuals(visuals);

            // Make scrollbars always visible and solid (not floating)
            let mut style = (*ctx.style()).clone();
            style.spacing.scroll = egui::style::ScrollStyle {
                floating: false,  // Solid scrollbar, always takes space
                bar_width: 10.0,
                handle_min_length: 20.0,
                bar_inner_margin: 2.0,
                bar_outer_margin: 2.0,
                ..Default::default()
            };
            // Reduce spacing for tighter text layout (helps with ASCII art)
            style.spacing.item_spacing.y = 0.0;
            ctx.set_style(style);

            // Load custom font if font name changed
            if self.loaded_font_name != self.font_name {
                self.loaded_font_name = self.font_name.clone();

                let mut fonts = egui::FontDefinitions::default();

                if !self.font_name.is_empty() {
                    // Try to load the system font
                    if let Some(font_data) = Self::find_system_font(&self.font_name) {
                        // Add the custom font with tweaks for tighter line spacing (ASCII art)
                        let font_data = egui::FontData::from_owned(font_data).tweak(
                            egui::FontTweak {
                                scale: 1.05,              // Slightly larger to fill row height
                                y_offset_factor: -0.02,   // Move up slightly to reduce gaps
                                y_offset: 0.0,
                                baseline_offset_factor: 0.0,
                            }
                        );
                        fonts.font_data.insert(
                            "custom_mono".to_owned(),
                            std::sync::Arc::new(font_data),
                        );

                        // Make it the first priority for monospace
                        fonts.families
                            .entry(egui::FontFamily::Monospace)
                            .or_default()
                            .insert(0, "custom_mono".to_owned());

                        // Also use for proportional text
                        fonts.families
                            .entry(egui::FontFamily::Proportional)
                            .or_default()
                            .insert(0, "custom_mono".to_owned());
                    }
                }
                // Load symbol fonts for Unicode/emoji coverage
                // NotoSansSymbols2 has geometric shapes including colored square emoji
                let symbol_fonts: &[(&str, &str)] = &[
                    ("symbols2", "/usr/share/fonts/truetype/noto/NotoSansSymbols2-Regular.ttf"),
                    ("symbols", "/usr/share/fonts/truetype/noto/NotoSansSymbols-Regular.ttf"),
                    ("symbola", "/usr/share/fonts/truetype/ancient-scripts/Symbola_hint.ttf"),
                ];
                for (name, path) in symbol_fonts {
                    if let Ok(font_data) = std::fs::read(path) {
                        fonts.font_data.insert(
                            (*name).to_owned(),
                            std::sync::Arc::new(egui::FontData::from_owned(font_data)),
                        );
                        fonts.families
                            .entry(egui::FontFamily::Monospace)
                            .or_default()
                            .push((*name).to_owned());
                        fonts.families
                            .entry(egui::FontFamily::Proportional)
                            .or_default()
                            .push((*name).to_owned());
                    }
                }

                ctx.set_fonts(fonts);
            }

            // Apply font size to monospace text style
            let mut style = (*ctx.style()).clone();
            if let Some(font_id) = style.text_styles.get_mut(&egui::TextStyle::Monospace) {
                font_id.size = self.font_size;
            }
            // Also apply to body text
            if let Some(font_id) = style.text_styles.get_mut(&egui::TextStyle::Body) {
                font_id.size = self.font_size;
            }
            ctx.set_style(style);

            // Request repaint to keep polling messages
            ctx.request_repaint();

            if !self.connected || !self.authenticated {
                // Show login dialog with dog and Clay branding
                egui::CentralPanel::default()
                    .frame(egui::Frame::none().fill(theme.bg_deep()))
                    .show(ctx, |ui| {
                    ui.vertical_centered(|ui| {
                        ui.add_space(30.0);

                        // Clay logo image with CLAY block letters to the right
                        let clay_colors = [
                            egui::Color32::from_rgb(0xff, 0x87, 0x5f),  // 209
                            egui::Color32::from_rgb(0xff, 0x87, 0x00),  // 208
                            egui::Color32::from_rgb(0xff, 0xaf, 0x5f),  // 215
                            egui::Color32::from_rgb(0xff, 0xaf, 0x87),  // 216
                            egui::Color32::from_rgb(0xff, 0xaf, 0xaf),  // 217
                            egui::Color32::from_rgb(0xff, 0xaf, 0xd7),  // 218
                        ];
                        let clay_lines = [
                            "           ",
                            "      ",
                            "            ",
                            "              ",
                            "        ",
                            "         ",
                        ];

                        ui.horizontal(|ui| {
                            // Center the horizontal group
                            ui.add_space((ui.available_width() - 400.0) / 2.0);

                            // Image on left (30% smaller: 179x125)
                            let splash_image = egui::Image::from_bytes(
                                "bytes://clay_splash",
                                include_bytes!("../clay.png"),
                            ).fit_to_exact_size(egui::vec2(179.0, 125.0));
                            ui.add(splash_image);

                            ui.add_space(10.0);

                            // CLAY text on right, moved down one line
                            ui.vertical(|ui| {
                                ui.label("");  // One line of spacing
                                for (i, line) in clay_lines.iter().enumerate() {
                                    ui.label(egui::RichText::new(*line).color(clay_colors[i]).monospace());
                                }
                            });
                        });

                        let tagline_color = egui::Color32::from_rgb(0xff, 0x87, 0xff);  // 213
                        ui.add_space(10.0);
                        ui.label(egui::RichText::new("A 90dies mud client written today").color(tagline_color).italics());
                        ui.add_space(5.0);
                        ui.label(egui::RichText::new("/help for how to use clay").color(theme.fg_muted()));
                        ui.add_space(20.0);

                        // Login card
                        egui::Frame::none()
                            .fill(theme.bg_surface())
                            .stroke(egui::Stroke::new(1.0, theme.border_subtle()))
                            .rounding(egui::Rounding::same(8.0))
                            .inner_margin(egui::Margin::same(20.0))
                            .show(ui, |ui| {
                                ui.set_min_width(280.0);
                                ui.set_max_width(280.0);

                                // Server address
                                ui.label(egui::RichText::new(format!("Connecting to {}", self.ws_url))
                                    .color(theme.fg_muted())
                                    .size(11.0));
                                ui.add_space(16.0);

                                // Auto-connect on first frame to check if allow list grants access
                                if !self.auto_connect_attempted && !self.connected {
                                    self.auto_connect_attempted = true;
                                    self.connect_websocket();
                                }

                                // Check if we're still waiting for allow list response (500ms timeout)
                                let allow_list_timeout = std::time::Duration::from_millis(500);
                                let still_checking_allow_list = self.connected
                                    && !self.authenticated
                                    && !self.password_submitted
                                    && self.connect_time.map_or(false, |t| t.elapsed() < allow_list_timeout);

                                // Show connection status or password prompt
                                if still_checking_allow_list {
                                    ui.label(egui::RichText::new("Checking allow list...")
                                        .color(theme.fg_secondary()));
                                    ui.add_space(10.0);
                                    // Request repaint to update when timeout expires
                                    ctx.request_repaint();
                                }

                                // Password label
                                ui.label(egui::RichText::new("PASSWORD")
                                    .color(theme.fg_muted())
                                    .size(10.0));
                                ui.add_space(4.0);

                                // Password input with custom styling
                                let password_edit = TextEdit::singleline(&mut self.password)
                                    .password(true)
                                    .desired_width(f32::INFINITY)
                                    .margin(egui::Margin::symmetric(12.0, 8.0));
                                let response = ui.add(password_edit);

                                if response.lost_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter)) {
                                    self.password_submitted = true;
                                    if self.connected {
                                        self.send_auth();
                                    } else {
                                        self.connect_websocket();
                                    }
                                }

                                ui.add_space(12.0);

                                // Connect button - styled as primary
                                let button = egui::Button::new(
                                    egui::RichText::new("CONNECT")
                                        .color(theme.bg_deep())
                                        .strong()
                                        .size(11.0)
                                )
                                .fill(theme.accent_dim())
                                .stroke(egui::Stroke::NONE)
                                .rounding(egui::Rounding::same(4.0))
                                .min_size(egui::vec2(f32::INFINITY, 32.0));

                                if ui.add(button).clicked() {
                                    self.password_submitted = true;
                                    if self.connected {
                                        self.send_auth();
                                    } else {
                                        self.connect_websocket();
                                    }
                                }

                                // Error message
                                if let Some(ref err) = self.error_message {
                                    ui.add_space(12.0);
                                    egui::Frame::none()
                                        .fill(Color32::from_rgba_unmultiplied(248, 113, 113, 25))
                                        .rounding(egui::Rounding::same(4.0))
                                        .inner_margin(egui::Margin::same(8.0))
                                        .show(ui, |ui| {
                                            ui.label(egui::RichText::new(err)
                                                .color(theme.error())
                                                .size(11.0));
                                        });
                                }
                            });
                    });
                });
            } else {
                // Show main interface with menu bar
                let mut action: Option<&str> = None;
                let mut cursor_home = false;

                // Handle keyboard shortcuts (only when no popup is open)
                if self.popup_state == PopupState::None && !self.filter_active {
                    let mut switch_world: Option<usize> = None;
                    let mut history_action: Option<i32> = None; // -1 = prev, 1 = next
                    let mut scroll_action: Option<i32> = None; // -1 = up, 1 = down
                    let mut clear_input = false;
                    let mut delete_word = false;
                    let mut resize_input: i32 = 0;
                    let mut tab_complete = false;

                    // Use input_mut to consume events before widgets get them
                    ctx.input_mut(|i| {
                        // Ctrl+key shortcuts
                        if i.modifiers.ctrl {
                            if i.consume_key(egui::Modifiers::CTRL, egui::Key::L) {
                                action = Some("world_list");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::E) {
                                action = Some("edit_current");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::S) {
                                action = Some("setup");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::U) {
                                // Ctrl+U - clear input (like console)
                                clear_input = true;
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::O) {
                                action = Some("connect");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::D) {
                                action = Some("disconnect");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::P) {
                                // Ctrl+P - previous command history
                                history_action = Some(-1);
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::N) {
                                // Ctrl+N - next command history
                                history_action = Some(1);
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::ArrowUp) {
                                // Ctrl+Up - resize input smaller
                                resize_input = -1;
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::ArrowDown) {
                                // Ctrl+Down - resize input larger
                                resize_input = 1;
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::W) {
                                // Ctrl+W - delete word before cursor
                                delete_word = true;
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::Q) {
                                // Ctrl+Q - spell check
                                action = Some("spell_check");
                            } else if i.consume_key(egui::Modifiers::CTRL, egui::Key::A) {
                                // Ctrl+A - move cursor to beginning of line
                                cursor_home = true;
                            }
                        } else if i.modifiers.shift {
                            // Shift+Up/Down - cycle through all worlds
                            if i.consume_key(egui::Modifiers::SHIFT, egui::Key::ArrowUp) {
                                if !self.worlds.is_empty() {
                                    let prev = if self.current_world == 0 {
                                        self.worlds.len() - 1
                                    } else {
                                        self.current_world - 1
                                    };
                                    switch_world = Some(prev);
                                }
                            } else if i.consume_key(egui::Modifiers::SHIFT, egui::Key::ArrowDown) {
                                if !self.worlds.is_empty() {
                                    let next = (self.current_world + 1) % self.worlds.len();
                                    switch_world = Some(next);
                                }
                            }
                        } else {
                            // Non-modified keys - consume to prevent widgets from handling
                            if i.consume_key(egui::Modifiers::NONE, egui::Key::PageUp) {
                                scroll_action = Some(-1);
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::PageDown) {
                                scroll_action = Some(1);
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F2) {
                                // F2 - toggle MUD tag display
                                self.show_tags = !self.show_tags;
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F4) {
                                // F4 - toggle filter popup
                                self.filter_active = true;
                                self.filter_text.clear();
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::F8) {
                                // F8 - toggle action pattern highlighting
                                self.highlight_actions = !self.highlight_actions;
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::Tab) {
                                // Tab - command completion if input starts with /
                                // Otherwise release pending lines or scroll down if viewing history
                                if self.input_buffer.starts_with('/') {
                                    tab_complete = true;
                                } else if self.current_world < self.worlds.len()
                                    && self.worlds[self.current_world].pending_count > 0
                                {
                                    // Send ReleasePending to server to release one screenful
                                    // Use 20 as a reasonable default batch size
                                    if let Some(ref tx) = self.ws_tx {
                                        let _ = tx.send(WsMessage::ReleasePending {
                                            world_index: self.current_world,
                                            count: 20,
                                        });
                                    }
                                } else if self.scroll_offset.is_some() {
                                    // Viewing history - scroll down like PgDn
                                    if let Some(offset) = self.scroll_offset {
                                        let new_offset = offset + 300.0;
                                        if new_offset >= self.scroll_max_offset - 10.0 {
                                            self.scroll_offset = None; // Snap to bottom
                                        } else {
                                            self.scroll_offset = Some(new_offset);
                                        }
                                    }
                                }
                            }

                            // Up/Down arrow - always cycle active worlds
                            // Use shared world switching logic
                            let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
                                .map(|w| crate::util::WorldSwitchInfo {
                                    name: w.name.clone(),
                                    connected: w.connected,
                                    unseen_lines: w.unseen_lines,
                                    pending_lines: w.pending_count,
                                })
                                .collect();

                            if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowUp) {
                                if let Some(prev_idx) = crate::util::calculate_prev_world(
                                    &world_info,
                                    self.current_world,
                                    self.world_switch_mode,
                                ) {
                                    switch_world = Some(prev_idx);
                                }
                            } else if i.consume_key(egui::Modifiers::NONE, egui::Key::ArrowDown) {
                                if let Some(next_idx) = crate::util::calculate_next_world(
                                    &world_info,
                                    self.current_world,
                                    self.world_switch_mode,
                                ) {
                                    switch_world = Some(next_idx);
                                }
                            }
                        }
                    });

                    // Apply clear input
                    if clear_input {
                        self.input_buffer.clear();
                        self.history_index = 0;
                    }

                    // Apply delete word
                    if delete_word && !self.input_buffer.is_empty() {
                        // Delete one word before cursor (end of buffer)
                        // First, skip any trailing whitespace
                        while self.input_buffer.ends_with(|c: char| c.is_whitespace()) {
                            self.input_buffer.pop();
                        }
                        // Then delete the word (non-whitespace characters)
                        while !self.input_buffer.is_empty()
                            && !self.input_buffer.ends_with(|c: char| c.is_whitespace())
                        {
                            self.input_buffer.pop();
                        }
                    }

                    // Apply tab completion
                    if tab_complete && self.input_buffer.starts_with('/') {
                        // Get the partial command (everything up to first space)
                        let input = self.input_buffer.clone();
                        let (partial, args) = if let Some(space_pos) = input.find(' ') {
                            (&input[..space_pos], &input[space_pos..])
                        } else {
                            (input.as_str(), "")
                        };

                        // Build list of completions: internal commands + manual actions
                        let internal_commands = vec![
                            "/help", "/disconnect", "/dc", "/send", "/worlds", "/connections",
                            "/setup", "/web", "/actions", "/keepalive", "/reload", "/quit", "/gag", "/testmusic",
                        ];

                        // Get manual actions (empty pattern)
                        let manual_actions: Vec<String> = self.actions.iter()
                            .filter(|a| a.pattern.is_empty())
                            .map(|a| format!("/{}", a.name))
                            .collect();

                        // Find all matches
                        let partial_lower = partial.to_lowercase();
                        let mut matches: Vec<String> = internal_commands.iter()
                            .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                            .map(|s| s.to_string())
                            .collect();
                        matches.extend(manual_actions.iter()
                            .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                            .cloned());

                        if !matches.is_empty() {
                            matches.sort();
                            matches.dedup();

                            // Find next match index
                            let next_idx = if partial.to_lowercase() == self.completion_prefix.to_lowercase() {
                                // Cycle to next match
                                (self.completion_index + 1) % matches.len()
                            } else {
                                // Find current match if we're already on a completed command
                                matches.iter()
                                    .position(|m| m.eq_ignore_ascii_case(partial))
                                    .map(|idx| (idx + 1) % matches.len())
                                    .unwrap_or(0)
                            };

                            // Update completion state
                            self.completion_prefix = partial.to_string();
                            self.completion_index = next_idx;

                            // Replace input with completion
                            self.input_buffer = format!("{}{}", matches[next_idx], args);
                        }
                    }

                    // Apply input resize
                    if resize_input != 0 {
                        let new_height = (self.input_height as i32 + resize_input).clamp(1, 15) as u16;
                        self.input_height = new_height;
                    }

                    // Apply history navigation
                    if let Some(dir) = history_action {
                        if dir < 0 {
                            // Previous (older)
                            if self.history_index == 0 && !self.command_history.is_empty() {
                                self.saved_input = self.input_buffer.clone();
                                self.history_index = 1;
                                self.input_buffer = self.command_history[self.command_history.len() - 1].clone();
                            } else if self.history_index > 0 && self.history_index < self.command_history.len() {
                                self.history_index += 1;
                                let idx = self.command_history.len() - self.history_index;
                                self.input_buffer = self.command_history[idx].clone();
                            }
                        } else {
                            // Next (newer)
                            if self.history_index > 1 {
                                self.history_index -= 1;
                                let idx = self.command_history.len() - self.history_index;
                                self.input_buffer = self.command_history[idx].clone();
                            } else if self.history_index == 1 {
                                self.history_index = 0;
                                self.input_buffer = std::mem::take(&mut self.saved_input);
                            }
                        }
                    }

                    // Apply world switch (GUI-local only, doesn't affect console)
                    if let Some(new_world) = switch_world {
                        if new_world != self.current_world && new_world < self.worlds.len() {
                            self.current_world = new_world;
                            self.worlds[new_world].unseen_lines = 0;
                            self.scroll_offset = None; // Reset scroll
                            // Notify server so other clients sync their unseen counts
                            if let Some(ref tx) = self.ws_tx {
                                let _ = tx.send(WsMessage::MarkWorldSeen { world_index: new_world });
                            }
                        }
                    }

                    // Handle scroll action (will be used by scroll area)
                    // In egui, scroll_offset is from the TOP, so:
                    // - PageUp = decrease offset (scroll towards top/older content)
                    // - PageDown = increase offset (scroll towards bottom/newer content)
                    if let Some(dir) = scroll_action {
                        if dir < 0 {
                            // Scroll up (PageUp) - decrease offset to show older content
                            if let Some(offset) = self.scroll_offset {
                                let new_offset = (offset - 300.0).max(0.0);
                                self.scroll_offset = Some(new_offset);
                            } else {
                                // Currently at bottom, start scrolling up from max offset
                                let new_offset = (self.scroll_max_offset - 300.0).max(0.0);
                                self.scroll_offset = Some(new_offset);
                            }
                        } else {
                            // Scroll down (PageDown) - increase offset to show newer content
                            if let Some(offset) = self.scroll_offset {
                                let new_offset = offset + 300.0;
                                // If we're within one page of the bottom, snap to bottom
                                if new_offset >= self.scroll_max_offset - 10.0 {
                                    self.scroll_offset = None;
                                } else {
                                    self.scroll_offset = Some(new_offset);
                                }
                            }
                            // If scroll_offset is None, we're already at bottom, nothing to do
                        }
                    }
                }

                // Handle filter popup escape
                if self.filter_active {
                    ctx.input(|i| {
                        if i.key_pressed(egui::Key::Escape) || i.key_pressed(egui::Key::F4) {
                            self.filter_active = false;
                            self.filter_text.clear();
                        }
                    });
                }

                let alpha = (self.transparency * 255.0) as u8;
                let menu_bg = theme.panel_bg();
                let menu_bg_transparent = egui::Color32::from_rgba_unmultiplied(menu_bg.r(), menu_bg.g(), menu_bg.b(), alpha);
                egui::TopBottomPanel::top("menu_bar")
                    .frame(egui::Frame::none()
                        .fill(menu_bg_transparent)
                        .inner_margin(egui::Margin::symmetric(4.0, 5.0))  // 3px extra padding top/bottom
                        .stroke(egui::Stroke::NONE))
                    .show(ctx, |ui| {
                    ui.horizontal_centered(|ui| {
                        // Paw menu icon - SVG matching web interface
                        const PAW_SVG: &[u8] = br##"<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 48.839 48.839"><path fill="#c0c0c0" d="M39.041,36.843c2.054,3.234,3.022,4.951,3.022,6.742c0,3.537-2.627,5.252-6.166,5.252c-1.56,0-2.567-0.002-5.112-1.326c0,0-1.649-1.509-5.508-1.354c-3.895-0.154-5.545,1.373-5.545,1.373c-2.545,1.323-3.516,1.309-5.074,1.309c-3.539,0-6.168-1.713-6.168-5.252c0-1.791,0.971-3.506,3.024-6.742c0,0,3.881-6.445,7.244-9.477c2.43-2.188,5.973-2.18,5.973-2.18h1.093v-0.001c0,0,3.698-0.009,5.976,2.181C35.059,30.51,39.041,36.844,39.041,36.843z M16.631,20.878c3.7,0,6.699-4.674,6.699-10.439S20.331,0,16.631,0S9.932,4.674,9.932,10.439S12.931,20.878,16.631,20.878z M10.211,30.988c2.727-1.259,3.349-5.723,1.388-9.971s-5.761-6.672-8.488-5.414s-3.348,5.723-1.388,9.971C3.684,29.822,7.484,32.245,10.211,30.988z M32.206,20.878c3.7,0,6.7-4.674,6.7-10.439S35.906,0,32.206,0s-6.699,4.674-6.699,10.439C25.507,16.204,28.506,20.878,32.206,20.878z M45.727,15.602c-2.728-1.259-6.527,1.165-8.488,5.414s-1.339,8.713,1.389,9.972c2.728,1.258,6.527-1.166,8.488-5.414S48.455,16.861,45.727,15.602z"/></svg>"##;
                        let paw_size = 24.0;  // 20% bigger than 20.0
                        let paw_image = egui::Image::from_bytes("bytes://paw_icon.svg", PAW_SVG)
                            .fit_to_exact_size(egui::vec2(paw_size, paw_size));
                        ui.menu_image_button(paw_image, |ui| {
                            // First segment - alphabetical
                            if ui.button("Actions").clicked() {
                                action = Some("actions");
                                ui.close_menu();
                            }
                            if ui.button("Font").clicked() {
                                action = Some("font");
                                ui.close_menu();
                            }
                            if ui.button("Setup").clicked() {
                                action = Some("setup");
                                ui.close_menu();
                            }
                            if ui.button("Web").clicked() {
                                action = Some("web");
                                ui.close_menu();
                            }
                            if ui.button("Worlds").clicked() {
                                action = Some("connected_worlds");
                                ui.close_menu();
                            }
                            ui.separator();
                            // Second segment - alphabetical
                            if ui.button("Toggle Highlight").clicked() {
                                action = Some("toggle_highlight");
                                ui.close_menu();
                            }
                            if ui.button("Toggle Tags").clicked() {
                                action = Some("toggle_tags");
                                ui.close_menu();
                            }
                            ui.separator();
                            // Third segment
                            if ui.button("Resync").clicked() {
                                action = Some("resync");
                                ui.close_menu();
                            }
                        });

                        // Font size slider on the right side of menu bar
                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                            // Define the 4 font size positions
                            const FONT_SIZES: [f32; 4] = [8.5, 12.0, 14.0, 18.0];

                            // Find current position (0-3)
                            let current_pos = FONT_SIZES.iter()
                                .position(|&s| (s - self.font_size).abs() < 0.5)
                                .unwrap_or(2) as i32;

                            let label_color = egui::Color32::from_gray(128);

                            // Slider dimensions
                            let slider_width = 80.0;
                            let slider_height = 20.0;
                            let label_spacing = 4.0;

                            // Allocate space for: large A + slider + small A
                            let total_width = 14.0 + label_spacing + slider_width + label_spacing + 8.0;
                            let (total_rect, response) = ui.allocate_exact_size(
                                egui::vec2(total_width, slider_height),
                                egui::Sense::click_and_drag()
                            );

                            // Calculate positions (RTL: large A on right, small A on left)
                            let small_a_x = total_rect.left() + 4.0;
                            let slider_left = total_rect.left() + 8.0 + label_spacing;
                            let slider_right = slider_left + slider_width;
                            let large_a_x = slider_right + label_spacing;
                            let rect = egui::Rect::from_min_max(
                                egui::pos2(slider_left, total_rect.top()),
                                egui::pos2(slider_right, total_rect.bottom())
                            );

                            if ui.is_rect_visible(total_rect) {
                                let painter = ui.painter();

                                // Draw triangle background (point on left, tall on right)
                                let triangle_color = if theme.is_dark() {
                                    egui::Color32::from_gray(60)
                                } else {
                                    egui::Color32::from_gray(180)
                                };

                                let triangle_points = vec![
                                    egui::pos2(rect.left() + 2.0, rect.bottom() - 2.0),  // Bottom left
                                    egui::pos2(rect.right() - 2.0, rect.bottom() - 2.0), // Bottom right
                                    egui::pos2(rect.right() - 2.0, rect.top() + 2.0),    // Top right
                                ];
                                painter.add(egui::Shape::convex_polygon(
                                    triangle_points,
                                    triangle_color,
                                    egui::Stroke::NONE,
                                ));

                                // Draw slider handle
                                let handle_x = rect.left() + 6.0 + (current_pos as f32) * ((slider_width - 12.0) / 3.0);
                                let handle_color = if theme.is_dark() {
                                    egui::Color32::from_rgb(100, 180, 255)
                                } else {
                                    egui::Color32::from_rgb(50, 120, 200)
                                };

                                painter.circle_filled(
                                    egui::pos2(handle_x, rect.center().y),
                                    6.0,
                                    handle_color
                                );

                                // Draw A labels aligned with bottom of slider
                                let label_y = rect.bottom() - 2.0;

                                // Small A on left
                                painter.text(
                                    egui::pos2(small_a_x, label_y),
                                    egui::Align2::LEFT_BOTTOM,
                                    "A",
                                    egui::FontId::proportional(8.0),
                                    label_color,
                                );

                                // Large A on right
                                painter.text(
                                    egui::pos2(large_a_x, label_y),
                                    egui::Align2::LEFT_BOTTOM,
                                    "A",
                                    egui::FontId::proportional(14.0),
                                    label_color,
                                );
                            }

                            // Handle clicks and drags on the slider area
                            if response.clicked() || response.dragged() {
                                if let Some(pos) = response.interact_pointer_pos() {
                                    if pos.x >= rect.left() && pos.x <= rect.right() {
                                        let rel_x = pos.x - rect.left() - 6.0;
                                        let step_width = (slider_width - 12.0) / 3.0;
                                        let new_pos = ((rel_x / step_width).round() as i32).clamp(0, 3);
                                        let new_size = FONT_SIZES[new_pos as usize];
                                        if (new_size - self.font_size).abs() > 0.5 {
                                            self.font_size = new_size;
                                            action = Some("font_changed");
                                        }
                                    }
                                }
                            }
                        });
                    });
                });

                // Handle menu actions
                match action {
                    Some("world_list") => {
                        self.popup_state = PopupState::ConnectedWorlds;
                        self.world_list_selected = self.current_world;
                        self.only_connected_worlds = false;
                    }
                    Some("connected_worlds") => {
                        self.popup_state = PopupState::ConnectedWorlds;
                        self.world_list_selected = self.current_world;
                        self.only_connected_worlds = true;
                    }
                    Some("actions") => {
                        self.popup_state = PopupState::ActionsList;
                        self.actions_selected = 0;
                        self.action_error = None;
                    }
                    Some("edit_current") => self.open_world_editor(self.current_world),
                    Some("setup") => self.popup_state = PopupState::Setup,
                    Some("web") => self.popup_state = PopupState::Web,
                    Some("font") => {
                        self.edit_font_name = self.font_name.clone();
                        self.edit_font_size = self.font_size.to_string();
                        self.popup_state = PopupState::Font;
                    }
                    Some("font_changed") => {
                        // Font size was changed via S/M/L buttons - update server settings
                        self.update_global_settings();
                    }
                    Some("connect") => self.connect_world(self.current_world),
                    Some("disconnect") => self.disconnect_world(self.current_world),
                    Some("toggle_tags") => self.show_tags = !self.show_tags,
                    Some("toggle_highlight") => self.highlight_actions = !self.highlight_actions,
                    Some("resync") => {
                        // Request full state resync from server
                        if let Some(ref ws_tx) = self.ws_tx {
                            let _ = ws_tx.send(WsMessage::RequestState);
                        }
                    }
                    Some("spell_check") => {
                        if let Some(message) = self.handle_spell_check() {
                            // Add suggestion message to current world's output
                            if let Some(world) = self.worlds.get_mut(self.current_world) {
                                world.output_lines.push(TimestampedLine {
                                    text: message,
                                    ts: current_timestamp_secs(),
                                });
                            }
                        }
                    }
                    Some("help") => self.popup_state = PopupState::Help,
                    _ => {}
                }

                // Input area at bottom (full width)
                let input_height = self.input_height as f32 * 16.0 + 8.0;
                let prompt_text = self.worlds.get(self.current_world)
                    .map(|w| Self::strip_ansi_for_copy(&w.prompt))
                    .unwrap_or_default();

                let input_bg = theme.bg();
                let input_bg_transparent = egui::Color32::from_rgba_unmultiplied(input_bg.r(), input_bg.g(), input_bg.b(), alpha);
                egui::TopBottomPanel::bottom("input_panel")
                    .exact_height(input_height)
                    .frame(egui::Frame::none()
                        .fill(input_bg_transparent)
                        .inner_margin(egui::Margin::same(2.0))
                        .stroke(egui::Stroke::NONE))
                    .show(ctx, |ui| {
                        ui.spacing_mut().item_spacing.x = 0.0; // Remove horizontal spacing

                        // Text input takes full area
                        // Build layout job with spell check coloring (misspelled words in red)
                        let input_id = egui::Id::new("main_input");
                        let misspelled = self.find_misspelled_words();
                        let font_id = egui::FontId::monospace(self.font_size);
                        let default_color = theme.fg();
                        let line_height = 16.0_f32; // Approximate line height for scrolling calc

                        // Build layouter using actual text parameter (not pre-computed job)
                        // This ensures cursor positioning works correctly when text changes
                        let misspelled_ranges = misspelled;
                        let layouter_font_id = font_id.clone();
                        let layouter_default_color = default_color;

                        // Calculate prompt width for offset
                        let prompt_width = if !prompt_text.is_empty() {
                            ui.fonts(|f| f.glyph_width(&egui::FontId::monospace(self.font_size), ' ')) * prompt_text.len() as f32
                        } else {
                            0.0
                        };

                        // Use ScrollArea to handle scrolling, with manual scroll-to-cursor
                        let available_height = ui.available_height();
                        let scroll_id = egui::Id::new("input_scroll_area");

                        let mut scroll_to_y: Option<f32> = None;

                        let scroll_output = egui::ScrollArea::vertical()
                            .id_salt(scroll_id)
                            .max_height(available_height)
                            .auto_shrink([false, false])
                            .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::AlwaysHidden)
                            .show(ui, |ui| {
                            ui.horizontal_top(|ui| {
                                // Show prompt if present (cyan colored like TUI)
                                if !prompt_text.is_empty() {
                                    ui.label(egui::RichText::new(&prompt_text)
                                        .monospace()
                                        .color(theme.prompt()));
                                }

                                let available_width = ui.available_width();
                                let response = ui.add(
                                    TextEdit::multiline(&mut self.input_buffer)
                                        .font(egui::TextStyle::Monospace)
                                        .desired_width(available_width)
                                        .margin(egui::Margin::ZERO)
                                        .frame(false)
                                        .id(input_id)
                                        .layouter(&mut |_ui, text, wrap_width| {
                                            // Build layout job from actual text parameter
                                            let mut job = egui::text::LayoutJob::default();
                                            let chars: Vec<char> = text.chars().collect();
                                            let mut pos = 0;

                                            // Use misspelled ranges (may be slightly stale for one frame)
                                            let mut ranges = misspelled_ranges.clone();
                                            ranges.sort_by_key(|(start, _)| *start);

                                            for (start, end) in ranges {
                                                if start >= chars.len() || end > chars.len() {
                                                    continue; // Skip stale ranges
                                                }
                                                // Add normal text before misspelled word
                                                if pos < start {
                                                    let normal_text: String = chars[pos..start].iter().collect();
                                                    job.append(&normal_text, 0.0, egui::TextFormat {
                                                        font_id: layouter_font_id.clone(),
                                                        color: layouter_default_color,
                                                        ..Default::default()
                                                    });
                                                }
                                                // Add misspelled word in red
                                                let misspelled_text: String = chars[start..end].iter().collect();
                                                job.append(&misspelled_text, 0.0, egui::TextFormat {
                                                    font_id: layouter_font_id.clone(),
                                                    color: egui::Color32::RED,
                                                    ..Default::default()
                                                });
                                                pos = end;
                                            }
                                            // Add remaining text
                                            if pos < chars.len() {
                                                let remaining: String = chars[pos..].iter().collect();
                                                job.append(&remaining, 0.0, egui::TextFormat {
                                                    font_id: layouter_font_id.clone(),
                                                    color: layouter_default_color,
                                                    ..Default::default()
                                                });
                                            }
                                            // Handle empty text
                                            if chars.is_empty() {
                                                job.append("", 0.0, egui::TextFormat {
                                                    font_id: layouter_font_id.clone(),
                                                    color: layouter_default_color,
                                                    ..Default::default()
                                                });
                                            }

                                            job.wrap = egui::text::TextWrapping {
                                                max_width: wrap_width,
                                                ..Default::default()
                                            };
                                            _ui.fonts(|f| f.layout_job(job))
                                        })
                                );
                                response
                            }).inner
                        });

                        let response = scroll_output.inner;

                        // Calculate cursor position and scroll to it if needed
                        if response.has_focus() {
                            if let Some(state) = egui::TextEdit::load_state(ctx, input_id) {
                                if let Some(cursor_range) = state.cursor.char_range() {
                                    // Estimate cursor Y position based on character position
                                    // Count newlines before cursor to estimate line number
                                    let cursor_pos = cursor_range.primary.index;
                                    let text_before_cursor: String = self.input_buffer.chars().take(cursor_pos).collect();
                                    let lines_before = text_before_cursor.matches('\n').count();
                                    // Also account for wrapped lines (rough estimate)
                                    let wrap_width = ui.available_width() - prompt_width;
                                    let char_width = ui.fonts(|f| f.glyph_width(&egui::FontId::monospace(self.font_size), 'M'));
                                    let chars_per_line = (wrap_width / char_width).max(1.0) as usize;
                                    let wrapped_lines: usize = text_before_cursor.lines()
                                        .map(|line| (line.len() / chars_per_line.max(1)).max(0))
                                        .sum();
                                    let cursor_line = lines_before + wrapped_lines;
                                    let cursor_y = cursor_line as f32 * line_height;

                                    // Check if cursor is outside visible area
                                    let scroll_offset = scroll_output.state.offset.y;
                                    let visible_top = scroll_offset;
                                    let visible_bottom = scroll_offset + available_height - line_height;

                                    if cursor_y < visible_top {
                                        scroll_to_y = Some(cursor_y);
                                    } else if cursor_y > visible_bottom {
                                        scroll_to_y = Some(cursor_y - available_height + line_height * 2.0);
                                    }
                                }
                            }
                        }

                        // Apply scroll adjustment if needed
                        if let Some(target_y) = scroll_to_y {
                            let mut scroll_state = scroll_output.state;
                            scroll_state.offset.y = target_y.max(0.0);
                            scroll_state.store(ctx, scroll_output.id);
                        }

                        // Always keep cursor visible in input area when no popup is open
                        // But don't steal focus if user is selecting text with mouse
                        if !response.has_focus() && self.popup_state == PopupState::None && !self.filter_active {
                            let mouse_down = ctx.input(|i| i.pointer.any_down());
                            let typed_text: Option<String> = ctx.input(|i| {
                                // Find any text that was typed
                                for e in &i.events {
                                    if let egui::Event::Text(text) = e {
                                        return Some(text.clone());
                                    }
                                }
                                None
                            });

                            // Request focus if mouse isn't being held (not selecting text)
                            // or if user started typing
                            if !mouse_down || typed_text.is_some() {
                                response.request_focus();
                            }

                            if let Some(text) = typed_text {
                                // Add the typed text to input buffer
                                self.input_buffer.push_str(&text);
                                // Set cursor position to end of buffer (create state if needed)
                                let mut state = egui::TextEdit::load_state(ctx, input_id)
                                    .unwrap_or_default();
                                let ccursor = egui::text::CCursor::new(self.input_buffer.len());
                                state.cursor.set_char_range(Some(egui::text::CCursorRange::one(ccursor)));
                                state.store(ctx, input_id);
                            }
                        }

                        // Apply cursor_home (Ctrl+A)
                        if cursor_home {
                            let mut state = egui::TextEdit::load_state(ctx, input_id)
                                .unwrap_or_default();
                            let ccursor = egui::text::CCursor::new(0);
                            state.cursor.set_char_range(Some(egui::text::CCursorRange::one(ccursor)));
                            state.store(ctx, input_id);
                        }

                        // Send on Enter (without Shift)
                        if response.has_focus() && ui.input(|i| i.key_pressed(egui::Key::Enter) && !i.modifiers.shift) {
                            // Remove all newlines from the command (cursor in middle causes TextEdit to insert newline)
                            let cmd: String = std::mem::take(&mut self.input_buffer)
                                .chars()
                                .filter(|c| *c != '\n')
                                .collect();
                            // Reset spell state when sending command
                            self.reset_spell_state();
                            if !cmd.is_empty() {
                                // Use shared command parsing
                                let parsed = super::parse_command(&cmd);

                                // Handle local GUI popup commands
                                match parsed {
                                    super::Command::Setup => {
                                        self.popup_state = PopupState::Setup;
                                    }
                                    super::Command::Web => {
                                        self.popup_state = PopupState::Web;
                                    }
                                    super::Command::WorldSelector => {
                                        self.popup_state = PopupState::ConnectedWorlds;
                                        self.world_list_selected = self.current_world;
                                        self.only_connected_worlds = false;
                                    }
                                    super::Command::WorldsList => {
                                        // Output connected worlds list as text
                                        let worlds_info: Vec<super::util::WorldListInfo> = self.worlds.iter().enumerate().map(|(idx, world)| {
                                            super::util::WorldListInfo {
                                                name: world.name.clone(),
                                                connected: world.connected,
                                                is_current: idx == self.current_world,
                                                unseen_lines: world.unseen_lines,
                                                last_send_secs: world.last_send_secs,
                                                last_recv_secs: world.last_recv_secs,
                                                last_nop_secs: world.last_nop_secs,
                                                next_nop_secs: None,
                                            }
                                        }).collect();
                                        let output = super::util::format_worlds_list(&worlds_info);
                                        let ts = super::current_timestamp_secs();
                                        if self.current_world < self.worlds.len() {
                                            for line in output.lines() {
                                                self.worlds[self.current_world].output_lines.push(TimestampedLine {
                                                    text: line.to_string(),
                                                    ts,
                                                });
                                            }
                                        }
                                    }
                                    super::Command::Help => {
                                        self.popup_state = PopupState::Help;
                                    }
                                    super::Command::Menu => {
                                        self.popup_state = PopupState::Menu;
                                        self.menu_selected = 0;
                                    }
                                    super::Command::Actions { .. } => {
                                        self.actions_selected = 0;
                                        self.popup_state = PopupState::ActionsList;
                                    }
                                    super::Command::WorldEdit { name } => {
                                        // Open world editor
                                        let idx = if let Some(ref world_name) = name {
                                            self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(world_name))
                                                .unwrap_or(self.current_world)
                                        } else {
                                            self.current_world
                                        };
                                        self.open_world_editor(idx);
                                    }
                                    super::Command::WorldSwitch { ref name } => {
                                        // /worlds <name> - switch to world, connect if not connected
                                        if let Some(idx) = self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                            // Switch locally
                                            self.current_world = idx;
                                            // If not connected, send connect command to server
                                            if !self.worlds[idx].connected {
                                                self.connect_world(idx);
                                            }
                                        } else {
                                            // World not found - show error locally (red with %% prefix)
                                            let ts = current_timestamp_secs();
                                            if self.current_world < self.worlds.len() {
                                                self.worlds[self.current_world].output_lines.push(
                                                    TimestampedLine { text: format!("\x1b[31m%% World '{}' not found.\x1b[0m", name), ts }
                                                );
                                            }
                                        }
                                    }
                                    super::Command::WorldConnectNoLogin { ref name } => {
                                        // /worlds -l <name> - switch to world, connect without auto-login
                                        if let Some(idx) = self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                            self.current_world = idx;
                                            if !self.worlds[idx].connected {
                                                // Send the command to server (it handles -l flag)
                                                self.send_command(idx, cmd);
                                            }
                                        } else {
                                            // World not found - show error locally (red with %% prefix)
                                            let ts = current_timestamp_secs();
                                            if self.current_world < self.worlds.len() {
                                                self.worlds[self.current_world].output_lines.push(
                                                    TimestampedLine { text: format!("\x1b[31m%% World '{}' not found.\x1b[0m", name), ts }
                                                );
                                            }
                                        }
                                    }
                                    _ => {
                                        // Check for /font which is GUI-specific
                                        if cmd.trim().eq_ignore_ascii_case("/font") {
                                            self.edit_font_name = self.font_name.clone();
                                            self.edit_font_size = format!("{:.1}", self.font_size);
                                            self.popup_state = PopupState::Font;
                                        } else {
                                            // Send other commands to server
                                            self.send_command(self.current_world, cmd);
                                        }
                                    }
                                }
                            }
                        }

                        // Show suggestion message if present
                        if let Some(ref msg) = self.suggestion_message {
                            ui.label(egui::RichText::new(msg).color(theme.prompt()).monospace());
                        }
                    });

                // Separator bar (matches TUI style)
                let separator_bg = match theme {
                    GuiTheme::Dark => egui::Color32::from_rgb(40, 40, 40),
                    GuiTheme::Light => egui::Color32::from_rgb(200, 200, 200),  // Darker for light theme
                };
                let separator_bg_transparent = egui::Color32::from_rgba_unmultiplied(separator_bg.r(), separator_bg.g(), separator_bg.b(), alpha);
                egui::TopBottomPanel::bottom("separator_bar")
                    .exact_height(20.0)
                    .frame(egui::Frame::none()
                        .fill(separator_bg_transparent)
                        .inner_margin(egui::Margin::same(0.0))
                        .stroke(egui::Stroke::NONE))
                    .show(ctx, |ui| {
                        ui.horizontal(|ui| {
                            // Get current world info
                            let world_name = self.worlds.get(self.current_world)
                                .map(|w| w.name.as_str())
                                .unwrap_or("---");
                            let connected = self.worlds.get(self.current_world)
                                .map(|w| w.connected)
                                .unwrap_or(false);

                            // Collect worlds with activity (unseen output only)
                            // Note: pending_count is server-side more-mode concept, not meaningful for GUI activity
                            let worlds_with_activity: Vec<(&str, usize)> = self.worlds.iter()
                                .enumerate()
                                .filter(|(i, w)| *i != self.current_world && w.unseen_lines > 0)
                                .map(|(_, w)| (w.name.as_str(), w.unseen_lines))
                                .collect();
                            let activity_count = worlds_with_activity.len();

                            // Status indicator (More/Hist or underscores)
                            // Status area - spaces instead of underscores when no More/Hist indicator
                            let status_text = "           ";
                            ui.label(egui::RichText::new(status_text).monospace());

                            // Underscore padding
                            ui.label(egui::RichText::new(" ").monospace().color(theme.fg_dim()));

                            // World name (bold)
                            let name_color = if connected { theme.success() } else { theme.fg() };
                            ui.label(egui::RichText::new(world_name).monospace().strong().color(name_color));

                            // Tag indicator (only shown when F2 toggled to show tags)
                            if self.show_tags {
                                ui.label(egui::RichText::new(" [tag]").monospace().color(theme.prompt()));
                            }

                            // Activity indicator with hover tooltip
                            if activity_count > 0 {
                                ui.label(egui::RichText::new(" ").monospace().color(theme.fg_dim()));
                                let activity_label = ui.label(egui::RichText::new(format!("(Activity: {})", activity_count))
                                    .monospace().color(theme.highlight()));
                                // Show hover popup with list of worlds that have activity
                                activity_label.on_hover_ui(|ui| {
                                    ui.label(egui::RichText::new("Worlds with unseen output:").strong());
                                    for (world_name, unseen) in &worlds_with_activity {
                                        ui.label(format!("{}: {} unseen", world_name, unseen));
                                    }
                                });
                            }

                            // Spacer with underscore-style fill
                            ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                // Current time (HH:MM) in local timezone
                                let (hours, mins) = unsafe {
                                    let mut now: libc::time_t = 0;
                                    libc::time(&mut now);
                                    let tm = libc::localtime(&now);
                                    if tm.is_null() {
                                        (0, 0)
                                    } else {
                                        ((*tm).tm_hour as u32, (*tm).tm_min as u32)
                                    }
                                };
                                ui.label(egui::RichText::new(format!("{}:{:02}", hours, mins))
                                    .monospace().color(theme.accent()));
                            });
                        });
                    });

                // Filter popup (F4) - separate OS window
                if self.filter_active {
                    let mut should_close = false;
                    let mut filter_text = self.filter_text.clone();

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("filter_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Filter - Clay MUD Client")
                            .with_inner_size([300.0, 60.0]),
                        |ctx, _class| {
                            egui::CentralPanel::default().show(ctx, |ui| {
                                if ui.input(|i| i.key_pressed(egui::Key::Escape)) ||
                                   ui.input(|i| i.key_pressed(egui::Key::F4)) ||
                                   ui.input(|i| i.viewport().close_requested()) {
                                    should_close = true;
                                }

                                ui.horizontal(|ui| {
                                    ui.label("Filter:");
                                    let response = ui.text_edit_singleline(&mut filter_text);
                                    response.request_focus();
                                });
                            });
                        },
                    );

                    self.filter_text = filter_text;
                    if should_close {
                        self.filter_active = false;
                        self.filter_text.clear();
                    }
                }

                // Main output area with scrollbar (no frame/border/margin)
                let bg = theme.bg();
                let alpha = (self.transparency * 255.0) as u8;
                let transparent_bg = egui::Color32::from_rgba_unmultiplied(bg.r(), bg.g(), bg.b(), alpha);
                egui::CentralPanel::default()
                    .frame(egui::Frame::none()
                        .fill(transparent_bg)
                        .inner_margin(egui::Margin::same(0.0))
                        .stroke(egui::Stroke::NONE))
                    .show(ctx, |ui| {
                    if let Some(world) = self.worlds.get(self.current_world) {
                        // Cache "now" for timestamp formatting - compute once per frame
                        let cached_now = GuiCachedNow::new();

                        // Keep original lines with ANSI for coloring
                        let colored_lines: Vec<&TimestampedLine> = world.output_lines.iter()
                            .filter(|line| {
                                // Apply filter if active (filter on stripped text)
                                if self.filter_active && !self.filter_text.is_empty() {
                                    let stripped = Self::strip_ansi_for_copy(&line.text);
                                    stripped.to_lowercase().contains(&self.filter_text.to_lowercase())
                                } else {
                                    true
                                }
                            })
                            .collect();

                        // Build plain text version for selection (strip ANSI codes and empty lines)
                        let lines: Vec<String> = colored_lines.iter()
                            .map(|line| {
                                let stripped = Self::strip_ansi_for_copy(&line.text);
                                if self.show_tags {
                                    // Add timestamp prefix when showing tags
                                    // Also convert temperatures
                                    let ts_prefix = Self::format_timestamp_gui_cached(line.ts, &cached_now);
                                    let with_temps = convert_temperatures(&stripped);
                                    format!("{} {}", ts_prefix, with_temps)
                                } else {
                                    // Strip MUD tags like [channel:] or [channel(player)]
                                    Self::strip_mud_tags(&stripped)
                                }
                            })
                            .collect();
                        let plain_text: String = lines.join("\n");

                        // Build combined LayoutJob with ANSI colors
                        let default_color = theme.fg();
                        let font_id = egui::FontId::monospace(self.font_size);
                        let mut combined_job = egui::text::LayoutJob::default();
                        combined_job.wrap = egui::text::TextWrapping {
                            max_width: ui.available_width(),
                            ..Default::default()
                        };

                        // Check if any line has Discord emojis
                        let has_any_discord_emojis = colored_lines.iter()
                            .any(|line| Self::has_discord_emojis(&line.text));

                        // Build display lines for both paths
                        let world_name = &world.name;
                        let highlight_actions = self.highlight_actions;
                        let actions = &self.actions;
                        let display_lines: Vec<String> = colored_lines.iter().map(|line| {
                            let base_line = if self.show_tags {
                                let ts_prefix = Self::format_timestamp_gui_cached(line.ts, &cached_now);
                                // Also convert temperatures when showing tags
                                let with_temps = convert_temperatures(&line.text);
                                format!("\x1b[36m{}\x1b[0m {}", ts_prefix, with_temps)
                            } else {
                                Self::strip_mud_tags_ansi(&line.text)
                            };
                            // Apply action highlighting if enabled
                            if highlight_actions && line_matches_action(&line.text, world_name, actions) {
                                // Dark yellow/brown background (same as console: 48;5;58)
                                let bg_code = "\x1b[48;5;58m";
                                // Replace any resets to preserve background
                                let highlighted = base_line.replace("\x1b[0m", &format!("\x1b[0m{}", bg_code));
                                format!("{}{}\x1b[0m", bg_code, highlighted)
                            } else {
                                base_line
                            }
                        }).collect();

                        // For non-emoji path, build combined LayoutJob
                        if !has_any_discord_emojis {
                            for (i, display_line) in display_lines.iter().enumerate() {
                                let line_text = convert_discord_emojis(display_line);
                                // Apply word breaks for long words
                                let line_text = Self::insert_word_breaks(&line_text);
                                let is_light_theme = matches!(theme, GuiTheme::Light);
                                Self::append_ansi_to_job(&line_text, default_color, font_id.clone(), &mut combined_job, is_light_theme);

                                if i < display_lines.len() - 1 {
                                    combined_job.append("\n", 0.0, egui::TextFormat {
                                        font_id: font_id.clone(),
                                        color: default_color,
                                        ..Default::default()
                                    });
                                }
                            }
                        }

                        // Use a unique ID per world to ensure scroll state is preserved per-world
                        let scroll_id = egui::Id::new(format!("output_scroll_{}", self.current_world));
                        let stick_to_bottom = self.scroll_offset.is_none() && !self.filter_active;

                        // Apply scroll offset if set (from PageUp/PageDown)
                        let scroll_delta = if let Some(offset) = self.scroll_offset.take() {
                            // Convert our offset to a delta we want to apply
                            Some(offset)
                        } else {
                            None
                        };

                        let mut scroll_area = ScrollArea::vertical()
                            .id_salt(scroll_id)
                            .auto_shrink([false; 2])
                            .stick_to_bottom(stick_to_bottom)
                            .scroll_bar_visibility(egui::scroll_area::ScrollBarVisibility::AlwaysVisible);

                        // If we have a scroll delta, apply it
                        if let Some(delta) = scroll_delta {
                            scroll_area = scroll_area.vertical_scroll_offset(delta);
                        }

                        // Clone the job for the layouter closure
                        let layout_job = combined_job.clone();

                        // Debug: log LayoutJob info
                        static DEBUG_ONCE: std::sync::atomic::AtomicBool = std::sync::atomic::AtomicBool::new(false);
                        if !DEBUG_ONCE.swap(true, std::sync::atomic::Ordering::Relaxed) {
                            use std::io::Write;
                            if let Ok(mut f) = std::fs::OpenOptions::new()
                                .create(true).append(true)
                                .open("/tmp/clay_gui_debug.log")
                            {
                                let _ = writeln!(f, "=== LayoutJob Debug ===");
                                let _ = writeln!(f, "plain_text len: {}", plain_text.len());
                                let _ = writeln!(f, "layout_job.text len: {}", layout_job.text.len());
                                let _ = writeln!(f, "layout_job.sections: {}", layout_job.sections.len());
                                let _ = writeln!(f, "texts_match: {}", plain_text == layout_job.text);
                                // Log first few sections with colors
                                for (i, section) in layout_job.sections.iter().take(10).enumerate() {
                                    let _ = writeln!(f, "  Section {}: byte_range={:?}, color=({},{},{},{})",
                                        i, section.byte_range,
                                        section.format.color.r(), section.format.color.g(),
                                        section.format.color.b(), section.format.color.a());
                                }
                                // Log first 200 chars of each
                                let _ = writeln!(f, "plain_text first 200: {:?}", plain_text.chars().take(200).collect::<String>());
                                let _ = writeln!(f, "layout_job.text first 200: {:?}", layout_job.text.chars().take(200).collect::<String>());
                            }
                        }

                        // Clone values needed in the closure
                        let has_emojis = has_any_discord_emojis;
                        let emoji_lines = display_lines.clone();
                        let emoji_font_id = font_id.clone();
                        let emoji_default_color = default_color;
                        let emoji_is_light = matches!(theme, GuiTheme::Light);
                        let emoji_link_color = theme.link();
                        let emoji_plain_text = plain_text.clone();

                        let scroll_output = scroll_area.show(ui, |ui| {
                                ui.set_width(ui.available_width());
                                // Remove vertical spacing between lines for seamless ASCII art
                                ui.spacing_mut().item_spacing.y = 0.0;

                                // Use different rendering path for Discord emojis
                                if has_emojis {
                                    // Render each line with inline emoji images
                                    for line in &emoji_lines {
                                        Self::render_line_with_emojis(
                                            ui,
                                            line,
                                            emoji_default_color,
                                            &emoji_font_id,
                                            emoji_is_light,
                                            emoji_link_color,
                                        );
                                    }

                                    // Add context menu for copy functionality
                                    let text_for_copy = emoji_plain_text.clone();
                                    ui.interact(ui.min_rect(), egui::Id::new("emoji_output_ctx"), egui::Sense::click())
                                        .context_menu(|ui| {
                                            if ui.button("Copy All").clicked() {
                                                ui.ctx().copy_text(text_for_copy.clone());
                                                ui.close_menu();
                                            }
                                        });

                                    return; // Skip the TextEdit path
                                }

                                // Use TextEdit with custom layouter for colored text
                                let mut text_copy = plain_text.clone();
                                let response = TextEdit::multiline(&mut text_copy)
                                    .font(egui::TextStyle::Monospace)
                                    .desired_width(f32::INFINITY)
                                    .interactive(true)
                                    .frame(false)
                                    .text_color_opt(None)
                                    .layouter(&mut |_ui, _string, wrap_width| {
                                        let mut job = layout_job.clone();
                                        job.wrap.max_width = wrap_width;
                                        _ui.fonts(|f| f.layout_job(job))
                                    })
                                    .show(ui);

                                // Store selection in egui memory on every frame when there is one
                                // This ensures we have it captured before any click clears it
                                // Skip storage on secondary click to preserve existing selection
                                let selection_id = egui::Id::new("output_selection");
                                let selection_range_id = egui::Id::new("output_selection_range");
                                let selection_raw_id = egui::Id::new("output_selection_raw");
                                let is_secondary_click = response.response.secondary_clicked();
                                if !is_secondary_click {
                                if let Some(cursor_range) = response.cursor_range {
                                    if cursor_range.primary != cursor_range.secondary {
                                        let start_char = cursor_range.primary.ccursor.index.min(cursor_range.secondary.ccursor.index);
                                        let end_char = cursor_range.primary.ccursor.index.max(cursor_range.secondary.ccursor.index);
                                        // Convert character indices to byte indices for proper UTF-8 slicing
                                        let galley_text = response.galley.text();
                                        let start_byte = galley_text.char_indices().nth(start_char).map(|(i, _)| i).unwrap_or(galley_text.len());
                                        let end_byte = galley_text.char_indices().nth(end_char).map(|(i, _)| i).unwrap_or(galley_text.len());
                                        let selected = galley_text[start_byte..end_byte].to_string();

                                        // Extract the selected portion from raw lines, preserving ANSI codes
                                        // Helper to extract visible char range from raw text with ANSI
                                        fn extract_raw_selection(raw: &str, vis_start: usize, vis_end: usize) -> String {
                                            let mut result = String::new();
                                            let mut vis_pos = 0;
                                            let mut chars = raw.chars().peekable();

                                            while let Some(c) = chars.next() {
                                                if c == '\x1b' {
                                                    // Start of ANSI sequence - include it if we're in selection
                                                    let mut seq = String::from(c);
                                                    while let Some(&next) = chars.peek() {
                                                        seq.push(chars.next().unwrap());
                                                        if next.is_ascii_alphabetic() {
                                                            break;
                                                        }
                                                    }
                                                    if vis_pos >= vis_start && vis_pos < vis_end {
                                                        result.push_str(&seq);
                                                    }
                                                } else {
                                                    // Visible character
                                                    if vis_pos >= vis_start && vis_pos < vis_end {
                                                        result.push(c);
                                                    }
                                                    vis_pos += 1;
                                                    if vis_pos >= vis_end {
                                                        break;
                                                    }
                                                }
                                            }
                                            result
                                        }

                                        // Build selection from raw lines
                                        let mut raw_selected_parts = Vec::new();
                                        let mut char_pos = 0;
                                        for (i, galley_line) in galley_text.lines().enumerate() {
                                            let line_start = char_pos;
                                            let line_end = char_pos + galley_line.chars().count();

                                            // Check if this line overlaps with selection
                                            if line_end > start_char && line_start < end_char {
                                                if let Some(ts_line) = colored_lines.get(i) {
                                                    // Calculate visible char range within this line
                                                    let sel_start_in_line = start_char.saturating_sub(line_start);
                                                    let sel_end_in_line = (end_char - line_start).min(galley_line.chars().count());

                                                    let raw_part = extract_raw_selection(
                                                        &ts_line.text,
                                                        sel_start_in_line,
                                                        sel_end_in_line
                                                    );
                                                    if !raw_part.is_empty() {
                                                        raw_selected_parts.push(raw_part);
                                                    }
                                                }
                                            }
                                            char_pos = line_end + 1; // +1 for newline
                                        }
                                        let raw_text = raw_selected_parts.join("\n").replace('\x1b', "<esc>");

                                        // Always store selection text, range, and raw lines when we have one
                                        ui.ctx().data_mut(|d| {
                                            d.insert_temp(selection_id, selected);
                                            d.insert_temp(selection_range_id, (start_char, end_char));
                                            d.insert_temp(selection_raw_id, raw_text);
                                        });
                                    }
                                }
                                } // end if !is_secondary_click
                                // Handle clicks - check for URL clicks and clear selection
                                if response.response.clicked() {
                                    if let Some(cursor_range) = response.cursor_range {
                                        if cursor_range.primary == cursor_range.secondary {
                                            let click_pos = cursor_range.primary.ccursor.index;

                                            // Check if clicking on a URL
                                            // Use galley text (not plain_text) to match cursor positions
                                            let galley_text = response.galley.text();
                                            let urls = Self::find_urls(galley_text);
                                            let mut url_clicked = false;
                                            for (start, end, url) in urls {
                                                if click_pos >= start && click_pos <= end {
                                                    // Strip zero-width spaces that were inserted for word breaking
                                                    let clean_url = url.replace('\u{200B}', "");
                                                    Self::open_url(&clean_url);
                                                    url_clicked = true;
                                                    break;
                                                }
                                            }

                                            // Clear selection if not clicking a URL
                                            if !url_clicked {
                                                ui.ctx().data_mut(|d| {
                                                    d.remove::<String>(selection_id);
                                                    d.remove::<(usize, usize)>(selection_range_id);
                                                    d.remove::<String>(selection_raw_id);
                                                });
                                            }
                                        }
                                    } else {
                                        ui.ctx().data_mut(|d| {
                                            d.remove::<String>(selection_id);
                                            d.remove::<(usize, usize)>(selection_range_id);
                                            d.remove::<String>(selection_raw_id);
                                        });
                                    }
                                }

                                // Always draw custom selection highlight when we have a stored selection
                                // This ensures no flicker when context menu opens/closes
                                {
                                    if let Some((start, end)) = ui.ctx().data(|d| d.get_temp::<(usize, usize)>(selection_range_id)) {
                                        let galley = &response.galley;
                                        let text_pos = response.galley_pos;

                                        // Get cursor positions for start and end
                                        let start_cursor = galley.from_ccursor(egui::text::CCursor::new(start));
                                        let end_cursor = galley.from_ccursor(egui::text::CCursor::new(end));

                                        // Draw selection rectangles for each row in the selection
                                        let selection_color = egui::Color32::from_rgba_unmultiplied(100, 100, 200, 100);
                                        let painter = ui.painter();

                                        for row_idx in start_cursor.rcursor.row..=end_cursor.rcursor.row {
                                            if let Some(row) = galley.rows.get(row_idx) {
                                                let row_start = if row_idx == start_cursor.rcursor.row {
                                                    galley.pos_from_cursor(&start_cursor).min.x
                                                } else {
                                                    row.rect.left()
                                                };
                                                let row_end = if row_idx == end_cursor.rcursor.row {
                                                    galley.pos_from_cursor(&end_cursor).min.x
                                                } else {
                                                    row.rect.right()
                                                };

                                                let rect = egui::Rect::from_min_max(
                                                    egui::pos2(text_pos.x + row_start, text_pos.y + row.rect.top()),
                                                    egui::pos2(text_pos.x + row_end, text_pos.y + row.rect.bottom()),
                                                );
                                                painter.rect_filled(rect, 0.0, selection_color);
                                            }
                                        }
                                    }
                                }

                                // Draw URL underlines and handle hover cursor
                                {
                                    // Use galley text (not plain_text) to match cursor positions
                                    let galley = &response.galley;
                                    let galley_text = galley.text();
                                    let urls = Self::find_urls(galley_text);

                                    if !urls.is_empty() {
                                        let text_pos = response.galley_pos;
                                        let painter = ui.painter();
                                        let link_color = theme.link();
                                        let hover_pos = ui.input(|i| i.pointer.hover_pos());

                                        for (start, end, _url) in &urls {
                                            let start_cursor = galley.from_ccursor(egui::text::CCursor::new(*start));
                                            let end_cursor = galley.from_ccursor(egui::text::CCursor::new(*end));

                                            // Draw underline for each row the URL spans
                                            for row_idx in start_cursor.rcursor.row..=end_cursor.rcursor.row {
                                                if let Some(row) = galley.rows.get(row_idx) {
                                                    let row_start = if row_idx == start_cursor.rcursor.row {
                                                        galley.pos_from_cursor(&start_cursor).min.x
                                                    } else {
                                                        row.rect.left()
                                                    };
                                                    let row_end = if row_idx == end_cursor.rcursor.row {
                                                        galley.pos_from_cursor(&end_cursor).min.x
                                                    } else {
                                                        row.rect.right()
                                                    };

                                                    // Create rect for this URL segment
                                                    let url_rect = egui::Rect::from_min_max(
                                                        egui::pos2(text_pos.x + row_start, text_pos.y + row.rect.top()),
                                                        egui::pos2(text_pos.x + row_end, text_pos.y + row.rect.bottom()),
                                                    );

                                                    // Check if mouse is hovering over this URL segment
                                                    if let Some(pos) = hover_pos {
                                                        if url_rect.contains(pos) {
                                                            ui.ctx().set_cursor_icon(egui::CursorIcon::PointingHand);
                                                        }
                                                    }

                                                    // Draw underline at bottom of text
                                                    let y = text_pos.y + row.rect.bottom() - 1.0;
                                                    painter.line_segment(
                                                        [egui::pos2(text_pos.x + row_start, y), egui::pos2(text_pos.x + row_end, y)],
                                                        egui::Stroke::new(1.0, link_color),
                                                    );
                                                }
                                            }
                                        }
                                    }
                                }

                                // Right-click context menu
                                let plain_text_for_menu = plain_text.clone();
                                let debug_request_id = egui::Id::new("debug_text_request");
                                response.response.context_menu(|ui| {
                                    // Get stored selection from egui memory
                                    let stored_selection: Option<String> = ui.ctx().data(|d| d.get_temp(selection_id));
                                    let stored_raw: Option<String> = ui.ctx().data(|d| d.get_temp(selection_raw_id));

                                    // Show Copy button if there's stored selected text
                                    if let Some(ref selected) = stored_selection {
                                        if ui.button("Copy").clicked() {
                                            ui.ctx().copy_text(selected.clone());
                                            ui.close_menu();
                                        }
                                    }
                                    if ui.button("Copy All").clicked() {
                                        ui.ctx().copy_text(plain_text_for_menu.clone());
                                        ui.close_menu();
                                    }
                                    ui.separator();
                                    // Debug option - show raw ANSI codes
                                    if let Some(raw_text) = stored_raw {
                                        if ui.button("Debug Selection").clicked() {
                                            // Store in egui memory for retrieval outside closure
                                            ui.ctx().data_mut(|d| d.insert_temp(debug_request_id, raw_text));
                                            ui.close_menu();
                                        }
                                    }
                                });
                                // Check if debug was requested
                                let debug_request: Option<String> = ui.ctx().data_mut(|d| d.remove_temp(debug_request_id));
                                if let Some(debug_text) = debug_request {
                                    self.debug_text = debug_text;
                                    self.popup_state = PopupState::DebugText;
                                }
                            });

                        // Track actual scroll position from scroll area state
                        let content_size = scroll_output.content_size.y;
                        let viewport_height = scroll_output.inner_rect.height();
                        let max_offset = (content_size - viewport_height).max(0.0);
                        let current_offset = scroll_output.state.offset.y;

                        // Save max offset for PageUp/PageDown calculations
                        self.scroll_max_offset = max_offset;

                        // Update our tracked offset based on actual scroll position
                        if current_offset >= max_offset - 1.0 {
                            // At or near bottom
                            self.scroll_offset = None;
                        } else if self.scroll_offset.is_some() {
                            // Clamp our tracked offset to valid range
                            self.scroll_offset = Some(current_offset.clamp(0.0, max_offset));
                        }
                    }
                });

                // Popup windows
                let mut close_popup = false;
                let mut popup_action: Option<(&str, usize)> = None;

                // Worlds popup (combined world selector and connected worlds list) - separate OS window
                if self.popup_state == PopupState::ConnectedWorlds {
                    let mut should_close = false;
                    let mut selected = self.world_list_selected;
                    let mut connect_world: Option<usize> = None;
                    let mut edit_world: Option<usize> = None;
                    let mut add_world = false;
                    let mut toggle_only_connected = false;
                    let worlds_clone = self.worlds.clone();
                    let current_world = self.current_world;

                    let only_connected = self.only_connected_worlds;
                    let window_title = if only_connected { "Worlds List" } else { "World Selector" };

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("connected_worlds_window"),
                        egui::ViewportBuilder::default()
                            .with_title(window_title)
                            .with_inner_size([640.0, 352.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("connected_worlds_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 17.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.horizontal(|ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Left side: Connected toggle
                                        ui.label(egui::RichText::new("Connected")
                                            .size(11.0)
                                            .color(theme.fg_secondary())
                                            .family(egui::FontFamily::Monospace));

                                        // Toggle switch (like SSL toggle in world editor)
                                        let toggle_width = 36.0;
                                        let toggle_height = 18.0;
                                        let toggle_rect = ui.allocate_space(egui::vec2(toggle_width, toggle_height)).1;
                                        let toggle_response = ui.interact(toggle_rect, ui.id().with("only_connected_toggle"), egui::Sense::click());

                                        // Draw toggle background
                                        let toggle_bg = if only_connected { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(toggle_rect, egui::Rounding::same(toggle_height / 2.0), toggle_bg);

                                        // Draw toggle knob
                                        let knob_radius = (toggle_height - 4.0) / 2.0;
                                        let knob_x = if only_connected {
                                            toggle_rect.right() - knob_radius - 2.0
                                        } else {
                                            toggle_rect.left() + knob_radius + 2.0
                                        };
                                        let knob_color = if only_connected { theme.bg_deep() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, toggle_rect.center().y), knob_radius, knob_color);

                                        if toggle_response.clicked() {
                                            toggle_only_connected = true;
                                        }

                                        // Spacer to push buttons to right
                                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                            ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                            // Close button
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("CLOSE").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                                .fill(theme.bg_hover())
                                                .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(70.0, 28.0))
                                            ).clicked() {
                                                should_close = true;
                                            }

                                            // Connect button (primary)
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("CONNECT").size(11.0).color(theme.bg_deep()).strong().family(egui::FontFamily::Monospace))
                                                .fill(theme.accent_dim())
                                                .stroke(egui::Stroke::NONE)
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(80.0, 28.0))
                                            ).clicked() {
                                                connect_world = Some(selected);
                                                should_close = true;
                                            }

                                            // Edit button
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("EDIT").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                                .fill(theme.bg_hover())
                                                .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(60.0, 28.0))
                                            ).clicked() {
                                                edit_world = Some(selected);
                                            }

                                            // Add button
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("ADD").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                                .fill(theme.bg_hover())
                                                .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(60.0, 28.0))
                                            ).clicked() {
                                                add_world = true;
                                            }
                                        });
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Filter input
                                    let filter_rect = ui.allocate_space(egui::vec2(ui.available_width(), 28.0)).1;
                                    ui.painter().rect_filled(filter_rect, egui::Rounding::same(4.0), theme.bg_deep());
                                    let filter_inner = filter_rect.shrink2(egui::vec2(8.0, 4.0));
                                    let mut filter_ui = ui.new_child(egui::UiBuilder::new()
                                        .max_rect(filter_inner)
                                        .layout(egui::Layout::left_to_right(egui::Align::Center)));
                                    let filter_edit = TextEdit::singleline(&mut self.connected_worlds_filter)
                                        .frame(false)
                                        .hint_text(egui::RichText::new("Filter worlds...").color(theme.fg_dim()))
                                        .desired_width(filter_inner.width())
                                        .text_color(theme.fg())
                                        .font(egui::FontId::monospace(12.0));
                                    filter_ui.add(filter_edit);
                                    ui.add_space(12.0);

                                    // Table header row
                                    let row_height = 24.0;
                                    let col_widths = [180.0, 180.0, 60.0, 80.0]; // World, Hostname, Port, User
                                    let header_rect = ui.allocate_space(egui::vec2(ui.available_width(), row_height)).1;
                                    let header_y = header_rect.center().y;
                                    // World header aligned with text after status dot (4 + 14 = 18)
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + 18.0, header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "World",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + col_widths[0], header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "Hostname",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + col_widths[0] + col_widths[1], header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "Port",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + col_widths[0] + col_widths[1] + col_widths[2], header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "User",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());

                                    ui.add_space(4.0);
                                    ui.add(egui::Separator::default().spacing(0.0));
                                    ui.add_space(4.0);

                                    // Build filtered list of worlds
                                    let filter_lower = self.connected_worlds_filter.to_lowercase();
                                    let filtered_worlds: Vec<(usize, &RemoteWorld)> = worlds_clone.iter()
                                        .enumerate()
                                        .filter(|(_, w)| !only_connected || w.connected)
                                        .filter(|(_, w)| {
                                            if filter_lower.is_empty() {
                                                true
                                            } else {
                                                w.name.to_lowercase().contains(&filter_lower) ||
                                                w.settings.hostname.to_lowercase().contains(&filter_lower) ||
                                                w.settings.user.to_lowercase().contains(&filter_lower)
                                            }
                                        })
                                        .collect();

                                    let empty_message = if only_connected { "No worlds connected." } else { "No worlds found." };
                                    if filtered_worlds.is_empty() {
                                        ui.add_space(8.0);
                                        ui.label(egui::RichText::new(empty_message)
                                            .size(12.0)
                                            .color(theme.fg_muted())
                                            .family(egui::FontFamily::Monospace));
                                    } else {
                                        ScrollArea::vertical().auto_shrink([false; 2]).show(ui, |ui| {
                                            for (idx, world) in filtered_worlds.iter() {
                                                let is_current = *idx == current_world;
                                                let is_selected = *idx == selected;

                                                // Full row as a clickable area
                                                let row_rect = ui.allocate_space(egui::vec2(ui.available_width(), row_height)).1;
                                                let response = ui.interact(row_rect, ui.id().with(idx), egui::Sense::click());

                                                // Draw selection/hover background for full row
                                                if is_selected {
                                                    ui.painter().rect_filled(row_rect, egui::Rounding::same(2.0),
                                                        Color32::from_rgba_unmultiplied(34, 211, 238, 38));
                                                } else if response.hovered() {
                                                    ui.painter().rect_filled(row_rect, egui::Rounding::same(2.0), theme.bg_hover());
                                                }

                                                if response.clicked() {
                                                    selected = *idx;
                                                }

                                                // Draw row content
                                                let mut col_x = row_rect.left() + 4.0;
                                                let text_y = row_rect.center().y;

                                                // World column with status dot and current marker
                                                let status_color = if world.connected { theme.success() } else { theme.fg_dim() };
                                                let dot_rect = egui::Rect::from_center_size(
                                                    egui::pos2(col_x + 4.0, text_y),
                                                    egui::vec2(6.0, 6.0));
                                                ui.painter().circle_filled(dot_rect.center(), 3.0, status_color);
                                                col_x += 14.0;

                                                let current_marker = if is_current { "* " } else { "" };
                                                let name_color = if is_current { theme.accent() } else if is_selected { theme.fg() } else { theme.fg_secondary() };
                                                ui.painter().text(
                                                    egui::pos2(col_x, text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    format!("{}{}", current_marker, world.name),
                                                    egui::FontId::monospace(12.0),
                                                    name_color);
                                                col_x = row_rect.left() + col_widths[0];

                                                // Hostname column
                                                ui.painter().text(
                                                    egui::pos2(col_x, text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    &world.settings.hostname,
                                                    egui::FontId::monospace(12.0),
                                                    theme.fg_secondary());
                                                col_x += col_widths[1];

                                                // Port column
                                                ui.painter().text(
                                                    egui::pos2(col_x, text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    &world.settings.port,
                                                    egui::FontId::monospace(12.0),
                                                    theme.fg_secondary());
                                                col_x += col_widths[2];

                                                // User column
                                                let user_text = if world.settings.user.is_empty() { "" } else { &world.settings.user };
                                                ui.painter().text(
                                                    egui::pos2(col_x, text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    user_text,
                                                    egui::FontId::monospace(12.0),
                                                    theme.fg_secondary());
                                            }
                                        });
                                    }
                                });
                        },
                    );

                    self.world_list_selected = selected;
                    if toggle_only_connected {
                        self.only_connected_worlds = !self.only_connected_worlds;
                    }
                    if let Some(idx) = connect_world {
                        popup_action = Some(("connect", idx));
                    }
                    if let Some(idx) = edit_world {
                        popup_action = Some(("edit", idx));
                    }
                    if add_world {
                        popup_action = Some(("add", 0));
                    }
                    if should_close {
                        close_popup = true;
                    }
                }

                // World Editor popup (separate OS window)
                if let PopupState::WorldEditor(world_idx) = self.popup_state {
                    let mut should_close = false;
                    let mut should_save = false;
                    let mut should_connect = false;
                    let mut should_delete = false;

                    // Copy mutable state for viewport
                    let mut edit_name = self.edit_name.clone();
                    let mut edit_hostname = self.edit_hostname.clone();
                    let mut edit_port = self.edit_port.clone();
                    let mut edit_user = self.edit_user.clone();
                    let mut edit_password = self.edit_password.clone();
                    let mut edit_ssl = self.edit_ssl;
                    let mut edit_log_enabled = self.edit_log_enabled;
                    let mut edit_encoding = self.edit_encoding;
                    let mut edit_auto_login = self.edit_auto_login;
                    let mut edit_keep_alive_type = self.edit_keep_alive_type;
                    let mut edit_keep_alive_cmd = self.edit_keep_alive_cmd.clone();
                    let can_delete = self.worlds.len() > 1;

                    // Dynamic height based on whether keep-alive cmd is shown
                    let popup_height = if edit_keep_alive_type == KeepAliveType::Custom { 480.0 } else { 440.0 };

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("world_editor_window"),
                        egui::ViewportBuilder::default()
                            .with_title("World Editor")
                            .with_inner_size([440.0, popup_height]),
                        |ctx, _class| {
                            // Apply popup styling - remove ALL strokes everywhere
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                // All widget states: NO stroke anywhere
                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = widget_bg;
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.expansion = 0.0;
                                style.visuals.widgets.inactive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.hovered.bg_fill = widget_bg;
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.expansion = 0.0;
                                style.visuals.widgets.hovered.weak_bg_fill = widget_bg;

                                style.visuals.widgets.active.bg_fill = widget_bg;
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.expansion = 0.0;
                                style.visuals.widgets.active.weak_bg_fill = widget_bg;

                                style.visuals.widgets.open.bg_fill = widget_bg;
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.expansion = 0.0;
                                style.visuals.widgets.open.weak_bg_fill = widget_bg;

                                // Selection highlight - no stroke
                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;

                                // Text edit - no cursor stroke
                                style.visuals.extreme_bg_color = widget_bg;
                                style.visuals.text_cursor.stroke = egui::Stroke::new(1.0, theme.fg());
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons (right margin reduced to move buttons right)
                            egui::TopBottomPanel::bottom("world_editor_buttons")
                                .exact_height(48.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::new(1.0, theme.border_subtle()))
                                    .inner_margin(egui::Margin { left: 16.0, right: 1.0, top: 10.0, bottom: 10.0 }))
                                .show(ctx, |ui| {
                                    ui.horizontal(|ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Delete button (danger, left side)
                                        if can_delete {
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("Delete").size(11.0).color(theme.error()))
                                                .fill(Color32::TRANSPARENT)
                                                .stroke(egui::Stroke::new(1.0, theme.error_dim()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(70.0, 28.0))
                                            ).clicked() {
                                                should_delete = true;
                                            }
                                        }

                                        // Spacer to push remaining buttons to the right
                                        let remaining = ui.available_width() - 240.0; // 3 buttons * 70 + spacing
                                        if remaining > 0.0 {
                                            ui.add_space(remaining);
                                        }

                                        // Cancel button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Cancel").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // Connect button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Connect").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_save = true;
                                            should_connect = true;
                                        }

                                        // Save button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Save").size(11.0).color(theme.bg_deep()).strong())
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_save = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin { left: 20.0, right: 16.0, top: 20.0, bottom: 20.0 }))
                                .show(ctx, |ui| {
                                    // Header
                                    ui.label(egui::RichText::new("WORLD EDITOR")
                                        .size(10.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(16.0);

                                    // Layout dimensions
                                    let label_width = 100.0;
                                    let label_spacing = 12.0;
                                    let row_height = 28.0;
                                    // input_width will be calculated dynamically using available_width()

                                    // Helper to draw chevron (down arrow) like mockup SVG
                                    let draw_chevron = |painter: &egui::Painter, center: egui::Pos2, color: Color32| {
                                        // Chevron: two lines from top corners to bottom center
                                        // Similar to SVG path "M6 9l6 6 6-6" scaled to fit
                                        let half_width = 5.0;
                                        let half_height = 3.0;
                                        let stroke = egui::Stroke::new(1.5, color);
                                        // Left line: top-left to bottom-center
                                        painter.line_segment(
                                            [egui::pos2(center.x - half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                        // Right line: top-right to bottom-center
                                        painter.line_segment(
                                            [egui::pos2(center.x + half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                    };

                                    // Helper macro-like closure for form rows
                                    let form_row = |ui: &mut egui::Ui, label: &str, add_widget: &mut dyn FnMut(&mut egui::Ui)| {
                                        ui.horizontal(|ui| {
                                            ui.spacing_mut().item_spacing = egui::vec2(0.0, 0.0);
                                            ui.set_height(row_height);
                                            // Right-aligned label
                                            ui.allocate_ui_with_layout(
                                                egui::vec2(label_width, row_height),
                                                egui::Layout::right_to_left(egui::Align::Center),
                                                |ui| {
                                                    ui.label(egui::RichText::new(label.to_uppercase())
                                                        .size(10.0)
                                                        .color(theme.fg_muted()));
                                                }
                                            );
                                            ui.add_space(label_spacing);
                                            add_widget(ui);
                                        });
                                        ui.add_space(6.0);
                                    };

                                    // Helper to create styled text input - uses available width or fixed
                                    // NO BORDERS - just background fill
                                    let styled_text_input = |ui: &mut egui::Ui, text: &mut String, fixed_width: Option<f32>, id_salt: &str| {
                                        let width = fixed_width.unwrap_or_else(|| ui.available_width());
                                        let field_id = ui.id().with(id_salt);
                                        let field_rect = ui.allocate_space(egui::vec2(width, row_height)).1;
                                        let _response = ui.interact(field_rect, field_id, egui::Sense::click());

                                        // Draw background only - NO border
                                        ui.painter().rect_filled(field_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        // Inner text edit area (no frame, no background)
                                        let inner_rect = field_rect.shrink2(egui::vec2(8.0, 4.0));
                                        let mut child_ui = ui.new_child(egui::UiBuilder::new()
                                            .max_rect(inner_rect)
                                            .layout(egui::Layout::left_to_right(egui::Align::Center)));
                                        let text_edit = TextEdit::singleline(text)
                                            .frame(false)
                                            .desired_width(inner_rect.width())
                                            .text_color(theme.fg())
                                            .font(egui::FontId::monospace(11.0));
                                        child_ui.add(text_edit);
                                    };

                                    // Name (full width)
                                    form_row(ui, "Name", &mut |ui| {
                                        styled_text_input(ui, &mut edit_name, None, "name_input");
                                    });

                                    // Hostname (full width)
                                    form_row(ui, "Hostname", &mut |ui| {
                                        styled_text_input(ui, &mut edit_hostname, None, "hostname_input");
                                    });

                                    // Port (fixed width)
                                    form_row(ui, "Port", &mut |ui| {
                                        styled_text_input(ui, &mut edit_port, Some(80.0), "port_input");
                                    });

                                    // User (full width)
                                    form_row(ui, "User", &mut |ui| {
                                        styled_text_input(ui, &mut edit_user, None, "user_input");
                                    });

                                    // Password (full width, not masked)
                                    form_row(ui, "Password", &mut |ui| {
                                        styled_text_input(ui, &mut edit_password, None, "password_input");
                                    });

                                    // Use SSL (toggle)
                                    form_row(ui, "Use SSL", &mut |ui| {
                                        // Toggle switch style
                                        let (toggle_bg, toggle_border, knob_pos) = if edit_ssl {
                                            (theme.accent_dim(), theme.accent_dim(), 18.0)
                                        } else {
                                            (theme.bg_deep(), theme.border_medium(), 3.0)
                                        };

                                        let toggle_rect = ui.allocate_space(egui::vec2(36.0, 20.0));
                                        let response = ui.interact(toggle_rect.1, ui.id().with("ssl_toggle"), egui::Sense::click());

                                        if response.clicked() {
                                            edit_ssl = !edit_ssl;
                                        }

                                        // Draw toggle background
                                        ui.painter().rect_filled(
                                            toggle_rect.1,
                                            egui::Rounding::same(10.0),
                                            toggle_bg
                                        );
                                        ui.painter().rect_stroke(
                                            toggle_rect.1,
                                            egui::Rounding::same(10.0),
                                            egui::Stroke::new(1.0, toggle_border)
                                        );

                                        // Draw knob
                                        let knob_color = if edit_ssl { theme.bg_deep() } else { theme.fg_muted() };
                                        let knob_center = egui::pos2(
                                            toggle_rect.1.min.x + knob_pos + 7.0,
                                            toggle_rect.1.center().y
                                        );
                                        ui.painter().circle_filled(knob_center, 7.0, knob_color);
                                    });

                                    // Logging (toggle)
                                    form_row(ui, "Logging", &mut |ui| {
                                        // Toggle switch style
                                        let (toggle_bg, toggle_border, knob_pos) = if edit_log_enabled {
                                            (theme.accent_dim(), theme.accent_dim(), 18.0)
                                        } else {
                                            (theme.bg_deep(), theme.border_medium(), 3.0)
                                        };

                                        let toggle_rect = ui.allocate_space(egui::vec2(36.0, 20.0));
                                        let response = ui.interact(toggle_rect.1, ui.id().with("log_toggle"), egui::Sense::click());

                                        if response.clicked() {
                                            edit_log_enabled = !edit_log_enabled;
                                        }

                                        // Draw toggle background
                                        ui.painter().rect_filled(
                                            toggle_rect.1,
                                            egui::Rounding::same(10.0),
                                            toggle_bg
                                        );
                                        ui.painter().rect_stroke(
                                            toggle_rect.1,
                                            egui::Rounding::same(10.0),
                                            egui::Stroke::new(1.0, toggle_border)
                                        );

                                        // Draw knob
                                        let knob_color = if edit_log_enabled { theme.bg_deep() } else { theme.fg_muted() };
                                        let knob_center = egui::pos2(
                                            toggle_rect.1.min.x + knob_pos + 7.0,
                                            toggle_rect.1.center().y
                                        );
                                        ui.painter().circle_filled(knob_center, 7.0, knob_color);
                                    });

                                    // Encoding (custom styled dropdown, full width, NO border)
                                    form_row(ui, "Encoding", &mut |ui| {
                                        let dropdown_id = ui.id().with("encoding_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        // Background only - NO border
                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            edit_encoding.name(),
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(edit_encoding == Encoding::Utf8,
                                                egui::RichText::new("UTF-8").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_encoding = Encoding::Utf8;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_encoding == Encoding::Latin1,
                                                egui::RichText::new("Latin-1").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_encoding = Encoding::Latin1;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_encoding == Encoding::Fansi,
                                                egui::RichText::new("FANSI").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_encoding = Encoding::Fansi;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });

                                    // Auto Login (custom styled dropdown, full width, NO border)
                                    form_row(ui, "Auto Login", &mut |ui| {
                                        let dropdown_id = ui.id().with("auto_login_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        // Background only - NO border
                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            edit_auto_login.name(),
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(edit_auto_login == AutoConnectType::Connect,
                                                egui::RichText::new("Connect").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_auto_login = AutoConnectType::Connect;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_auto_login == AutoConnectType::Prompt,
                                                egui::RichText::new("Prompt").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_auto_login = AutoConnectType::Prompt;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_auto_login == AutoConnectType::MooPrompt,
                                                egui::RichText::new("MOO Prompt").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_auto_login = AutoConnectType::MooPrompt;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });

                                    // Keep Alive (custom styled dropdown, full width, NO border)
                                    form_row(ui, "Keep Alive", &mut |ui| {
                                        let dropdown_id = ui.id().with("keep_alive_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        // Background only - NO border
                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            edit_keep_alive_type.name(),
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(edit_keep_alive_type == KeepAliveType::Nop,
                                                egui::RichText::new("NOP").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_keep_alive_type = KeepAliveType::Nop;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_keep_alive_type == KeepAliveType::Custom,
                                                egui::RichText::new("Custom").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_keep_alive_type = KeepAliveType::Custom;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_keep_alive_type == KeepAliveType::Generic,
                                                egui::RichText::new("Generic").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_keep_alive_type = KeepAliveType::Generic;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });

                                    // Only show Keep-Alive CMD when Custom is selected (full width)
                                    if edit_keep_alive_type == KeepAliveType::Custom {
                                        form_row(ui, "Keep Alive CMD", &mut |ui| {
                                            styled_text_input(ui, &mut edit_keep_alive_cmd, None, "keep_alive_cmd_input");
                                        });
                                    }
                            });
                        },
                    );

                    // Apply changes back to self
                    self.edit_name = edit_name;
                    self.edit_hostname = edit_hostname;
                    self.edit_port = edit_port;
                    self.edit_user = edit_user;
                    self.edit_password = edit_password;
                    self.edit_ssl = edit_ssl;
                    self.edit_log_enabled = edit_log_enabled;
                    self.edit_encoding = edit_encoding;
                    self.edit_auto_login = edit_auto_login;
                    self.edit_keep_alive_type = edit_keep_alive_type;
                    self.edit_keep_alive_cmd = edit_keep_alive_cmd;

                    if should_save {
                        // Update local world settings and send to server
                        if let Some(world) = self.worlds.get_mut(world_idx) {
                            world.name = self.edit_name.clone();
                            world.settings.hostname = self.edit_hostname.clone();
                            world.settings.port = self.edit_port.clone();
                            world.settings.user = self.edit_user.clone();
                            world.settings.password = self.edit_password.clone();
                            world.settings.use_ssl = self.edit_ssl;
                            world.settings.log_enabled = self.edit_log_enabled;
                            world.settings.encoding = self.edit_encoding.name().to_string();
                            world.settings.auto_login = self.edit_auto_login.name().to_string();
                            world.settings.keep_alive_type = self.edit_keep_alive_type.name().to_string();
                            world.settings.keep_alive_cmd = self.edit_keep_alive_cmd.clone();
                        }
                        // Send update to server
                        self.update_world_settings(world_idx);
                        if should_connect {
                            popup_action = Some(("connect", world_idx));
                        }
                        close_popup = true;
                    } else if should_delete {
                        self.popup_state = PopupState::WorldConfirmDelete(world_idx);
                    } else if should_close {
                        close_popup = true;
                    }
                }

                // World delete confirmation popup (separate OS window)
                if let PopupState::WorldConfirmDelete(world_idx) = self.popup_state {
                    let world_name = self.worlds.get(world_idx)
                        .map(|w| w.name.clone())
                        .unwrap_or_default();
                    let mut should_delete = false;
                    let mut should_cancel = false;

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("world_confirm_delete_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Confirm Delete")
                            .with_inner_size([320.0, 140.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(20.0)))
                                .show(ctx, |ui| {
                                if ui.input(|i| i.key_pressed(egui::Key::Escape)) ||
                                   ui.input(|i| i.key_pressed(egui::Key::N)) ||
                                   ui.input(|i| i.viewport().close_requested()) {
                                    should_cancel = true;
                                }
                                if ui.input(|i| i.key_pressed(egui::Key::Y)) {
                                    should_delete = true;
                                }

                                // Header
                                ui.label(egui::RichText::new("CONFIRM DELETE")
                                    .size(11.0)
                                    .color(theme.fg_muted())
                                    .strong());
                                ui.add_space(16.0);

                                ui.label(egui::RichText::new(format!("Delete world '{}'?", world_name))
                                    .color(theme.fg_secondary()));
                                ui.add_space(20.0);

                                ui.horizontal(|ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // No button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("No").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_cancel = true;
                                        }

                                        // Yes button (danger)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Yes").size(11.0).color(theme.error()))
                                            .fill(Color32::TRANSPARENT)
                                            .stroke(egui::Stroke::new(1.0, theme.error_dim()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_delete = true;
                                        }
                                    });
                                });
                            });
                        },
                    );

                    if should_delete {
                        // Delete the world - send request to server
                        if world_idx < self.worlds.len() && self.worlds.len() > 1 {
                            if let Some(ref ws_tx) = self.ws_tx {
                                let msg = WsMessage::DeleteWorld { world_index: world_idx };
                                let _ = ws_tx.send(msg);
                            }
                            // Local removal will happen when server sends WorldRemoved
                        }
                        // Return to Worlds popup
                        self.popup_state = PopupState::ConnectedWorlds;
                    } else if should_cancel {
                        // Return to Worlds popup
                        self.popup_state = PopupState::ConnectedWorlds;
                    }
                }

                // Setup popup - separate OS window
                if self.popup_state == PopupState::Setup {
                    // Save original transparency when popup first opens
                    if self.original_transparency.is_none() {
                        self.original_transparency = Some(self.transparency);
                    }

                    // Copy state for editing in viewport
                    let mut more_mode = self.more_mode;
                    let mut spell_check = self.spell_check_enabled;
                    let mut world_switch = self.world_switch_mode;
                    let debug_enabled = self.debug_enabled;
                    let mut show_tags = self.show_tags;
                    let mut ansi_music = self.ansi_music_enabled;
                    let mut tls_proxy = self.tls_proxy_enabled;
                    let mut input_height = self.input_height;
                    let mut gui_theme = self.theme;
                    let mut transparency = self.transparency;
                    let mut should_close = false;
                    let mut should_save = false;
                    let mut should_cancel = false;

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("setup_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Settings")
                            .with_inner_size([420.0, 340.0]),
                        |ctx, _class| {
                            // Apply popup styling - remove all default strokes
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = widget_bg;

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = widget_bg;

                                style.visuals.widgets.open.bg_fill = widget_bg;
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = widget_bg;

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_cancel = true;
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("setup_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 17.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Cancel button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("CANCEL").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_cancel = true;
                                            should_close = true;
                                        }

                                        // Save button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("SAVE").size(11.0).color(theme.bg_deep()).strong().family(egui::FontFamily::Monospace))
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_save = true;
                                            should_close = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin { left: 20.0, right: 16.0, top: 20.0, bottom: 16.0 }))
                                .show(ctx, |ui| {
                                    // Layout dimensions (matching World Editor)
                                    let label_width = 110.0;
                                    let label_spacing = 12.0;
                                    let row_height = 28.0;

                                    // Helper to draw chevron
                                    let draw_chevron = |painter: &egui::Painter, center: egui::Pos2, color: Color32| {
                                        let half_width = 5.0;
                                        let half_height = 3.0;
                                        let stroke = egui::Stroke::new(1.5, color);
                                        painter.line_segment(
                                            [egui::pos2(center.x - half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                        painter.line_segment(
                                            [egui::pos2(center.x + half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                    };

                                    // Helper for form rows
                                    let form_row = |ui: &mut egui::Ui, label: &str, add_widget: &mut dyn FnMut(&mut egui::Ui)| {
                                        ui.horizontal(|ui| {
                                            ui.spacing_mut().item_spacing = egui::vec2(0.0, 0.0);
                                            ui.set_height(row_height);
                                            ui.allocate_ui_with_layout(
                                                egui::vec2(label_width, row_height),
                                                egui::Layout::right_to_left(egui::Align::Center),
                                                |ui| {
                                                    ui.label(egui::RichText::new(label.to_uppercase())
                                                        .size(10.0)
                                                        .color(theme.fg_muted()));
                                                }
                                            );
                                            ui.add_space(label_spacing);
                                            add_widget(ui);
                                        });
                                        ui.add_space(6.0);
                                    };

                                    // World Switching (dropdown)
                                    form_row(ui, "World Switching", &mut |ui| {
                                        let dropdown_id = ui.id().with("world_switch_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            world_switch.name(),
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(world_switch == WorldSwitchMode::UnseenFirst,
                                                egui::RichText::new("Unseen First").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                world_switch = WorldSwitchMode::UnseenFirst;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(world_switch == WorldSwitchMode::Alphabetical,
                                                egui::RichText::new("Alphabetical").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                world_switch = WorldSwitchMode::Alphabetical;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });

                                    // Theme (dropdown)
                                    form_row(ui, "Theme", &mut |ui| {
                                        let dropdown_id = ui.id().with("theme_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        let theme_name = match gui_theme {
                                            GuiTheme::Dark => "Dark",
                                            GuiTheme::Light => "Light",
                                        };
                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            theme_name,
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(gui_theme == GuiTheme::Dark,
                                                egui::RichText::new("Dark").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                gui_theme = GuiTheme::Dark;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(gui_theme == GuiTheme::Light,
                                                egui::RichText::new("Light").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                gui_theme = GuiTheme::Light;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });

                                    ui.add_space(8.0);

                                    // Input Height
                                    form_row(ui, "Input Height", &mut |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(4.0, 0.0);
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("-").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                            .fill(theme.bg_deep())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(28.0, 24.0))
                                        ).clicked() && input_height > 1 {
                                            input_height -= 1;
                                        }
                                        ui.add_space(4.0);
                                        // Number display in a styled box
                                        let num_rect = ui.allocate_space(egui::vec2(40.0, row_height)).1;
                                        ui.painter().rect_filled(num_rect, egui::Rounding::same(4.0), theme.bg_deep());
                                        ui.painter().text(
                                            num_rect.center(),
                                            egui::Align2::CENTER_CENTER,
                                            format!("{}", input_height),
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );
                                        ui.add_space(4.0);
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("+").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                            .fill(theme.bg_deep())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(28.0, 24.0))
                                        ).clicked() && input_height < 15 {
                                            input_height += 1;
                                        }
                                    });

                                    // Transparency
                                    form_row(ui, "Transparency", &mut |ui| {
                                        let slider_width = ui.available_width();
                                        let slider_height = row_height;
                                        let slider_rect = ui.allocate_space(egui::vec2(slider_width, slider_height)).1;

                                        // Draw track background
                                        let track_rect = egui::Rect::from_center_size(
                                            slider_rect.center(),
                                            egui::vec2(slider_width - 20.0, 4.0)
                                        );
                                        ui.painter().rect_filled(track_rect, egui::Rounding::same(2.0), theme.bg_deep());

                                        // Calculate knob position
                                        let knob_x = track_rect.left() + (transparency - 0.3) / 0.7 * track_rect.width();
                                        let knob_center = egui::pos2(knob_x, slider_rect.center().y);

                                        // Draw filled portion
                                        let filled_rect = egui::Rect::from_min_max(
                                            track_rect.min,
                                            egui::pos2(knob_x, track_rect.max.y)
                                        );
                                        ui.painter().rect_filled(filled_rect, egui::Rounding::same(2.0), theme.accent_dim());

                                        // Draw knob
                                        ui.painter().circle_filled(knob_center, 8.0, theme.accent());

                                        // Handle interaction
                                        let response = ui.interact(slider_rect, ui.id().with("transparency_slider"), egui::Sense::click_and_drag());
                                        if response.dragged() || response.clicked() {
                                            if let Some(pos) = response.interact_pointer_pos() {
                                                let new_value = ((pos.x - track_rect.left()) / track_rect.width() * 0.7 + 0.3)
                                                    .clamp(0.3, 1.0);
                                                transparency = new_value;
                                            }
                                        }
                                    });

                                    ui.add_space(8.0);

                                    // More Mode
                                    form_row(ui, "More Mode", &mut |ui| {
                                        let switch_width = 44.0;
                                        let switch_height = 22.0;
                                        let switch_rect = ui.allocate_space(egui::vec2(switch_width, switch_height)).1;
                                        let response = ui.interact(switch_rect, ui.id().with("more_mode_toggle"), egui::Sense::click());
                                        let track_color = if more_mode { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(switch_rect, egui::Rounding::same(11.0), track_color);
                                        let knob_x = if more_mode { switch_rect.right() - 11.0 } else { switch_rect.left() + 11.0 };
                                        let knob_color = if more_mode { theme.accent() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, switch_rect.center().y), 7.0, knob_color);
                                        if response.clicked() { more_mode = !more_mode; }
                                    });

                                    // Spell Check
                                    form_row(ui, "Spell Check", &mut |ui| {
                                        let switch_width = 44.0;
                                        let switch_height = 22.0;
                                        let switch_rect = ui.allocate_space(egui::vec2(switch_width, switch_height)).1;
                                        let response = ui.interact(switch_rect, ui.id().with("spell_check_toggle"), egui::Sense::click());
                                        let track_color = if spell_check { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(switch_rect, egui::Rounding::same(11.0), track_color);
                                        let knob_x = if spell_check { switch_rect.right() - 11.0 } else { switch_rect.left() + 11.0 };
                                        let knob_color = if spell_check { theme.accent() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, switch_rect.center().y), 7.0, knob_color);
                                        if response.clicked() { spell_check = !spell_check; }
                                    });

                                    // Show Tags
                                    form_row(ui, "Show Tags", &mut |ui| {
                                        let switch_width = 44.0;
                                        let switch_height = 22.0;
                                        let switch_rect = ui.allocate_space(egui::vec2(switch_width, switch_height)).1;
                                        let response = ui.interact(switch_rect, ui.id().with("show_tags_toggle"), egui::Sense::click());
                                        let track_color = if show_tags { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(switch_rect, egui::Rounding::same(11.0), track_color);
                                        let knob_x = if show_tags { switch_rect.right() - 11.0 } else { switch_rect.left() + 11.0 };
                                        let knob_color = if show_tags { theme.accent() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, switch_rect.center().y), 7.0, knob_color);
                                        if response.clicked() { show_tags = !show_tags; }
                                    });

                                    // ANSI Music
                                    form_row(ui, "ANSI Music", &mut |ui| {
                                        let switch_width = 44.0;
                                        let switch_height = 22.0;
                                        let switch_rect = ui.allocate_space(egui::vec2(switch_width, switch_height)).1;
                                        let response = ui.interact(switch_rect, ui.id().with("ansi_music_toggle"), egui::Sense::click());
                                        let track_color = if ansi_music { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(switch_rect, egui::Rounding::same(11.0), track_color);
                                        let knob_x = if ansi_music { switch_rect.right() - 11.0 } else { switch_rect.left() + 11.0 };
                                        let knob_color = if ansi_music { theme.accent() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, switch_rect.center().y), 7.0, knob_color);
                                        if response.clicked() { ansi_music = !ansi_music; }
                                    });

                                    // TLS Proxy
                                    form_row(ui, "TLS Proxy", &mut |ui| {
                                        let switch_width = 44.0;
                                        let switch_height = 22.0;
                                        let switch_rect = ui.allocate_space(egui::vec2(switch_width, switch_height)).1;
                                        let response = ui.interact(switch_rect, ui.id().with("tls_proxy_toggle"), egui::Sense::click());
                                        let track_color = if tls_proxy { theme.accent_dim() } else { theme.bg_deep() };
                                        ui.painter().rect_filled(switch_rect, egui::Rounding::same(11.0), track_color);
                                        let knob_x = if tls_proxy { switch_rect.right() - 11.0 } else { switch_rect.left() + 11.0 };
                                        let knob_color = if tls_proxy { theme.accent() } else { theme.fg_muted() };
                                        ui.painter().circle_filled(egui::pos2(knob_x, switch_rect.center().y), 7.0, knob_color);
                                        if response.clicked() { tls_proxy = !tls_proxy; }
                                    });
                            });
                        },
                    );

                    // Apply changes back (live preview for transparency)
                    self.more_mode = more_mode;
                    self.spell_check_enabled = spell_check;
                    self.world_switch_mode = world_switch;
                    self.debug_enabled = debug_enabled;
                    self.show_tags = show_tags;
                    self.ansi_music_enabled = ansi_music;
                    self.tls_proxy_enabled = tls_proxy;
                    self.input_height = input_height;
                    self.theme = gui_theme;
                    self.transparency = transparency;

                    if should_save {
                        self.update_global_settings();
                        self.original_transparency = None;
                    }
                    if should_cancel {
                        // Revert transparency to original value
                        if let Some(orig) = self.original_transparency.take() {
                            self.transparency = orig;
                        }
                    }
                    if should_close {
                        self.original_transparency = None;
                        close_popup = true;
                    }
                }

                // Web popup (matches console /web) - separate OS window
                if self.popup_state == PopupState::Web {
                    let mut should_close = false;
                    let mut should_save = false;

                    // Copy mutable state for viewport
                    let mut web_secure = self.web_secure;
                    let mut http_enabled = self.http_enabled;
                    let mut http_port = self.http_port;
                    let mut ws_enabled = self.ws_enabled;
                    let mut ws_port = self.ws_port;
                    let mut ws_allow_list = self.ws_allow_list.clone();

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("web_settings_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Web Settings")
                            .with_inner_size([380.0, 300.0]),
                        |ctx, _class| {
                            // Apply popup styling - remove all default strokes
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = widget_bg;

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = widget_bg;

                                style.visuals.widgets.open.bg_fill = widget_bg;
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = widget_bg;

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("web_settings_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::new(1.0, theme.border_subtle()))
                                    .inner_margin(egui::Margin { left: 16.0, right: 1.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Cancel button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Cancel").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // Save button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Save").size(11.0).color(theme.bg_deep()).strong())
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_save = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Header
                                    ui.label(egui::RichText::new("WEB SETTINGS")
                                        .size(11.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(16.0);

                                    egui::Grid::new("web_grid")
                                        .num_columns(2)
                                        .spacing([16.0, 10.0])
                                        .show(ui, |ui| {
                                            // Protocol selection
                                            ui.label(egui::RichText::new("Protocol").size(12.0).color(theme.fg_secondary()));
                                            ui.horizontal(|ui| {
                                                ui.spacing_mut().item_spacing = egui::vec2(2.0, 0.0);
                                                if ui.add(egui::Button::new(
                                                    egui::RichText::new("Secure").size(11.0)
                                                        .color(if web_secure { theme.bg_deep() } else { theme.fg_muted() }))
                                                    .fill(if web_secure { theme.accent_dim() } else { theme.bg_hover() })
                                                    .stroke(egui::Stroke::NONE)
                                                    .rounding(egui::Rounding::same(4.0))
                                                    .min_size(egui::vec2(70.0, 24.0))
                                                ).clicked() {
                                                    web_secure = true;
                                                }
                                                if ui.add(egui::Button::new(
                                                    egui::RichText::new("Non-Secure").size(11.0)
                                                        .color(if !web_secure { theme.bg_deep() } else { theme.fg_muted() }))
                                                    .fill(if !web_secure { theme.accent_dim() } else { theme.bg_hover() })
                                                    .stroke(egui::Stroke::NONE)
                                                    .rounding(egui::Rounding::same(4.0))
                                                    .min_size(egui::vec2(80.0, 24.0))
                                                ).clicked() {
                                                    web_secure = false;
                                                }
                                            });
                                            ui.end_row();

                                            // HTTP/HTTPS enabled
                                            let http_label = if web_secure { "HTTPS enabled" } else { "HTTP enabled" };
                                            ui.label(egui::RichText::new(http_label).size(12.0).color(theme.fg_secondary()));
                                            let http_text = if http_enabled { "ON" } else { "OFF" };
                                            let http_color = if http_enabled { theme.accent() } else { theme.fg_muted() };
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new(http_text).size(11.0).color(http_color))
                                                .fill(if http_enabled { theme.accent_dim() } else { theme.bg_hover() })
                                                .stroke(egui::Stroke::new(1.0, if http_enabled { theme.accent_dim() } else { theme.border_medium() }))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(50.0, 24.0))
                                            ).clicked() {
                                                http_enabled = !http_enabled;
                                            }
                                            ui.end_row();

                                            // HTTP/HTTPS port
                                            let http_port_label = if web_secure { "HTTPS port" } else { "HTTP port" };
                                            ui.label(egui::RichText::new(http_port_label).size(12.0).color(theme.fg_secondary()));
                                            let mut http_port_str = http_port.to_string();
                                            if ui.add(egui::TextEdit::singleline(&mut http_port_str)
                                                .desired_width(80.0)
                                                .margin(egui::Margin::symmetric(8.0, 6.0))).changed() {
                                                if let Ok(port) = http_port_str.parse::<u16>() {
                                                    http_port = port;
                                                }
                                            }
                                            ui.end_row();

                                            // WS/WSS enabled
                                            let ws_label = if web_secure { "WSS enabled" } else { "WS enabled" };
                                            ui.label(egui::RichText::new(ws_label).size(12.0).color(theme.fg_secondary()));
                                            let ws_text = if ws_enabled { "ON" } else { "OFF" };
                                            let ws_color = if ws_enabled { theme.accent() } else { theme.fg_muted() };
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new(ws_text).size(11.0).color(ws_color))
                                                .fill(if ws_enabled { theme.accent_dim() } else { theme.bg_hover() })
                                                .stroke(egui::Stroke::new(1.0, if ws_enabled { theme.accent_dim() } else { theme.border_medium() }))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(50.0, 24.0))
                                            ).clicked() {
                                                ws_enabled = !ws_enabled;
                                            }
                                            ui.end_row();

                                            // WS/WSS port
                                            let ws_port_label = if web_secure { "WSS port" } else { "WS port" };
                                            ui.label(egui::RichText::new(ws_port_label).size(12.0).color(theme.fg_secondary()));
                                            let mut ws_port_str = ws_port.to_string();
                                            if ui.add(egui::TextEdit::singleline(&mut ws_port_str)
                                                .desired_width(80.0)
                                                .margin(egui::Margin::symmetric(8.0, 6.0))).changed() {
                                                if let Ok(port) = ws_port_str.parse::<u16>() {
                                                    ws_port = port;
                                                }
                                            }
                                            ui.end_row();

                                            // Allow list
                                            ui.label(egui::RichText::new("Allow List").size(12.0).color(theme.fg_secondary()));
                                            ui.add(egui::TextEdit::singleline(&mut ws_allow_list)
                                                .hint_text("localhost, 192.168.*")
                                                .desired_width(180.0)
                                                .margin(egui::Margin::symmetric(8.0, 6.0)));
                                            ui.end_row();
                                        });
                            });
                        },
                    );

                    // Apply changes back to self
                    self.web_secure = web_secure;
                    self.http_enabled = http_enabled;
                    self.http_port = http_port;
                    self.ws_enabled = ws_enabled;
                    self.ws_port = ws_port;
                    self.ws_allow_list = ws_allow_list;

                    if should_save {
                        self.update_global_settings();
                        close_popup = true;
                    } else if should_close {
                        close_popup = true;
                    }
                }

                // Font popup - separate OS window
                if self.popup_state == PopupState::Font {
                    // Common monospace font families
                    const FONT_FAMILIES: &[(&str, &str)] = &[
                        ("", "System Default"),
                        ("Monospace", "Monospace"),
                        ("DejaVu Sans Mono", "DejaVu Sans Mono"),
                        ("Liberation Mono", "Liberation Mono"),
                        ("Ubuntu Mono", "Ubuntu Mono"),
                        ("Fira Code", "Fira Code"),
                        ("Source Code Pro", "Source Code Pro"),
                        ("JetBrains Mono", "JetBrains Mono"),
                        ("Hack", "Hack"),
                        ("Inconsolata", "Inconsolata"),
                        ("Courier New", "Courier New"),
                        ("Consolas", "Consolas"),
                    ];

                    let mut should_close = false;
                    let mut should_save = false;

                    // Copy mutable state for viewport
                    let mut edit_font_name = self.edit_font_name.clone();
                    let mut edit_font_size = self.edit_font_size.clone();

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("font_settings_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Font Settings")
                            .with_inner_size([380.0, 180.0]),
                        |ctx, _class| {
                            // Apply popup styling - remove all default strokes
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = widget_bg;

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = widget_bg;

                                style.visuals.widgets.open.bg_fill = widget_bg;
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = widget_bg;

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("font_settings_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::new(1.0, theme.border_subtle()))
                                    .inner_margin(egui::Margin { left: 16.0, right: 1.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Cancel button
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Cancel").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // OK button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("OK").size(11.0).color(theme.bg_deep()).strong())
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_save = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Header
                                    ui.label(egui::RichText::new("FONT SETTINGS")
                                        .size(11.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(16.0);

                                    egui::Grid::new("font_grid")
                                        .num_columns(2)
                                        .spacing([16.0, 12.0])
                                        .show(ui, |ui| {
                                            ui.label(egui::RichText::new("Font family").size(12.0).color(theme.fg_secondary()));
                                            let current_label = FONT_FAMILIES.iter()
                                                .find(|(value, _)| *value == edit_font_name)
                                                .map(|(_, label)| *label)
                                                .unwrap_or_else(|| {
                                                    if edit_font_name.is_empty() { "System Default" } else { &edit_font_name }
                                                });
                                            egui::ComboBox::from_id_salt("font_family")
                                                .selected_text(current_label)
                                                .width(180.0)
                                                .show_ui(ui, |ui| {
                                                    for (value, label) in FONT_FAMILIES {
                                                        if ui.selectable_value(&mut edit_font_name, value.to_string(), *label).clicked() {
                                                            // Selection handled by selectable_value
                                                        }
                                                    }
                                                });
                                            ui.end_row();

                                            ui.label(egui::RichText::new("Font size").size(12.0).color(theme.fg_secondary()));
                                            ui.horizontal(|ui| {
                                                ui.spacing_mut().item_spacing = egui::vec2(4.0, 0.0);
                                                if ui.add(egui::Button::new(
                                                    egui::RichText::new("-").size(11.0).color(theme.fg_secondary()))
                                                    .fill(theme.bg_hover())
                                                    .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                    .rounding(egui::Rounding::same(4.0))
                                                    .min_size(egui::vec2(28.0, 24.0))
                                                ).clicked() {
                                                    if let Ok(size) = edit_font_size.parse::<f32>() {
                                                        let new_size = (size - 1.0).max(8.0);
                                                        edit_font_size = format!("{:.1}", new_size);
                                                    }
                                                }
                                                ui.add(egui::TextEdit::singleline(&mut edit_font_size)
                                                    .desired_width(50.0)
                                                    .margin(egui::Margin::symmetric(8.0, 6.0)));
                                                if ui.add(egui::Button::new(
                                                    egui::RichText::new("+").size(11.0).color(theme.fg_secondary()))
                                                    .fill(theme.bg_hover())
                                                    .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                    .rounding(egui::Rounding::same(4.0))
                                                    .min_size(egui::vec2(28.0, 24.0))
                                                ).clicked() {
                                                    if let Ok(size) = edit_font_size.parse::<f32>() {
                                                        let new_size = (size + 1.0).min(48.0);
                                                        edit_font_size = format!("{:.1}", new_size);
                                                    }
                                                }
                                            });
                                            ui.end_row();
                                        });
                            });
                        },
                    );

                    // Apply changes back to self
                    self.edit_font_name = edit_font_name;
                    self.edit_font_size = edit_font_size;

                    if should_save {
                        // Parse and apply font settings
                        self.font_name = self.edit_font_name.clone();
                        if let Ok(size) = self.edit_font_size.parse::<f32>() {
                            self.font_size = size.clamp(8.0, 48.0);
                        }
                        // Send updated settings to server
                        self.update_global_settings();
                        close_popup = true;
                    } else if should_close {
                        close_popup = true;
                    }
                }

                // Help popup - separate OS window
                if self.popup_state == PopupState::Help {
                    let mut should_close = false;
                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("help_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Help - Clay MUD Client")
                            .with_inner_size([450.0, 400.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            // Check for Escape key or window close
                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for button
                            egui::TopBottomPanel::bottom("help_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 1.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("OK").size(11.0).color(theme.bg_deep()).strong())
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Title
                                    ui.label(egui::RichText::new("CLAY MUD CLIENT")
                                        .size(11.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(12.0);

                                    egui::ScrollArea::vertical()
                                        .auto_shrink([false; 2])
                                        .show(ui, |ui| {
                                            // World Switching section
                                            ui.label(egui::RichText::new("World Switching")
                                                .size(12.0)
                                                .color(theme.accent())
                                                .strong());
                                            ui.add_space(4.0);
                                            ui.label(egui::RichText::new("  Up/Down         Cycle through active worlds")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Shift+Up/Down   Cycle through all worlds")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.add_space(12.0);

                                            // Output Navigation section
                                            ui.label(egui::RichText::new("Output Navigation")
                                                .size(12.0)
                                                .color(theme.accent())
                                                .strong());
                                            ui.add_space(4.0);
                                            ui.label(egui::RichText::new("  PageUp/Down     Scroll through output history")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Tab             Release one screenful (when paused)")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Alt+J           Jump to end, release all pending")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.add_space(12.0);

                                            // Input section
                                            ui.label(egui::RichText::new("Input")
                                                .size(12.0)
                                                .color(theme.accent())
                                                .strong());
                                            ui.add_space(4.0);
                                            ui.label(egui::RichText::new("  Enter           Send command")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Ctrl+P/N        Previous/Next command history")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Ctrl+U          Clear input line")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Ctrl+W          Delete word before cursor")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Ctrl+Q          Spell check suggestions")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.add_space(12.0);

                                            // Display section
                                            ui.label(egui::RichText::new("Display")
                                                .size(12.0)
                                                .color(theme.accent())
                                                .strong());
                                            ui.add_space(4.0);
                                            ui.label(egui::RichText::new("  F2              Toggle MUD tag display")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  F4              Open filter popup")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.add_space(12.0);

                                            // Options Menu section
                                            ui.label(egui::RichText::new("Options Menu")
                                                .size(12.0)
                                                .color(theme.accent())
                                                .strong());
                                            ui.add_space(4.0);
                                            ui.label(egui::RichText::new("  World List      View and select worlds")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  World Editor    Edit world connection settings")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Setup           Global settings")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Font            Change font family and size")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Connect         Connect to current world")
                                                .size(11.0).color(theme.fg_secondary()));
                                            ui.label(egui::RichText::new("  Disconnect      Disconnect from current world")
                                                .size(11.0).color(theme.fg_secondary()));
                                        });
                                });
                        },
                    );
                    if should_close {
                        close_popup = true;
                    }
                }

                // Menu popup - separate OS window
                if self.popup_state == PopupState::Menu {
                    let mut should_close = false;
                    let mut selected_command: Option<String> = None;
                    let menu_items = [
                        ("Help", "/help"),
                        ("Setup", "/setup"),
                        ("Web Settings", "/web"),
                        ("Actions", "/actions"),
                        ("World Selector", "/worlds"),
                        ("Connected Worlds", "/connections"),
                    ];

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("menu_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Menu")
                            .with_inner_size([220.0, 250.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                            });

                            // Handle keyboard
                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }
                            if ctx.input(|i| i.key_pressed(egui::Key::ArrowUp)) {
                                if self.menu_selected > 0 {
                                    self.menu_selected -= 1;
                                } else {
                                    self.menu_selected = menu_items.len() - 1;
                                }
                            }
                            if ctx.input(|i| i.key_pressed(egui::Key::ArrowDown)) {
                                if self.menu_selected < menu_items.len() - 1 {
                                    self.menu_selected += 1;
                                } else {
                                    self.menu_selected = 0;
                                }
                            }
                            if ctx.input(|i| i.key_pressed(egui::Key::Enter)) {
                                selected_command = Some(menu_items[self.menu_selected].1.to_string());
                                should_close = true;
                            }

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(12.0)))
                                .show(ctx, |ui| {
                                    ui.vertical(|ui| {
                                        for (i, (label, _cmd)) in menu_items.iter().enumerate() {
                                            let is_selected = i == self.menu_selected;
                                            let bg_color = if is_selected { theme.accent_dim() } else { Color32::TRANSPARENT };
                                            let text_color = if is_selected { theme.bg_deep() } else { theme.fg() };

                                            let response = ui.add(
                                                egui::Button::new(
                                                    egui::RichText::new(*label)
                                                        .size(12.0)
                                                        .color(text_color)
                                                        .strong()
                                                )
                                                .fill(bg_color)
                                                .stroke(egui::Stroke::NONE)
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(190.0, 28.0))
                                            );

                                            if response.clicked() {
                                                selected_command = Some(menu_items[i].1.to_string());
                                                should_close = true;
                                            }
                                        }

                                        ui.add_space(12.0);
                                        ui.label(egui::RichText::new(" select, Enter open")
                                            .size(10.0)
                                            .color(theme.fg_secondary()));
                                    });
                                });
                        },
                    );

                    if let Some(cmd) = selected_command {
                        // Execute the command
                        let parsed = super::parse_command(&cmd);
                        match parsed {
                            super::Command::Help => self.popup_state = PopupState::Help,
                            super::Command::Setup => self.popup_state = PopupState::Setup,
                            super::Command::Web => self.popup_state = PopupState::Web,
                            super::Command::Actions { .. } => {
                                self.popup_state = PopupState::ActionsList;
                                self.actions_selected = 0;
                            }
                            super::Command::WorldSelector | super::Command::WorldsList => {
                                self.popup_state = PopupState::ConnectedWorlds;
                                self.world_list_selected = self.current_world;
                            }
                            _ => close_popup = true,
                        }
                    } else if should_close {
                        close_popup = true;
                    }
                }

                // Debug Text popup - separate OS window
                if self.popup_state == PopupState::DebugText {
                    let mut should_close = false;
                    let debug_text_clone = self.debug_text.clone();

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("debug_text_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Debug - Raw ANSI Codes")
                            .with_inner_size([600.0, 250.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("debug_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 1.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Close button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Close").size(11.0).color(theme.bg_deep()).strong())
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // Copy button (secondary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("Copy").size(11.0).color(theme.fg_secondary()))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            ui.ctx().copy_text(debug_text_clone.clone());
                                        }
                                    });
                                });

                            // Central panel for content
                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Header
                                    ui.label(egui::RichText::new("RAW ANSI CODES")
                                        .size(11.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(4.0);
                                    ui.label(egui::RichText::new("ESC character shown as <esc>")
                                        .size(10.0)
                                        .color(theme.fg_muted()));
                                    ui.add_space(12.0);

                                    // Content area with background
                                    let display_text = if debug_text_clone.is_empty() {
                                        "(No text captured)".to_string()
                                    } else {
                                        debug_text_clone.clone()
                                    };

                                    egui::Frame::none()
                                        .fill(theme.bg_deep())
                                        .rounding(egui::Rounding::same(4.0))
                                        .inner_margin(egui::Margin::same(12.0))
                                        .show(ui, |ui| {
                                            egui::ScrollArea::both()
                                                .auto_shrink([false; 2])
                                                .show(ui, |ui| {
                                                    ui.add(
                                                        egui::Label::new(
                                                            egui::RichText::new(&display_text)
                                                                .monospace()
                                                                .size(11.0)
                                                                .color(theme.fg_secondary())
                                                        ).wrap()
                                                    );
                                                });
                                        });
                                });
                        },
                    );
                    if should_close {
                        close_popup = true;
                    }
                }

                // Actions List popup (separate OS window)
                if self.popup_state == PopupState::ActionsList {
                    let mut should_close = false;
                    let mut new_popup_state: Option<PopupState> = None;
                    let mut actions_selected = self.actions_selected;
                    let mut actions_list_filter = self.actions_list_filter.clone();
                    let actions_clone = self.actions.clone();

                    // State for opening editor
                    let mut open_editor_idx: Option<usize> = None;
                    let mut add_new_action = false;

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("actions_list_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Actions - Clay MUD Client")
                            .with_inner_size([500.0, 344.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("actions_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 17.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.horizontal(|ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Delete button (danger) - left aligned
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("DELETE").size(11.0).color(theme.error()).family(egui::FontFamily::Monospace))
                                            .fill(Color32::TRANSPARENT)
                                            .stroke(egui::Stroke::new(1.0, theme.error_dim()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() && !actions_clone.is_empty() {
                                            new_popup_state = Some(PopupState::ActionConfirmDelete);
                                        }

                                        // Spacer to push remaining buttons to the right
                                        ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                            ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                            // OK button (primary)
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("OK").size(11.0).color(theme.bg_deep()).strong().family(egui::FontFamily::Monospace))
                                                .fill(theme.accent_dim())
                                                .stroke(egui::Stroke::NONE)
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(70.0, 28.0))
                                            ).clicked() {
                                                should_close = true;
                                            }

                                            // Edit button (secondary)
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("EDIT").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                                .fill(theme.bg_hover())
                                                .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(70.0, 28.0))
                                            ).clicked() && !actions_clone.is_empty() {
                                                open_editor_idx = Some(actions_selected);
                                            }

                                            // Add button (secondary)
                                            if ui.add(egui::Button::new(
                                                egui::RichText::new("ADD").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                                .fill(theme.bg_hover())
                                                .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                                .rounding(egui::Rounding::same(4.0))
                                                .min_size(egui::vec2(70.0, 28.0))
                                            ).clicked() {
                                                add_new_action = true;
                                            }
                                        });
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    // Filter input
                                    let filter_rect = ui.allocate_space(egui::vec2(ui.available_width(), 28.0)).1;
                                    ui.painter().rect_filled(filter_rect, egui::Rounding::same(4.0), theme.bg_deep());
                                    let filter_inner = filter_rect.shrink2(egui::vec2(8.0, 4.0));
                                    let mut filter_ui = ui.new_child(egui::UiBuilder::new()
                                        .max_rect(filter_inner)
                                        .layout(egui::Layout::left_to_right(egui::Align::Center)));
                                    let filter_edit = TextEdit::singleline(&mut actions_list_filter)
                                        .frame(false)
                                        .hint_text(egui::RichText::new("Filter actions...").color(theme.fg_dim()))
                                        .desired_width(filter_inner.width())
                                        .text_color(theme.fg())
                                        .font(egui::FontId::monospace(12.0));
                                    filter_ui.add(filter_edit);
                                    ui.add_space(12.0);

                                    // Table header row
                                    let row_height = 24.0;
                                    let col_widths = [140.0, 100.0, 220.0]; // Name, World, Pattern
                                    let header_rect = ui.allocate_space(egui::vec2(ui.available_width(), row_height)).1;
                                    let header_y = header_rect.center().y;
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + 4.0, header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "Name",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + col_widths[0], header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "World",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());
                                    ui.painter().text(
                                        egui::pos2(header_rect.left() + col_widths[0] + col_widths[1], header_y),
                                        egui::Align2::LEFT_CENTER,
                                        "Pattern",
                                        egui::FontId::monospace(11.0),
                                        theme.fg_muted());

                                    ui.add_space(4.0);
                                    ui.add(egui::Separator::default().spacing(0.0));
                                    ui.add_space(4.0);

                                    // Build filtered list of actions
                                    let filter_lower = actions_list_filter.to_lowercase();
                                    let filtered_actions: Vec<(usize, &Action)> = actions_clone.iter()
                                        .enumerate()
                                        .filter(|(_, a)| {
                                            if filter_lower.is_empty() {
                                                true
                                            } else {
                                                a.name.to_lowercase().contains(&filter_lower) ||
                                                a.world.to_lowercase().contains(&filter_lower) ||
                                                a.pattern.to_lowercase().contains(&filter_lower)
                                            }
                                        })
                                        .collect();

                                    if filtered_actions.is_empty() {
                                        ui.add_space(8.0);
                                        let msg = if actions_clone.is_empty() { "No actions defined." } else { "No actions found." };
                                        ui.label(egui::RichText::new(msg)
                                            .size(12.0)
                                            .color(theme.fg_muted())
                                            .family(egui::FontFamily::Monospace));
                                    } else {
                                        ScrollArea::vertical().auto_shrink([false; 2]).show(ui, |ui| {
                                            for (idx, action) in filtered_actions.iter() {
                                                let is_selected = *idx == actions_selected;

                                                // Full row as a clickable area
                                                let row_rect = ui.allocate_space(egui::vec2(ui.available_width(), row_height)).1;
                                                let response = ui.interact(row_rect, ui.id().with(idx), egui::Sense::click());

                                                // Draw selection/hover background for full row
                                                if is_selected {
                                                    ui.painter().rect_filled(row_rect, egui::Rounding::same(2.0),
                                                        Color32::from_rgba_unmultiplied(34, 211, 238, 38));
                                                } else if response.hovered() {
                                                    ui.painter().rect_filled(row_rect, egui::Rounding::same(2.0), theme.bg_hover());
                                                }

                                                if response.clicked() {
                                                    actions_selected = *idx;
                                                }

                                                // Draw row content
                                                let col_x = row_rect.left() + 4.0;
                                                let text_y = row_rect.center().y;

                                                // Name column
                                                let name_color = if is_selected { theme.fg() } else { theme.fg_secondary() };
                                                ui.painter().text(
                                                    egui::pos2(col_x, text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    &action.name,
                                                    egui::FontId::monospace(12.0),
                                                    name_color);

                                                // World column
                                                let world_display = if action.world.is_empty() { "(all)" } else { &action.world };
                                                ui.painter().text(
                                                    egui::pos2(row_rect.left() + col_widths[0], text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    world_display,
                                                    egui::FontId::monospace(12.0),
                                                    theme.fg_muted());

                                                // Pattern column
                                                let pattern_display = if action.pattern.is_empty() { "(manual)" } else { &action.pattern };
                                                ui.painter().text(
                                                    egui::pos2(row_rect.left() + col_widths[0] + col_widths[1], text_y),
                                                    egui::Align2::LEFT_CENTER,
                                                    pattern_display,
                                                    egui::FontId::monospace(12.0),
                                                    theme.fg_muted());
                                            }
                                        });
                                    }
                                });
                        },
                    );

                    // Apply changes back to self
                    self.actions_selected = actions_selected;
                    self.actions_list_filter = actions_list_filter;

                    if let Some(state) = new_popup_state {
                        self.popup_state = state;
                    } else if let Some(idx) = open_editor_idx {
                        // Load selected action into editor
                        if let Some(action) = self.actions.get(idx) {
                            self.edit_action_name = action.name.clone();
                            self.edit_action_world = action.world.clone();
                            self.edit_action_match_type = action.match_type;
                            self.edit_action_pattern = action.pattern.clone();
                            self.edit_action_command = action.command.clone();
                            self.action_error = None;
                            self.popup_state = PopupState::ActionEditor(idx);
                        }
                    } else if add_new_action {
                        // Create new action and open editor
                        self.edit_action_name = String::new();
                        self.edit_action_world = String::new();
                        self.edit_action_match_type = MatchType::Regexp;
                        self.edit_action_pattern = String::new();
                        self.edit_action_command = String::new();
                        self.action_error = None;
                        self.popup_state = PopupState::ActionEditor(usize::MAX); // MAX = new action
                    } else if should_close {
                        close_popup = true;
                    }
                }

                // Actions Editor popup (separate OS window)
                if let PopupState::ActionEditor(edit_idx) = self.popup_state.clone() {
                    let title = if edit_idx == usize::MAX { "New Action - Clay MUD Client" } else { "Edit Action - Clay MUD Client" };
                    let mut should_close = false;
                    let mut should_save = false;

                    // Copy mutable state for viewport
                    let mut edit_action_name = self.edit_action_name.clone();
                    let mut edit_action_world = self.edit_action_world.clone();
                    let mut edit_action_match_type = self.edit_action_match_type;
                    let mut edit_action_pattern = self.edit_action_pattern.clone();
                    let mut edit_action_command = self.edit_action_command.clone();
                    let mut action_error = self.action_error.clone();
                    let actions_clone = self.actions.clone();

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("actions_editor_window"),
                        egui::ViewportBuilder::default()
                            .with_title(title)
                            .with_inner_size([450.0, 340.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("action_editor_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 17.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // Cancel button (secondary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("CANCEL").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // Save button (primary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("SAVE").size(11.0).color(theme.bg_deep()).strong().family(egui::FontFamily::Monospace))
                                            .fill(theme.accent_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            // Validate
                                            let name = edit_action_name.trim();
                                            if name.is_empty() {
                                                action_error = Some("Name is required".to_string());
                                            } else {
                                                // Check for duplicates (excluding current if editing)
                                                let mut duplicate = false;
                                                for (i, a) in actions_clone.iter().enumerate() {
                                                    if (edit_idx == usize::MAX || i != edit_idx) &&
                                                       a.name.eq_ignore_ascii_case(name) {
                                                        action_error = Some(format!("Action '{}' already exists", name));
                                                        duplicate = true;
                                                        break;
                                                    }
                                                }
                                                if !duplicate {
                                                    should_save = true;
                                                }
                                            }
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin { left: 20.0, right: 16.0, top: 20.0, bottom: 16.0 }))
                                .show(ctx, |ui| {
                                    // Layout dimensions (matching World Editor)
                                    let label_width = 90.0;
                                    let label_spacing = 12.0;
                                    let row_height = 28.0;

                                    // Helper to draw chevron (down arrow) like World Editor
                                    let draw_chevron = |painter: &egui::Painter, center: egui::Pos2, color: Color32| {
                                        let half_width = 5.0;
                                        let half_height = 3.0;
                                        let stroke = egui::Stroke::new(1.5, color);
                                        painter.line_segment(
                                            [egui::pos2(center.x - half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                        painter.line_segment(
                                            [egui::pos2(center.x + half_width, center.y - half_height),
                                             egui::pos2(center.x, center.y + half_height)],
                                            stroke
                                        );
                                    };

                                    // Helper for form rows with right-aligned uppercase labels
                                    let form_row = |ui: &mut egui::Ui, label: &str, add_widget: &mut dyn FnMut(&mut egui::Ui)| {
                                        ui.horizontal(|ui| {
                                            ui.spacing_mut().item_spacing = egui::vec2(0.0, 0.0);
                                            ui.set_height(row_height);
                                            // Right-aligned label
                                            ui.allocate_ui_with_layout(
                                                egui::vec2(label_width, row_height),
                                                egui::Layout::right_to_left(egui::Align::Center),
                                                |ui| {
                                                    ui.label(egui::RichText::new(label.to_uppercase())
                                                        .size(10.0)
                                                        .color(theme.fg_muted()));
                                                }
                                            );
                                            ui.add_space(label_spacing);
                                            add_widget(ui);
                                        });
                                        ui.add_space(6.0);
                                    };

                                    // Helper for styled text input (no border, just background)
                                    let styled_text_input = |ui: &mut egui::Ui, text: &mut String, hint: Option<&str>, id_salt: &str| {
                                        let width = ui.available_width();
                                        let field_rect = ui.allocate_space(egui::vec2(width, row_height)).1;
                                        ui.painter().rect_filled(field_rect, egui::Rounding::same(4.0), theme.bg_deep());
                                        let inner_rect = field_rect.shrink2(egui::vec2(8.0, 4.0));
                                        let mut child_ui = ui.new_child(egui::UiBuilder::new()
                                            .max_rect(inner_rect)
                                            .layout(egui::Layout::left_to_right(egui::Align::Center)));
                                        let mut text_edit = TextEdit::singleline(text)
                                            .frame(false)
                                            .desired_width(inner_rect.width())
                                            .text_color(theme.fg())
                                            .font(egui::FontId::monospace(11.0));
                                        if let Some(h) = hint {
                                            text_edit = text_edit.hint_text(egui::RichText::new(h).color(theme.fg_dim()));
                                        }
                                        child_ui.add(text_edit);
                                        let _ = id_salt; // Used for uniqueness if needed
                                    };

                                    // Name
                                    form_row(ui, "Name", &mut |ui| {
                                        styled_text_input(ui, &mut edit_action_name, None, "action_name");
                                    });

                                    // World
                                    form_row(ui, "World", &mut |ui| {
                                        styled_text_input(ui, &mut edit_action_world, Some("(empty = all worlds)"), "action_world");
                                    });

                                    // Match Type (custom styled dropdown, full width, NO border - exactly like World Editor)
                                    form_row(ui, "Match Type", &mut |ui| {
                                        let dropdown_id = ui.id().with("match_type_dropdown");
                                        let _is_open = ui.memory(|mem| mem.is_popup_open(dropdown_id));
                                        let dropdown_width = ui.available_width();

                                        let button_rect = ui.allocate_space(egui::vec2(dropdown_width, row_height)).1;
                                        let response = ui.interact(button_rect, dropdown_id.with("button"), egui::Sense::click());

                                        // Background only - NO border
                                        ui.painter().rect_filled(button_rect, egui::Rounding::same(4.0), theme.bg_deep());

                                        let match_type_text = match edit_action_match_type {
                                            MatchType::Regexp => "Regexp",
                                            MatchType::Wildcard => "Wildcard",
                                        };
                                        ui.painter().text(
                                            egui::pos2(button_rect.min.x + 12.0, button_rect.center().y),
                                            egui::Align2::LEFT_CENTER,
                                            match_type_text,
                                            egui::FontId::monospace(11.0),
                                            theme.fg()
                                        );

                                        draw_chevron(ui.painter(), egui::pos2(button_rect.max.x - 16.0, button_rect.center().y), theme.fg_muted());

                                        if response.clicked() {
                                            ui.memory_mut(|mem| mem.toggle_popup(dropdown_id));
                                        }

                                        egui::popup_below_widget(ui, dropdown_id, &response, egui::PopupCloseBehavior::CloseOnClickOutside, |ui| {
                                            ui.set_min_width(dropdown_width);
                                            ui.style_mut().visuals.widgets.inactive.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.hovered.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            ui.style_mut().visuals.widgets.active.fg_stroke = egui::Stroke::new(1.0, theme.fg());
                                            if ui.selectable_label(edit_action_match_type == MatchType::Regexp,
                                                egui::RichText::new("Regexp").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_action_match_type = MatchType::Regexp;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                            if ui.selectable_label(edit_action_match_type == MatchType::Wildcard,
                                                egui::RichText::new("Wildcard").size(11.0).color(theme.fg()).family(egui::FontFamily::Monospace)).clicked() {
                                                edit_action_match_type = MatchType::Wildcard;
                                                ui.memory_mut(|mem| mem.close_popup());
                                            }
                                        });
                                    });
                                    ui.add_space(6.0);

                                    // Pattern
                                    let pattern_hint = match edit_action_match_type {
                                        MatchType::Regexp => "(regex, empty = manual only)",
                                        MatchType::Wildcard => "(wildcard: * ?, empty = manual only)",
                                    };
                                    form_row(ui, "Pattern", &mut |ui| {
                                        styled_text_input(ui, &mut edit_action_pattern, Some(pattern_hint), "action_pattern");
                                    });

                                    ui.add_space(4.0);

                                    // Command label (right-aligned like other labels)
                                    ui.horizontal(|ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(0.0, 0.0);
                                        ui.allocate_ui_with_layout(
                                            egui::vec2(label_width, row_height),
                                            egui::Layout::right_to_left(egui::Align::Center),
                                            |ui| {
                                                ui.label(egui::RichText::new("COMMAND")
                                                    .size(10.0)
                                                    .color(theme.fg_muted()));
                                            }
                                        );
                                    });
                                    ui.add_space(4.0);

                                    // Command area with background (full width)
                                    let cmd_rect = ui.allocate_space(egui::vec2(ui.available_width(), 100.0)).1;
                                    ui.painter().rect_filled(cmd_rect, egui::Rounding::same(4.0), theme.bg_deep());
                                    let cmd_inner = cmd_rect.shrink2(egui::vec2(8.0, 6.0));
                                    let mut cmd_ui = ui.new_child(egui::UiBuilder::new()
                                        .max_rect(cmd_inner)
                                        .layout(egui::Layout::left_to_right(egui::Align::TOP)));
                                    cmd_ui.add(egui::TextEdit::multiline(&mut edit_action_command)
                                        .frame(false)
                                        .hint_text(egui::RichText::new("Commands (semicolon-separated)").color(theme.fg_dim()))
                                        .desired_width(cmd_inner.width())
                                        .desired_rows(3)
                                        .text_color(theme.fg())
                                        .font(egui::FontId::monospace(11.0)));

                                    // Error message
                                    if let Some(ref err) = action_error {
                                        ui.add_space(8.0);
                                        ui.label(egui::RichText::new(err)
                                            .size(11.0)
                                            .color(theme.error()));
                                    }
                                });
                        },
                    );

                    // Apply changes back to self
                    self.edit_action_name = edit_action_name;
                    self.edit_action_world = edit_action_world;
                    self.edit_action_match_type = edit_action_match_type;
                    self.edit_action_pattern = edit_action_pattern;
                    self.edit_action_command = edit_action_command;
                    self.action_error = action_error;

                    if should_save {
                        let new_action = Action {
                            name: self.edit_action_name.trim().to_string(),
                            world: self.edit_action_world.trim().to_string(),
                            match_type: self.edit_action_match_type,
                            pattern: self.edit_action_pattern.clone(),
                            command: self.edit_action_command.clone(),
                            owner: None,
                        };
                        if edit_idx == usize::MAX {
                            // New action
                            self.actions.push(new_action);
                            self.actions_selected = self.actions.len() - 1;
                        } else {
                            // Update existing
                            self.actions[edit_idx] = new_action;
                        }
                        // Send updated actions to server
                        self.update_actions();
                        self.popup_state = PopupState::ActionsList;
                    } else if should_close {
                        self.popup_state = PopupState::ActionsList;
                    }
                }

                // Action delete confirmation popup (separate OS window)
                if self.popup_state == PopupState::ActionConfirmDelete {
                    let mut should_close = false;
                    let mut should_delete = false;
                    let action_name = self.actions.get(self.actions_selected)
                        .map(|a| a.name.clone())
                        .unwrap_or_else(|| "(unknown)".to_string());

                    ctx.show_viewport_immediate(
                        egui::ViewportId::from_hash_of("action_confirm_delete_window"),
                        egui::ViewportBuilder::default()
                            .with_title("Confirm Delete - Clay MUD Client")
                            .with_inner_size([340.0, 140.0]),
                        |ctx, _class| {
                            // Apply popup styling
                            ctx.style_mut(|style| {
                                style.visuals.window_fill = theme.bg_elevated();
                                style.visuals.panel_fill = theme.bg_elevated();
                                style.visuals.window_stroke = egui::Stroke::NONE;
                                style.visuals.window_shadow = egui::epaint::Shadow::NONE;

                                let widget_bg = theme.bg_deep();
                                let widget_rounding = egui::Rounding::same(4.0);

                                style.visuals.widgets.noninteractive.bg_fill = widget_bg;
                                style.visuals.widgets.noninteractive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.noninteractive.rounding = widget_rounding;
                                style.visuals.widgets.noninteractive.weak_bg_fill = widget_bg;

                                style.visuals.widgets.inactive.bg_fill = theme.bg_hover();
                                style.visuals.widgets.inactive.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.inactive.rounding = widget_rounding;
                                style.visuals.widgets.inactive.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.hovered.bg_fill = theme.bg_hover();
                                style.visuals.widgets.hovered.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.hovered.rounding = widget_rounding;
                                style.visuals.widgets.hovered.weak_bg_fill = theme.bg_hover();

                                style.visuals.widgets.active.bg_fill = theme.accent_dim();
                                style.visuals.widgets.active.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.active.rounding = widget_rounding;
                                style.visuals.widgets.active.weak_bg_fill = theme.accent_dim();

                                style.visuals.widgets.open.bg_fill = theme.bg_hover();
                                style.visuals.widgets.open.bg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.fg_stroke = egui::Stroke::NONE;
                                style.visuals.widgets.open.rounding = widget_rounding;
                                style.visuals.widgets.open.weak_bg_fill = theme.bg_hover();

                                style.visuals.selection.bg_fill = Color32::from_rgba_unmultiplied(34, 211, 238, 38);
                                style.visuals.selection.stroke = egui::Stroke::NONE;
                                style.visuals.extreme_bg_color = widget_bg;
                            });

                            if ctx.input(|i| i.key_pressed(egui::Key::Escape)) ||
                               ctx.input(|i| i.viewport().close_requested()) {
                                should_close = true;
                            }

                            // Bottom panel for buttons
                            egui::TopBottomPanel::bottom("action_confirm_delete_buttons")
                                .exact_height(44.0)
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_surface())
                                    .stroke(egui::Stroke::NONE)
                                    .inner_margin(egui::Margin { left: 16.0, right: 17.0, top: 8.0, bottom: 8.0 }))
                                .show(ctx, |ui| {
                                    ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
                                        ui.spacing_mut().item_spacing = egui::vec2(8.0, 0.0);

                                        // No button (secondary)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("NO").size(11.0).color(theme.fg_secondary()).family(egui::FontFamily::Monospace))
                                            .fill(theme.bg_hover())
                                            .stroke(egui::Stroke::new(1.0, theme.border_medium()))
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_close = true;
                                        }

                                        // Yes button (danger)
                                        if ui.add(egui::Button::new(
                                            egui::RichText::new("YES").size(11.0).color(Color32::WHITE).strong().family(egui::FontFamily::Monospace))
                                            .fill(theme.error_dim())
                                            .stroke(egui::Stroke::NONE)
                                            .rounding(egui::Rounding::same(4.0))
                                            .min_size(egui::vec2(70.0, 28.0))
                                        ).clicked() {
                                            should_delete = true;
                                        }
                                    });
                                });

                            egui::CentralPanel::default()
                                .frame(egui::Frame::none()
                                    .fill(theme.bg_elevated())
                                    .inner_margin(egui::Margin::same(16.0)))
                                .show(ctx, |ui| {
                                    ui.label(egui::RichText::new("CONFIRM DELETE")
                                        .size(11.0)
                                        .color(theme.fg_muted())
                                        .strong());
                                    ui.add_space(16.0);

                                    ui.label(egui::RichText::new(format!("Delete action '{}'?", action_name))
                                        .size(12.0)
                                        .color(theme.fg()));
                                });
                        },
                    );

                    if should_delete {
                        if self.actions_selected < self.actions.len() {
                            self.actions.remove(self.actions_selected);
                            if self.actions_selected >= self.actions.len() && !self.actions.is_empty() {
                                self.actions_selected = self.actions.len() - 1;
                            }
                            // Send updated actions to server
                            self.update_actions();
                        }
                        self.popup_state = PopupState::ActionsList;
                    } else if should_close {
                        self.popup_state = PopupState::ActionsList;
                    }
                }

                // Handle popup actions
                if let Some((action, idx)) = popup_action {
                    match action {
                        "connect" => self.connect_world(idx),
                        "edit" => self.open_world_editor(idx),
                        "switch" => {
                            self.current_world = idx;
                            self.switch_world(idx);
                        }
                        "delete" => {
                            if self.worlds.len() > 1 && idx < self.worlds.len() {
                                self.popup_state = PopupState::WorldConfirmDelete(idx);
                            }
                        }
                        _ => {}
                    }
                }

                if close_popup {
                    self.popup_state = PopupState::None;
                }
            }
        }
    }

    /// Run the remote GUI client
    pub fn run(addr: &str, runtime: tokio::runtime::Handle) -> io::Result<()> {
        let options = eframe::NativeOptions {
            viewport: egui::ViewportBuilder::default()
                .with_inner_size([800.0, 600.0])
                .with_title("Clay Mud Client")
                .with_transparent(true),
            ..Default::default()
        };

        let addr_string = addr.to_string();

        eframe::run_native(
            "Clay Mud Client",
            options,
            Box::new(move |cc| {
                // Install image loaders for Discord emoji support
                egui_extras::install_image_loaders(&cc.egui_ctx);
                Ok(Box::new(RemoteGuiApp::new(addr_string, runtime)) as Box<dyn eframe::App>)
            }),
        ).map_err(|e| io::Error::other(format!("eframe error: {}", e)))
    }
}

#[cfg(feature = "remote-gui")]
fn run_remote_gui(addr: &str) -> io::Result<()> {
    let runtime = tokio::runtime::Handle::current();
    remote_gui::run(addr, runtime)
}

/// Run in multiuser server mode - web interface only, no console
async fn run_multiuser_server() -> io::Result<()> {
    let mut app = App::new();
    app.multiuser_mode = true;

    // Load multiuser settings from separate file
    let settings_path = get_multiuser_settings_path();
    if !settings_path.exists() {
        println!("Multiuser settings file not found: {}", settings_path.display());
        print!("Would you like to create a sample configuration? (y/n): ");
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;

        if input.trim().eq_ignore_ascii_case("y") || input.trim().eq_ignore_ascii_case("yes") {
            // Create sample multiuser configuration
            let sample_config = r#"[global]
ws_enabled=true
ws_port=9002
http_enabled=true
http_port=9000

[user:star]
password=xyzzy

[world:ascii:star]
world_type=mud
hostname=teenymush.dynu.net
port=4096
use_ssl=false
encoding=utf8
auto_connect_type=Connect
keep_alive_type=Generic
"#;
            std::fs::write(&settings_path, sample_config)?;
            println!("Created sample configuration at: {}", settings_path.display());
            println!("Default user: star, password: xyzzy");
            println!("IMPORTANT: Change the user password before production use!");
            println!();
        } else {
            println!("Multiuser mode requires a configuration file.");
            println!("Create {} with [user:NAME] and [world:NAME:OWNER] sections.", settings_path.display());
            return Ok(());
        }
    }

    if let Err(e) = load_multiuser_settings(&mut app) {
        eprintln!("Error loading multiuser settings: {}", e);
        return Ok(());
    }

    // Validate: must have at least one user
    if app.users.is_empty() {
        eprintln!("Error: No users defined in multiuser settings.");
        eprintln!("Add [user:NAME] sections to {}", settings_path.display());
        return Ok(());
    }

    // Validate: all worlds must have owners
    for world in &app.worlds {
        if world.owner.is_none() {
            eprintln!("Error: World '{}' has no owner.", world.name);
            eprintln!("Use [world:{}:OWNERNAME] format in settings file.", world.name);
            return Ok(());
        }
    }

    // Validate: all actions must have owners
    for action in &app.settings.actions {
        if action.owner.is_none() {
            eprintln!("Error: Action '{}' has no owner.", action.name);
            eprintln!("Use [action:{}:OWNERNAME] format in settings file.", action.name);
            return Ok(());
        }
    }

    println!("Starting multiuser server...");
    println!("Users: {}", app.users.iter().map(|u| u.name.as_str()).collect::<Vec<_>>().join(", "));
    println!("Worlds: {}", app.worlds.iter().map(|w| format!("{} ({})", w.name, w.owner.as_ref().unwrap())).collect::<Vec<_>>().join(", "));

    let (event_tx, mut event_rx) = mpsc::channel::<AppEvent>(100);

    // Start WebSocket server (required for multiuser mode)
    if !app.settings.ws_enabled {
        eprintln!("Warning: WebSocket server not enabled. Enabling for multiuser mode.");
        app.settings.ws_enabled = true;
    }

    // Start the WebSocket server
    let mut server = WebSocketServer::new(
        &app.settings.websocket_password,
        app.settings.ws_port,
        &app.settings.websocket_allow_list,
        app.settings.websocket_whitelisted_host.clone(),
        app.multiuser_mode,
        app.ban_list.clone(),
    );

    // Configure TLS if secure mode and cert/key files are specified
    #[cfg(feature = "native-tls-backend")]
    let tls_configured = if app.settings.web_secure
        && !app.settings.websocket_cert_file.is_empty()
        && !app.settings.websocket_key_file.is_empty()
    {
        match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
            Ok(()) => true,
            Err(e) => {
                eprintln!("Warning: Failed to configure WSS TLS: {}", e);
                false
            }
        }
    } else {
        false
    };
    #[cfg(feature = "rustls-backend")]
    let tls_configured = if app.settings.web_secure
        && !app.settings.websocket_cert_file.is_empty()
        && !app.settings.websocket_key_file.is_empty()
    {
        match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
            Ok(()) => true,
            Err(e) => {
                eprintln!("Warning: Failed to configure WSS TLS: {}", e);
                false
            }
        }
    } else {
        false
    };

    // Add user credentials to the WebSocket server for multiuser authentication
    for user in &app.users {
        server.add_user(&user.name, &user.password);
    }

    if let Err(e) = start_websocket_server(&mut server, event_tx.clone()).await {
        eprintln!("Failed to start WebSocket server: {}", e);
        return Ok(());
    }
    let protocol = if tls_configured { "wss" } else { "ws" };
    println!("WebSocket server started on port {} ({})", app.settings.ws_port, protocol);
    app.ws_server = Some(server);

    // Start HTTP server if enabled
    if app.settings.http_enabled {
        let mut http_server = HttpServer::new(app.settings.http_port);
        match start_http_server(&mut http_server, app.settings.ws_port, false, app.ban_list.clone()).await {
            Ok(()) => {
                println!("HTTP server started on port {}", app.settings.http_port);
                app.http_server = Some(http_server);
            }
            Err(e) => {
                eprintln!("Warning: Failed to start HTTP server: {}", e);
            }
        }
    }

    println!("Multiuser server running. Press Ctrl+C to stop.");

    // Main event loop - only handles WebSocket events
    loop {
        tokio::select! {
            Some(event) = event_rx.recv() => {
                match event {
                    AppEvent::WsClientMessage(client_id, msg) => {
                        handle_multiuser_ws_message(&mut app, client_id, *msg, &event_tx).await;
                    }
                    // Legacy events - not used in multiuser mode (we use Multiuser* variants)
                    AppEvent::ServerData(_, _) => {}
                    AppEvent::Disconnected(_) => {}
                    AppEvent::ConnectWorldRequest(world_index, requesting_username) => {
                        // Connect a world on behalf of a user (per-user isolated connection)
                        let key = (world_index, requesting_username.clone());
                        let already_connected = app.user_connections.get(&key).map(|c| c.connected).unwrap_or(false);

                        if world_index < app.worlds.len() && !already_connected {
                            let settings = app.worlds[world_index].settings.clone();
                            let world_name = app.worlds[world_index].name.clone();

                            // Create per-user connection
                            if let Some(cmd_tx) = connect_multiuser_world(
                                world_index,
                                requesting_username.clone(),
                                &settings,
                                event_tx.clone(),
                            ).await {
                                // Store connection in user_connections
                                let mut conn = UserConnection::new();
                                conn.connected = true;
                                conn.command_tx = Some(cmd_tx);
                                conn.last_send_time = Some(std::time::Instant::now());
                                conn.last_receive_time = Some(std::time::Instant::now());
                                app.user_connections.insert(key, conn);

                                // Send WorldConnected only to this user
                                if let Some(ws) = &app.ws_server {
                                    ws.broadcast_to_owner(
                                        WsMessage::WorldConnected { world_index, name: world_name },
                                        Some(&requesting_username)
                                    );
                                }
                            } else {
                                // Connection failed - send error to user
                                if let Some(ws) = &app.ws_server {
                                    ws.broadcast_to_owner(WsMessage::ServerData {
                                        world_index,
                                        data: format!("\x1b[31m%% Connection failed.\x1b[0m\n"),
                                        is_viewed: true,
                                        ts: current_timestamp_secs(),
                                    }, Some(&requesting_username));
                                }
                            }
                        }
                    }
                    AppEvent::MultiuserServerData(world_index, username, data) => {
                        // Route server data to specific user's connection
                        let key = (world_index, username.clone());
                        if let Some(conn) = app.user_connections.get_mut(&key) {
                            let encoding = if world_index < app.worlds.len() {
                                app.worlds[world_index].settings.encoding
                            } else {
                                Encoding::Utf8
                            };
                            let decoded = encoding.decode(&data);

                            // Add to user's output buffer
                            for line in decoded.lines() {
                                conn.output_lines.push(OutputLine::new(line.to_string()));
                            }

                            // Send to this user's WebSocket clients only
                            if let Some(ws) = &app.ws_server {
                                ws.broadcast_to_owner(WsMessage::ServerData {
                                    world_index,
                                    data: decoded,
                                    is_viewed: true,
                                    ts: current_timestamp_secs(),
                                }, Some(&username));
                            }
                        }
                    }
                    AppEvent::MultiuserDisconnected(world_index, username) => {
                        // Handle disconnect for specific user's connection
                        let key = (world_index, username.clone());
                        if let Some(conn) = app.user_connections.get_mut(&key) {
                            conn.connected = false;
                            conn.command_tx = None;

                            // Send disconnect to this user only
                            if let Some(ws) = &app.ws_server {
                                ws.broadcast_to_owner(
                                    WsMessage::WorldDisconnected { world_index },
                                    Some(&username)
                                );
                            }
                        }
                    }
                    AppEvent::MultiuserTelnetDetected(world_index, username) => {
                        let key = (world_index, username.clone());
                        if let Some(conn) = app.user_connections.get_mut(&key) {
                            conn.telnet_mode = true;
                        }
                    }
                    AppEvent::MultiuserPrompt(world_index, username, prompt_bytes) => {
                        let key = (world_index, username.clone());
                        if let Some(conn) = app.user_connections.get_mut(&key) {
                            let encoding = if world_index < app.worlds.len() {
                                app.worlds[world_index].settings.encoding
                            } else {
                                Encoding::Utf8
                            };
                            let prompt_text = encoding.decode(&prompt_bytes);
                            conn.prompt = prompt_text.trim_end().to_string() + " ";

                            // Send prompt update to this user
                            if let Some(ws) = &app.ws_server {
                                ws.broadcast_to_owner(WsMessage::PromptUpdate {
                                    world_index,
                                    prompt: conn.prompt.clone(),
                                }, Some(&username));
                            }
                        }
                    }
                    _ => {} // Ignore other events in multiuser mode
                }
            }
            _ = tokio::signal::ctrl_c() => {
                println!("\nShutting down multiuser server...");
                break;
            }
        }
    }

    Ok(())
}

/// Connect to a world for a specific user in multiuser mode
/// Returns the command sender if successful
async fn connect_multiuser_world(
    world_index: usize,
    username: String,
    settings: &WorldSettings,
    event_tx: mpsc::Sender<AppEvent>,
) -> Option<mpsc::Sender<WriteCommand>> {
    use tokio::net::TcpStream;
    use tokio::io::AsyncReadExt;
    use bytes::BytesMut;

    let host = &settings.hostname;
    let port = &settings.port;
    let use_ssl = settings.use_ssl;

    if host.is_empty() || port.is_empty() {
        return None;
    }

    match TcpStream::connect(format!("{}:{}", host, port)).await {
        Ok(tcp_stream) => {
            let _ = tcp_stream.set_nodelay(true);

            // Handle SSL if needed
            let (mut read_half, mut write_half): (StreamReader, StreamWriter) = if use_ssl {
                #[cfg(feature = "native-tls-backend")]
                {
                    let connector = match native_tls::TlsConnector::builder()
                        .danger_accept_invalid_certs(true)
                        .build()
                    {
                        Ok(c) => c,
                        Err(_) => return None,
                    };
                    let connector = tokio_native_tls::TlsConnector::from(connector);

                    match connector.connect(host, tcp_stream).await {
                        Ok(tls_stream) => {
                            let (r, w) = tokio::io::split(tls_stream);
                            (StreamReader::Tls(r), StreamWriter::Tls(w))
                        }
                        Err(_) => return None,
                    }
                }

                #[cfg(feature = "rustls-backend")]
                {
                    use std::sync::Arc;
                    use rustls::RootCertStore;
                    use tokio_rustls::TlsConnector;
                    use rustls::pki_types::ServerName;

                    let mut root_store = RootCertStore::empty();
                    root_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());

                    let config = rustls::ClientConfig::builder()
                        .dangerous()
                        .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
                        .with_no_client_auth();

                    let connector = TlsConnector::from(Arc::new(config));
                    let server_name = match ServerName::try_from(host.clone()) {
                        Ok(sn) => sn,
                        Err(_) => return None,
                    };

                    match connector.connect(server_name, tcp_stream).await {
                        Ok(tls_stream) => {
                            let (r, w) = tokio::io::split(tls_stream);
                            (StreamReader::Tls(r), StreamWriter::Tls(w))
                        }
                        Err(_) => return None,
                    }
                }

                #[cfg(not(any(feature = "native-tls-backend", feature = "rustls-backend")))]
                {
                    return None;
                }
            } else {
                let (r, w) = tcp_stream.into_split();
                (StreamReader::Plain(r), StreamWriter::Plain(w))
            };

            let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);

            // Send auto-login if configured
            let user = settings.user.clone();
            let password = settings.password.clone();
            let auto_connect_type = settings.auto_connect_type;
            if !user.is_empty() && auto_connect_type == AutoConnectType::Connect {
                let tx = cmd_tx.clone();
                tokio::spawn(async move {
                    tokio::time::sleep(Duration::from_millis(500)).await;
                    let connect_cmd = format!("connect {} {}", user, password);
                    let _ = tx.send(WriteCommand::Text(connect_cmd)).await;
                });
            }

            // Clone for reader task
            let telnet_tx = cmd_tx.clone();
            let event_tx_read = event_tx.clone();
            let username_read = username.clone();

            // Spawn reader task
            tokio::spawn(async move {
                let mut buffer = BytesMut::with_capacity(4096);
                buffer.resize(4096, 0);
                let mut line_buffer: Vec<u8> = Vec::new();

                loop {
                    match read_half.read(&mut buffer).await {
                        Ok(0) => {
                            // Connection closed
                            if !line_buffer.is_empty() {
                                let (cleaned, responses, detected, prompt, _wont_echo) = process_telnet(&line_buffer);
                                if !responses.is_empty() {
                                    let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                }
                                if detected {
                                    let _ = event_tx_read.send(AppEvent::MultiuserTelnetDetected(world_index, username_read.clone())).await;
                                }
                                if let Some(prompt_bytes) = prompt {
                                    let _ = event_tx_read.send(AppEvent::MultiuserPrompt(world_index, username_read.clone(), prompt_bytes)).await;
                                }
                                if !cleaned.is_empty() {
                                    let _ = event_tx_read.send(AppEvent::MultiuserServerData(world_index, username_read.clone(), cleaned)).await;
                                }
                            }
                            let _ = event_tx_read.send(AppEvent::MultiuserServerData(
                                world_index,
                                username_read.clone(),
                                "Connection closed by server.".as_bytes().to_vec(),
                            )).await;
                            let _ = event_tx_read.send(AppEvent::MultiuserDisconnected(world_index, username_read.clone())).await;
                            break;
                        }
                        Ok(n) => {
                            line_buffer.extend_from_slice(&buffer[..n]);
                            let split_at = find_safe_split_point(&line_buffer);
                            let to_send = if split_at > 0 {
                                line_buffer.drain(..split_at).collect()
                            } else if !line_buffer.is_empty() {
                                std::mem::take(&mut line_buffer)
                            } else {
                                Vec::new()
                            };

                            if !to_send.is_empty() {
                                let (cleaned, responses, detected, prompt, _wont_echo) = process_telnet(&to_send);
                                if !responses.is_empty() {
                                    let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                }
                                if detected {
                                    let _ = event_tx_read.send(AppEvent::MultiuserTelnetDetected(world_index, username_read.clone())).await;
                                }
                                if let Some(prompt_bytes) = prompt {
                                    let _ = event_tx_read.send(AppEvent::MultiuserPrompt(world_index, username_read.clone(), prompt_bytes)).await;
                                }
                                if !cleaned.is_empty() {
                                    let _ = event_tx_read.send(AppEvent::MultiuserServerData(world_index, username_read.clone(), cleaned)).await;
                                }
                            }
                        }
                        Err(e) => {
                            let msg = format!("Read error: {}", e);
                            let _ = event_tx_read.send(AppEvent::MultiuserServerData(world_index, username_read.clone(), msg.into_bytes())).await;
                            let _ = event_tx_read.send(AppEvent::MultiuserDisconnected(world_index, username_read.clone())).await;
                            break;
                        }
                    }
                }
            });

            // Spawn writer task
            tokio::spawn(async move {
                use tokio::io::AsyncWriteExt;
                while let Some(cmd) = cmd_rx.recv().await {
                    match cmd {
                        WriteCommand::Text(text) => {
                            let bytes = format!("{}\r\n", text).into_bytes();
                            if write_half.write_all(&bytes).await.is_err() {
                                break;
                            }
                            let _ = write_half.flush().await;
                        }
                        WriteCommand::Raw(raw) => {
                            if write_half.write_all(&raw).await.is_err() {
                                break;
                            }
                            let _ = write_half.flush().await;
                        }
                        WriteCommand::Shutdown => {
                            // Gracefully shutdown the connection
                            let _ = write_half.shutdown().await;
                            break;
                        }
                    }
                }
            });

            Some(cmd_tx)
        }
        Err(_) => None,
    }
}

/// Build initial state message for a specific user (multiuser mode)
/// World definitions are shared, but connection state is per-user
/// Actions are still filtered per-user
fn build_multiuser_initial_state(app: &App, username: &str) -> WsMessage {
    // Show all worlds with per-user connection state
    let worlds: Vec<WorldStateMsg> = app.worlds.iter().enumerate()
        .map(|(idx, world)| {
            // Get user's connection state for this world (if any)
            let key = (idx, username.to_string());
            let user_conn = app.user_connections.get(&key);

            // Use user's connection state or empty defaults
            let (connected, output_lines, pending_lines, prompt, scroll_offset, paused, unseen_lines, last_send, last_recv) =
                if let Some(conn) = user_conn {
                    (
                        conn.connected,
                        &conn.output_lines,
                        &conn.pending_lines,
                        conn.prompt.clone(),
                        conn.scroll_offset,
                        conn.paused,
                        conn.unseen_lines,
                        conn.last_send_time,
                        conn.last_receive_time,
                    )
                } else {
                    (false, &vec![] as &Vec<OutputLine>, &vec![] as &Vec<OutputLine>, String::new(), 0, false, 0, None, None)
                };

            let clean_output: Vec<String> = output_lines.iter()
                .map(|s| s.text.replace('\r', ""))
                .collect();
            let clean_pending: Vec<String> = pending_lines.iter()
                .map(|s| s.text.replace('\r', ""))
                .collect();
            let output_lines_ts: Vec<TimestampedLine> = output_lines.iter()
                .map(|s| {
                    let text = s.text.replace('\r', "");
                    let text = if !s.from_server {
                        format!("\x1b[31m%% {}\x1b[0m", text)
                    } else {
                        text
                    };
                    TimestampedLine {
                        text,
                        ts: s.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                    }
                })
                .collect();
            let pending_lines_ts: Vec<TimestampedLine> = pending_lines.iter()
                .map(|s| {
                    let text = s.text.replace('\r', "");
                    let text = if !s.from_server {
                        format!("\x1b[31m%% {}\x1b[0m", text)
                    } else {
                        text
                    };
                    TimestampedLine {
                        text,
                        ts: s.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                    }
                })
                .collect();

            WorldStateMsg {
                index: idx,
                name: world.name.clone(),
                connected,
                output_lines: clean_output,
                pending_lines: clean_pending,
                output_lines_ts,
                pending_lines_ts,
                prompt: prompt.replace('\r', ""),
                scroll_offset,
                paused,
                unseen_lines,
                settings: WorldSettingsMsg {
                    hostname: world.settings.hostname.clone(),
                    port: world.settings.port.clone(),
                    user: world.settings.user.clone(),
                    password: world.settings.password.clone(),
                    use_ssl: world.settings.use_ssl,
                    log_enabled: world.settings.log_enabled,
                    encoding: world.settings.encoding.name().to_string(),
                    auto_connect_type: world.settings.auto_connect_type.name().to_string(),
                    keep_alive_type: world.settings.keep_alive_type.name().to_string(),
                    keep_alive_cmd: world.settings.keep_alive_cmd.clone(),
                },
                last_send_secs: last_send.map(|t| t.elapsed().as_secs()),
                last_recv_secs: last_recv.map(|t| t.elapsed().as_secs()),
                last_nop_secs: None,
                keep_alive_type: world.settings.keep_alive_type.name().to_string(),
            }
        }).collect();

    // Filter actions owned by this user
    let actions: Vec<Action> = app.settings.actions.iter()
        .filter(|a| a.owner.as_deref() == Some(username))
        .cloned()
        .collect();

    // Build settings (same for all users for now)
    let settings = GlobalSettingsMsg {
        more_mode_enabled: app.settings.more_mode_enabled,
        spell_check_enabled: app.settings.spell_check_enabled,
        world_switch_mode: app.settings.world_switch_mode.name().to_string(),
        debug_enabled: app.settings.debug_enabled,
        show_tags: app.show_tags,
        ansi_music_enabled: app.settings.ansi_music_enabled,
        console_theme: app.settings.theme.name().to_string(),
        gui_theme: app.settings.gui_theme.name().to_string(),
        gui_transparency: app.settings.gui_transparency,
        input_height: app.input_height,
        font_name: app.settings.font_name.clone(),
        font_size: app.settings.font_size,
        ws_allow_list: app.settings.websocket_allow_list.clone(),
        web_secure: app.settings.web_secure,
        http_enabled: app.settings.http_enabled,
        http_port: app.settings.http_port,
        ws_enabled: app.settings.ws_enabled,
        ws_port: app.settings.ws_port,
        ws_cert_file: app.settings.websocket_cert_file.clone(),
        ws_key_file: app.settings.websocket_key_file.clone(),
        tls_proxy_enabled: app.settings.tls_proxy_enabled,
    };

    // Find current world index for this user
    // Use the first world they have a connection to, or 9999 if none (no world selected)
    let current_world_index = app.user_connections.keys()
        .filter(|(_, u)| u == username)
        .map(|(idx, _)| *idx)
        .min()
        .unwrap_or(9999);

    // Generate splash lines for multiuser mode
    let splash_lines = generate_splash_strings();

    WsMessage::InitialState {
        worlds,
        settings,
        current_world_index,
        actions,
        splash_lines,
    }
}

/// Generate splash screen content as strings (for web client)
fn generate_splash_strings() -> Vec<String> {
    vec![
        "".to_string(),
        "\x1b[38;5;180m          (\\/\\__o     \x1b[38;5;209m           \x1b[0m".to_string(),
        "\x1b[38;5;180m  __      `-/ `_/     \x1b[38;5;208m      \x1b[0m".to_string(),
        "\x1b[38;5;180m `--\\______/  |       \x1b[38;5;215m            \x1b[0m".to_string(),
        "\x1b[38;5;180m    /        /        \x1b[38;5;216m              \x1b[0m".to_string(),
        "\x1b[38;5;180m -`/_------'\\_.       \x1b[38;5;217m        \x1b[0m".to_string(),
        "\x1b[38;5;218m                               \x1b[0m".to_string(),
        "".to_string(),
        "\x1b[38;5;213m A 90dies mud client written today \x1b[0m".to_string(),
        "".to_string(),
        "\x1b[38;5;244mSelect a world to connect\x1b[0m".to_string(),
        "".to_string(),
    ]
}

/// Handle WebSocket message in multiuser mode
async fn handle_multiuser_ws_message(
    app: &mut App,
    client_id: u64,
    msg: WsMessage,
    event_tx: &mpsc::Sender<AppEvent>,
) {
    // Get the username for this client
    let username = if let Some(ws) = &app.ws_server {
        ws.get_client_username(client_id)
    } else {
        None
    };

    match msg {
        WsMessage::AuthRequest { .. } => {
            // Client just authenticated - send them their InitialState filtered by username
            if let Some(ref uname) = username {
                let initial_state = build_multiuser_initial_state(app, uname);
                if let Some(ws) = &app.ws_server {
                    ws.send_to_client(client_id, initial_state);
                }
            }
        }
        WsMessage::SendCommand { world_index, command } => {
            // Send command to user's own connection
            if let Some(ref uname) = username {
                let key = (world_index, uname.clone());
                if let Some(conn) = app.user_connections.get(&key) {
                    if let Some(tx) = &conn.command_tx {
                        let _ = tx.send(WriteCommand::Text(command)).await;
                    }
                }
            }
        }
        WsMessage::ConnectWorld { world_index } => {
            // Any user can connect to any world
            if world_index < app.worlds.len() {
                if let Some(ref uname) = username {
                    let _ = event_tx.send(AppEvent::ConnectWorldRequest(world_index, uname.clone())).await;
                }
            }
        }
        WsMessage::DisconnectWorld { world_index } => {
            // Disconnect user's own connection
            if let Some(ref uname) = username {
                let key = (world_index, uname.clone());
                if let Some(conn) = app.user_connections.get_mut(&key) {
                    conn.command_tx = None;
                    conn.connected = false;
                    // Notify the user
                    if let Some(ws) = &app.ws_server {
                        ws.broadcast_to_owner(
                            WsMessage::WorldDisconnected { world_index },
                            Some(uname)
                        );
                    }
                }
            }
        }
        WsMessage::ChangePassword { old_password_hash, new_password_hash } => {
            if let Some(ref uname) = username {
                // Find the user and verify old password
                if let Some(user) = app.users.iter_mut().find(|u| &u.name == uname) {
                    let old_hash = hash_password(&user.password);
                    if old_hash == old_password_hash {
                        // Update password (store the hash, will be encrypted on save)
                        user.password = new_password_hash.clone();
                        // Save settings
                        if let Err(e) = save_multiuser_settings(app) {
                            eprintln!("Failed to save settings after password change: {}", e);
                        }
                        // Send success response
                        if let Some(ws) = &app.ws_server {
                            ws.send_to_client(client_id, WsMessage::PasswordChanged {
                                success: true,
                                error: None,
                            });
                        }
                    } else {
                        // Wrong old password
                        if let Some(ws) = &app.ws_server {
                            ws.send_to_client(client_id, WsMessage::PasswordChanged {
                                success: false,
                                error: Some("Invalid current password".to_string()),
                            });
                        }
                    }
                }
            }
        }
        WsMessage::Logout => {
            if let Some(ref uname) = username {
                // Close all connections for this user
                let keys_to_remove: Vec<_> = app.user_connections.keys()
                    .filter(|(_, u)| u == uname)
                    .cloned()
                    .collect();

                for key in &keys_to_remove {
                    // Send shutdown command to gracefully close the TCP connection
                    if let Some(conn) = app.user_connections.get(key) {
                        if let Some(tx) = &conn.command_tx {
                            let _ = tx.try_send(WriteCommand::Shutdown);
                        }
                    }
                }

                for key in keys_to_remove {
                    // Remove the connection entry
                    app.user_connections.remove(&key);
                }

                // Clear the client's authentication state
                if let Some(ws) = &app.ws_server {
                    ws.clear_client_auth(client_id);
                    // Send LoggedOut response
                    ws.send_to_client(client_id, WsMessage::LoggedOut);
                }
            }
        }
        WsMessage::RequestState => {
            // Client requests full state resync
            if let Some(ref uname) = username {
                let initial_state = build_multiuser_initial_state(app, uname);
                if let Some(ws) = &app.ws_server {
                    ws.send_to_client(client_id, initial_state);
                }
            }
        }
        WsMessage::SwitchWorld { world_index } => {
            // Verify the client owns this world
            if let Some(world) = app.worlds.get(world_index) {
                if world.owner.as_ref() == username.as_ref() {
                    // Send WorldSwitched message to the client
                    if let Some(ws) = &app.ws_server {
                        ws.send_to_client(client_id, WsMessage::WorldSwitched { new_index: world_index });
                    }
                }
            }
        }
        WsMessage::MarkWorldSeen { world_index } => {
            // Verify the client owns this world
            if let Some(world) = app.worlds.get_mut(world_index) {
                if world.owner.as_ref() == username.as_ref() {
                    world.unseen_lines = 0;
                    // Broadcast to all clients of this owner
                    if let Some(ws) = &app.ws_server {
                        ws.broadcast_to_owner(WsMessage::UnseenCleared { world_index }, world.owner.as_deref());
                    }
                }
            }
        }
        WsMessage::ReleasePending { world_index, count } => {
            // Verify the client owns this world
            if let Some(world) = app.worlds.get_mut(world_index) {
                if world.owner.as_ref() == username.as_ref() {
                    let release_count = if count == 0 { world.pending_lines.len() } else { count.min(world.pending_lines.len()) };
                    let released: Vec<OutputLine> = world.pending_lines.drain(..release_count).collect();
                    world.output_lines.extend(released);

                    if world.pending_lines.is_empty() {
                        world.paused = false;
                    }

                    // Broadcast to all clients of this owner
                    if let Some(ws) = &app.ws_server {
                        ws.broadcast_to_owner(WsMessage::PendingReleased { world_index, count: release_count }, world.owner.as_deref());
                    }
                }
            }
        }
        WsMessage::CalculateNextWorld { current_index } | WsMessage::CalculatePrevWorld { current_index } => {
            // Calculate next/prev world owned by this user
            if let Some(ref uname) = username {
                let user_worlds: Vec<usize> = app.worlds.iter().enumerate()
                    .filter(|(_, w)| w.owner.as_deref() == Some(uname))
                    .map(|(idx, _)| idx)
                    .collect();

                let current_pos = user_worlds.iter().position(|&idx| idx == current_index);
                let next_index = match msg {
                    WsMessage::CalculateNextWorld { .. } => {
                        current_pos.map(|p| user_worlds[(p + 1) % user_worlds.len()])
                    }
                    WsMessage::CalculatePrevWorld { .. } => {
                        current_pos.map(|p| {
                            if p == 0 { user_worlds[user_worlds.len() - 1] }
                            else { user_worlds[p - 1] }
                        })
                    }
                    _ => None,
                };

                if let Some(ws) = &app.ws_server {
                    ws.send_to_client(client_id, WsMessage::CalculatedWorld { index: next_index });
                }
            }
        }
        // Reject world editing in multiuser mode
        WsMessage::UpdateWorldSettings { .. } | WsMessage::DeleteWorld { .. } | WsMessage::CreateWorld { .. } => {
            // Silently reject - users can't edit worlds in multiuser mode
        }
        _ => {} // Handle other messages as needed
    }
}

#[tokio::main]
async fn main() -> io::Result<()> {
    // Check for --tls-proxy=host:port:socket_path argument for TLS proxy mode
    // This is used internally when spawning TLS proxy processes
    if let Some(proxy_arg) = std::env::args().find(|a| a.starts_with("--tls-proxy=")) {
        let params = proxy_arg.strip_prefix("--tls-proxy=").unwrap();
        let parts: Vec<&str> = params.splitn(3, ':').collect();
        if parts.len() == 3 {
            let host = parts[0];
            let port = parts[1];
            let socket_path = PathBuf::from(parts[2]);
            run_tls_proxy_async(host, port, &socket_path).await;
        }
        return Ok(());
    }

    // Check for --remote=host:port argument for GUI client mode
    if let Some(remote_arg) = std::env::args().find(|a| a.starts_with("--remote=")) {
        #[cfg(feature = "remote-gui")]
        {
            let addr = remote_arg.strip_prefix("--remote=").unwrap();
            return run_remote_gui(addr);
        }
        #[cfg(not(feature = "remote-gui"))]
        {
            eprintln!("Error: --remote requires the 'remote-gui' feature.");
            eprintln!("Rebuild with: cargo build --features remote-gui");
            eprintln!("Argument provided: {}", remote_arg);
            return Ok(());
        }
    }

    // Check for --multiuser mode
    if std::env::args().any(|a| a == "--multiuser") {
        return run_multiuser_server().await;
    }

    // Set up SIGFPE handler to print debug info before crashing
    unsafe {
        extern "C" fn sigfpe_handler(_: libc::c_int) {
            // Restore terminal before printing
            let _ = disable_raw_mode();
            let _ = execute!(std::io::stdout(), LeaveAlternateScreen);
            eprintln!("\n\n=== SIGFPE (Floating Point Exception) detected! ===");
            eprintln!("This is typically caused by division by zero.");
            eprintln!("Please report this bug with the steps to reproduce.");

            // Try to print a backtrace
            eprintln!("\nBacktrace:");
            let bt = std::backtrace::Backtrace::force_capture();
            eprintln!("{}", bt);

            std::process::exit(136);  // 128 + 8 (SIGFPE)
        }
        libc::signal(libc::SIGFPE, sigfpe_handler as libc::sighandler_t);
    }

    // Set up crash handler for automatic recovery
    setup_crash_handler();

    enable_raw_mode()?;
    let mut stdout = stdout();
    // Use explicit cursor positioning and clearing for Windows 11 compatibility
    execute!(
        stdout,
        EnterAlternateScreen,
        Clear(ClearType::All),
        cursor::MoveTo(0, 0)
    )?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    terminal.clear()?;

    let result = run_app(&mut terminal).await;

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;

    if let Err(err) = result {
        eprintln!("Error: {err}");
    }

    Ok(())
}

async fn run_app(terminal: &mut Terminal<CrosstermBackend<io::Stdout>>) -> io::Result<()> {
    let mut app = App::new();

    // Check if we're in reload mode (via --reload command line argument)
    let is_reload = std::env::args().any(|a| a == "--reload");
    app.is_reload = is_reload; // Suppress server startup messages during reload
    // Check if we're recovering from a crash (via --crash command line argument)
    let is_crash = std::env::args().any(|a| a == "--crash");

    // Initialize crash count from environment variable
    let crash_count = get_crash_count();
    CRASH_COUNT.store(crash_count, Ordering::SeqCst);

    // Collect any startup messages to display after ensuring we have a world
    let mut startup_messages: Vec<String> = Vec::new();

    // Crash recovery also loads state like reload
    let should_load_state = is_reload || is_crash;

    if should_load_state {
        // Load the reload state
        match load_reload_state(&mut app) {
            Ok(true) => {
                if is_crash {
                    startup_messages.push(format!(
                        "Crash recovery successful (attempt {}/{})",
                        crash_count, MAX_CRASH_RESTARTS
                    ));
                } else {
                    startup_messages.push("Hot reload successful!".to_string());
                }
            }
            Ok(false) => {
                startup_messages.push("Warning: No reload state found, starting fresh.".to_string());
                if let Err(e) = load_settings(&mut app) {
                    startup_messages.push(format!("Warning: Could not load settings: {}", e));
                }
            }
            Err(e) => {
                startup_messages.push(format!("Warning: Failed to load reload state: {}", e));
                if let Err(e) = load_settings(&mut app) {
                    startup_messages.push(format!("Warning: Could not load settings: {}", e));
                }
            }
        }
    } else {
        // Normal startup - load settings from file
        if let Err(e) = load_settings(&mut app) {
            startup_messages.push(format!("Warning: Could not load settings: {}", e));
        }
    }

    // Ensure we have at least one world (creates initial world only if no worlds loaded)
    app.ensure_has_world();

    // After reload, clear pending_lines and pause state on ALL worlds since these
    // are display state that doesn't carry over between sessions
    // Note: unseen_lines IS preserved to maintain activity notifications
    if should_load_state && !app.worlds.is_empty() {
        for world in &mut app.worlds {
            world.pending_lines.clear();
            world.pending_since = None;
            world.paused = false;
        }
    }

    // Now display any startup messages
    for msg in startup_messages {
        app.add_output(&msg);
    }

    let (event_tx, mut event_rx) = mpsc::channel::<AppEvent>(100);

    // If in reload or crash recovery mode, reconstruct connections from saved fds
    if should_load_state {
        // First pass: identify TLS worlds WITHOUT proxy that need to be disconnected
        // TLS worlds WITH proxy will be reconnected via Unix socket
        let mut tls_disconnect_worlds: Vec<usize> = Vec::new();
        for (world_idx, world) in app.worlds.iter().enumerate() {
            if world.connected && world.is_tls && world.proxy_pid.is_none() {
                tls_disconnect_worlds.push(world_idx);
            }
        }

        // Disconnect TLS worlds without proxy
        let tls_msg = if is_crash {
            "TLS connection was closed during crash recovery. Use /worlds to reconnect."
        } else {
            "TLS connection was closed during reload. Use /worlds to reconnect."
        };
        for world_idx in tls_disconnect_worlds {
            app.worlds[world_idx].connected = false;
            app.worlds[world_idx].command_tx = None;
            app.worlds[world_idx].socket_fd = None;
            app.worlds[world_idx].output_lines.push(OutputLine::new(tls_msg.to_string()));
        }

        // Second pass: reconstruct plain TCP connections
        for world_idx in 0..app.worlds.len() {
            let world = &app.worlds[world_idx];
            if world.connected && world.socket_fd.is_some() && !world.is_tls {
                let fd = world.socket_fd.unwrap();

                // Reconstruct TcpStream from the raw fd
                let tcp_stream = unsafe { std::net::TcpStream::from_raw_fd(fd) };
                tcp_stream.set_nonblocking(true)?;
                let tcp_stream = TcpStream::from_std(tcp_stream)?;

                let (r, w) = tcp_stream.into_split();
                let mut read_half = StreamReader::Plain(r);
                let mut write_half = StreamWriter::Plain(w);

                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                // Skip auto-login for restored connections (only fresh connects should auto-login)
                app.worlds[world_idx].skip_auto_login = true;

                // Re-open log file if enabled
                app.worlds[world_idx].open_log_file();

                // Clone tx for use in reader (for telnet responses)
                let telnet_tx = cmd_tx;

                // Capture world name for the reader task (stable across world deletions)
                let world_name = app.worlds[world_idx].name.clone();

                // Spawn reader task
                let event_tx_read = event_tx.clone();
                tokio::spawn(async move {
                    let mut buffer = BytesMut::with_capacity(10240);
                    buffer.resize(10240, 0);
                    let mut line_buffer: Vec<u8> = Vec::new();

                    loop {
                        match read_half.read(&mut buffer).await {
                            Ok(0) => {
                                // Send any remaining buffered data
                                if !line_buffer.is_empty() {
                                    let (cleaned, responses, detected, prompt, _wont_echo) = process_telnet(&line_buffer);
                                    if !responses.is_empty() {
                                        let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                    }
                                    if detected {
                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(world_name.clone())).await;
                                    }
                                    // Send prompt FIRST for immediate auto-login response
                                    if let Some(prompt_bytes) = prompt {
                                        let _ = event_tx_read.send(AppEvent::Prompt(world_name.clone(), prompt_bytes)).await;
                                    }
                                    // Send remaining data
                                    if !cleaned.is_empty() {
                                        let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), cleaned)).await;
                                    }
                                }
                                let _ = event_tx_read
                                    .send(AppEvent::ServerData(
                                        world_name.clone(),
                                        "Connection closed by server.".as_bytes().to_vec(),
                                    ))
                                    .await;
                                let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                break;
                            }
                            Ok(n) => {
                                // Append new data to line buffer
                                line_buffer.extend_from_slice(&buffer[..n]);

                                // Find safe split point (complete lines with complete ANSI sequences)
                                let split_at = find_safe_split_point(&line_buffer);

                                // Send data immediately - either up to split point, or all if no incomplete sequences
                                let to_send = if split_at > 0 {
                                    line_buffer.drain(..split_at).collect()
                                } else if !line_buffer.is_empty() {
                                    // No safe split point but we have data - send it anyway
                                    std::mem::take(&mut line_buffer)
                                } else {
                                    Vec::new()
                                };

                                if !to_send.is_empty() {
                                    // Process telnet sequences
                                    let (cleaned, responses, detected, prompt, _wont_echo) = process_telnet(&to_send);

                                    // Send telnet responses if any
                                    if !responses.is_empty() {
                                        let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                    }

                                    // Notify if telnet detected
                                    if detected {
                                        let _ = event_tx_read
                                            .send(AppEvent::TelnetDetected(world_name.clone()))
                                            .await;
                                    }

                                    // Send prompt FIRST if detected via telnet GA
                                    if let Some(prompt_bytes) = prompt {
                                        let _ = event_tx_read
                                            .send(AppEvent::Prompt(world_name.clone(), prompt_bytes))
                                            .await;
                                    }

                                    // Send cleaned data to main loop
                                    if !cleaned.is_empty()
                                        && event_tx_read
                                            .send(AppEvent::ServerData(world_name.clone(), cleaned))
                                            .await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                            }
                            Err(e) => {
                                let msg = format!("Read error: {}", e);
                                let _ = event_tx_read
                                    .send(AppEvent::ServerData(world_name.clone(), msg.into_bytes()))
                                    .await;
                                let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                break;
                            }
                        }
                    }
                });

                // Spawn writer task
                tokio::spawn(async move {
                    use tokio::io::AsyncWriteExt;
                    while let Some(cmd) = cmd_rx.recv().await {
                        match cmd {
                            WriteCommand::Text(text) => {
                                let bytes = format!("{}\r\n", text).into_bytes();
                                if write_half.write_all(&bytes).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Raw(raw) => {
                                if write_half.write_all(&raw).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Shutdown => {
                                let _ = write_half.shutdown().await;
                                break;
                            }
                        }
                    }
                });
            }
        }

        // Third pass: reconnect to TLS proxy connections
        for world_idx in 0..app.worlds.len() {
            let world = &app.worlds[world_idx];
            if world.connected && world.is_tls && world.proxy_pid.is_some() {
                let proxy_pid = world.proxy_pid.unwrap();
                let socket_path = world.proxy_socket_path.clone();

                // Check if proxy is still alive and socket exists
                if !is_process_alive(proxy_pid) || socket_path.is_none() || !socket_path.as_ref().unwrap().exists() {
                    // Proxy died, mark disconnected
                    app.worlds[world_idx].connected = false;
                    app.worlds[world_idx].proxy_pid = None;
                    app.worlds[world_idx].proxy_socket_path = None;
                    app.worlds[world_idx].output_lines.push(OutputLine::new(
                        "TLS proxy terminated during reload. Use /worlds to reconnect.".to_string()
                    ));
                    continue;
                }

                let socket_path = socket_path.unwrap();

                // Reconnect to proxy via Unix socket
                match tokio::net::UnixStream::connect(&socket_path).await {
                    Ok(unix_stream) => {
                        let (r, w) = unix_stream.into_split();
                        let mut read_half = StreamReader::Proxy(r);
                        let mut write_half = StreamWriter::Proxy(w);

                        let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                        app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                        app.worlds[world_idx].skip_auto_login = true;

                        // Re-open log file if enabled
                        app.worlds[world_idx].open_log_file();

                        let world_name = app.worlds[world_idx].name.clone();

                        // Spawn reader task (simplified since proxy handles TLS)
                        let event_tx_read = event_tx.clone();
                        tokio::spawn(async move {
                            let mut buf = [0u8; 4096];
                            loop {
                                match tokio::io::AsyncReadExt::read(&mut read_half, &mut buf).await {
                                    Ok(0) => {
                                        let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                        break;
                                    }
                                    Ok(n) => {
                                        let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), buf[..n].to_vec())).await;
                                    }
                                    Err(_) => {
                                        let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                        break;
                                    }
                                }
                            }
                        });

                        // Spawn writer task
                        tokio::spawn(async move {
                            while let Some(cmd) = cmd_rx.recv().await {
                                let bytes = match &cmd {
                                    WriteCommand::Text(text) => {
                                        let mut b = text.as_bytes().to_vec();
                                        b.extend_from_slice(b"\r\n");
                                        b
                                    }
                                    WriteCommand::Raw(raw) => raw.clone(),
                                    WriteCommand::Shutdown => break,
                                };
                                if tokio::io::AsyncWriteExt::write_all(&mut write_half, &bytes).await.is_err() {
                                    break;
                                }
                            }
                        });

                        app.worlds[world_idx].output_lines.push(OutputLine::new(
                            "TLS connection restored via proxy.".to_string()
                        ));
                    }
                    Err(e) => {
                        // Failed to reconnect
                        app.worlds[world_idx].connected = false;
                        app.worlds[world_idx].proxy_pid = None;
                        app.worlds[world_idx].proxy_socket_path = None;
                        app.worlds[world_idx].output_lines.push(OutputLine::new(
                            format!("Failed to reconnect to TLS proxy: {}. Use /worlds to reconnect.", e)
                        ));
                    }
                }
            }
        }

        // Final cleanup pass: mark any world as disconnected if it claims to be connected
        // but has no command channel (meaning the connection wasn't successfully reconstructed)
        for world in &mut app.worlds {
            if world.connected && world.command_tx.is_none() {
                world.connected = false;
                world.socket_fd = None;
                world.output_lines
                    .push(OutputLine::new("Connection was not restored during reload. Use /worlds to reconnect.".to_string()));
            }
            // Clear pending_lines for disconnected worlds - they're only meaningful for active connections
            // Note: unseen_lines is preserved so user still sees activity indicator for unread output
            if !world.connected {
                world.pending_lines.clear();
                world.pending_since = None;
                world.paused = false;
            }
        }

        // Send immediate keepalive for all reconnected worlds since we don't know how long they were idle
        for world in &mut app.worlds {
            if world.connected {
                if let Some(tx) = &world.command_tx {
                    let now = std::time::Instant::now();

                    debug_log(app.settings.debug_enabled, &format!(
                        "KEEPALIVE_RELOAD world='{}' type={:?} cmd='{}'",
                        world.name, world.settings.keep_alive_type, world.settings.keep_alive_cmd
                    ));

                    match world.settings.keep_alive_type {
                        KeepAliveType::None => {
                            // Keepalive disabled - do nothing, don't update times
                            debug_log(app.settings.debug_enabled, &format!(
                                "KEEPALIVE_RELOAD_SKIP world='{}' - keepalive disabled", world.name
                            ));
                        }
                        KeepAliveType::Nop => {
                            let nop = vec![TELNET_IAC, TELNET_NOP];
                            let _ = tx.try_send(WriteCommand::Raw(nop));
                            debug_log_keepalive(app.settings.debug_enabled, &world.name, "NOP", "NOP");
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                        KeepAliveType::Custom => {
                            let rand_num = (std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_nanos() % 1000 + 1) as u32;
                            let idler_tag = format!("###_idler_message_{}_###", rand_num);
                            let cmd = world.settings.keep_alive_cmd
                                .replace("##rand##", &idler_tag);
                            let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                            debug_log_keepalive(app.settings.debug_enabled, &world.name, "Custom", &cmd);
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                        KeepAliveType::Generic => {
                            let rand_num = (std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_nanos() % 1000 + 1) as u32;
                            let cmd = format!("help commands ###_idler_message_{}_###", rand_num);
                            let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                            debug_log_keepalive(app.settings.debug_enabled, &world.name, "Generic", &cmd);
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                    }
                }
            }
        }
    }

    // Start WebSocket server if enabled (ws:// or wss:// based on web_secure setting)
    if app.settings.ws_enabled && !app.settings.websocket_password.is_empty() {
        let mut server = WebSocketServer::new(
            &app.settings.websocket_password,
            app.settings.ws_port,
            &app.settings.websocket_allow_list,
            app.settings.websocket_whitelisted_host.clone(),
            app.multiuser_mode,
            app.ban_list.clone(),
        );

        // Configure TLS if secure mode and cert/key files are specified
        #[cfg(feature = "native-tls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => {
                    app.add_output(&format!("Warning: Failed to configure WSS TLS: {}", e));
                    false
                }
            }
        } else {
            false
        };
        #[cfg(feature = "rustls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => {
                    app.add_output(&format!("Warning: Failed to configure WSS TLS: {}", e));
                    false
                }
            }
        } else {
            false
        };

        if let Err(e) = start_websocket_server(&mut server, event_tx.clone()).await {
            // Don't show error if port is in use (likely another clay instance)
            let err_str = e.to_string();
            if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                app.add_output(&format!("Warning: Failed to start WebSocket server: {}", e));
            }
        } else {
            if !app.is_reload {
                let protocol = if tls_configured { "wss" } else { "ws" };
                app.add_output(&format!("WebSocket server started on port {} ({})", app.settings.ws_port, protocol));
            }
            app.ws_server = Some(server);
        }
    }

    // Start HTTP/HTTPS web interface server if enabled
    if app.settings.http_enabled {
        if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            // Start HTTPS server (secure mode)
            #[cfg(feature = "native-tls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true, // HTTPS uses secure WebSocket (wss://)
                ).await {
                    Ok(()) => {
                        if !app.is_reload {
                            app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                        }
                        app.https_server = Some(https_server);
                    }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                        }
                    }
                }
            }
            #[cfg(feature = "rustls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true, // HTTPS uses secure WebSocket (wss://)
                ).await {
                    Ok(()) => {
                        if !app.is_reload {
                            app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                        }
                        app.https_server = Some(https_server);
                    }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                        }
                    }
                }
            }
        } else {
            // Start HTTP server (non-secure mode)
            let mut http_server = HttpServer::new(app.settings.http_port);
            match start_http_server(
                &mut http_server,
                app.settings.ws_port,
                false, // HTTP uses non-secure WebSocket (ws://)
                app.ban_list.clone(),
            ).await {
                Ok(()) => {
                    if !app.is_reload {
                        app.add_output(&format!("HTTP web interface started on port {} (ws://localhost:{})", app.settings.http_port, app.settings.ws_port));
                    }
                    app.http_server = Some(http_server);
                }
                Err(e) => {
                    let err_str = e.to_string();
                    if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                        app.add_output(&format!("Warning: Failed to start HTTP server: {}", e));
                    }
                }
            }
        }
    }

    // Keepalive: send NOP every 5 minutes if telnet mode and idle
    const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(5 * 60);

    // Use async event stream instead of polling to reduce CPU usage
    let mut event_stream = EventStream::new();

    // Set up SIGUSR1 handler for hot reload
    let mut sigusr1 = signal(SignalKind::user_defined1())
        .expect("Failed to set up SIGUSR1 handler");

    // Initial draw
    terminal.clear()?;
    terminal.draw(|f| ui(f, &mut app))?;
    // Render output with crossterm (needed after reload when ratatui early-returns)
    render_output_crossterm(&app);

    // Create a persistent interval for periodic tasks (clock updates, keepalive checks)
    let mut keepalive_interval = tokio::time::interval(Duration::from_secs(60));
    // Skip the first tick which fires immediately
    keepalive_interval.tick().await;

    // Create interval for prompt timeout detection (150ms)
    let mut prompt_check_interval = tokio::time::interval(Duration::from_millis(150));
    prompt_check_interval.tick().await;

    // Set the app pointer for crash recovery
    // SAFETY: app lives for the duration of this function and the pointer is only used
    // in the panic hook which only runs while this function is on the stack
    set_app_ptr(&mut app as *mut App);

    // Track if we've cleared the crash count after successful user input
    let mut crash_count_cleared = false;

    loop {
        // Use tokio::select! to efficiently wait for events without busy-polling
        tokio::select! {
            // SIGUSR1 signal - trigger hot reload
            _ = sigusr1.recv() => {
                app.add_output("Received SIGUSR1, performing hot reload...");
                if handle_command("/reload", &mut app, event_tx.clone()).await {
                    return Ok(());
                }
            }
            // Terminal events (keyboard input)
            maybe_event = event_stream.next() => {
                if let Some(Ok(Event::Key(key))) = maybe_event {
                    match handle_key_event(key, &mut app) {
                        KeyAction::Quit => return Ok(()),
                        KeyAction::Redraw => {
                            // Filter output to only show server data (remove client-generated lines)
                            app.current_world_mut().filter_to_server_output();
                            terminal.clear()?;
                            app.needs_output_redraw = true;
                        }
                        KeyAction::Connect => {
                            if !app.current_world().connected
                                && handle_command("/connect", &mut app, event_tx.clone()).await
                            {
                                return Ok(());
                            }
                        }
                        KeyAction::Reload => {
                            if handle_command("/reload", &mut app, event_tx.clone()).await {
                                return Ok(());
                            }
                        }
                        KeyAction::SendCommand(cmd) => {
                            // Clear crash count after first successful user input
                            // This indicates the client is stable and running normally
                            if !crash_count_cleared {
                                clear_crash_count();
                                crash_count_cleared = true;
                            }

                            app.spell_state.reset();
                            app.suggestion_message = None;

                            if cmd.starts_with('/') {
                                if handle_command(&cmd, &mut app, event_tx.clone()).await {
                                    return Ok(());
                                }
                            } else if app.current_world().connected {
                                if let Some(tx) = &app.current_world().command_tx {
                                    if tx.send(WriteCommand::Text(cmd)).await.is_err() {
                                        app.add_output("Failed to send command");
                                    } else {
                                        let now = std::time::Instant::now();
                                        app.current_world_mut().last_send_time = Some(now);
                                        app.current_world_mut().last_user_command_time = Some(now);
                                        app.current_world_mut().prompt.clear();
                                    }
                                }
                            } else {
                                app.add_output("Not connected. Use /worlds to connect.");
                            }
                        }
                        KeyAction::UpdateWebSocket => {
                            // Check if we need to start or stop the WebSocket server
                            let ws_enabled = app.settings.ws_enabled;
                            let has_password = !app.settings.websocket_password.is_empty();
                            let is_running = app.ws_server.is_some();

                            if ws_enabled && has_password && !is_running {
                                // Start the server
                                let mut server = WebSocketServer::new(
                                    &app.settings.websocket_password,
                                    app.settings.ws_port,
                                    &app.settings.websocket_allow_list,
                                    app.settings.websocket_whitelisted_host.clone(),
                                    app.multiuser_mode,
                                    app.ban_list.clone(),
                                );

                                // Configure TLS if secure mode enabled
                                #[cfg(feature = "native-tls-backend")]
                                let tls_configured = if app.settings.web_secure
                                    && !app.settings.websocket_cert_file.is_empty()
                                    && !app.settings.websocket_key_file.is_empty()
                                {
                                    match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                                        Ok(()) => true,
                                        Err(e) => {
                                            app.add_output(&format!("Warning: Failed to configure TLS: {}", e));
                                            false
                                        }
                                    }
                                } else {
                                    false
                                };
                                #[cfg(feature = "rustls-backend")]
                                let tls_configured = if app.settings.web_secure
                                    && !app.settings.websocket_cert_file.is_empty()
                                    && !app.settings.websocket_key_file.is_empty()
                                {
                                    match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                                        Ok(()) => true,
                                        Err(e) => {
                                            app.add_output(&format!("Warning: Failed to configure TLS: {}", e));
                                            false
                                        }
                                    }
                                } else {
                                    false
                                };

                                if let Err(e) = start_websocket_server(&mut server, event_tx.clone()).await {
                                    // Don't show error if port is in use (likely another clay instance)
                                    let err_str = e.to_string();
                                    if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                                        app.add_output(&format!("Warning: Failed to start WebSocket server: {}", e));
                                    }
                                } else {
                                    let protocol = if tls_configured { "wss" } else { "ws" };
                                    app.add_output(&format!("WebSocket server started on port {} ({})", app.settings.ws_port, protocol));
                                    app.ws_server = Some(server);
                                }
                            } else if (!ws_enabled || !has_password) && is_running {
                                // Stop the server
                                if let Some(ref mut server) = app.ws_server {
                                    server.stop();
                                }
                                app.ws_server = None;
                                app.add_output("WebSocket server stopped.");
                            }

                            // Check if we need to start or stop the HTTP/HTTPS server
                            {
                                let http_enabled = app.settings.http_enabled;
                                let http_running = app.http_server.is_some();
                                let https_running = app.https_server.is_some();
                                let has_cert = !app.settings.websocket_cert_file.is_empty()
                                    && !app.settings.websocket_key_file.is_empty();
                                let web_secure = app.settings.web_secure;

                                if http_enabled && web_secure && has_cert && !https_running {
                                    // Stop HTTP if running, start HTTPS
                                    if http_running {
                                        app.http_server = None;
                                    }
                                    #[cfg(feature = "native-tls-backend")]
                                    {
                                        let mut https_server = HttpsServer::new(app.settings.http_port);
                                        match start_https_server(
                                            &mut https_server,
                                            &app.settings.websocket_cert_file,
                                            &app.settings.websocket_key_file,
                                            app.settings.ws_port,
                                            true,
                                        ).await {
                                            Ok(()) => {
                                                app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                                                app.https_server = Some(https_server);
                                            }
                                            Err(e) => {
                                                app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                                            }
                                        }
                                    }
                                    #[cfg(feature = "rustls-backend")]
                                    {
                                        let mut https_server = HttpsServer::new(app.settings.http_port);
                                        match start_https_server(
                                            &mut https_server,
                                            &app.settings.websocket_cert_file,
                                            &app.settings.websocket_key_file,
                                            app.settings.ws_port,
                                            true,
                                        ).await {
                                            Ok(()) => {
                                                app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                                                app.https_server = Some(https_server);
                                            }
                                            Err(e) => {
                                                app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                                            }
                                        }
                                    }
                                } else if http_enabled && !web_secure && !http_running {
                                    // Stop HTTPS if running, start HTTP
                                    if https_running {
                                        app.https_server = None;
                                    }
                                    let mut http_server = HttpServer::new(app.settings.http_port);
                                    match start_http_server(
                                        &mut http_server,
                                        app.settings.ws_port,
                                        false,
                                        app.ban_list.clone(),
                                    ).await {
                                        Ok(()) => {
                                            app.add_output(&format!("HTTP web interface started on port {} (ws://localhost:{})", app.settings.http_port, app.settings.ws_port));
                                            app.http_server = Some(http_server);
                                        }
                                        Err(e) => {
                                            app.add_output(&format!("Warning: Failed to start HTTP server: {}", e));
                                        }
                                    }
                                } else if !http_enabled && (http_running || https_running) {
                                    // Stop both servers
                                    if http_running {
                                        app.http_server = None;
                                        app.add_output("HTTP web interface stopped.");
                                    }
                                    if https_running {
                                        app.https_server = None;
                                        app.add_output("HTTPS web interface stopped.");
                                    }
                                }
                            }
                        }
                        KeyAction::SwitchedWorld(_world_index) => {
                            // UnseenCleared is now broadcast by switch_world() itself
                        }
                        KeyAction::None => {}
                    }
                    app.check_word_ended();
                }
            }

            // Server events (data from MUD connections)
            Some(event) = event_rx.recv() => {
                match event {
                    AppEvent::ServerData(ref world_name, bytes) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                            // Consider "current" if console OR any web/GUI client is viewing this world
                            let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                            let decoded_data = app.worlds[world_idx].settings.encoding.decode(&bytes);

                            // Extract ANSI music sequences FIRST, before any other processing
                            let (data, music_sequences) = if app.settings.ansi_music_enabled {
                                ansi_music::extract_music(&decoded_data)
                            } else {
                                (decoded_data, Vec::new())
                            };

                            // Broadcast music to WebSocket clients (web/GUI play audio)
                            for notes in music_sequences {
                                app.ws_broadcast(WsMessage::AnsiMusic {
                                    world_index: world_idx,
                                    notes,
                                });
                            }

                            let world_name_for_triggers = world_name.clone();
                            let actions = app.settings.actions.clone();

                            // Combine with any partial line from previous data chunk
                            let had_trigger_partial = !app.worlds[world_idx].trigger_partial_line.is_empty();
                            let combined_data = if had_trigger_partial {
                                let mut s = std::mem::take(&mut app.worlds[world_idx].trigger_partial_line);
                                s.push_str(&data);
                                s
                            } else {
                                data.clone()
                            };

                            // Process action triggers on complete lines
                            // Track lines with gagged flag: (line, is_gagged)
                            let mut processed_lines: Vec<(&str, bool)> = Vec::new();
                            let mut commands_to_execute: Vec<String> = Vec::new();
                            let ends_with_newline = combined_data.ends_with('\n');
                            let lines: Vec<&str> = combined_data.lines().collect();
                            let line_count = lines.len();
                            let mut has_partial = false;
                            // Use persistent flag to track idler filtering across TCP packets
                            let mut just_filtered_idler = app.worlds[world_idx].just_filtered_idler;

                            for (i, line) in lines.iter().enumerate() {
                                let is_last = i == line_count - 1;
                                let is_partial = is_last && !ends_with_newline;

                                // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
                                let uses_idler_keepalive = matches!(
                                    app.worlds[world_idx].settings.keep_alive_type,
                                    KeepAliveType::Custom | KeepAliveType::Generic
                                );
                                if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                                    just_filtered_idler = true;
                                    continue;
                                }

                                // Filter blank lines that immediately follow an idler message
                                if just_filtered_idler && is_visually_empty(line) {
                                    just_filtered_idler = false; // Reset after filtering the blank
                                    continue;
                                }
                                just_filtered_idler = false;

                                // Check triggers on complete lines only
                                if is_partial {
                                    // Store partial line for next chunk - don't process yet
                                    app.worlds[world_idx].trigger_partial_line = line.to_string();
                                    has_partial = true;
                                } else {
                                    let mut is_gagged = false;
                                    if let Some(result) = check_action_triggers(line, &world_name_for_triggers, &actions) {
                                        // Collect commands to execute
                                        commands_to_execute.extend(result.commands);
                                        is_gagged = result.should_gag;
                                    }
                                    // Only add complete lines with gagged flag
                                    processed_lines.push((line, is_gagged));
                                }
                            }

                            // Save the idler filter state for next packet
                            app.worlds[world_idx].just_filtered_idler = just_filtered_idler;

                            // If we have a partial line and world uses WONT ECHO prompts, start timeout
                            if has_partial && app.worlds[world_idx].prompt.is_empty()
                                && app.worlds[world_idx].uses_wont_echo_prompt {
                                app.worlds[world_idx].wont_echo_time = Some(std::time::Instant::now());
                            }

                            // Separate gagged and non-gagged lines
                            let non_gagged_lines: Vec<&str> = processed_lines.iter()
                                .filter(|(_, gagged)| !gagged)
                                .map(|(line, _)| *line)
                                .collect();
                            let gagged_lines: Vec<&str> = processed_lines.iter()
                                .filter(|(_, gagged)| *gagged)
                                .map(|(line, _)| *line)
                                .collect();

                            // Rebuild data for non-gagged lines
                            // Add trailing newline if original ended with newline OR if we have a partial
                            // (because a partial means there was a newline before it that we need to preserve)
                            let filtered_data = if non_gagged_lines.is_empty() {
                                String::new()
                            } else {
                                let mut result = non_gagged_lines.join("\n");
                                if ends_with_newline || has_partial {
                                    result.push('\n');
                                }
                                result
                            };

                            // Add non-gagged output to world
                            if !filtered_data.is_empty() {
                                let settings = app.settings.clone();
                                let output_height = app.output_height;
                                let output_width = app.output_width;
                                app.worlds[world_idx].add_output(&filtered_data, is_current, &settings, output_height, output_width, true, true);
                                // Mark output for redraw if this is the current world
                                if world_idx == app.current_world_index {
                                    app.needs_output_redraw = true;
                                }
                                // Check if terminal needs full redraw (after splash clear)
                                if app.worlds[world_idx].needs_redraw {
                                    app.worlds[world_idx].needs_redraw = false;
                                    terminal.clear()?;
                                }
                                // Broadcast filtered data to WebSocket clients (music already extracted above)
                                // Strip carriage returns - some MUDs send \r\n or bare \r
                                let ws_data = filtered_data.replace('\r', "");
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: ws_data,
                                    is_viewed: is_current,
                                    ts: current_timestamp_secs(),
                                });
                                // Broadcast updated unseen count so all clients stay in sync
                                let unseen_count = app.worlds[world_idx].unseen_lines;
                                if unseen_count > 0 {
                                    app.ws_broadcast(WsMessage::UnseenUpdate {
                                        world_index: world_idx,
                                        count: unseen_count,
                                    });
                                }
                            }

                            // Add gagged lines to output (they'll only show with F2)
                            for line in gagged_lines {
                                app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(line.to_string()));
                            }
                            // Keep scroll at bottom if we added gagged lines
                            if !app.worlds[world_idx].paused {
                                app.worlds[world_idx].scroll_to_bottom();
                            }

                            // Execute any triggered commands
                            if let Some(tx) = &app.worlds[world_idx].command_tx {
                                for cmd in commands_to_execute {
                                    // Send command to the MUD (not as a local command)
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                }
                            }
                        }
                    }
                    AppEvent::Disconnected(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].connected = false;
                            app.worlds[world_idx].command_tx = None;
                            app.worlds[world_idx].telnet_mode = false;
                            app.worlds[world_idx].socket_fd = None;
                            // If there's a prompt, display it as output before clearing
                            if !app.worlds[world_idx].prompt.is_empty() {
                                let prompt_text = app.worlds[world_idx].prompt.trim().to_string();
                                app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_text));
                            }
                            app.worlds[world_idx].prompt.clear();
                            // Broadcast to WebSocket clients
                            app.ws_broadcast(WsMessage::WorldDisconnected { world_index: world_idx });
                        }
                    }
                    AppEvent::TelnetDetected(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            if !app.worlds[world_idx].telnet_mode {
                                app.worlds[world_idx].telnet_mode = true;
                            }
                        }
                    }
                    AppEvent::WontEchoSeen(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            if !app.worlds[world_idx].uses_wont_echo_prompt {
                                app.worlds[world_idx].uses_wont_echo_prompt = true;
                            }
                        }
                    }
                    AppEvent::Prompt(ref world_name, prompt_bytes) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                            let encoding = app.worlds[world_idx].settings.encoding;
                            let prompt_text = encoding.decode(&prompt_bytes);
                            // Normalize: strip CR/LF, strip trailing spaces, add exactly one space
                            let prompt_clean = prompt_text.replace('\r', "").replace('\n', " ");
                            let prompt_normalized = format!("{} ", prompt_clean.trim());

                            // If world is not connected, display prompt as output instead of input area
                            if !app.worlds[world_idx].connected {
                                app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_normalized.trim().to_string()));
                                app.worlds[world_idx].prompt.clear();
                                continue;
                            }

                            app.worlds[world_idx].prompt = prompt_normalized.clone();

                            // Broadcast prompt to WebSocket clients
                            app.ws_broadcast(WsMessage::PromptUpdate {
                                world_index: world_idx,
                                prompt: prompt_normalized,
                            });

                            let world = &mut app.worlds[world_idx];
                            world.prompt_count += 1;

                            // Skip auto-login if flag is set (from /worlds -l)
                            if world.skip_auto_login {
                                continue;
                            }

                            let auto_type = world.settings.auto_connect_type;
                            let user = world.settings.user.clone();
                            let password = world.settings.password.clone();
                            let prompt_num = world.prompt_count;

                            if !user.is_empty() || !password.is_empty() {
                                let cmd_to_send = match auto_type {
                                    AutoConnectType::Prompt => {
                                        match prompt_num {
                                            1 if !user.is_empty() => Some(user),
                                            2 if !password.is_empty() => Some(password),
                                            _ => None,
                                        }
                                    }
                                    AutoConnectType::MooPrompt => {
                                        match prompt_num {
                                            1 if !user.is_empty() => Some(user.clone()),
                                            2 if !password.is_empty() => Some(password),
                                            3 if !user.is_empty() => Some(user),
                                            _ => None,
                                        }
                                    }
                                    AutoConnectType::Connect => None,
                                };

                                if let Some(cmd) = cmd_to_send {
                                    if let Some(tx) = &world.command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                        world.last_send_time = Some(std::time::Instant::now());
                                        // Clear prompt since we auto-answered it
                                        world.prompt.clear();
                                    }
                                }
                            }
                        }
                    }
                    AppEvent::SystemMessage(message) => {
                        // Display system message in current world's output
                        app.add_output(&message);
                    }
                    // Multiuser events are only used in multiuser mode, ignore in normal mode
                    AppEvent::ConnectWorldRequest(_, _) => {}
                    AppEvent::MultiuserServerData(_, _, _) => {}
                    AppEvent::MultiuserDisconnected(_, _) => {}
                    AppEvent::MultiuserTelnetDetected(_, _) => {}
                    AppEvent::MultiuserPrompt(_, _, _) => {}
                    // Slack/Discord events
                    AppEvent::SlackMessage(ref world_name, message) | AppEvent::DiscordMessage(ref world_name, message) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                            let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                            let world_name_for_triggers = world_name.clone();
                            let actions = app.settings.actions.clone();

                            // Check action triggers on the message
                            let mut is_gagged = false;
                            let mut commands_to_execute: Vec<String> = Vec::new();
                            if let Some(result) = check_action_triggers(&message, &world_name_for_triggers, &actions) {
                                commands_to_execute = result.commands;
                                is_gagged = result.should_gag;
                            }

                            let data = format!("{}\n", message);

                            if is_gagged {
                                // Add as gagged line (only visible with F2)
                                app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(message.clone()));
                                if !app.worlds[world_idx].paused {
                                    app.worlds[world_idx].scroll_to_bottom();
                                }
                            } else {
                                // Add non-gagged output normally
                                let settings = app.settings.clone();
                                let output_height = app.output_height;
                                let output_width = app.output_width;
                                app.worlds[world_idx].add_output(&data, is_current, &settings, output_height, output_width, true, true);
                                // Broadcast to WebSocket clients (only non-gagged)
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data,
                                    is_viewed: is_current,
                                    ts: current_timestamp_secs(),
                                });
                            }

                            // Execute any triggered commands
                            if let Some(tx) = &app.worlds[world_idx].command_tx {
                                for cmd in commands_to_execute {
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                }
                            }
                        }
                    }
                    // WebSocket events
                    AppEvent::WsClientConnected(_client_id) => {
                        // Client connected but not yet authenticated - nothing to do
                    }
                    AppEvent::WsClientDisconnected(client_id) => {
                        // Client disconnected - remove from ws_client_worlds cache
                        app.ws_client_worlds.remove(&client_id);
                    }
                    AppEvent::WsClientMessage(client_id, msg) => {
                        match *msg {
                            WsMessage::AuthRequest { .. } => {
                                // Client just authenticated - send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                            }
                            WsMessage::SendCommand { world_index, command } => {
                                // Use shared command parsing
                                let parsed = parse_command(&command);

                                match parsed {
                                    // Commands handled locally on server
                                    Command::ActionCommand { name, args } => {
                                        // Execute action if it exists
                                        if let Some(action) = app.settings.actions.iter().find(|a| a.name.eq_ignore_ascii_case(&name)) {
                                            let commands = split_action_commands(&action.command);
                                            let mut sent_to_server = false;
                                            for cmd in commands {
                                                // Substitute $1-$9 and $* with arguments
                                                let cmd = substitute_action_args(&cmd, &args);

                                                if cmd.eq_ignore_ascii_case("/gag") || cmd.to_lowercase().starts_with("/gag ") {
                                                    continue;
                                                }
                                                // If command starts with /, send back to client for local execution
                                                if cmd.starts_with('/') {
                                                    app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: cmd });
                                                } else if world_index < app.worlds.len() {
                                                    // Plain text - send to MUD server
                                                    if let Some(tx) = &app.worlds[world_index].command_tx {
                                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                                        sent_to_server = true;
                                                    }
                                                }
                                            }
                                            if sent_to_server {
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                            }
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Unknown action: /{}", name),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    }
                                    Command::NotACommand { text } => {
                                        // Regular text - send to MUD
                                        if world_index < app.worlds.len() {
                                            if let Some(tx) = &app.worlds[world_index].command_tx {
                                                if tx.try_send(WriteCommand::Text(text)).is_ok() {
                                                    app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                    app.worlds[world_index].prompt.clear();
                                                }
                                            }
                                        }
                                    }
                                    Command::Unknown { cmd } => {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Unknown command: {}", cmd),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                    Command::Send { text, all_worlds, target_world, no_newline } => {
                                        // Handle /send command
                                        // Helper to create the write command
                                        let make_write_cmd = |t: &str| -> WriteCommand {
                                            if no_newline {
                                                WriteCommand::Raw(t.as_bytes().to_vec())
                                            } else {
                                                WriteCommand::Text(t.to_string())
                                            }
                                        };

                                        if all_worlds {
                                            // Send to all connected worlds
                                            for world in app.worlds.iter_mut() {
                                                if world.connected {
                                                    if let Some(tx) = &world.command_tx {
                                                        let _ = tx.try_send(make_write_cmd(&text));
                                                        world.last_send_time = Some(std::time::Instant::now());
                                                    }
                                                }
                                            }
                                        } else if let Some(ref target) = target_world {
                                            // Send to specific world by name
                                            if let Some(world) = app.worlds.iter_mut().find(|w| w.name.eq_ignore_ascii_case(target)) {
                                                if world.connected {
                                                    if let Some(tx) = &world.command_tx {
                                                        let _ = tx.try_send(make_write_cmd(&text));
                                                        world.last_send_time = Some(std::time::Instant::now());
                                                    }
                                                } else {
                                                    app.ws_broadcast(WsMessage::ServerData {
                                                        world_index,
                                                        data: format!("World '{}' is not connected.", target),
                                                        is_viewed: false,
                                                        ts: current_timestamp_secs(),
                                                    });
                                                }
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("Unknown world: {}", target),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                });
                                            }
                                        } else {
                                            // Send to current world (the one this command came from)
                                            if world_index < app.worlds.len() {
                                                if let Some(tx) = &app.worlds[world_index].command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                }
                                            }
                                        }
                                    }
                                    Command::Disconnect => {
                                        // Disconnect the specified world
                                        if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                            // Kill proxy process if one exists
                                            if let Some(proxy_pid) = app.worlds[world_index].proxy_pid {
                                                unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                            }
                                            if let Some(ref socket_path) = app.worlds[world_index].proxy_socket_path {
                                                let _ = std::fs::remove_file(socket_path);
                                            }
                                            app.worlds[world_index].proxy_pid = None;
                                            app.worlds[world_index].proxy_socket_path = None;
                                            app.worlds[world_index].command_tx = None;
                                            app.worlds[world_index].connected = false;
                                            app.worlds[world_index].socket_fd = None;
                                            app.worlds[world_index].close_log_file();
                                            app.worlds[world_index].prompt.clear();
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "Disconnected.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                            app.ws_broadcast(WsMessage::WorldDisconnected { world_index });
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "Not connected.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    }
                                    Command::Flush => {
                                        // Clear output buffer for this world
                                        if world_index < app.worlds.len() {
                                            let line_count = app.worlds[world_index].output_lines.len();
                                            app.worlds[world_index].output_lines.clear();
                                            app.worlds[world_index].pending_lines.clear();
                                            app.worlds[world_index].scroll_offset = 0;
                                            app.worlds[world_index].lines_since_pause = 0;
                                            app.worlds[world_index].paused = false;
                                            app.ws_broadcast(WsMessage::WorldFlushed { world_index });
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Flushed {} lines from output buffer.", line_count),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    }
                                    Command::Keepalive => {
                                        // Show keepalive settings for this world
                                        if world_index < app.worlds.len() {
                                            let world = &app.worlds[world_index];
                                            let info = format!(
                                                "Keepalive: {} ({})",
                                                world.settings.keep_alive_type.name(),
                                                if world.settings.keep_alive_type == KeepAliveType::Custom {
                                                    world.settings.keep_alive_cmd.clone()
                                                } else {
                                                    world.settings.keep_alive_type.name().to_string()
                                                }
                                            );
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: info,
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    }
                                    Command::Gag { pattern } => {
                                        // TODO: Implement gag patterns storage
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Gag pattern set: {}", pattern),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                    Command::BanList => {
                                        // Send current ban list
                                        let bans = app.ban_list.get_ban_info();
                                        if bans.is_empty() {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "No hosts are currently banned.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        } else {
                                            let mut output = String::new();
                                            output.push_str("\nBanned Hosts:\n");
                                            output.push_str(&"".repeat(70));
                                            output.push_str(&format!("\n{:<20} {:<12} {}\n", "Host", "Type", "Last URL/Reason"));
                                            output.push_str(&"".repeat(70));
                                            output.push('\n');
                                            for (ip, ban_type, reason) in &bans {
                                                let reason_display = if reason.is_empty() { "(unknown)" } else { reason };
                                                output.push_str(&format!("{:<20} {:<12} {}\n", ip, ban_type, reason_display));
                                            }
                                            output.push_str(&"".repeat(70));
                                            output.push_str("\nUse /unban <host> to remove a ban.");
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: output,
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                        app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                                    }
                                    Command::Unban { host } => {
                                        if app.ban_list.remove_ban(&host) {
                                            // Save settings to persist the change
                                            let _ = save_settings(&app);
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Removed ban for: {}", host),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                            // Broadcast updated ban list
                                            app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                            app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("No ban found for: {}", host),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                            app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                        }
                                    }
                                    Command::TestMusic => {
                                        // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
                                        let test_notes = vec![
                                            ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                                            ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                                            ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                                            ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                                            ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
                                        ];
                                        app.ws_broadcast(WsMessage::AnsiMusic {
                                            world_index,
                                            notes: test_notes,
                                        });
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Playing test music (C-D-E-F-G)...".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                    // Commands that should be blocked from remote
                                    Command::Quit | Command::Reload => {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "This command is not available from remote interfaces.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                    // UI popup commands - handled client-side, no-op on server
                                    Command::Help | Command::Menu | Command::Setup | Command::Web | Command::Actions { .. } |
                                    Command::WorldsList | Command::WorldSelector | Command::WorldEdit { .. } => {
                                        // These are handled by the GUI/web interface locally
                                        // No server action needed
                                    }
                                    // Connect command is handled via ConnectWorld message
                                    Command::Connect { .. } => {
                                        // Remote clients should use ConnectWorld message instead
                                        // But we can try to handle it here too
                                        if world_index < app.worlds.len() && !app.worlds[world_index].connected {
                                            if app.worlds[world_index].settings.has_connection_settings() {
                                                // Save current index, connect target, restore
                                                let prev_index = app.current_world_index;
                                                app.current_world_index = world_index;
                                                let _ = handle_command("/connect", &mut app, event_tx.clone()).await;
                                                app.current_world_index = prev_index;
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: "No connection settings configured for this world.".to_string(),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                });
                                            }
                                        }
                                    }
                                    // WorldSwitch and WorldConnectNoLogin need proper handling
                                    Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                                        if let Some(idx) = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                            // Switch to the world
                                            app.switch_world(idx);
                                            app.ws_broadcast(WsMessage::WorldSwitched { new_index: idx });
                                            // Connect if not connected and has settings
                                            if !app.worlds[idx].connected
                                                && app.worlds[idx].settings.has_connection_settings()
                                            {
                                                // For WorldConnectNoLogin, set skip flag
                                                if matches!(parsed, Command::WorldConnectNoLogin { .. }) {
                                                    app.worlds[idx].skip_auto_login = true;
                                                }
                                                let prev_index = app.current_world_index;
                                                app.current_world_index = idx;
                                                let _ = handle_command("/connect", &mut app, event_tx.clone()).await;
                                                app.current_world_index = prev_index;
                                            }
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("World '{}' not found.", name),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    }
                                }
                            }
                            WsMessage::SwitchWorld { world_index } => {
                                // Switch current world and broadcast
                                if world_index < app.worlds.len() {
                                    app.switch_world(world_index);
                                    app.ws_broadcast(WsMessage::WorldSwitched { new_index: world_index });
                                }
                            }
                            WsMessage::ConnectWorld { world_index } => {
                                // Trigger connection for specified world
                                if world_index < app.worlds.len() && !app.worlds[world_index].connected {
                                    // Save current world index, switch to target, connect, then restore
                                    let prev_index = app.current_world_index;
                                    app.current_world_index = world_index;
                                    if handle_command("/connect", &mut app, event_tx.clone()).await {
                                        // Quit was triggered (shouldn't happen from /connect)
                                        return Ok(());
                                    }
                                    // Broadcast world connected
                                    let name = app.worlds[world_index].name.clone();
                                    app.ws_broadcast(WsMessage::WorldConnected { world_index, name });
                                    // Restore previous world if it wasn't the target
                                    if prev_index != world_index {
                                        app.current_world_index = prev_index;
                                        // Mark the restored world as seen (data may have arrived during connect)
                                        app.current_world_mut().mark_seen();
                                    }
                                }
                            }
                            WsMessage::DisconnectWorld { world_index } => {
                                // Disconnect specified world
                                if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                    let prev_index = app.current_world_index;
                                    app.current_world_index = world_index;
                                    if handle_command("/disconnect", &mut app, event_tx.clone()).await {
                                        return Ok(());
                                    }
                                    app.current_world_index = prev_index;
                                    // Mark the restored world as seen (data may have arrived during disconnect)
                                    app.current_world_mut().mark_seen();
                                    // WorldDisconnected broadcast happens via AppEvent::Disconnected
                                }
                            }
                            WsMessage::DeleteWorld { world_index } => {
                                // Delete specified world (if not the last one)
                                if app.worlds.len() > 1 && world_index < app.worlds.len() {
                                    let deleted_name = app.worlds[world_index].name.clone();
                                    app.worlds.remove(world_index);
                                    // Adjust current_world_index if needed
                                    if app.current_world_index >= app.worlds.len() {
                                        app.current_world_index = app.worlds.len().saturating_sub(1);
                                    } else if app.current_world_index > world_index {
                                        app.current_world_index -= 1;
                                    }
                                    app.add_output(&format!("World '{}' deleted.\n", deleted_name));
                                    // Broadcast WorldRemoved to all clients
                                    app.ws_broadcast(WsMessage::WorldRemoved { world_index });
                                    let _ = save_settings(&app);
                                }
                            }
                            WsMessage::MarkWorldSeen { world_index } => {
                                // A remote client has viewed this world - update their current_world
                                if world_index < app.worlds.len() {
                                    // Track which world this client is viewing (sync cache)
                                    app.ws_client_worlds.insert(client_id, world_index);
                                    // Also update async client info
                                    if let Some(ref server) = app.ws_server {
                                        let clients = server.clients.clone();
                                        let cid = client_id;
                                        tokio::spawn(async move {
                                            let mut clients_guard = clients.write().await;
                                            if let Some(client) = clients_guard.get_mut(&cid) {
                                                client.current_world = Some(world_index);
                                            }
                                        });
                                    }
                                    app.worlds[world_index].mark_seen();
                                    // Broadcast to all clients so they update their UI
                                    app.ws_broadcast(WsMessage::UnseenCleared { world_index });
                                }
                            }
                            WsMessage::ReleasePending { world_index, count } => {
                                // A remote client is releasing pending lines - sync across all interfaces
                                if world_index < app.worlds.len() {
                                    let pending_count = app.worlds[world_index].pending_lines.len();
                                    if pending_count > 0 {
                                        // Determine how many lines to release
                                        let to_release = if count == 0 { pending_count } else { count.min(pending_count) };
                                        // Release the lines on the server
                                        app.worlds[world_index].release_pending(to_release);
                                        // Broadcast to all clients so they release the same number
                                        app.ws_broadcast(WsMessage::PendingReleased { world_index, count: to_release });
                                        // Also update pending count
                                        let new_count = app.worlds[world_index].pending_lines.len();
                                        app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index, count: new_count });
                                    }
                                }
                            }
                            WsMessage::UpdateWorldSettings { world_index, name, hostname, port, user, password, use_ssl, log_enabled, encoding, auto_login, keep_alive_type, keep_alive_cmd } => {
                                // Update world settings from remote client
                                if world_index < app.worlds.len() {
                                    app.worlds[world_index].name = name.clone();
                                    app.worlds[world_index].settings.hostname = hostname.clone();
                                    app.worlds[world_index].settings.port = port.clone();
                                    app.worlds[world_index].settings.user = user.clone();
                                    app.worlds[world_index].settings.password = password.clone();
                                    app.worlds[world_index].settings.use_ssl = use_ssl;
                                    app.worlds[world_index].settings.log_enabled = log_enabled;
                                    app.worlds[world_index].settings.encoding = match encoding.as_str() {
                                        "latin1" => Encoding::Latin1,
                                        "fansi" => Encoding::Fansi,
                                        _ => Encoding::Utf8,
                                    };
                                    app.worlds[world_index].settings.auto_connect_type = AutoConnectType::from_name(&auto_login);
                                    app.worlds[world_index].settings.keep_alive_type = KeepAliveType::from_name(&keep_alive_type);
                                    app.worlds[world_index].settings.keep_alive_cmd = keep_alive_cmd.clone();
                                    // Save settings to persist changes
                                    let _ = save_settings(&app);
                                    // Build settings message for broadcast (encrypt password)
                                    let settings_msg = WorldSettingsMsg {
                                        hostname,
                                        port,
                                        user,
                                        password: encrypt_password(&password),
                                        use_ssl,
                                        log_enabled,
                                        encoding,
                                        auto_connect_type: auto_login,
                                        keep_alive_type,
                                        keep_alive_cmd,
                                    };
                                    // Broadcast update to all clients
                                    app.ws_broadcast(WsMessage::WorldSettingsUpdated {
                                        world_index,
                                        settings: settings_msg,
                                        name,
                                    });
                                }
                            }
                            WsMessage::UpdateGlobalSettings { more_mode_enabled, spell_check_enabled, world_switch_mode, show_tags, ansi_music_enabled, console_theme, gui_theme, gui_transparency, input_height, font_name, font_size, ws_allow_list, web_secure, http_enabled, http_port, ws_enabled, ws_port, ws_cert_file, ws_key_file, tls_proxy_enabled } => {
                                // Update global settings from remote client
                                app.settings.more_mode_enabled = more_mode_enabled;
                                app.settings.spell_check_enabled = spell_check_enabled;
                                app.settings.world_switch_mode = WorldSwitchMode::from_name(&world_switch_mode);
                                app.show_tags = show_tags;
                                app.settings.ansi_music_enabled = ansi_music_enabled;
                                // Console theme affects the TUI on the server
                                app.settings.theme = Theme::from_name(&console_theme);
                                // GUI theme is stored for sending back to GUI clients
                                app.settings.gui_theme = Theme::from_name(&gui_theme);
                                app.settings.gui_transparency = gui_transparency.clamp(0.3, 1.0);
                                app.input_height = input_height.clamp(1, 15);
                                app.input.visible_height = app.input_height;
                                app.settings.font_name = font_name;
                                app.settings.font_size = font_size.clamp(8.0, 48.0);
                                app.settings.websocket_allow_list = ws_allow_list.clone();
                                // Update the running WebSocket server's allow list
                                if let Some(ref server) = app.ws_server {
                                    server.update_allow_list(&ws_allow_list);
                                }
                                // Update web settings
                                app.settings.web_secure = web_secure;
                                app.settings.http_enabled = http_enabled;
                                app.settings.http_port = http_port;
                                app.settings.ws_enabled = ws_enabled;
                                app.settings.ws_port = ws_port;
                                app.settings.websocket_cert_file = ws_cert_file;
                                app.settings.websocket_key_file = ws_key_file;
                                app.settings.tls_proxy_enabled = tls_proxy_enabled;
                                // Save settings to persist changes
                                let _ = save_settings(&app);
                                // Build settings message for broadcast
                                let settings_msg = GlobalSettingsMsg {
                                    more_mode_enabled: app.settings.more_mode_enabled,
                                    spell_check_enabled: app.settings.spell_check_enabled,
                                    world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                                    debug_enabled: app.settings.debug_enabled,
                                    show_tags: app.show_tags,
                                    ansi_music_enabled: app.settings.ansi_music_enabled,
                                    console_theme: app.settings.theme.name().to_string(),
                                    gui_theme: app.settings.gui_theme.name().to_string(),
                                    gui_transparency: app.settings.gui_transparency,
                                    input_height: app.input_height,
                                    font_name: app.settings.font_name.clone(),
                                    font_size: app.settings.font_size,
                                    ws_allow_list: app.settings.websocket_allow_list.clone(),
                                    web_secure: app.settings.web_secure,
                                    http_enabled: app.settings.http_enabled,
                                    http_port: app.settings.http_port,
                                    ws_enabled: app.settings.ws_enabled,
                                    ws_port: app.settings.ws_port,
                                    ws_cert_file: app.settings.websocket_cert_file.clone(),
                                    ws_key_file: app.settings.websocket_key_file.clone(),
                                    tls_proxy_enabled: app.settings.tls_proxy_enabled,
                                };
                                // Broadcast update to all clients
                                app.ws_broadcast(WsMessage::GlobalSettingsUpdated {
                                    settings: settings_msg,
                                    input_height: app.input_height,
                                });
                            }
                            WsMessage::UpdateActions { actions } => {
                                // Update actions from remote client
                                app.settings.actions = actions.clone();
                                // Save settings to persist changes
                                let _ = save_settings(&app);
                                // Broadcast update to all clients
                                app.ws_broadcast(WsMessage::ActionsUpdated {
                                    actions,
                                });
                            }
                            WsMessage::CalculateNextWorld { current_index } => {
                                // Calculate next world using shared logic
                                let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                    .map(|w| crate::util::WorldSwitchInfo {
                                        name: w.name.clone(),
                                        connected: w.connected,
                                        unseen_lines: w.unseen_lines,
                                        pending_lines: w.pending_lines.len(),
                                    })
                                    .collect();
                                let next_idx = crate::util::calculate_next_world(
                                    &world_info,
                                    current_index,
                                    app.settings.world_switch_mode,
                                );
                                app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: next_idx });
                            }
                            WsMessage::CalculatePrevWorld { current_index } => {
                                // Calculate prev world using shared logic
                                let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                    .map(|w| crate::util::WorldSwitchInfo {
                                        name: w.name.clone(),
                                        connected: w.connected,
                                        unseen_lines: w.unseen_lines,
                                        pending_lines: w.pending_lines.len(),
                                    })
                                    .collect();
                                let prev_idx = crate::util::calculate_prev_world(
                                    &world_info,
                                    current_index,
                                    app.settings.world_switch_mode,
                                );
                                app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: prev_idx });
                            }
                            WsMessage::RequestState => {
                                // Client requested full state resync - send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                            }
                            WsMessage::BanListRequest => {
                                // Send current ban list to client
                                let bans = app.ban_list.get_ban_info();
                                app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                            }
                            WsMessage::UnbanRequest { host } => {
                                if app.ban_list.remove_ban(&host) {
                                    // Save settings to persist the change
                                    let _ = save_settings(&app);
                                    // Broadcast updated ban list to all clients
                                    app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                    app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                } else {
                                    app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                }
                            }
                            _ => {
                                // Other message types handled elsewhere or ignored
                            }
                        }
                    }
                }
            }

            // Periodic timer for clock updates and keepalive checks (once per minute)
            _ = keepalive_interval.tick() => {
                // Check keepalive for all connected worlds (send NOP if no activity in 5 min)
                for world in &mut app.worlds {
                    if world.connected {
                        // Check last activity time (either send or receive)
                        let last_activity = match (world.last_send_time, world.last_receive_time) {
                            (Some(s), Some(r)) => Some(s.max(r)),
                            (Some(s), None) => Some(s),
                            (None, Some(r)) => Some(r),
                            (None, None) => None,
                        };
                        let should_send = match last_activity {
                            Some(t) => t.elapsed() >= KEEPALIVE_INTERVAL,
                            None => true,
                        };
                        if should_send {
                            if let Some(tx) = &world.command_tx {
                                let now = std::time::Instant::now();

                                // Log the keepalive type being used
                                debug_log(app.settings.debug_enabled, &format!(
                                    "KEEPALIVE_CHECK world='{}' type={:?} cmd='{}'",
                                    world.name, world.settings.keep_alive_type, world.settings.keep_alive_cmd
                                ));

                                // Send keepalive based on type
                                match world.settings.keep_alive_type {
                                    KeepAliveType::None => {
                                        debug_log(app.settings.debug_enabled, &format!(
                                            "KEEPALIVE_SKIP world='{}' - keepalive disabled", world.name
                                        ));
                                        // Don't update times - nothing was sent
                                    }
                                    KeepAliveType::Nop => {
                                        let nop = vec![TELNET_IAC, TELNET_NOP];
                                        let _ = tx.try_send(WriteCommand::Raw(nop));
                                        debug_log_keepalive(app.settings.debug_enabled, &world.name, "NOP", "NOP");
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Custom => {
                                        // Generate random number 1-1000
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let idler_tag = format!("###_idler_message_{}_###", rand_num);
                                        let cmd = world.settings.keep_alive_cmd
                                            .replace("##rand##", &idler_tag);
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                        debug_log_keepalive(app.settings.debug_enabled, &world.name, "Custom", &cmd);
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Generic => {
                                        // Generate random number 1-1000
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let cmd = format!("help commands ###_idler_message_{}_###", rand_num);
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                        debug_log_keepalive(app.settings.debug_enabled, &world.name, "Generic", &cmd);
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                }
                            }
                        }
                    }
                }

                // Check proxy health for TLS proxy connections
                for world in &mut app.worlds {
                    if world.connected {
                        if let Some(proxy_pid) = world.proxy_pid {
                            if !is_process_alive(proxy_pid) {
                                // Proxy died - mark world as disconnected
                                world.connected = false;
                                world.command_tx = None;
                                world.proxy_pid = None;
                                world.proxy_socket_path = None;
                                world.output_lines.push(OutputLine::new("TLS proxy terminated. Connection lost.".to_string()));
                            }
                        }
                    }
                }
                // Redraw to update the clock display in separator bar
            }

            // Prompt timeout check (every 150ms)
            _ = prompt_check_interval.tick() => {
                let now = std::time::Instant::now();
                for world in &mut app.worlds {
                    // Check if there's a partial line waiting to become a prompt
                    if let Some(wont_echo_time) = world.wont_echo_time {
                        // If 150ms+ has passed since partial line was seen
                        if now.duration_since(wont_echo_time) >= Duration::from_millis(150) {
                            // Check if there's a partial line to extract as prompt
                            if !world.trigger_partial_line.is_empty() && world.prompt.is_empty() {
                                // Extract partial line as prompt
                                let prompt_text = std::mem::take(&mut world.trigger_partial_line);
                                // Normalize: strip CR/LF, strip trailing spaces, add exactly one space
                                let prompt_clean = prompt_text.replace('\r', "").replace('\n', " ");
                                let normalized = format!("{} ", prompt_clean.trim());

                                // If world is not connected, display prompt as output instead
                                if !world.connected {
                                    world.output_lines.push(OutputLine::new(normalized.trim().to_string()));
                                    world.wont_echo_time = None;
                                    continue;
                                }

                                world.prompt = normalized;
                                world.prompt_count += 1;

                                // Handle auto-login (same logic as AppEvent::Prompt handler)
                                if !world.skip_auto_login {
                                    let auto_type = world.settings.auto_connect_type;
                                    let user = world.settings.user.clone();
                                    let password = world.settings.password.clone();
                                    let prompt_num = world.prompt_count;

                                    if !user.is_empty() || !password.is_empty() {
                                        let cmd_to_send = match auto_type {
                                            AutoConnectType::Prompt => {
                                                match prompt_num {
                                                    1 if !user.is_empty() => Some(user),
                                                    2 if !password.is_empty() => Some(password),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::MooPrompt => {
                                                match prompt_num {
                                                    1 if !user.is_empty() => Some(user.clone()),
                                                    2 if !password.is_empty() => Some(password),
                                                    3 if !user.is_empty() => Some(user),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::Connect => None,
                                        };

                                        if let Some(cmd) = cmd_to_send {
                                            world.prompt.clear(); // Clear prompt since we're auto-responding
                                            if let Some(tx) = &world.command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(cmd));
                                            }
                                        }
                                    }
                                }
                            }
                            world.wont_echo_time = None;
                        }
                    }
                }
            }
        }

        // Check if any popup is now visible
        let any_popup_visible = app.settings_popup.visible
            || app.world_selector.visible
            || app.confirm_dialog.visible
            || app.worlds_popup.visible
            || app.filter_popup.visible
            || app.help_popup.visible
            || app.menu_popup.visible
            || app.actions_popup.visible
            || app.web_popup.visible;

        // If transitioning from no popup to popup, clear terminal to sync ratatui with terminal state
        if any_popup_visible && !app.popup_was_visible {
            terminal.clear()?;
        }
        // Detect popup visibility change before updating
        let popup_visibility_changed = any_popup_visible != app.popup_was_visible;
        app.popup_was_visible = any_popup_visible;

        // Use ratatui for everything, but render output area with raw crossterm
        // after the ratatui draw (ratatui's Paragraph has rendering bugs)
        terminal.draw(|f| ui(f, &mut app))?;

        // Render output area with crossterm only when needed (optimization)
        // Also redraw when popup visibility changes
        if app.needs_output_redraw || popup_visibility_changed {
            render_output_crossterm(&app);
            app.needs_output_redraw = false;
        }

        // Process any additional queued server events before next select
        // Track if we processed any events to know if we need to redraw
        let mut processed_events = false;
        while let Ok(event) = event_rx.try_recv() {
            processed_events = true;
            match event {
                AppEvent::ServerData(ref world_name, bytes) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        // Consider "current" if console OR any web/GUI client is viewing this world
                        let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                        let decoded_data = app.worlds[world_idx].settings.encoding.decode(&bytes);

                        // Extract ANSI music sequences FIRST, before any other processing
                        let (data, music_sequences) = if app.settings.ansi_music_enabled {
                            ansi_music::extract_music(&decoded_data)
                        } else {
                            (decoded_data.clone(), Vec::new())
                        };

                        // Broadcast music to WebSocket clients (web/GUI play audio)
                        for notes in music_sequences {
                            app.ws_broadcast(WsMessage::AnsiMusic {
                                world_index: world_idx,
                                notes,
                            });
                        }

                        let world_name_for_triggers = world_name.clone();
                        let actions = app.settings.actions.clone();

                        // Combine with any partial line from previous data chunk
                        let had_trigger_partial = !app.worlds[world_idx].trigger_partial_line.is_empty();
                        let combined_data = if had_trigger_partial {
                            let mut s = std::mem::take(&mut app.worlds[world_idx].trigger_partial_line);
                            s.push_str(&data);
                            s
                        } else {
                            data.clone()
                        };

                        // Process action triggers on complete lines
                        // Track lines with gagged flag: (line, is_gagged)
                        let mut processed_lines: Vec<(&str, bool)> = Vec::new();
                        let mut commands_to_execute: Vec<String> = Vec::new();
                        let ends_with_newline = combined_data.ends_with('\n');
                        let lines: Vec<&str> = combined_data.lines().collect();
                        let line_count = lines.len();
                        let mut has_partial = false;
                        // Use persistent flag to track idler filtering across TCP packets
                        let mut just_filtered_idler = app.worlds[world_idx].just_filtered_idler;

                        for (i, line) in lines.iter().enumerate() {
                            let is_last = i == line_count - 1;
                            let is_partial = is_last && !ends_with_newline;

                            // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
                            let uses_idler_keepalive = matches!(
                                app.worlds[world_idx].settings.keep_alive_type,
                                KeepAliveType::Custom | KeepAliveType::Generic
                            );
                            if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                                just_filtered_idler = true;
                                continue;
                            }

                            // Filter blank lines that immediately follow an idler message
                            if just_filtered_idler && is_visually_empty(line) {
                                just_filtered_idler = false; // Reset after filtering the blank
                                continue;
                            }
                            just_filtered_idler = false;

                            // Check triggers on complete lines only
                            if is_partial {
                                // Store partial line for next chunk - don't process yet
                                app.worlds[world_idx].trigger_partial_line = line.to_string();
                                has_partial = true;
                            } else {
                                let mut is_gagged = false;
                                if let Some(result) = check_action_triggers(line, &world_name_for_triggers, &actions) {
                                    commands_to_execute.extend(result.commands);
                                    is_gagged = result.should_gag;
                                }
                                // Only add complete lines with gagged flag
                                processed_lines.push((line, is_gagged));
                            }
                        }

                        // Save the idler filter state for next packet
                        app.worlds[world_idx].just_filtered_idler = just_filtered_idler;

                        // If we have a partial line and world uses WONT ECHO prompts, start timeout
                        if has_partial && app.worlds[world_idx].prompt.is_empty()
                            && app.worlds[world_idx].uses_wont_echo_prompt {
                            app.worlds[world_idx].wont_echo_time = Some(std::time::Instant::now());
                        }

                        // Separate gagged and non-gagged lines
                        let non_gagged_lines: Vec<&str> = processed_lines.iter()
                            .filter(|(_, gagged)| !gagged)
                            .map(|(line, _)| *line)
                            .collect();
                        let gagged_lines: Vec<&str> = processed_lines.iter()
                            .filter(|(_, gagged)| *gagged)
                            .map(|(line, _)| *line)
                            .collect();

                        // Add trailing newline if original ended with newline OR if we have a partial
                        // (because a partial means there was a newline before it that we need to preserve)
                        let filtered_data = if non_gagged_lines.is_empty() {
                            String::new()
                        } else {
                            let mut result = non_gagged_lines.join("\n");
                            if ends_with_newline || has_partial {
                                result.push('\n');
                            }
                            result
                        };

                        if !filtered_data.is_empty() {
                            let settings = app.settings.clone();
                            let output_height = app.output_height;
                            let output_width = app.output_width;
                            app.worlds[world_idx].add_output(&filtered_data, is_current, &settings, output_height, output_width, true, true);
                            // Mark output for redraw if this is the current world
                            if world_idx == app.current_world_index {
                                app.needs_output_redraw = true;
                            }
                            if app.worlds[world_idx].needs_redraw {
                                app.worlds[world_idx].needs_redraw = false;
                                let _ = terminal.clear();
                            }
                            // Strip carriage returns for WebSocket - some MUDs send \r\n or bare \r
                            // Music already extracted above
                            let ws_data = filtered_data.replace('\r', "");
                            app.ws_broadcast(WsMessage::ServerData {
                                world_index: world_idx,
                                data: ws_data,
                                is_viewed: is_current,
                                ts: current_timestamp_secs(),
                            });
                        }

                        // Add gagged lines to output (they'll only show with F2)
                        for line in gagged_lines {
                            app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(line.to_string()));
                        }
                        if !app.worlds[world_idx].paused {
                            app.worlds[world_idx].scroll_to_bottom();
                        }

                        if let Some(tx) = &app.worlds[world_idx].command_tx {
                            for cmd in commands_to_execute {
                                let _ = tx.try_send(WriteCommand::Text(cmd));
                            }
                        }
                    }
                }
                AppEvent::Disconnected(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].connected = false;
                        app.worlds[world_idx].command_tx = None;
                        app.worlds[world_idx].telnet_mode = false;
                        app.worlds[world_idx].socket_fd = None;
                        // If there's a prompt, display it as output before clearing
                        if !app.worlds[world_idx].prompt.is_empty() {
                            let prompt_text = app.worlds[world_idx].prompt.trim().to_string();
                            app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_text));
                        }
                        app.worlds[world_idx].prompt.clear();
                        app.ws_broadcast(WsMessage::WorldDisconnected { world_index: world_idx });
                    }
                }
                AppEvent::TelnetDetected(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        if !app.worlds[world_idx].telnet_mode {
                            app.worlds[world_idx].telnet_mode = true;
                        }
                    }
                }
                AppEvent::WontEchoSeen(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        if !app.worlds[world_idx].uses_wont_echo_prompt {
                            app.worlds[world_idx].uses_wont_echo_prompt = true;
                        }
                    }
                }
                AppEvent::Prompt(ref world_name, prompt_bytes) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        let encoding = app.worlds[world_idx].settings.encoding;
                        let prompt_text = encoding.decode(&prompt_bytes);
                        // Normalize: strip CR/LF, strip trailing spaces, add exactly one space
                        let prompt_clean = prompt_text.replace('\r', "").replace('\n', " ");
                        let prompt_normalized = format!("{} ", prompt_clean.trim());

                        // If world is not connected, display prompt as output instead of input area
                        if !app.worlds[world_idx].connected {
                            app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_normalized.trim().to_string()));
                            app.worlds[world_idx].prompt.clear();
                            continue;
                        }

                        app.worlds[world_idx].prompt = prompt_normalized.clone();
                        app.ws_broadcast(WsMessage::PromptUpdate {
                            world_index: world_idx,
                            prompt: prompt_normalized,
                        });

                        let world = &mut app.worlds[world_idx];
                        world.prompt_count += 1;

                        // Skip auto-login if flag is set (from /worlds -l)
                        if world.skip_auto_login {
                            continue;
                        }

                        let auto_type = world.settings.auto_connect_type;
                        let user = world.settings.user.clone();
                        let password = world.settings.password.clone();
                        let prompt_num = world.prompt_count;

                        if !user.is_empty() || !password.is_empty() {
                            let cmd_to_send = match auto_type {
                                AutoConnectType::Prompt => {
                                    match prompt_num {
                                        1 if !user.is_empty() => Some(user),
                                        2 if !password.is_empty() => Some(password),
                                        _ => None,
                                    }
                                }
                                AutoConnectType::MooPrompt => {
                                    match prompt_num {
                                        1 if !user.is_empty() => Some(user.clone()),
                                        2 if !password.is_empty() => Some(password),
                                        3 if !user.is_empty() => Some(user),
                                        _ => None,
                                    }
                                }
                                AutoConnectType::Connect => None,
                            };

                            if let Some(cmd) = cmd_to_send {
                                if let Some(tx) = &world.command_tx {
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                    world.last_send_time = Some(std::time::Instant::now());
                                    // Clear prompt since we auto-answered it
                                    world.prompt.clear();
                                }
                            }
                        }
                    }
                }
                AppEvent::SystemMessage(message) => {
                    // Display system message in current world's output
                    app.add_output(&message);
                }
                // Multiuser events are only used in multiuser mode, ignore in normal mode
                AppEvent::ConnectWorldRequest(_, _) => {}
                AppEvent::MultiuserServerData(_, _, _) => {}
                AppEvent::MultiuserDisconnected(_, _) => {}
                AppEvent::MultiuserTelnetDetected(_, _) => {}
                AppEvent::MultiuserPrompt(_, _, _) => {}
                // Slack/Discord events
                AppEvent::SlackMessage(ref world_name, message) | AppEvent::DiscordMessage(ref world_name, message) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                        let world_name_for_triggers = world_name.clone();
                        let actions = app.settings.actions.clone();

                        // Check action triggers on the message
                        let mut is_gagged = false;
                        let mut commands_to_execute: Vec<String> = Vec::new();
                        if let Some(result) = check_action_triggers(&message, &world_name_for_triggers, &actions) {
                            commands_to_execute = result.commands;
                            is_gagged = result.should_gag;
                        }

                        let data = format!("{}\n", message);

                        if is_gagged {
                            // Add as gagged line (only visible with F2)
                            app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(message.clone()));
                            if !app.worlds[world_idx].paused {
                                app.worlds[world_idx].scroll_to_bottom();
                            }
                        } else {
                            // Add non-gagged output normally
                            let settings = app.settings.clone();
                            let output_height = app.output_height;
                            let output_width = app.output_width;
                            app.worlds[world_idx].add_output(&data, is_current, &settings, output_height, output_width, true, true);
                            // Broadcast to WebSocket clients (only non-gagged)
                            app.ws_broadcast(WsMessage::ServerData {
                                world_index: world_idx,
                                data,
                                is_viewed: is_current,
                                ts: current_timestamp_secs(),
                            });
                        }

                        // Execute any triggered commands
                        if let Some(tx) = &app.worlds[world_idx].command_tx {
                            for cmd in commands_to_execute {
                                let _ = tx.try_send(WriteCommand::Text(cmd));
                            }
                        }
                    }
                }
                // WebSocket events (drain loop - complex handlers use primary loop)
                AppEvent::WsClientConnected(_) => {}
                AppEvent::WsClientDisconnected(client_id) => {
                    // Client disconnected - remove from ws_client_worlds cache
                    app.ws_client_worlds.remove(&client_id);
                }
                AppEvent::WsClientMessage(client_id, msg) => {
                    // Handle simple messages in drain loop
                    match *msg {
                        WsMessage::AuthRequest { .. } => {
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                        }
                        WsMessage::SendCommand { world_index, command } => {
                            // Use shared command parsing
                            let parsed = parse_command(&command);

                            match parsed {
                                // Commands handled locally on server
                                Command::ActionCommand { name, args } => {
                                    // Execute action if it exists
                                    if let Some(action) = app.settings.actions.iter().find(|a| a.name.eq_ignore_ascii_case(&name)) {
                                        let commands = split_action_commands(&action.command);
                                        let mut sent_to_server = false;
                                        for cmd in commands {
                                            // Substitute $1-$9 and $* with arguments
                                            let cmd = substitute_action_args(&cmd, &args);

                                            if cmd.eq_ignore_ascii_case("/gag") || cmd.to_lowercase().starts_with("/gag ") {
                                                continue;
                                            }
                                            // If command starts with /, send back to client for local execution
                                            if cmd.starts_with('/') {
                                                app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: cmd });
                                            } else if world_index < app.worlds.len() {
                                                // Plain text - send to MUD server
                                                if let Some(tx) = &app.worlds[world_index].command_tx {
                                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                                    sent_to_server = true;
                                                }
                                            }
                                        }
                                        if sent_to_server {
                                            app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                        }
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Unknown action: /{}", name),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                }
                                Command::NotACommand { text } => {
                                    // Regular text - send to MUD
                                    if world_index < app.worlds.len() {
                                        if let Some(tx) = &app.worlds[world_index].command_tx {
                                            if tx.try_send(WriteCommand::Text(text)).is_ok() {
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                app.worlds[world_index].prompt.clear();
                                            }
                                        }
                                    }
                                }
                                Command::Unknown { cmd } => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: format!("Unknown command: {}", cmd),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                    });
                                }
                                Command::Send { text, all_worlds, target_world, no_newline } => {
                                    // Handle /send command
                                    // Helper to create the write command
                                    let make_write_cmd = |t: &str| -> WriteCommand {
                                        if no_newline {
                                            WriteCommand::Raw(t.as_bytes().to_vec())
                                        } else {
                                            WriteCommand::Text(t.to_string())
                                        }
                                    };

                                    if all_worlds {
                                        // Send to all connected worlds
                                        for world in app.worlds.iter_mut() {
                                            if world.connected {
                                                if let Some(tx) = &world.command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    world.last_send_time = Some(std::time::Instant::now());
                                                }
                                            }
                                        }
                                    } else if let Some(ref target) = target_world {
                                        // Send to specific world by name
                                        if let Some(world) = app.worlds.iter_mut().find(|w| w.name.eq_ignore_ascii_case(target)) {
                                            if world.connected {
                                                if let Some(tx) = &world.command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    world.last_send_time = Some(std::time::Instant::now());
                                                }
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("World '{}' is not connected.", target),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                });
                                            }
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Unknown world: {}", target),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                            });
                                        }
                                    } else {
                                        // Send to current world (the one this command came from)
                                        if world_index < app.worlds.len() {
                                            if let Some(tx) = &app.worlds[world_index].command_tx {
                                                let _ = tx.try_send(make_write_cmd(&text));
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                            }
                                        }
                                    }
                                }
                                Command::Disconnect => {
                                    // Disconnect the specified world
                                    if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                        // Kill proxy process if one exists
                                        if let Some(proxy_pid) = app.worlds[world_index].proxy_pid {
                                            unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                        }
                                        if let Some(ref socket_path) = app.worlds[world_index].proxy_socket_path {
                                            let _ = std::fs::remove_file(socket_path);
                                        }
                                        app.worlds[world_index].proxy_pid = None;
                                        app.worlds[world_index].proxy_socket_path = None;
                                        app.worlds[world_index].command_tx = None;
                                        app.worlds[world_index].connected = false;
                                        app.worlds[world_index].socket_fd = None;
                                        app.worlds[world_index].close_log_file();
                                        app.worlds[world_index].prompt.clear();
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Disconnected.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                        app.ws_broadcast(WsMessage::WorldDisconnected { world_index });
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Not connected.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                }
                                Command::Flush => {
                                    // Clear output buffer for this world
                                    if world_index < app.worlds.len() {
                                        let line_count = app.worlds[world_index].output_lines.len();
                                        app.worlds[world_index].output_lines.clear();
                                        app.worlds[world_index].pending_lines.clear();
                                        app.worlds[world_index].scroll_offset = 0;
                                        app.worlds[world_index].lines_since_pause = 0;
                                        app.worlds[world_index].paused = false;
                                        app.ws_broadcast(WsMessage::WorldFlushed { world_index });
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Flushed {} lines from output buffer.", line_count),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                }
                                Command::Keepalive => {
                                    // Show keepalive settings for this world
                                    if world_index < app.worlds.len() {
                                        let world = &app.worlds[world_index];
                                        let info = format!(
                                            "Keepalive: {} ({})",
                                            world.settings.keep_alive_type.name(),
                                            if world.settings.keep_alive_type == KeepAliveType::Custom {
                                                world.settings.keep_alive_cmd.clone()
                                            } else {
                                                world.settings.keep_alive_type.name().to_string()
                                            }
                                        );
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: info,
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                }
                                Command::Gag { pattern } => {
                                    // TODO: Implement gag patterns storage
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: format!("Gag pattern set: {}", pattern),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                    });
                                }
                                Command::BanList => {
                                    // Send current ban list
                                    let bans = app.ban_list.get_ban_info();
                                    if bans.is_empty() {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "No hosts are currently banned.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    } else {
                                        let mut output = String::new();
                                        output.push_str("\nBanned Hosts:\n");
                                        output.push_str(&"".repeat(70));
                                        output.push_str(&format!("\n{:<20} {:<12} {}\n", "Host", "Type", "Last URL/Reason"));
                                        output.push_str(&"".repeat(70));
                                        output.push('\n');
                                        for (ip, ban_type, reason) in &bans {
                                            let reason_display = if reason.is_empty() { "(unknown)" } else { reason };
                                            output.push_str(&format!("{:<20} {:<12} {}\n", ip, ban_type, reason_display));
                                        }
                                        output.push_str(&"".repeat(70));
                                        output.push_str("\nUse /unban <host> to remove a ban.");
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: output,
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                    app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                                }
                                Command::Unban { host } => {
                                    if app.ban_list.remove_ban(&host) {
                                        // Save settings to persist the change
                                        let _ = save_settings(&app);
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Removed ban for: {}", host),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                        // Broadcast updated ban list
                                        app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                        app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("No ban found for: {}", host),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                        app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                    }
                                }
                                Command::TestMusic => {
                                    // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
                                    let test_notes = vec![
                                        ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                                        ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                                        ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                                        ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                                        ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
                                    ];
                                    app.ws_broadcast(WsMessage::AnsiMusic {
                                        world_index,
                                        notes: test_notes,
                                    });
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: "Playing test music (C-D-E-F-G)...".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                    });
                                }
                                // Commands that should be blocked from remote
                                Command::Quit | Command::Reload => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: "This command is not available from remote interfaces.".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                    });
                                }
                                // UI popup commands - handled client-side, no-op on server
                                Command::Help | Command::Menu | Command::Setup | Command::Web | Command::Actions { .. } |
                                Command::WorldsList | Command::WorldSelector | Command::WorldEdit { .. } => {
                                    // These are handled by the GUI/web interface locally
                                    // No server action needed
                                }
                                // Connect command - can't do async in drain loop, use ConnectWorld message
                                Command::Connect { .. } => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: "Use ConnectWorld message for connection.".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                    });
                                }
                                // WorldSwitch - do the switch part, skip async connect
                                Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                                    if let Some(idx) = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                        // Switch to the world
                                        app.switch_world(idx);
                                        app.ws_broadcast(WsMessage::WorldSwitched { new_index: idx });
                                        // Note: Connection requires async, use ConnectWorld message
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("World '{}' not found.", name),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                        });
                                    }
                                }
                            }
                        }
                        WsMessage::SwitchWorld { world_index } => {
                            if world_index < app.worlds.len() {
                                app.switch_world(world_index);
                                app.ws_broadcast(WsMessage::WorldSwitched { new_index: world_index });
                            }
                        }
                        WsMessage::UpdateWorldSettings { world_index, name, hostname, port, user, password, use_ssl, log_enabled, encoding, auto_login, keep_alive_type, keep_alive_cmd } => {
                            if world_index < app.worlds.len() {
                                app.worlds[world_index].name = name.clone();
                                app.worlds[world_index].settings.hostname = hostname.clone();
                                app.worlds[world_index].settings.port = port.clone();
                                app.worlds[world_index].settings.user = user.clone();
                                app.worlds[world_index].settings.password = password.clone();
                                app.worlds[world_index].settings.use_ssl = use_ssl;
                                app.worlds[world_index].settings.log_enabled = log_enabled;
                                app.worlds[world_index].settings.encoding = match encoding.as_str() {
                                    "latin1" => Encoding::Latin1,
                                    "fansi" => Encoding::Fansi,
                                    _ => Encoding::Utf8,
                                };
                                app.worlds[world_index].settings.auto_connect_type = AutoConnectType::from_name(&auto_login);
                                app.worlds[world_index].settings.keep_alive_type = KeepAliveType::from_name(&keep_alive_type);
                                app.worlds[world_index].settings.keep_alive_cmd = keep_alive_cmd.clone();
                                let _ = save_settings(&app);
                                let settings_msg = WorldSettingsMsg {
                                    hostname, port, user,
                                    password: encrypt_password(&password),
                                    use_ssl,
                                    log_enabled,
                                    encoding,
                                    auto_connect_type: auto_login,
                                    keep_alive_type,
                                    keep_alive_cmd,
                                };
                                app.ws_broadcast(WsMessage::WorldSettingsUpdated { world_index, settings: settings_msg, name });
                            }
                        }
                        WsMessage::UpdateGlobalSettings { more_mode_enabled, spell_check_enabled, world_switch_mode, show_tags, ansi_music_enabled, console_theme, gui_theme, gui_transparency, input_height, font_name, font_size, ws_allow_list, web_secure, http_enabled, http_port, ws_enabled, ws_port, ws_cert_file, ws_key_file, tls_proxy_enabled } => {
                            app.settings.more_mode_enabled = more_mode_enabled;
                            app.settings.spell_check_enabled = spell_check_enabled;
                            app.settings.world_switch_mode = WorldSwitchMode::from_name(&world_switch_mode);
                            app.show_tags = show_tags;
                            app.settings.ansi_music_enabled = ansi_music_enabled;
                            app.settings.theme = Theme::from_name(&console_theme);
                            app.settings.gui_theme = Theme::from_name(&gui_theme);
                            app.settings.gui_transparency = gui_transparency.clamp(0.3, 1.0);
                            app.input_height = input_height.clamp(1, 15);
                            app.input.visible_height = app.input_height;
                            app.settings.font_name = font_name;
                            app.settings.font_size = font_size.clamp(8.0, 48.0);
                            app.settings.websocket_allow_list = ws_allow_list.clone();
                            if let Some(ref server) = app.ws_server {
                                server.update_allow_list(&ws_allow_list);
                            }
                            app.settings.web_secure = web_secure;
                            app.settings.http_enabled = http_enabled;
                            app.settings.http_port = http_port;
                            app.settings.ws_enabled = ws_enabled;
                            app.settings.ws_port = ws_port;
                            app.settings.websocket_cert_file = ws_cert_file;
                            app.settings.websocket_key_file = ws_key_file;
                            app.settings.tls_proxy_enabled = tls_proxy_enabled;
                            let _ = save_settings(&app);
                            let settings_msg = GlobalSettingsMsg {
                                more_mode_enabled: app.settings.more_mode_enabled,
                                spell_check_enabled: app.settings.spell_check_enabled,
                                world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                                debug_enabled: app.settings.debug_enabled,
                                show_tags: app.show_tags,
                                ansi_music_enabled: app.settings.ansi_music_enabled,
                                console_theme: app.settings.theme.name().to_string(),
                                gui_theme: app.settings.gui_theme.name().to_string(),
                                gui_transparency: app.settings.gui_transparency,
                                input_height: app.input_height,
                                font_name: app.settings.font_name.clone(),
                                font_size: app.settings.font_size,
                                ws_allow_list: app.settings.websocket_allow_list.clone(),
                                web_secure: app.settings.web_secure,
                                http_enabled: app.settings.http_enabled,
                                http_port: app.settings.http_port,
                                ws_enabled: app.settings.ws_enabled,
                                ws_port: app.settings.ws_port,
                                ws_cert_file: app.settings.websocket_cert_file.clone(),
                                ws_key_file: app.settings.websocket_key_file.clone(),
                                tls_proxy_enabled: app.settings.tls_proxy_enabled,
                            };
                            app.ws_broadcast(WsMessage::GlobalSettingsUpdated { settings: settings_msg, input_height: app.input_height });
                        }
                        WsMessage::UpdateActions { actions } => {
                            app.settings.actions = actions.clone();
                            let _ = save_settings(&app);
                            app.ws_broadcast(WsMessage::ActionsUpdated { actions });
                        }
                        WsMessage::CalculateNextWorld { current_index } => {
                            let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                .map(|w| crate::util::WorldSwitchInfo {
                                    name: w.name.clone(),
                                    connected: w.connected,
                                    unseen_lines: w.unseen_lines,
                                    pending_lines: w.pending_lines.len(),
                                })
                                .collect();
                            let next_idx = crate::util::calculate_next_world(
                                &world_info,
                                current_index,
                                app.settings.world_switch_mode,
                            );
                            app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: next_idx });
                        }
                        WsMessage::CalculatePrevWorld { current_index } => {
                            let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                .map(|w| crate::util::WorldSwitchInfo {
                                    name: w.name.clone(),
                                    connected: w.connected,
                                    unseen_lines: w.unseen_lines,
                                    pending_lines: w.pending_lines.len(),
                                })
                                .collect();
                            let prev_idx = crate::util::calculate_prev_world(
                                &world_info,
                                current_index,
                                app.settings.world_switch_mode,
                            );
                            app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: prev_idx });
                        }
                        WsMessage::RequestState => {
                            // Client requested full state resync - send initial state
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                        }
                        WsMessage::BanListRequest => {
                            // Send current ban list to client
                            let bans = app.ban_list.get_ban_info();
                            app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                        }
                        WsMessage::UnbanRequest { host } => {
                            if app.ban_list.remove_ban(&host) {
                                // Save settings to persist the change
                                let _ = save_settings(&app);
                                // Broadcast updated ban list to all clients
                                app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                            } else {
                                app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                            }
                        }
                        _ => {}
                    }
                }
            }
        }

        // If we processed events in try_recv, redraw before waiting in select
        if processed_events {
            terminal.draw(|f| ui(f, &mut app))?;
            render_output_crossterm(&app);
        }
    }
}

enum KeyAction {
    Quit,
    SendCommand(String),
    Connect, // Trigger connection from settings popup
    Redraw,  // Force screen redraw
    Reload,  // Trigger /reload
    UpdateWebSocket, // Check and update WebSocket server state
    SwitchedWorld(usize), // Console switched to this world, broadcast unseen clear
    None,
}

fn handle_key_event(key: KeyEvent, app: &mut App) -> KeyAction {
    // Handle confirm dialog first (highest priority)
    if app.confirm_dialog.visible {
        match key.code {
            KeyCode::Left | KeyCode::Right | KeyCode::Up | KeyCode::Down | KeyCode::Tab => {
                // Toggle between Yes and No
                app.confirm_dialog.yes_selected = !app.confirm_dialog.yes_selected;
            }
            KeyCode::Char('y') | KeyCode::Char('Y') => {
                app.confirm_dialog.yes_selected = true;
            }
            KeyCode::Char('n') | KeyCode::Char('N') => {
                app.confirm_dialog.yes_selected = false;
            }
            KeyCode::Enter => {
                if app.confirm_dialog.yes_selected {
                    // Execute the action
                    match app.confirm_dialog.action {
                        ConfirmAction::DeleteWorld(world_index) => {
                            // Delete the world
                            if app.worlds.len() > 1 {
                                // Save the world name before deletion
                                let world_name = app.worlds[world_index].name.clone();
                                // Disconnect if connected
                                app.worlds[world_index].connected = false;
                                app.worlds[world_index].command_tx = None;
                                app.worlds.remove(world_index);
                                // Adjust current world index
                                if app.current_world_index >= app.worlds.len() {
                                    app.current_world_index = app.worlds.len() - 1;
                                }
                                app.add_output("");
                                app.add_output(&format!("World '{}' deleted.", world_name));
                                app.add_output("");
                                // Save settings to persist deletion
                                let _ = save_settings(app);
                            } else {
                                app.add_output("");
                                app.add_output("Cannot delete the last world.");
                                app.add_output("");
                            }
                        }
                        ConfirmAction::None => {}
                    }
                }
                app.confirm_dialog.close();
                app.settings_popup.close();
            }
            KeyCode::Esc => {
                // Cancel - just close the dialog
                app.confirm_dialog.close();
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle worlds popup input (simple OK dialog)
    if app.worlds_popup.visible {
        match key.code {
            KeyCode::Esc | KeyCode::Enter | KeyCode::Char(' ') => {
                app.worlds_popup.close();
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle help popup input
    if app.help_popup.visible {
        match key.code {
            KeyCode::Esc | KeyCode::Enter => {
                app.help_popup.close();
            }
            KeyCode::Up => {
                app.help_popup.scroll_up();
            }
            KeyCode::Down => {
                // Calculate visible height (popup height - borders - blank line - button line)
                let visible_height = 16usize.saturating_sub(4);
                app.help_popup.scroll_down(visible_height);
            }
            KeyCode::PageUp => {
                for _ in 0..5 {
                    app.help_popup.scroll_up();
                }
            }
            KeyCode::PageDown => {
                let visible_height = 16usize.saturating_sub(4);
                for _ in 0..5 {
                    app.help_popup.scroll_down(visible_height);
                }
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle menu popup input
    if app.menu_popup.visible {
        match key.code {
            KeyCode::Esc => {
                app.menu_popup.close();
            }
            KeyCode::Up => {
                app.menu_popup.move_up();
            }
            KeyCode::Down => {
                app.menu_popup.move_down();
            }
            KeyCode::Enter => {
                // Get the selected item's command and execute it
                let item = app.menu_popup.selected_item();
                app.menu_popup.close();
                // Execute the command
                return KeyAction::SendCommand(item.command().to_string());
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle actions popup input (split into List, Editor, and ConfirmDelete views)
    if app.actions_popup.visible {
        match app.actions_popup.view {
            ActionsView::ConfirmDelete => {
                // Confirm delete dialog
                match key.code {
                    KeyCode::Esc => {
                        app.actions_popup.close_confirm_delete();
                    }
                    KeyCode::Left | KeyCode::Right | KeyCode::Tab => {
                        app.actions_popup.confirm_selected = !app.actions_popup.confirm_selected;
                    }
                    KeyCode::Char('y') | KeyCode::Char('Y') => {
                        // Delete and return to list
                        app.actions_popup.delete_selected_action();
                        app.settings.actions = app.actions_popup.actions.clone();
                        let _ = save_settings(app);
                        app.ws_broadcast(WsMessage::ActionsUpdated {
                            actions: app.settings.actions.clone(),
                        });
                        app.actions_popup.close_confirm_delete();
                    }
                    KeyCode::Char('n') | KeyCode::Char('N') => {
                        app.actions_popup.close_confirm_delete();
                    }
                    KeyCode::Enter => {
                        if app.actions_popup.confirm_selected {
                            // Yes - delete
                            app.actions_popup.delete_selected_action();
                            app.settings.actions = app.actions_popup.actions.clone();
                            let _ = save_settings(app);
                            app.ws_broadcast(WsMessage::ActionsUpdated {
                                actions: app.settings.actions.clone(),
                            });
                        }
                        app.actions_popup.close_confirm_delete();
                    }
                    _ => {}
                }
            }
            ActionsView::Editor => {
                // Editor view
                match key.code {
                    KeyCode::Esc => {
                        app.actions_popup.close_editor();
                    }
                    KeyCode::Tab => {
                        if key.modifiers.contains(KeyModifiers::SHIFT) {
                            app.actions_popup.prev_editor_field();
                        } else {
                            app.actions_popup.next_editor_field();
                        }
                    }
                    KeyCode::Up => {
                        if app.actions_popup.editor_field == ActionEditorField::Command {
                            // In command field: move cursor up if not on first row
                            let (row, _) = app.actions_popup.get_command_cursor_row_col(44);
                            if row > 0 {
                                app.actions_popup.move_command_cursor_up(44);
                                app.actions_popup.adjust_command_scroll(44);
                            } else {
                                app.actions_popup.prev_editor_field();
                            }
                        } else {
                            app.actions_popup.prev_editor_field();
                        }
                    }
                    KeyCode::Down => {
                        if app.actions_popup.editor_field == ActionEditorField::Command {
                            // In command field: move cursor down if not on last row
                            let lines = app.actions_popup.wrap_command_lines(44);
                            let (row, _) = app.actions_popup.get_command_cursor_row_col(44);
                            if row < lines.len().saturating_sub(1) {
                                app.actions_popup.move_command_cursor_down(44);
                                app.actions_popup.adjust_command_scroll(44);
                            } else {
                                app.actions_popup.next_editor_field();
                            }
                        } else {
                            app.actions_popup.next_editor_field();
                        }
                    }
                    KeyCode::Left => {
                        match app.actions_popup.editor_field {
                            ActionEditorField::Name | ActionEditorField::World |
                            ActionEditorField::Pattern => {
                                app.actions_popup.move_cursor_left();
                                app.actions_popup.adjust_scroll(44); // field_width for 60-char popup
                            }
                            ActionEditorField::Command => {
                                app.actions_popup.move_cursor_left();
                                app.actions_popup.adjust_command_scroll(44);
                            }
                            ActionEditorField::MatchType => {
                                // Left/Right toggle match type
                                app.actions_popup.edit_match_type = app.actions_popup.edit_match_type.next();
                            }
                            ActionEditorField::CancelButton => {
                                app.actions_popup.editor_field = ActionEditorField::SaveButton;
                            }
                            _ => {}
                        }
                    }
                    KeyCode::Right => {
                        match app.actions_popup.editor_field {
                            ActionEditorField::Name | ActionEditorField::World |
                            ActionEditorField::Pattern => {
                                app.actions_popup.move_cursor_right();
                                app.actions_popup.adjust_scroll(44); // field_width for 60-char popup
                            }
                            ActionEditorField::Command => {
                                app.actions_popup.move_cursor_right();
                                app.actions_popup.adjust_command_scroll(44);
                            }
                            ActionEditorField::MatchType => {
                                // Left/Right toggle match type
                                app.actions_popup.edit_match_type = app.actions_popup.edit_match_type.next();
                            }
                            ActionEditorField::SaveButton => {
                                app.actions_popup.editor_field = ActionEditorField::CancelButton;
                            }
                            _ => {}
                        }
                    }
                    KeyCode::Home => {
                        app.actions_popup.move_cursor_home();
                        if app.actions_popup.editor_field == ActionEditorField::Command {
                            app.actions_popup.adjust_command_scroll(44);
                        } else {
                            app.actions_popup.adjust_scroll(44);
                        }
                    }
                    KeyCode::End => {
                        app.actions_popup.move_cursor_end();
                        if app.actions_popup.editor_field == ActionEditorField::Command {
                            app.actions_popup.adjust_command_scroll(44);
                        } else {
                            app.actions_popup.adjust_scroll(44);
                        }
                    }
                    KeyCode::Backspace => {
                        app.actions_popup.delete_char();
                        if app.actions_popup.editor_field == ActionEditorField::Command {
                            app.actions_popup.adjust_command_scroll(44);
                        } else {
                            app.actions_popup.adjust_scroll(44);
                        }
                    }
                    KeyCode::Enter => {
                        match app.actions_popup.editor_field {
                            ActionEditorField::SaveButton => {
                                if app.actions_popup.save_current_action() {
                                    app.settings.actions = app.actions_popup.actions.clone();
                                    let _ = save_settings(app);
                                    app.ws_broadcast(WsMessage::ActionsUpdated {
                                        actions: app.settings.actions.clone(),
                                    });
                                    app.actions_popup.close_editor();
                                }
                            }
                            ActionEditorField::CancelButton => {
                                app.actions_popup.close_editor();
                            }
                            ActionEditorField::MatchType => {
                                // Toggle match type
                                app.actions_popup.edit_match_type = app.actions_popup.edit_match_type.next();
                            }
                            _ => {
                                app.actions_popup.next_editor_field();
                            }
                        }
                    }
                    KeyCode::Char(c) => {
                        match app.actions_popup.editor_field {
                            ActionEditorField::Name | ActionEditorField::World |
                            ActionEditorField::Pattern => {
                                app.actions_popup.insert_char(c);
                                app.actions_popup.adjust_scroll(44); // field_width for 60-char popup
                            }
                            ActionEditorField::Command => {
                                app.actions_popup.insert_char(c);
                                app.actions_popup.adjust_command_scroll(44);
                            }
                            ActionEditorField::MatchType => {
                                // Space toggles match type
                                if c == ' ' {
                                    app.actions_popup.edit_match_type = app.actions_popup.edit_match_type.next();
                                }
                            }
                            _ => {}
                        }
                    }
                    _ => {}
                }
            }
            ActionsView::List => {
                // Check if we're in filter editing mode
                if app.actions_popup.filter_editing {
                    match key.code {
                        KeyCode::Esc => {
                            // Exit filter mode, clear filter
                            app.actions_popup.filter.clear();
                            app.actions_popup.filter_cursor = 0;
                            app.actions_popup.stop_filter_edit();
                        }
                        KeyCode::Enter => {
                            // Exit filter mode, keep filter
                            app.actions_popup.stop_filter_edit();
                        }
                        KeyCode::Backspace => {
                            if app.actions_popup.filter_cursor > 0 {
                                app.actions_popup.filter_cursor -= 1;
                                app.actions_popup.filter.remove(app.actions_popup.filter_cursor);
                                // Reset selection to first filtered item
                                let indices = app.actions_popup.filtered_indices();
                                if !indices.is_empty() {
                                    app.actions_popup.selected_index = indices[0];
                                    app.actions_popup.scroll_offset = 0;
                                }
                            }
                        }
                        KeyCode::Delete => {
                            if app.actions_popup.filter_cursor < app.actions_popup.filter.len() {
                                app.actions_popup.filter.remove(app.actions_popup.filter_cursor);
                                let indices = app.actions_popup.filtered_indices();
                                if !indices.is_empty() {
                                    app.actions_popup.selected_index = indices[0];
                                    app.actions_popup.scroll_offset = 0;
                                }
                            }
                        }
                        KeyCode::Left => {
                            if app.actions_popup.filter_cursor > 0 {
                                app.actions_popup.filter_cursor -= 1;
                            }
                        }
                        KeyCode::Right => {
                            if app.actions_popup.filter_cursor < app.actions_popup.filter.len() {
                                app.actions_popup.filter_cursor += 1;
                            }
                        }
                        KeyCode::Home => {
                            app.actions_popup.filter_cursor = 0;
                        }
                        KeyCode::End => {
                            app.actions_popup.filter_cursor = app.actions_popup.filter.len();
                        }
                        KeyCode::Up => {
                            app.actions_popup.select_prev_action();
                        }
                        KeyCode::Down => {
                            app.actions_popup.select_next_action();
                        }
                        KeyCode::Char(c) => {
                            app.actions_popup.filter.insert(app.actions_popup.filter_cursor, c);
                            app.actions_popup.filter_cursor += 1;
                            // Reset selection to first filtered item
                            let indices = app.actions_popup.filtered_indices();
                            if !indices.is_empty() {
                                app.actions_popup.selected_index = indices[0];
                                app.actions_popup.scroll_offset = 0;
                            }
                        }
                        _ => {}
                    }
                } else {
                    // Normal list navigation
                    match key.code {
                        KeyCode::Esc => {
                            app.actions_popup.close();
                        }
                        KeyCode::Tab => {
                            if key.modifiers.contains(KeyModifiers::SHIFT) {
                                app.actions_popup.prev_list_field();
                            } else {
                                app.actions_popup.next_list_field();
                            }
                        }
                        KeyCode::Up => {
                            if app.actions_popup.list_field == ActionListField::List {
                                app.actions_popup.select_prev_action();
                            } else {
                                app.actions_popup.list_field = ActionListField::List;
                            }
                        }
                        KeyCode::Down => {
                            if app.actions_popup.list_field == ActionListField::List {
                                app.actions_popup.select_next_action();
                            } else {
                                app.actions_popup.list_field = ActionListField::List;
                            }
                        }
                        KeyCode::Left => {
                            match app.actions_popup.list_field {
                                ActionListField::EditButton => {
                                    app.actions_popup.list_field = ActionListField::AddButton;
                                }
                                ActionListField::DeleteButton => {
                                    app.actions_popup.list_field = ActionListField::EditButton;
                                }
                                ActionListField::CancelButton => {
                                    app.actions_popup.list_field = ActionListField::DeleteButton;
                                }
                                _ => {}
                            }
                        }
                        KeyCode::Right => {
                            match app.actions_popup.list_field {
                                ActionListField::AddButton => {
                                    app.actions_popup.list_field = ActionListField::EditButton;
                                }
                                ActionListField::EditButton => {
                                    app.actions_popup.list_field = ActionListField::DeleteButton;
                                }
                                ActionListField::DeleteButton => {
                                    app.actions_popup.list_field = ActionListField::CancelButton;
                                }
                                _ => {}
                            }
                        }
                        KeyCode::Enter => {
                            match app.actions_popup.list_field {
                                ActionListField::List => {
                                    // Edit selected action
                                    let indices = app.actions_popup.filtered_indices();
                                    if !indices.is_empty() {
                                        let idx = app.actions_popup.selected_index;
                                        app.actions_popup.open_editor(Some(idx));
                                    }
                                }
                                ActionListField::AddButton => {
                                    app.actions_popup.open_editor(None);
                                }
                                ActionListField::EditButton => {
                                    let indices = app.actions_popup.filtered_indices();
                                    if !indices.is_empty() {
                                        let idx = app.actions_popup.selected_index;
                                        app.actions_popup.open_editor(Some(idx));
                                    }
                                }
                                ActionListField::DeleteButton => {
                                    app.actions_popup.open_confirm_delete();
                                }
                                ActionListField::CancelButton => {
                                    app.actions_popup.close();
                                }
                            }
                        }
                        KeyCode::Char('/') => {
                            // Start filter editing
                            if app.actions_popup.list_field == ActionListField::List {
                                app.actions_popup.start_filter_edit();
                            }
                        }
                        KeyCode::Char(c) => {
                            // Start filtering when typing in list
                            if app.actions_popup.list_field == ActionListField::List {
                                app.actions_popup.start_filter_edit();
                                app.actions_popup.filter.push(c);
                                app.actions_popup.filter_cursor = app.actions_popup.filter.len();
                                // Reset selection to first filtered item
                                let indices = app.actions_popup.filtered_indices();
                                if !indices.is_empty() {
                                    app.actions_popup.selected_index = indices[0];
                                    app.actions_popup.scroll_offset = 0;
                                }
                            }
                        }
                        _ => {}
                    }
                }
            }
        }
        return KeyAction::None;
    }

    // Handle filter popup input
    if app.filter_popup.visible {
        match key.code {
            KeyCode::Esc => {
                app.filter_popup.close();
                app.needs_output_redraw = true;
            }
            KeyCode::F(4) => {
                // F4 again closes the filter
                app.filter_popup.close();
                app.needs_output_redraw = true;
            }
            KeyCode::Backspace => {
                if app.filter_popup.cursor > 0 {
                    app.filter_popup.cursor -= 1;
                    app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                    let output_lines = app.current_world().output_lines.clone();
                    app.filter_popup.update_filter(&output_lines);
                    app.needs_output_redraw = true;
                }
            }
            KeyCode::Delete => {
                if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                    app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                    let output_lines = app.current_world().output_lines.clone();
                    app.filter_popup.update_filter(&output_lines);
                    app.needs_output_redraw = true;
                }
            }
            KeyCode::Left | KeyCode::Char('b') if key.code == KeyCode::Left || key.modifiers.contains(KeyModifiers::CONTROL) => {
                // Left or Ctrl+B = cursor left
                if app.filter_popup.cursor > 0 {
                    app.filter_popup.cursor -= 1;
                }
            }
            KeyCode::Right | KeyCode::Char('f') if key.code == KeyCode::Right || key.modifiers.contains(KeyModifiers::CONTROL) => {
                // Right or Ctrl+F = cursor right
                if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                    app.filter_popup.cursor += 1;
                }
            }
            KeyCode::Home => {
                app.filter_popup.cursor = 0;
            }
            KeyCode::End => {
                app.filter_popup.cursor = app.filter_popup.filter_text.len();
            }
            KeyCode::PageUp => {
                // Scroll up in filtered results
                let visible_height = app.output_height as usize;
                app.filter_popup.scroll_offset = app.filter_popup.scroll_offset
                    .saturating_sub(visible_height.saturating_sub(2));
                app.needs_output_redraw = true;
            }
            KeyCode::PageDown => {
                // Scroll down in filtered results
                let visible_height = app.output_height as usize;
                let max_offset = app.filter_popup.filtered_indices.len().saturating_sub(1);
                app.filter_popup.scroll_offset = (app.filter_popup.scroll_offset + visible_height.saturating_sub(2))
                    .min(max_offset);
                app.needs_output_redraw = true;
            }
            KeyCode::Char(c) => {
                app.filter_popup.filter_text.insert(app.filter_popup.cursor, c);
                app.filter_popup.cursor += 1;
                let output_lines = app.current_world().output_lines.clone();
                app.filter_popup.update_filter(&output_lines);
                app.needs_output_redraw = true;
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle settings popup input
    if app.settings_popup.visible {
        if app.settings_popup.editing {
            // Text editing mode - inline editing
            match key.code {
                KeyCode::Esc => {
                    // Cancel and close popup
                    app.settings_popup.cancel_edit();
                    app.settings_popup.close();
                }
                KeyCode::Backspace => {
                    if app.settings_popup.edit_cursor > 0 {
                        app.settings_popup.edit_cursor -= 1;
                        app.settings_popup.edit_buffer.remove(app.settings_popup.edit_cursor);
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Delete => {
                    if app.settings_popup.edit_cursor < app.settings_popup.edit_buffer.len() {
                        app.settings_popup.edit_buffer.remove(app.settings_popup.edit_cursor);
                    }
                }
                KeyCode::Left => {
                    if app.settings_popup.edit_cursor > 0 {
                        app.settings_popup.edit_cursor -= 1;
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Right => {
                    if app.settings_popup.edit_cursor < app.settings_popup.edit_buffer.len() {
                        app.settings_popup.edit_cursor += 1;
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Char('b') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                    // Ctrl+B = Left (backward)
                    if app.settings_popup.edit_cursor > 0 {
                        app.settings_popup.edit_cursor -= 1;
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Char('f') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                    // Ctrl+F = Right (forward)
                    if app.settings_popup.edit_cursor < app.settings_popup.edit_buffer.len() {
                        app.settings_popup.edit_cursor += 1;
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Home => {
                    app.settings_popup.edit_cursor = 0;
                    app.settings_popup.adjust_scroll(33);
                }
                KeyCode::End => {
                    app.settings_popup.edit_cursor = app.settings_popup.edit_buffer.len();
                    app.settings_popup.adjust_scroll(33);
                }
                KeyCode::Up => {
                    // Commit and move to previous field
                    app.settings_popup.commit_edit();
                    app.settings_popup.prev_field();
                    // Auto-start editing if new field is text
                    if app.settings_popup.selected_field.is_text_field() {
                        app.settings_popup.start_edit();
                    }
                }
                KeyCode::Down | KeyCode::Enter | KeyCode::Tab => {
                    // Commit and move to next field
                    app.settings_popup.commit_edit();
                    app.settings_popup.next_field();
                    // Auto-start editing if new field is text
                    if app.settings_popup.selected_field.is_text_field() {
                        app.settings_popup.start_edit();
                    }
                }
                KeyCode::Char(c) => {
                    app.settings_popup.edit_buffer.insert(app.settings_popup.edit_cursor, c);
                    app.settings_popup.edit_cursor += 1;
                    app.settings_popup.adjust_scroll(33);
                }
                _ => {}
            }
        } else {
            // Navigation mode
            match key.code {
                KeyCode::Esc => {
                    app.settings_popup.close();
                }
                KeyCode::Enter => {
                    if app.settings_popup.selected_field.is_text_field() {
                        // Start editing text field
                        app.settings_popup.start_edit();
                    } else if app.settings_popup.selected_field.is_button() {
                        // Handle buttons
                        match app.settings_popup.selected_field {
                            SettingsField::Connect => {
                                // Save settings first (to the world being edited)
                                let idx = app.settings_popup.editing_world_index.unwrap_or(app.current_world_index);
                                let (new_input_height, new_show_tags) = app.settings_popup
                                    .apply(&mut app.settings, &mut app.worlds[idx]);
                                app.input_height = new_input_height;
                                app.input.visible_height = new_input_height;
                                app.show_tags = new_show_tags;
                                if let Err(e) = save_settings(app) {
                                    app.add_output(&format!("Warning: Could not save settings: {}", e));
                                }
                                app.settings_popup.close();
                                // Return Connect action if not already connected
                                if !app.current_world().connected {
                                    return KeyAction::Connect;
                                } else {
                                    app.add_output("Already connected.");
                                }
                            }
                            SettingsField::SaveSetup => {
                                // Save global settings
                                let (new_input_height, new_show_tags) = app.settings_popup.apply_global(&mut app.settings);
                                app.input_height = new_input_height;
                                app.input.visible_height = new_input_height;
                                app.show_tags = new_show_tags;
                                // Log that debug was enabled/disabled
                                if app.settings.debug_enabled {
                                    debug_log(true, "Debug logging enabled");
                                    app.add_output("Debug logging enabled - writing to ~/clay.debug.log");
                                }
                                if let Err(e) = save_settings(app) {
                                    app.add_output(&format!("Warning: Could not save settings: {}", e));
                                }
                                app.settings_popup.close();
                                // Update WebSocket server state based on new settings
                                return KeyAction::UpdateWebSocket;
                            }
                            SettingsField::CancelSetup => {
                                // Just close without saving
                                app.settings_popup.close();
                            }
                            SettingsField::SaveWorld => {
                                // Save world settings (to the world being edited)
                                let idx = app.settings_popup.editing_world_index.unwrap_or(app.current_world_index);
                                let (new_input_height, new_show_tags) = app.settings_popup
                                    .apply(&mut app.settings, &mut app.worlds[idx]);
                                app.input_height = new_input_height;
                                app.input.visible_height = new_input_height;
                                app.show_tags = new_show_tags;
                                if let Err(e) = save_settings(app) {
                                    app.add_output(&format!("Warning: Could not save settings: {}", e));
                                }
                                app.settings_popup.close();
                            }
                            SettingsField::CancelWorld => {
                                // Just close without saving
                                app.settings_popup.close();
                            }
                            SettingsField::DeleteWorld => {
                                // Show confirmation dialog for the world being edited, not the current world
                                if let Some(world_index) = app.settings_popup.editing_world_index {
                                    let world_name = app.worlds[world_index].name.clone();
                                    app.confirm_dialog.show_delete_world(&world_name, world_index);
                                }
                            }
                            _ => {}
                        }
                    } else {
                        // Toggle/cycle for other fields
                        app.settings_popup.toggle_or_cycle();
                    }
                }
                KeyCode::Up => {
                    if app.settings_popup.selected_field.is_button() {
                        // When on a button, cycle between buttons (same as Left)
                        app.settings_popup.selected_field = match app.settings_popup.selected_field {
                            SettingsField::SaveWorld => SettingsField::Connect,
                            SettingsField::CancelWorld => SettingsField::SaveWorld,
                            SettingsField::DeleteWorld => SettingsField::CancelWorld,
                            SettingsField::Connect => SettingsField::DeleteWorld,
                            SettingsField::SaveSetup => SettingsField::CancelSetup,
                            SettingsField::CancelSetup => SettingsField::SaveSetup,
                            other => other,
                        };
                    } else {
                        app.settings_popup.prev_field();
                        // Auto-start editing if text field
                        if app.settings_popup.selected_field.is_text_field() {
                            app.settings_popup.start_edit();
                        }
                    }
                }
                KeyCode::Down => {
                    if app.settings_popup.selected_field.is_button() {
                        // When on a button, cycle between buttons (same as Right)
                        app.settings_popup.selected_field = match app.settings_popup.selected_field {
                            SettingsField::SaveWorld => SettingsField::CancelWorld,
                            SettingsField::CancelWorld => SettingsField::DeleteWorld,
                            SettingsField::DeleteWorld => SettingsField::Connect,
                            SettingsField::Connect => SettingsField::SaveWorld,
                            SettingsField::SaveSetup => SettingsField::CancelSetup,
                            SettingsField::CancelSetup => SettingsField::SaveSetup,
                            other => other,
                        };
                    } else {
                        app.settings_popup.next_field();
                        // Auto-start editing if text field
                        if app.settings_popup.selected_field.is_text_field() {
                            app.settings_popup.start_edit();
                        }
                    }
                }
                KeyCode::Tab => {
                    app.settings_popup.next_field();
                    // Auto-start editing if text field
                    if app.settings_popup.selected_field.is_text_field() {
                        app.settings_popup.start_edit();
                    }
                }
                KeyCode::Left => {
                    // Decrement for InputHeight, cycle backwards for Encoding/AutoConnect, or move between buttons
                    if app.settings_popup.selected_field == SettingsField::InputHeight {
                        if app.settings_popup.temp_input_height > 1 {
                            app.settings_popup.temp_input_height -= 1;
                        }
                    } else if app.settings_popup.selected_field == SettingsField::Encoding {
                        app.settings_popup.temp_encoding = app.settings_popup.temp_encoding.prev();
                    } else if app.settings_popup.selected_field == SettingsField::AutoConnect {
                        app.settings_popup.temp_auto_connect_type = app.settings_popup.temp_auto_connect_type.prev();
                    } else if app.settings_popup.selected_field == SettingsField::KeepAlive {
                        app.settings_popup.temp_keep_alive_type = app.settings_popup.temp_keep_alive_type.prev();
                    } else if app.settings_popup.selected_field.is_button() {
                        // Move to previous button (world settings buttons)
                        app.settings_popup.selected_field = match app.settings_popup.selected_field {
                            SettingsField::SaveWorld => SettingsField::Connect,
                            SettingsField::CancelWorld => SettingsField::SaveWorld,
                            SettingsField::DeleteWorld => SettingsField::CancelWorld,
                            SettingsField::Connect => SettingsField::DeleteWorld,
                            // Setup mode buttons
                            SettingsField::SaveSetup => SettingsField::CancelSetup,
                            SettingsField::CancelSetup => SettingsField::SaveSetup,
                            other => other,
                        };
                    }
                }
                KeyCode::Right => {
                    // Increment for InputHeight, cycle forwards for Encoding/AutoConnect, or move between buttons
                    if app.settings_popup.selected_field == SettingsField::InputHeight {
                        if app.settings_popup.temp_input_height < 15 {
                            app.settings_popup.temp_input_height += 1;
                        }
                    } else if app.settings_popup.selected_field == SettingsField::Encoding {
                        app.settings_popup.temp_encoding = app.settings_popup.temp_encoding.next();
                    } else if app.settings_popup.selected_field == SettingsField::AutoConnect {
                        app.settings_popup.temp_auto_connect_type = app.settings_popup.temp_auto_connect_type.next();
                    } else if app.settings_popup.selected_field == SettingsField::KeepAlive {
                        app.settings_popup.temp_keep_alive_type = app.settings_popup.temp_keep_alive_type.next();
                    } else if app.settings_popup.selected_field.is_button() {
                        // Move to next button (world settings buttons)
                        app.settings_popup.selected_field = match app.settings_popup.selected_field {
                            SettingsField::SaveWorld => SettingsField::CancelWorld,
                            SettingsField::CancelWorld => SettingsField::DeleteWorld,
                            SettingsField::DeleteWorld => SettingsField::Connect,
                            SettingsField::Connect => SettingsField::SaveWorld,
                            // Setup mode buttons
                            SettingsField::SaveSetup => SettingsField::CancelSetup,
                            SettingsField::CancelSetup => SettingsField::SaveSetup,
                            other => other,
                        };
                    }
                }
                KeyCode::Char(' ') => {
                    if app.settings_popup.selected_field.is_text_field() {
                        app.settings_popup.start_edit();
                        // Insert the space
                        app.settings_popup.edit_buffer.push(' ');
                        app.settings_popup.edit_cursor += 1;
                        app.settings_popup.adjust_scroll(33);
                    } else if app.settings_popup.selected_field.is_button() {
                        // Handle Connect button with Space too
                        if app.settings_popup.selected_field == SettingsField::Connect {
                            let idx = app.settings_popup.editing_world_index.unwrap_or(app.current_world_index);
                            let (new_input_height, new_show_tags) = app.settings_popup
                                .apply(&mut app.settings, &mut app.worlds[idx]);
                            app.input_height = new_input_height;
                            app.input.visible_height = new_input_height;
                            app.show_tags = new_show_tags;
                            if let Err(e) = save_settings(app) {
                                app.add_output(&format!("Warning: Could not save settings: {}", e));
                            }
                            app.settings_popup.close();
                            if !app.current_world().connected {
                                return KeyAction::Connect;
                            } else {
                                app.add_output("Already connected.");
                            }
                        }
                    } else {
                        app.settings_popup.toggle_or_cycle();
                    }
                }
                KeyCode::Char('s') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                    // Ctrl+S to save (to the world being edited)
                    let idx = app.settings_popup.editing_world_index.unwrap_or(app.current_world_index);
                    let (new_input_height, new_show_tags) = app.settings_popup
                        .apply(&mut app.settings, &mut app.worlds[idx]);
                    app.input_height = new_input_height;
                    app.input.visible_height = new_input_height;
                    app.show_tags = new_show_tags;
                    if !app.settings.more_mode_enabled {
                        app.worlds[idx].release_all_pending();
                    }
                    app.settings_popup.close();
                    if let Err(e) = save_settings(app) {
                        app.add_output(&format!("Warning: Could not save settings: {}", e));
                    } else {
                        app.add_output("Settings saved");
                    }
                }
                KeyCode::Char(c) => {
                    // Start editing on any character for text fields
                    if app.settings_popup.selected_field.is_text_field() {
                        app.settings_popup.start_edit();
                        app.settings_popup.edit_buffer.push(c);
                        app.settings_popup.edit_cursor += 1;
                        app.settings_popup.adjust_scroll(33);
                    }
                }
                _ => {}
            }
        }
        return KeyAction::None;
    }

    // Handle web popup input
    if app.web_popup.visible {
        if app.web_popup.editing {
            // Text editing mode
            match key.code {
                KeyCode::Esc => {
                    app.web_popup.cancel_edit();
                    app.web_popup.close();
                }
                KeyCode::Backspace => {
                    if app.web_popup.edit_cursor > 0 {
                        app.web_popup.edit_cursor -= 1;
                        app.web_popup.edit_buffer.remove(app.web_popup.edit_cursor);
                        app.web_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Delete => {
                    if app.web_popup.edit_cursor < app.web_popup.edit_buffer.len() {
                        app.web_popup.edit_buffer.remove(app.web_popup.edit_cursor);
                    }
                }
                KeyCode::Left => {
                    if app.web_popup.edit_cursor > 0 {
                        app.web_popup.edit_cursor -= 1;
                        app.web_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Right => {
                    if app.web_popup.edit_cursor < app.web_popup.edit_buffer.len() {
                        app.web_popup.edit_cursor += 1;
                        app.web_popup.adjust_scroll(33);
                    }
                }
                KeyCode::Home => {
                    app.web_popup.edit_cursor = 0;
                    app.web_popup.adjust_scroll(33);
                }
                KeyCode::End => {
                    app.web_popup.edit_cursor = app.web_popup.edit_buffer.len();
                    app.web_popup.adjust_scroll(33);
                }
                KeyCode::Up => {
                    app.web_popup.commit_edit();
                    app.web_popup.prev_field();
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                    }
                }
                KeyCode::Down | KeyCode::Enter | KeyCode::Tab => {
                    app.web_popup.commit_edit();
                    app.web_popup.next_field();
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                    }
                }
                KeyCode::Char(c) => {
                    app.web_popup.edit_buffer.insert(app.web_popup.edit_cursor, c);
                    app.web_popup.edit_cursor += 1;
                    app.web_popup.adjust_scroll(33);
                }
                _ => {}
            }
        } else {
            // Navigation mode
            match key.code {
                KeyCode::Esc => {
                    app.web_popup.close();
                }
                KeyCode::Enter => {
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                    } else if app.web_popup.selected_field.is_button() {
                        match app.web_popup.selected_field {
                            WebField::SaveWeb => {
                                app.web_popup.apply(&mut app.settings);
                                if let Err(e) = save_settings(app) {
                                    app.add_output(&format!("Warning: Could not save settings: {}", e));
                                }
                                app.web_popup.close();
                                return KeyAction::UpdateWebSocket;
                            }
                            WebField::CancelWeb => {
                                app.web_popup.close();
                            }
                            _ => {}
                        }
                    } else {
                        app.web_popup.toggle_option();
                    }
                }
                KeyCode::Up => {
                    if app.web_popup.selected_field.is_button() {
                        app.web_popup.selected_field = match app.web_popup.selected_field {
                            WebField::SaveWeb => WebField::CancelWeb,
                            WebField::CancelWeb => WebField::SaveWeb,
                            other => other,
                        };
                    } else {
                        app.web_popup.prev_field();
                        if app.web_popup.selected_field.is_text_field() {
                            app.web_popup.start_edit();
                        }
                    }
                }
                KeyCode::Down => {
                    if app.web_popup.selected_field.is_button() {
                        app.web_popup.selected_field = match app.web_popup.selected_field {
                            WebField::SaveWeb => WebField::CancelWeb,
                            WebField::CancelWeb => WebField::SaveWeb,
                            other => other,
                        };
                    } else {
                        app.web_popup.next_field();
                        if app.web_popup.selected_field.is_text_field() {
                            app.web_popup.start_edit();
                        }
                    }
                }
                KeyCode::Tab => {
                    app.web_popup.next_field();
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                    }
                }
                KeyCode::Left | KeyCode::Right => {
                    if app.web_popup.selected_field.is_button() {
                        app.web_popup.selected_field = match app.web_popup.selected_field {
                            WebField::SaveWeb => WebField::CancelWeb,
                            WebField::CancelWeb => WebField::SaveWeb,
                            other => other,
                        };
                    }
                }
                KeyCode::Char(' ') => {
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                        app.web_popup.edit_buffer.push(' ');
                        app.web_popup.edit_cursor += 1;
                        app.web_popup.adjust_scroll(33);
                    } else if !app.web_popup.selected_field.is_button() {
                        app.web_popup.toggle_option();
                    }
                }
                KeyCode::Char('s') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                    app.web_popup.apply(&mut app.settings);
                    app.web_popup.close();
                    if let Err(e) = save_settings(app) {
                        app.add_output(&format!("Warning: Could not save settings: {}", e));
                    } else {
                        app.add_output("Web settings saved");
                    }
                    return KeyAction::UpdateWebSocket;
                }
                KeyCode::Char(c) => {
                    if app.web_popup.selected_field.is_text_field() {
                        app.web_popup.start_edit();
                        app.web_popup.edit_buffer.push(c);
                        app.web_popup.edit_cursor += 1;
                        app.web_popup.adjust_scroll(33);
                    }
                }
                _ => {}
            }
        }
        return KeyAction::None;
    }

    // Handle world selector popup input
    if app.world_selector.visible {
        // Handle delete confirmation dialog first
        if app.world_selector.confirm_delete {
            match key.code {
                KeyCode::Esc => {
                    // Cancel delete
                    app.world_selector.confirm_delete = false;
                }
                KeyCode::Char('y') | KeyCode::Char('Y') => {
                    // Confirm delete
                    app.world_selector.confirm_delete_selected = true;
                    // Delete the selected world
                    let idx = app.world_selector.selected_index;
                    if app.worlds.len() > 1 && idx < app.worlds.len() {
                        let deleted_name = app.worlds[idx].name.clone();
                        app.worlds.remove(idx);
                        // Adjust current_world_index if needed
                        if app.current_world_index >= app.worlds.len() {
                            app.current_world_index = app.worlds.len().saturating_sub(1);
                        } else if app.current_world_index > idx {
                            app.current_world_index -= 1;
                        }
                        // Adjust selected_index
                        if app.world_selector.selected_index >= app.worlds.len() {
                            app.world_selector.selected_index = app.worlds.len().saturating_sub(1);
                        }
                        app.add_output(&format!("World '{}' deleted.\n", deleted_name));
                        let _ = save_settings(app);
                    }
                    app.world_selector.confirm_delete = false;
                }
                KeyCode::Char('n') | KeyCode::Char('N') => {
                    // Cancel delete
                    app.world_selector.confirm_delete = false;
                }
                KeyCode::Enter => {
                    if app.world_selector.confirm_delete_selected {
                        // Yes selected - delete
                        let idx = app.world_selector.selected_index;
                        if app.worlds.len() > 1 && idx < app.worlds.len() {
                            let deleted_name = app.worlds[idx].name.clone();
                            app.worlds.remove(idx);
                            if app.current_world_index >= app.worlds.len() {
                                app.current_world_index = app.worlds.len().saturating_sub(1);
                            } else if app.current_world_index > idx {
                                app.current_world_index -= 1;
                            }
                            if app.world_selector.selected_index >= app.worlds.len() {
                                app.world_selector.selected_index = app.worlds.len().saturating_sub(1);
                            }
                            app.add_output(&format!("World '{}' deleted.\n", deleted_name));
                            let _ = save_settings(app);
                        }
                    }
                    app.world_selector.confirm_delete = false;
                }
                KeyCode::Left | KeyCode::Right | KeyCode::Up | KeyCode::Down | KeyCode::Tab | KeyCode::BackTab => {
                    // Toggle between Yes and No
                    app.world_selector.confirm_delete_selected = !app.world_selector.confirm_delete_selected;
                }
                _ => {}
            }
            return KeyAction::None;
        }

        if app.world_selector.editing_filter {
            // Filter text editing mode
            match key.code {
                KeyCode::Esc => {
                    // Stop editing filter but keep popup open
                    app.world_selector.stop_filter_edit();
                }
                KeyCode::Enter => {
                    // Stop editing and connect to selected world
                    app.world_selector.stop_filter_edit();
                    let idx = app.world_selector.selected_index;
                    app.world_selector.close();
                    app.switch_world(idx);
                    if !app.current_world().connected
                        && app.current_world().settings.has_connection_settings()
                    {
                        return KeyAction::Connect;
                    }
                }
                KeyCode::Backspace => {
                    if app.world_selector.filter_cursor > 0 {
                        app.world_selector.filter_cursor -= 1;
                        app.world_selector.filter.remove(app.world_selector.filter_cursor);
                        // Reset selection to first filtered item
                        let indices = app.world_selector.filtered_indices(&app.worlds);
                        if !indices.is_empty() {
                            app.world_selector.selected_index = indices[0];
                        }
                    }
                }
                KeyCode::Delete => {
                    if app.world_selector.filter_cursor < app.world_selector.filter.len() {
                        app.world_selector.filter.remove(app.world_selector.filter_cursor);
                        let indices = app.world_selector.filtered_indices(&app.worlds);
                        if !indices.is_empty() {
                            app.world_selector.selected_index = indices[0];
                        }
                    }
                }
                KeyCode::Left => {
                    if app.world_selector.filter_cursor > 0 {
                        app.world_selector.filter_cursor -= 1;
                    }
                }
                KeyCode::Right => {
                    if app.world_selector.filter_cursor < app.world_selector.filter.len() {
                        app.world_selector.filter_cursor += 1;
                    }
                }
                KeyCode::Home => {
                    app.world_selector.filter_cursor = 0;
                }
                KeyCode::End => {
                    app.world_selector.filter_cursor = app.world_selector.filter.len();
                }
                KeyCode::Up => {
                    // In filter mode, just move through list (ignore if at edge)
                    let _ = app.world_selector.move_up(&app.worlds);
                }
                KeyCode::Down => {
                    // In filter mode, just move through list (ignore if at edge)
                    let _ = app.world_selector.move_down(&app.worlds);
                }
                KeyCode::Char(c) => {
                    app.world_selector.filter.insert(app.world_selector.filter_cursor, c);
                    app.world_selector.filter_cursor += 1;
                    // Reset selection to first filtered item
                    let indices = app.world_selector.filtered_indices(&app.worlds);
                    if !indices.is_empty() {
                        app.world_selector.selected_index = indices[0];
                    }
                }
                _ => {}
            }
        } else {
            // Navigation mode
            match key.code {
                KeyCode::Esc => {
                    app.world_selector.close();
                }
                KeyCode::Tab => {
                    // Cycle focus: List -> Edit -> Connect -> Cancel -> List
                    app.world_selector.next_focus();
                }
                KeyCode::BackTab => {
                    // Reverse cycle
                    app.world_selector.prev_focus();
                }
                KeyCode::Enter => {
                    // Action depends on current focus
                    match app.world_selector.focus {
                        WorldSelectorFocus::List | WorldSelectorFocus::ConnectButton => {
                            // Connect to selected world
                            let idx = app.world_selector.selected_index;
                            app.world_selector.close();
                            app.switch_world(idx);
                            if !app.current_world().connected
                                && app.current_world().settings.has_connection_settings()
                            {
                                return KeyAction::Connect;
                            }
                        }
                        WorldSelectorFocus::AddButton => {
                            // Create new world and open editor
                            let new_idx = app.worlds.len();
                            let new_name = format!("world{}", new_idx + 1);
                            app.worlds.push(World::new(&new_name));
                            app.switch_world(new_idx);  // Switch to the new world
                            app.world_selector.close();
                            let input_height = app.input_height;
                            let show_tags = app.show_tags;
                            app.settings_popup.open(&app.settings, &app.worlds[new_idx], new_idx, input_height, show_tags);
                        }
                        WorldSelectorFocus::EditButton => {
                            // Edit selected world (don't switch current world)
                            let idx = app.world_selector.selected_index;
                            app.world_selector.close();
                            let input_height = app.input_height;
                            let show_tags = app.show_tags;
                            app.settings_popup.open(&app.settings, &app.worlds[idx], idx, input_height, show_tags);
                        }
                        WorldSelectorFocus::DeleteButton => {
                            // Show delete confirmation
                            if app.worlds.len() > 1 {
                                app.world_selector.confirm_delete = true;
                                app.world_selector.confirm_delete_selected = false; // Default to No
                            } else {
                                app.add_output("Cannot delete the last world.\n");
                            }
                        }
                        WorldSelectorFocus::CancelButton => {
                            // Close without action
                            app.world_selector.close();
                        }
                    }
                }
                KeyCode::Up => {
                    if app.world_selector.focus == WorldSelectorFocus::List {
                        // Try to move up in list, if at top go to last button
                        if app.world_selector.move_up(&app.worlds) {
                            app.world_selector.focus = WorldSelectorFocus::CancelButton;
                        }
                    } else if app.world_selector.focus == WorldSelectorFocus::AddButton {
                        // At first button, go back to last item in list
                        app.world_selector.focus = WorldSelectorFocus::List;
                        app.world_selector.move_to_last(&app.worlds);
                    } else {
                        // Move to previous button
                        app.world_selector.prev_focus();
                    }
                }
                KeyCode::Down => {
                    if app.world_selector.focus == WorldSelectorFocus::List {
                        // Try to move down in list, if at bottom go to first button
                        if app.world_selector.move_down(&app.worlds) {
                            app.world_selector.focus = WorldSelectorFocus::AddButton;
                        }
                    } else if app.world_selector.focus == WorldSelectorFocus::CancelButton {
                        // At last button, go back to first item in list
                        app.world_selector.focus = WorldSelectorFocus::List;
                        app.world_selector.move_to_first(&app.worlds);
                    } else {
                        // Move to next button
                        app.world_selector.next_focus();
                    }
                }
                KeyCode::Left => {
                    // Move between buttons
                    if app.world_selector.focus != WorldSelectorFocus::List {
                        app.world_selector.prev_focus();
                        // Skip List when using Left/Right
                        if app.world_selector.focus == WorldSelectorFocus::List {
                            app.world_selector.focus = WorldSelectorFocus::CancelButton;
                        }
                    }
                }
                KeyCode::Right => {
                    // Move between buttons
                    if app.world_selector.focus != WorldSelectorFocus::List {
                        app.world_selector.next_focus();
                        // Skip List when using Left/Right
                        if app.world_selector.focus == WorldSelectorFocus::List {
                            app.world_selector.focus = WorldSelectorFocus::AddButton;
                        }
                    }
                }
                KeyCode::Char('/') => {
                    // Start filter editing
                    app.world_selector.focus = WorldSelectorFocus::List;
                    app.world_selector.start_filter_edit();
                }
                KeyCode::Char(c) => {
                    // Start filter editing with this character (only from List focus)
                    if app.world_selector.focus == WorldSelectorFocus::List {
                        app.world_selector.start_filter_edit();
                        app.world_selector.filter.push(c);
                        app.world_selector.filter_cursor = app.world_selector.filter.len();
                        // Reset selection to first filtered item
                        let indices = app.world_selector.filtered_indices(&app.worlds);
                        if !indices.is_empty() {
                            app.world_selector.selected_index = indices[0];
                        }
                    }
                }
                _ => {}
            }
        }
        return KeyAction::None;
    }

    // Handle Tab for command completion when input starts with /
    if key.code == KeyCode::Tab && key.modifiers.is_empty() && app.input.buffer.starts_with('/') {
        // Get the current partial command (everything up to first space, or whole buffer)
        let input = app.input.buffer.clone();
        let partial = if let Some(space_pos) = input.find(' ') {
            &input[..space_pos]
        } else {
            input.as_str()
        };

        // Only complete if we're still in the command part (no space yet or cursor before space)
        if !input.contains(' ') || app.input.cursor_position <= input.find(' ').unwrap_or(input.len()) {
            // Build list of completions: internal commands + manual actions
            let internal_commands = vec![
                "/help", "/disconnect", "/dc", "/send", "/worlds", "/connections",
                "/setup", "/web", "/actions", "/keepalive", "/reload", "/quit", "/gag", "/testmusic",
            ];

            // Get manual actions (empty pattern)
            let manual_actions: Vec<String> = app.settings.actions.iter()
                .filter(|a| a.pattern.is_empty())
                .map(|a| format!("/{}", a.name))
                .collect();

            // Find all matches
            let partial_lower = partial.to_lowercase();
            let mut matches: Vec<String> = internal_commands.iter()
                .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                .map(|s| s.to_string())
                .collect();
            matches.extend(manual_actions.iter()
                .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                .cloned());

            if !matches.is_empty() {
                // Sort matches alphabetically
                matches.sort();
                matches.dedup();

                // Find current match index if we're already on a completed command
                let current_idx = matches.iter().position(|m| m.eq_ignore_ascii_case(partial));

                // Get next match (cycle through)
                let next_idx = match current_idx {
                    Some(idx) => (idx + 1) % matches.len(),
                    None => 0,
                };

                // Replace the command part with the completion
                let completion = &matches[next_idx];
                if input.contains(' ') {
                    // Preserve arguments after the command
                    let args_start = input.find(' ').unwrap();
                    app.input.buffer = format!("{}{}", completion, &input[args_start..]);
                } else {
                    app.input.buffer = completion.clone();
                }
                app.input.cursor_position = completion.len();
                return KeyAction::None;
            }
        }
    }

    // Handle Tab - release pending lines when paused, or scroll down when viewing history
    if key.code == KeyCode::Tab && key.modifiers.is_empty() {
        if app.current_world().paused {
            // Paused with pending lines - release one screenful
            let batch_size = (app.output_height as usize).saturating_sub(2);
            let world_idx = app.current_world_index;
            let pending_before = app.worlds[world_idx].pending_lines.len();
            app.current_world_mut().release_pending(batch_size);
            let released = pending_before - app.worlds[world_idx].pending_lines.len();
            // Broadcast release event so other clients sync
            app.ws_broadcast(WsMessage::PendingReleased { world_index: world_idx, count: released });
            // Also broadcast updated pending count
            let pending_count = app.worlds[world_idx].pending_lines.len();
            app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: pending_count });
            app.needs_output_redraw = true;
            return KeyAction::None;
        } else if !app.current_world().is_at_bottom() {
            // Not paused but scrolled back (Hist indicator showing) - scroll down like PgDn
            app.scroll_output_down();
            return KeyAction::None;
        }
    }

    // Helper to check if escape was pressed recently (for Escape+key sequences)
    let recent_escape = app.last_escape
        .map(|t| t.elapsed() < Duration::from_millis(500))
        .unwrap_or(false);

    // Track bare Escape key presses for Escape+key sequences
    if key.code == KeyCode::Esc && key.modifiers.is_empty() {
        app.last_escape = Some(std::time::Instant::now());
        return KeyAction::None;
    }

    // Handle Escape+j (Alt+j) to jump to end - release all pending
    if key.code == KeyCode::Char('j') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None; // Clear escape state
        if app.current_world().paused {
            let world_idx = app.current_world_index;
            let released = app.worlds[world_idx].pending_lines.len();
            app.current_world_mut().release_all_pending();
            // Broadcast release event so other clients sync
            app.ws_broadcast(WsMessage::PendingReleased { world_index: world_idx, count: released });
            // Also broadcast updated pending count
            app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: 0 });
            app.needs_output_redraw = true;
        }
        return KeyAction::None;
    }

    // Handle Escape+w (Alt+w) to switch to world with oldest pending output
    if key.code == KeyCode::Char('w') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None; // Clear escape state
        app.switch_to_oldest_pending();
        return KeyAction::None;
    }

    match (key.modifiers, key.code) {
        (KeyModifiers::CONTROL, KeyCode::Char('c')) => {
            // Check if we pressed Ctrl+C within the last 15 seconds
            if let Some(last_time) = app.last_ctrl_c {
                if last_time.elapsed() < Duration::from_secs(15) {
                    return KeyAction::Quit;
                }
            }
            // First Ctrl+C or timeout - show message and record time
            app.last_ctrl_c = Some(std::time::Instant::now());
            app.add_output("Press Ctrl+C again within 15 seconds to exit, or use /quit");
            KeyAction::None
        }

        // Ctrl+L to redraw screen
        (KeyModifiers::CONTROL, KeyCode::Char('l')) => KeyAction::Redraw,

        // Ctrl+R to reload
        (KeyModifiers::CONTROL, KeyCode::Char('r')) => KeyAction::Reload,

        // F1 to open help popup
        (_, KeyCode::F(1)) => {
            app.help_popup.open();
            KeyAction::None
        }

        // F2 to toggle tag display
        (_, KeyCode::F(2)) => {
            app.show_tags = !app.show_tags;
            KeyAction::Redraw // Force full screen redraw to apply change
        }

        // F8 to toggle action pattern highlighting
        (_, KeyCode::F(8)) => {
            app.highlight_actions = !app.highlight_actions;
            KeyAction::Redraw // Force full screen redraw to apply change
        }

        // F4 to open filter popup
        (_, KeyCode::F(4)) => {
            app.filter_popup.open();
            let output_lines = app.current_world().output_lines.clone();
            app.filter_popup.update_filter(&output_lines);
            app.needs_output_redraw = true;
            KeyAction::None
        }

        // Switch worlds (Up/Down without modifiers)
        (KeyModifiers::NONE, KeyCode::Up) => {
            app.prev_world();
            KeyAction::SwitchedWorld(app.current_world_index)
        }
        (KeyModifiers::NONE, KeyCode::Down) => {
            app.next_world();
            KeyAction::SwitchedWorld(app.current_world_index)
        }

        // Resize input area
        (KeyModifiers::CONTROL, KeyCode::Up) => {
            app.increase_input_height();
            KeyAction::None
        }
        (KeyModifiers::CONTROL, KeyCode::Down) => {
            app.decrease_input_height();
            KeyAction::None
        }

        // Switch worlds (all that have been connected)
        (KeyModifiers::SHIFT, KeyCode::Up) => {
            app.prev_world_all();
            KeyAction::SwitchedWorld(app.current_world_index)
        }
        (KeyModifiers::SHIFT, KeyCode::Down) => {
            app.next_world_all();
            KeyAction::SwitchedWorld(app.current_world_index)
        }

        // Clear input
        (KeyModifiers::CONTROL, KeyCode::Char('u')) => {
            app.input.clear();
            app.spell_state.reset();
            app.suggestion_message = None;
            KeyAction::None
        }

        // Delete word before cursor
        (KeyModifiers::CONTROL, KeyCode::Char('w')) => {
            app.input.delete_word_before_cursor();
            app.spell_state.reset();
            app.suggestion_message = None;
            app.last_input_was_delete = true;
            KeyAction::None
        }

        // History navigation
        (KeyModifiers::CONTROL, KeyCode::Char('p')) => {
            app.input.history_prev();
            app.spell_state.reset();
            KeyAction::None
        }
        (KeyModifiers::CONTROL, KeyCode::Char('n')) => {
            app.input.history_next();
            app.spell_state.reset();
            KeyAction::None
        }

        // Spell check
        (KeyModifiers::CONTROL, KeyCode::Char('q')) => {
            app.handle_spell_check();
            KeyAction::None
        }

        // Submit
        (_, KeyCode::Enter) => {
            // If paused, release all pending and submit
            if app.current_world().paused {
                let world_idx = app.current_world_index;
                app.current_world_mut().release_all_pending();
                // Broadcast updated pending count to GUI clients
                app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: 0 });
            }
            let input = app.input.take_input();
            // Allow empty input to be sent if connected (some MUDs use empty lines)
            if !input.is_empty() || app.current_world().connected {
                // Reset more mode counter now, before any queued output is processed
                app.current_world_mut().lines_since_pause = 0;
                KeyAction::SendCommand(input)
            } else {
                KeyAction::None
            }
        }

        // Editing
        (_, KeyCode::Backspace) => {
            app.input.delete_char();
            app.last_input_was_delete = true;
            KeyAction::None
        }
        (_, KeyCode::Delete) => {
            app.input.delete_char_forward();
            app.last_input_was_delete = true;
            KeyAction::None
        }

        // Cursor movement
        (_, KeyCode::Left) | (KeyModifiers::CONTROL, KeyCode::Char('b')) => {
            app.input.move_cursor_left();
            KeyAction::None
        }
        (_, KeyCode::Right) | (KeyModifiers::CONTROL, KeyCode::Char('f')) => {
            app.input.move_cursor_right();
            KeyAction::None
        }
        (_, KeyCode::Home) | (KeyModifiers::CONTROL, KeyCode::Char('a')) => {
            app.input.home();
            KeyAction::None
        }
        (_, KeyCode::End) => {
            app.input.end();
            KeyAction::None
        }

        // Output scrolling (history)
        (_, KeyCode::PageUp) => {
            app.scroll_output_up();
            KeyAction::None
        }
        (_, KeyCode::PageDown) => {
            app.scroll_output_down();
            KeyAction::None
        }

        // Character input
        (_, KeyCode::Char(c)) => {
            if !c.is_alphabetic() && app.spell_state.showing_suggestions {
                app.spell_state.reset();
            }
            app.input.insert_char(c);
            app.last_input_was_delete = false;
            KeyAction::None
        }

        _ => KeyAction::None,
    }
}

// ============================================================================
// Slack Socket Mode Connection
// ============================================================================

async fn connect_slack(app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    // Capture world name for the reader task (stable across world deletions)
    let world_name = app.current_world().name.clone();

    // Clone settings values first to avoid borrow conflicts
    let token = app.current_world().settings.slack_token.clone();
    let channel = app.current_world().settings.slack_channel.clone();

    if token.is_empty() {
        app.add_output("Error: Slack token is required.");
        app.add_output("Configure the token in world settings (/worlds -e)");
        return false;
    }

    app.add_output("");
    app.add_output("Connecting to Slack...");
    app.add_output("");

    // Get WebSocket URL from Slack API
    let client = reqwest::Client::new();
    let response = match client
        .post("https://slack.com/api/apps.connections.open")
        .header("Authorization", format!("Bearer {}", token))
        .header("Content-Type", "application/x-www-form-urlencoded")
        .send()
        .await
    {
        Ok(r) => r,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Slack API: {}", e));
            return false;
        }
    };

    let body: serde_json::Value = match response.json().await {
        Ok(j) => j,
        Err(e) => {
            app.add_output(&format!("Failed to parse Slack response: {}", e));
            return false;
        }
    };

    if body.get("ok").and_then(|v| v.as_bool()) != Some(true) {
        let error = body.get("error").and_then(|v| v.as_str()).unwrap_or("unknown");
        app.add_output(&format!("Slack API error: {}", error));
        return false;
    }

    let ws_url = match body.get("url").and_then(|v| v.as_str()) {
        Some(u) => u.to_string(),
        None => {
            app.add_output("Slack response missing WebSocket URL");
            return false;
        }
    };

    app.add_output("Got WebSocket URL, connecting...");

    // Connect to Slack WebSocket
    use tokio_tungstenite::tungstenite::Message as WsMsg;
    use futures::StreamExt;

    let (ws_stream, _) = match tokio_tungstenite::connect_async(&ws_url).await {
        Ok(s) => s,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Slack WebSocket: {}", e));
            return false;
        }
    };

    app.add_output("Connected to Slack!");
    app.current_world_mut().connected = true;
    app.current_world_mut().was_connected = true;

    let (write, mut read) = ws_stream.split();
    let write = std::sync::Arc::new(tokio::sync::Mutex::new(write));

    // Create command channel for sending messages
    let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
    app.current_world_mut().command_tx = Some(cmd_tx);

    // Spawn reader task
    let event_tx_clone = event_tx.clone();
    let _token_clone = token.clone(); // Reserved for future use (user lookup, etc.)
    let channel_clone = channel.clone();
    let write_clone = write.clone();

    tokio::spawn(async move {
        use futures::SinkExt;

        while let Some(msg) = read.next().await {
            match msg {
                Ok(WsMsg::Text(text)) => {
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
                        // Handle envelope acknowledgment
                        if let Some(envelope_id) = json.get("envelope_id").and_then(|v| v.as_str()) {
                            let ack = serde_json::json!({ "envelope_id": envelope_id });
                            let mut w = write_clone.lock().await;
                            let _ = w.send(WsMsg::Text(ack.to_string().into())).await;
                        }

                        // Handle events
                        if let Some(payload) = json.get("payload") {
                            if let Some(event) = payload.get("event") {
                                let event_type = event.get("type").and_then(|v| v.as_str()).unwrap_or("");

                                if event_type == "message" {
                                    // Check if it's the right channel
                                    let msg_channel = event.get("channel").and_then(|v| v.as_str()).unwrap_or("");
                                    if channel_clone.is_empty() || msg_channel == channel_clone || msg_channel.contains(&channel_clone) {
                                        let user = event.get("user").and_then(|v| v.as_str()).unwrap_or("unknown");
                                        let text = event.get("text").and_then(|v| v.as_str()).unwrap_or("");
                                        let formatted = format!("[{}] <{}> {}", msg_channel, user, text);
                                        let _ = event_tx_clone.send(AppEvent::SlackMessage(world_name.clone(), formatted)).await;
                                    }
                                }
                            }
                        }
                    }
                }
                Ok(WsMsg::Close(_)) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone())).await;
                    break;
                }
                Err(_) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone())).await;
                    break;
                }
                _ => {}
            }
        }
    });

    // Spawn writer task for sending messages
    let token_for_writer = token.clone();
    let channel_for_writer = channel.clone();
    tokio::spawn(async move {
        let client = reqwest::Client::new();
        while let Some(cmd) = cmd_rx.recv().await {
            let text = match cmd {
                WriteCommand::Text(t) => t,
                WriteCommand::Raw(r) => String::from_utf8_lossy(&r).to_string(),
                WriteCommand::Shutdown => break,
            };
            // Send message via chat.postMessage API
            let _ = client
                .post("https://slack.com/api/chat.postMessage")
                .header("Authorization", format!("Bearer {}", token_for_writer))
                .header("Content-Type", "application/json")
                .json(&serde_json::json!({
                    "channel": channel_for_writer,
                    "text": text
                }))
                .send()
                .await;
        }
    });

    false
}

// ============================================================================
// Discord Gateway Bot Connection
// ============================================================================

async fn connect_discord(app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    // Capture world name for the reader task (stable across world deletions)
    let world_name = app.current_world().name.clone();

    // Clone settings values first to avoid borrow conflicts
    let token = app.current_world().settings.discord_token.clone();
    let _guild_id = app.current_world().settings.discord_guild.clone();
    let mut channel_id = app.current_world().settings.discord_channel.clone();
    let dm_user = app.current_world().settings.discord_dm_user.clone();

    if token.is_empty() {
        app.add_output("Error: Discord token is required.");
        app.add_output("Configure the token in world settings (/worlds -e)");
        return false;
    }

    app.add_output("");
    app.add_output("Connecting to Discord...");

    // If DM user is set, create a DM channel first
    if !dm_user.is_empty() && channel_id.is_empty() {
        app.add_output(&format!("Creating DM channel with user {}...", dm_user));

        let client = reqwest::Client::new();
        let response = match client
            .post("https://discord.com/api/v10/users/@me/channels")
            .header("Authorization", format!("Bot {}", token))
            .header("Content-Type", "application/json")
            .json(&serde_json::json!({
                "recipient_id": dm_user
            }))
            .send()
            .await
        {
            Ok(r) => r,
            Err(e) => {
                app.add_output(&format!("Failed to create DM channel: {}", e));
                return false;
            }
        };

        let status = response.status();
        let body: serde_json::Value = match response.json().await {
            Ok(j) => j,
            Err(e) => {
                app.add_output(&format!("Failed to parse DM response: {} (HTTP {})", e, status));
                return false;
            }
        };

        if status.is_success() {
            if let Some(id) = body.get("id").and_then(|v| v.as_str()) {
                channel_id = id.to_string();
                app.add_output(&format!("DM channel created: {}", channel_id));
            } else {
                app.add_output("Failed to create DM channel: no channel ID in response");
                app.add_output(&format!("Response: {}", body));
                return false;
            }
        } else {
            let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
            let error_code = body.get("code").and_then(|v| v.as_i64());
            app.add_output(&format!("Failed to create DM channel (HTTP {}): {}", status.as_u16(), error_msg));
            if let Some(code) = error_code {
                app.add_output(&format!("Discord error code: {}", code));
            }
            // Show hint for common errors
            if status.as_u16() == 401 {
                app.add_output("Hint: Check that your bot token is correct and includes 'Bot ' prefix if needed");
            } else if status.as_u16() == 403 {
                app.add_output("Hint: Bot may lack permissions or the user has DMs disabled");
            }
            return false;
        }
    }

    // Resolve channel name to ID if needed
    let guild_id = app.current_world().settings.discord_guild.clone();
    if !channel_id.is_empty() && !channel_id.chars().all(|c| c.is_ascii_digit()) {
        // Channel is a name, not an ID - need to resolve it
        if guild_id.is_empty() {
            app.add_output("Error: Guild ID is required when using a channel name.");
            app.add_output("Either use a numeric channel ID or configure the Guild ID.");
            return false;
        }

        app.add_output(&format!("Resolving channel name '{}'...", channel_id));

        let client = reqwest::Client::new();
        let url = format!("https://discord.com/api/v10/guilds/{}/channels", guild_id);
        let response = match client
            .get(&url)
            .header("Authorization", format!("Bot {}", token))
            .send()
            .await
        {
            Ok(r) => r,
            Err(e) => {
                app.add_output(&format!("Failed to fetch guild channels: {}", e));
                return false;
            }
        };

        let status = response.status();
        if !status.is_success() {
            let body: serde_json::Value = response.json().await.unwrap_or_default();
            let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
            app.add_output(&format!("Failed to fetch guild channels (HTTP {}): {}", status.as_u16(), error_msg));
            return false;
        }

        let channels: Vec<serde_json::Value> = match response.json().await {
            Ok(c) => c,
            Err(e) => {
                app.add_output(&format!("Failed to parse channels response: {}", e));
                return false;
            }
        };

        // Find channel by name (case-insensitive)
        let channel_name_lower = channel_id.to_lowercase();
        let found_channel = channels.iter().find(|ch| {
            ch.get("name")
                .and_then(|n| n.as_str())
                .map(|n| n.to_lowercase() == channel_name_lower)
                .unwrap_or(false)
        });

        match found_channel {
            Some(ch) => {
                if let Some(id) = ch.get("id").and_then(|v| v.as_str()) {
                    app.add_output(&format!("Resolved '{}' to channel ID {}", channel_id, id));
                    channel_id = id.to_string();
                } else {
                    app.add_output(&format!("Channel '{}' found but has no ID", channel_id));
                    return false;
                }
            }
            None => {
                app.add_output(&format!("Channel '{}' not found in guild", channel_id));
                // List available channels as a hint
                let available: Vec<&str> = channels.iter()
                    .filter_map(|ch| ch.get("name").and_then(|n| n.as_str()))
                    .take(10)
                    .collect();
                if !available.is_empty() {
                    app.add_output(&format!("Available channels: {}", available.join(", ")));
                }
                return false;
            }
        }
    }

    app.add_output("");

    // Connect to Discord Gateway
    use tokio_tungstenite::tungstenite::Message as WsMsg;
    use futures::StreamExt;

    let (ws_stream, _) = match tokio_tungstenite::connect_async("wss://gateway.discord.gg/?v=10&encoding=json").await {
        Ok(s) => s,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Discord Gateway: {}", e));
            return false;
        }
    };

    let (write, mut read) = ws_stream.split();
    let write = std::sync::Arc::new(tokio::sync::Mutex::new(write));

    // Create command channel for sending messages
    let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
    app.current_world_mut().command_tx = Some(cmd_tx);

    // Clone world_name for both spawns before moving into first one
    let world_name_for_writer = world_name.clone();

    // Spawn reader/heartbeat task
    let event_tx_clone = event_tx.clone();
    let token_clone = token.clone();
    let channel_id_clone = channel_id.clone();
    let write_clone = write.clone();

    tokio::spawn(async move {
        use futures::SinkExt;

        let mut _heartbeat_interval: Option<u64> = None; // Reserved for dynamic heartbeat
        let mut last_sequence: Option<u64> = None;
        let mut _identified = false; // Track READY state

        while let Some(msg) = read.next().await {
            match msg {
                Ok(WsMsg::Text(text)) => {
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
                        let op = json.get("op").and_then(|v| v.as_u64()).unwrap_or(0);

                        // Update sequence number
                        if let Some(s) = json.get("s").and_then(|v| v.as_u64()) {
                            last_sequence = Some(s);
                        }

                        match op {
                            10 => {
                                // Hello - start heartbeat
                                if let Some(d) = json.get("d") {
                                    if let Some(interval) = d.get("heartbeat_interval").and_then(|v| v.as_u64()) {
                                        _heartbeat_interval = Some(interval);

                                        // Send IDENTIFY
                                        let identify = serde_json::json!({
                                            "op": 2,
                                            "d": {
                                                "token": token_clone,
                                                "intents": 2099200, // GUILDS + GUILD_MESSAGES + MESSAGE_CONTENT
                                                "properties": {
                                                    "os": "linux",
                                                    "browser": "clay",
                                                    "device": "clay"
                                                }
                                            }
                                        });
                                        let mut w = write_clone.lock().await;
                                        let _ = w.send(WsMsg::Text(identify.to_string().into())).await;
                                    }
                                }
                            }
                            0 => {
                                // Dispatch event
                                let event_type = json.get("t").and_then(|v| v.as_str()).unwrap_or("");

                                if event_type == "READY" {
                                    _identified = true;
                                    let _ = event_tx_clone.send(AppEvent::DiscordMessage(world_name.clone(), "Connected to Discord!".to_string())).await;
                                } else if event_type == "MESSAGE_CREATE" {
                                    if let Some(d) = json.get("d") {
                                        let msg_channel = d.get("channel_id").and_then(|v| v.as_str()).unwrap_or("");
                                        if channel_id_clone.is_empty() || msg_channel == channel_id_clone {
                                            let author = d.get("author").and_then(|a| a.get("username")).and_then(|v| v.as_str()).unwrap_or("unknown");
                                            let content = d.get("content").and_then(|v| v.as_str()).unwrap_or("");
                                            let formatted = format!("[#{}] <{}> {}", msg_channel, author, content);
                                            let _ = event_tx_clone.send(AppEvent::DiscordMessage(world_name.clone(), formatted)).await;
                                        }
                                    }
                                }
                            }
                            11 => {
                                // Heartbeat ACK - good, keep going
                            }
                            1 => {
                                // Heartbeat request - send heartbeat
                                let hb = serde_json::json!({
                                    "op": 1,
                                    "d": last_sequence
                                });
                                let mut w = write_clone.lock().await;
                                let _ = w.send(WsMsg::Text(hb.to_string().into())).await;
                            }
                            _ => {}
                        }
                    }
                }
                Ok(WsMsg::Close(_)) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone())).await;
                    break;
                }
                Err(_) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone())).await;
                    break;
                }
                _ => {}
            }
        }
    });

    // Spawn heartbeat task
    let write_for_heartbeat = write.clone();
    tokio::spawn(async move {
        use futures::SinkExt;
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(41)); // ~41s heartbeat
        loop {
            interval.tick().await;
            let hb = serde_json::json!({
                "op": 1,
                "d": null
            });
            let mut w = write_for_heartbeat.lock().await;
            if w.send(WsMsg::Text(hb.to_string().into())).await.is_err() {
                break;
            }
        }
    });

    // Spawn writer task for sending messages via REST API
    let token_for_writer = token.clone();
    let channel_for_writer = channel_id.clone();
    let event_tx_for_writer = event_tx.clone();
    tokio::spawn(async move {
        let client = reqwest::Client::new();
        while let Some(cmd) = cmd_rx.recv().await {
            let text = match cmd {
                WriteCommand::Text(t) => t,
                WriteCommand::Raw(r) => String::from_utf8_lossy(&r).to_string(),
                WriteCommand::Shutdown => break,
            };
            if channel_for_writer.is_empty() {
                let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), "Error: No channel configured".to_string())).await;
                continue;
            }
            let url = format!("https://discord.com/api/v10/channels/{}/messages", channel_for_writer);
            match client
                .post(&url)
                .header("Authorization", format!("Bot {}", token_for_writer))
                .header("Content-Type", "application/json")
                .json(&serde_json::json!({
                    "content": text
                }))
                .send()
                .await
            {
                Ok(response) => {
                    if !response.status().is_success() {
                        let status = response.status();
                        let body: serde_json::Value = response.json().await.unwrap_or_default();
                        let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
                        let msg = format!("Discord send failed (HTTP {}): {}", status.as_u16(), error_msg);
                        let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), msg)).await;
                    }
                }
                Err(e) => {
                    let msg = format!("Discord send error: {}", e);
                    let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), msg)).await;
                }
            }
        }
    });

    app.current_world_mut().connected = true;
    app.current_world_mut().was_connected = true;

    false
}

async fn handle_command(cmd: &str, app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    let parsed = parse_command(cmd);

    match parsed {
        Command::Help => {
            app.help_popup.open();
        }
        Command::Menu => {
            app.menu_popup.open();
        }
        Command::Quit => {
            return true; // Signal to quit
        }
        Command::Setup => {
            // Open settings popup for global settings only
            app.settings_popup.open_setup(&app.settings, app.input_height, app.show_tags);
        }
        Command::Web => {
            // Open web settings popup
            app.web_popup.open(&app.settings);
        }
        Command::WorldSelector => {
            // /worlds (no args) - show world selector popup
            app.world_selector.open(app.current_world_index);
        }
        Command::WorldEdit { name } => {
            // /worlds -e or /worlds -e <name>
            let idx = if let Some(ref world_name) = name {
                // /worlds -e <name> - find or create the world, then edit
                app.find_or_create_world(world_name)
            } else {
                // /worlds -e - edit current world
                app.current_world_index
            };
            let input_height = app.input_height;
            let show_tags = app.show_tags;
            app.settings_popup.open(&app.settings, &app.worlds[idx], idx, input_height, show_tags);
        }
        Command::WorldConnectNoLogin { name } => {
            // /worlds -l <name> - connect without auto-login
            if let Some(idx) = app.find_world(&name) {
                app.switch_world(idx);
                if !app.current_world().connected {
                    if app.current_world().settings.has_connection_settings() {
                        // Set flag to skip auto-login
                        app.current_world_mut().skip_auto_login = true;
                        return Box::pin(handle_command("/connect", app, event_tx)).await;
                    } else {
                        app.add_output(&format!("World '{}' has no connection settings.", name));
                    }
                }
            } else {
                app.add_output(&format!("World '{}' not found.", name));
            }
        }
        Command::WorldSwitch { name } => {
            // /worlds <name> - switch to world and connect if not already connected
            if let Some(idx) = app.find_world(&name) {
                // World exists - switch to it
                app.switch_world(idx);
                // Connect if not already connected and has settings
                if !app.current_world().connected
                    && app.current_world().settings.has_connection_settings()
                {
                    return Box::pin(handle_command("/connect", app, event_tx)).await;
                }
            } else {
                // World doesn't exist - show error message (goes through more-mode flow)
                app.add_output(&format!("World '{}' not found.", name));
            }
        }
        Command::WorldsList => {
            // Output connected worlds list as text
            let current_idx = app.current_world_index;
            let worlds_info: Vec<util::WorldListInfo> = app.worlds.iter().enumerate().map(|(idx, world)| {
                let now = std::time::Instant::now();
                util::WorldListInfo {
                    name: world.name.clone(),
                    connected: world.connected,
                    is_current: idx == current_idx,
                    unseen_lines: world.unseen_lines,
                    last_send_secs: world.last_user_command_time.map(|t| now.duration_since(t).as_secs()),
                    last_recv_secs: world.last_receive_time.map(|t| now.duration_since(t).as_secs()),
                    last_nop_secs: world.last_nop_time.map(|t| now.duration_since(t).as_secs()),
                    next_nop_secs: None, // Calculated in format function
                }
            }).collect();
            let output = util::format_worlds_list(&worlds_info);
            app.add_output(&output);
        }
        Command::Keepalive => {
            // Show keepalive settings for all worlds
            let current_idx = app.current_world_index;
            let lines: Vec<String> = app.worlds.iter().enumerate().map(|(idx, world)| {
                let current = if idx == current_idx { "*" } else { " " };
                let connected = if world.connected { "" } else { " " };
                let type_str = world.settings.keep_alive_type.name();
                let cmd_str = if world.settings.keep_alive_cmd.is_empty() {
                    "(none)".to_string()
                } else {
                    world.settings.keep_alive_cmd.clone()
                };
                let last_nop = match world.last_nop_time {
                    Some(t) => format!("{:.0}s ago", t.elapsed().as_secs_f64()),
                    None => "never".to_string(),
                };
                format!(
                    "{}{} {:15} type={:8} cmd={:30} last={}",
                    current, connected, world.name, type_str, cmd_str, last_nop
                )
            }).collect();

            app.add_output("");
            app.add_output("Keepalive Settings for All Worlds:");
            app.add_output("".repeat(70).as_str());
            for line in lines {
                app.add_output(&line);
            }
            app.add_output("".repeat(70).as_str());
            app.add_output("(*=current, =connected)");
        }
        Command::Actions { world } => {
            if let Some(world_name) = world {
                app.actions_popup.open_with_world_filter(&app.settings.actions, &world_name);
            } else {
                app.actions_popup.open(&app.settings.actions);
            }
        }
        Command::Connect { host: arg_host, port: arg_port, ssl: arg_ssl } => {
            // Only master client can initiate connections
            if !app.is_master {
                app.add_output("Only the master client can initiate connections.");
                return false;
            }
            if app.current_world().connected {
                app.add_output("Already connected. Use /disconnect first.");
                return false;
            }

            // Route connection based on world type
            let world_type = app.current_world().settings.world_type.clone();
            match world_type {
                WorldType::Slack => {
                    return connect_slack(app, event_tx).await;
                }
                WorldType::Discord => {
                    return connect_discord(app, event_tx).await;
                }
                WorldType::Mud => {
                    // Continue with MUD connection below
                }
            }

            // MUD connection: Determine host/port/ssl: use args if provided, else use stored settings
            let world_settings = &app.current_world().settings;
            let (host, port, use_ssl) = if let (Some(h), Some(p)) = (arg_host, arg_port) {
                (h, p, arg_ssl)
            } else if !world_settings.hostname.is_empty() && !world_settings.port.is_empty() {
                (
                    world_settings.hostname.clone(),
                    world_settings.port.clone(),
                    world_settings.use_ssl,
                )
            } else {
                app.add_output("Configure host/port in world settings (/worlds)");
                return false;
            };

            // Check if using TLS proxy for connection preservation
            let use_tls_proxy = use_ssl && app.settings.tls_proxy_enabled;

            let ssl_msg = if use_ssl {
                if use_tls_proxy { " with SSL (via proxy)" } else { " with SSL" }
            } else { "" };
            app.add_output("");
            app.add_output(&format!("Connecting to {}:{}{}...", host, port, ssl_msg));
            app.add_output("");

            // Handle TLS proxy case separately (proxy does its own TCP connect)
            if use_tls_proxy {
                let world_name = app.current_world().name.clone();
                match spawn_tls_proxy(&world_name, &host, &port) {
                    Ok((proxy_pid, socket_path)) => {
                        // Connect to the proxy via Unix socket
                        match tokio::net::UnixStream::connect(&socket_path).await {
                            Ok(unix_stream) => {
                                app.add_output("SSL connection established via proxy.");
                                app.current_world_mut().socket_fd = None;  // Can't preserve TLS fd directly
                                app.current_world_mut().is_tls = true;
                                app.current_world_mut().proxy_pid = Some(proxy_pid);
                                app.current_world_mut().proxy_socket_path = Some(socket_path);

                                let (r, w) = unix_stream.into_split();
                                let mut read_half = StreamReader::Proxy(r);
                                let mut write_half = StreamWriter::Proxy(w);

                                app.current_world_mut().connected = true;
                                app.current_world_mut().was_connected = true;
                                app.current_world_mut().prompt_count = 0;
                                let now = std::time::Instant::now();
                                app.current_world_mut().last_send_time = Some(now);
                                app.current_world_mut().last_receive_time = Some(now);
                                app.current_world_mut().is_initial_world = false;
                                app.discard_initial_world();

                                let world_name = app.current_world().name.clone();

                                // Open log file if enabled
                                if app.current_world().settings.log_enabled {
                                    if app.current_world_mut().open_log_file() {
                                        let log_path = app.current_world().get_log_path();
                                        app.add_output(&format!("Logging to: {}", log_path.display()));
                                    } else {
                                        app.add_output("Warning: Could not open log file");
                                    }
                                }

                                // Start reader task (similar to the regular connection flow)
                                let event_tx_read = event_tx.clone();
                                let read_world_name = world_name.clone();
                                tokio::spawn(async move {
                                    let mut buf = [0u8; 4096];
                                    loop {
                                        match tokio::io::AsyncReadExt::read(&mut read_half, &mut buf).await {
                                            Ok(0) => {
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone())).await;
                                                break;
                                            }
                                            Ok(n) => {
                                                let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), buf[..n].to_vec())).await;
                                            }
                                            Err(_) => {
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone())).await;
                                                break;
                                            }
                                        }
                                    }
                                });

                                // Setup writer channel
                                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                                app.current_world_mut().command_tx = Some(cmd_tx);

                                tokio::spawn(async move {
                                    while let Some(cmd) = cmd_rx.recv().await {
                                        let bytes = match &cmd {
                                            WriteCommand::Text(text) => {
                                                let mut b = text.as_bytes().to_vec();
                                                b.extend_from_slice(b"\r\n");
                                                b
                                            }
                                            WriteCommand::Raw(raw) => raw.clone(),
                                            WriteCommand::Shutdown => break,
                                        };
                                        if tokio::io::AsyncWriteExt::write_all(&mut write_half, &bytes).await.is_err() {
                                            break;
                                        }
                                    }
                                });

                                return true;
                            }
                            Err(e) => {
                                app.add_output(&format!("Failed to connect to TLS proxy: {}", e));
                                // Kill the proxy process
                                unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                return false;
                            }
                        }
                    }
                    Err(e) => {
                        app.add_output(&format!("Failed to spawn TLS proxy: {}", e));
                        app.add_output("Falling back to direct TLS connection...");
                        // Fall through to direct TLS connection below
                    }
                }
            }

            match TcpStream::connect(format!("{}:{}", host, port)).await {
                Ok(tcp_stream) => {
                    // Store the socket fd for hot reload (before splitting)
                    let socket_fd = tcp_stream.as_raw_fd();

                    // Handle SSL if needed
                    let (mut read_half, mut write_half): (StreamReader, StreamWriter) = if use_ssl {
                        #[cfg(feature = "native-tls-backend")]
                        {
                            // Accept invalid/expired certificates (common for MUD servers)
                            let connector = match native_tls::TlsConnector::builder()
                                .danger_accept_invalid_certs(true)
                                .build()
                            {
                                Ok(c) => c,
                                Err(e) => {
                                    app.add_output(&format!("TLS error: {}", e));
                                    return false;
                                }
                            };
                            let connector = tokio_native_tls::TlsConnector::from(connector);

                            match connector.connect(&host, tcp_stream).await {
                                Ok(tls_stream) => {
                                    app.add_output("SSL handshake successful!");
                                    // For TLS, we can't preserve the connection across reload
                                    app.current_world_mut().socket_fd = None;
                                    app.current_world_mut().is_tls = true;
                                    let (r, w) = tokio::io::split(tls_stream);
                                    (StreamReader::Tls(r), StreamWriter::Tls(w))
                                }
                                Err(e) => {
                                    app.add_output(&format!("SSL handshake failed: {}", e));
                                    return false;
                                }
                            }
                        }

                        #[cfg(feature = "rustls-backend")]
                        {
                            use std::sync::Arc;
                            use rustls::RootCertStore;
                            use tokio_rustls::TlsConnector;
                            use rustls::pki_types::ServerName;

                            // Create a config that accepts invalid certs (common for MUD servers)
                            let mut root_store = RootCertStore::empty();
                            root_store.extend(webpki_roots::TLS_SERVER_ROOTS.iter().cloned());

                            let config = rustls::ClientConfig::builder()
                                .dangerous()
                                .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
                                .with_no_client_auth();

                            let connector = TlsConnector::from(Arc::new(config));
                            let server_name = match ServerName::try_from(host.clone()) {
                                Ok(sn) => sn,
                                Err(e) => {
                                    app.add_output(&format!("Invalid server name: {}", e));
                                    return false;
                                }
                            };

                            match connector.connect(server_name, tcp_stream).await {
                                Ok(tls_stream) => {
                                    app.add_output("SSL handshake successful!");
                                    app.current_world_mut().socket_fd = None;
                                    app.current_world_mut().is_tls = true;
                                    let (r, w) = tokio::io::split(tls_stream);
                                    (StreamReader::Tls(r), StreamWriter::Tls(w))
                                }
                                Err(e) => {
                                    app.add_output(&format!("SSL handshake failed: {}", e));
                                    return false;
                                }
                            }
                        }

                        #[cfg(not(any(feature = "native-tls-backend", feature = "rustls-backend")))]
                        {
                            app.add_output("No TLS backend available. Compile with native-tls-backend or rustls-backend feature.");
                            return false;
                        }
                    } else {
                        // Store fd for plain TCP connections (can be preserved across reload)
                        app.current_world_mut().socket_fd = Some(socket_fd);
                        app.current_world_mut().is_tls = false;
                        let (r, w) = tcp_stream.into_split();
                        (StreamReader::Plain(r), StreamWriter::Plain(w))
                    };

                    app.current_world_mut().connected = true;
                    app.current_world_mut().was_connected = true;
                    app.current_world_mut().prompt_count = 0; // Reset for auto-login
                    // Initialize timing for NOP tracking
                    let now = std::time::Instant::now();
                    app.current_world_mut().last_send_time = Some(now);
                    app.current_world_mut().last_receive_time = Some(now);

                    // Mark this world as no longer initial (if it was)
                    app.current_world_mut().is_initial_world = false;

                    // Discard any unused initial world now that we have a real connection
                    app.discard_initial_world();

                    // Capture world name for the reader task (stable across world deletions)
                    let world_name = app.current_world().name.clone();

                    // Open log file if enabled
                    if app.current_world().settings.log_enabled {
                        if app.current_world_mut().open_log_file() {
                            let log_path = app.current_world().get_log_path();
                            app.add_output(&format!("Logging to: {}", log_path.display()));
                        } else {
                            app.add_output("Warning: Could not open log file");
                        }
                    }

                    let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                    app.current_world_mut().command_tx = Some(cmd_tx.clone());

                    // Send "connect <user> <password>" if configured and auto_connect_type is Connect
                    // Skip if skip_auto_login flag is set (from /worlds -l)
                    let skip_login = app.current_world().skip_auto_login;
                    // Reset flag so future reconnects will try auto-login again
                    app.current_world_mut().skip_auto_login = false;
                    let user = app.current_world().settings.user.clone();
                    let password = app.current_world().settings.password.clone();
                    let auto_connect_type = app.current_world().settings.auto_connect_type;
                    if !skip_login && !user.is_empty() && auto_connect_type == AutoConnectType::Connect {
                        let tx = cmd_tx.clone();
                        tokio::spawn(async move {
                            tokio::time::sleep(Duration::from_millis(500)).await;
                            let connect_cmd = format!("connect {} {}", user, password);
                            let _ = tx.send(WriteCommand::Text(connect_cmd)).await;
                        });
                    }

                    // Clone tx for use in reader (for telnet responses)
                    let telnet_tx = cmd_tx.clone();
                    let event_tx_read = event_tx.clone();
                    tokio::spawn(async move {
                        let mut buffer = BytesMut::with_capacity(4096);
                        buffer.resize(4096, 0);
                        let mut line_buffer: Vec<u8> = Vec::new();

                        loop {
                            match read_half.read(&mut buffer).await {
                                Ok(0) => {
                                    // Send any remaining buffered data
                                    if !line_buffer.is_empty() {
                                        let (cleaned, responses, detected, prompt, _wont_echo) = process_telnet(&line_buffer);
                                        if !responses.is_empty() {
                                            let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                        }
                                        if detected {
                                            let _ = event_tx_read.send(AppEvent::TelnetDetected(world_name.clone())).await;
                                        }
                                        // Send prompt FIRST for immediate auto-login response
                                        if let Some(prompt_bytes) = prompt {
                                            let _ = event_tx_read.send(AppEvent::Prompt(world_name.clone(), prompt_bytes)).await;
                                        }
                                        // Send remaining data
                                        if !cleaned.is_empty() {
                                            let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), cleaned)).await;
                                        }
                                    }
                                    let _ = event_tx_read
                                        .send(AppEvent::ServerData(
                                            world_name.clone(),
                                            "Connection closed by server.".as_bytes().to_vec(),
                                        ))
                                        .await;
                                    let _ =
                                        event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                    break;
                                }
                                Ok(n) => {
                                    // Append new data to line buffer
                                    line_buffer.extend_from_slice(&buffer[..n]);

                                    // Find safe split point (complete lines with complete ANSI sequences)
                                    let split_at = find_safe_split_point(&line_buffer);

                                    // Send data immediately - either up to split point, or all if no incomplete sequences
                                    let to_send = if split_at > 0 {
                                        line_buffer.drain(..split_at).collect()
                                    } else if !line_buffer.is_empty() {
                                        // No safe split point but we have data - send it anyway
                                        std::mem::take(&mut line_buffer)
                                    } else {
                                        Vec::new()
                                    };

                                    if !to_send.is_empty() {
                                        // Process telnet sequences
                                        let (cleaned, responses, detected, prompt, wont_echo) = process_telnet(&to_send);

                                        // Send telnet responses if any
                                        if !responses.is_empty() {
                                            let _ = telnet_tx.send(WriteCommand::Raw(responses)).await;
                                        }

                                        // Notify if telnet detected
                                        if detected {
                                            let _ = event_tx_read
                                                .send(AppEvent::TelnetDetected(world_name.clone()))
                                                .await;
                                        }

                                        // Notify if WONT ECHO seen (for timeout-based prompt detection)
                                        if wont_echo {
                                            let _ = event_tx_read
                                                .send(AppEvent::WontEchoSeen(world_name.clone()))
                                                .await;
                                        }

                                        // Send prompt FIRST if detected via telnet GA
                                        if let Some(prompt_bytes) = prompt {
                                            let _ = event_tx_read
                                                .send(AppEvent::Prompt(world_name.clone(), prompt_bytes))
                                                .await;
                                        }

                                        // Send cleaned data to main loop
                                        if !cleaned.is_empty()
                                            && event_tx_read
                                                .send(AppEvent::ServerData(world_name.clone(), cleaned))
                                                .await
                                                .is_err()
                                        {
                                            break;
                                        }
                                    }
                                }
                                Err(e) => {
                                    let msg = format!("Read error: {}", e);
                                    let _ = event_tx_read
                                        .send(AppEvent::ServerData(world_name.clone(), msg.into_bytes()))
                                        .await;
                                    let _ =
                                        event_tx_read.send(AppEvent::Disconnected(world_name.clone())).await;
                                    break;
                                }
                            }
                        }
                    });

                    tokio::spawn(async move {
                        use tokio::io::AsyncWriteExt;
                        while let Some(cmd) = cmd_rx.recv().await {
                            match cmd {
                                WriteCommand::Text(text) => {
                                    let bytes = format!("{}\r\n", text).into_bytes();
                                    if write_half.write_all(&bytes).await.is_err() {
                                        break;
                                    }
                                }
                                WriteCommand::Raw(raw) => {
                                    if write_half.write_all(&raw).await.is_err() {
                                        break;
                                    }
                                }
                                WriteCommand::Shutdown => {
                                    let _ = write_half.shutdown().await;
                                    break;
                                }
                            }
                        }
                    });
                }
                Err(e) => {
                    app.add_output(&format!("Connection failed: {}", e));
                }
            }
        }
        Command::Disconnect => {
            if app.current_world().connected {
                // Kill proxy process if one exists
                if let Some(proxy_pid) = app.current_world().proxy_pid {
                    unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                }
                if let Some(ref socket_path) = app.current_world().proxy_socket_path {
                    let _ = std::fs::remove_file(socket_path);
                }
                app.current_world_mut().proxy_pid = None;
                app.current_world_mut().proxy_socket_path = None;
                app.current_world_mut().command_tx = None;
                app.current_world_mut().connected = false;
                app.current_world_mut().socket_fd = None;
                app.current_world_mut().close_log_file();
                app.current_world_mut().prompt.clear();
                app.add_output("Disconnected.");
            } else {
                app.add_output("Not connected.");
            }
        }
        Command::Flush => {
            let line_count = app.current_world().output_lines.len();
            app.current_world_mut().output_lines.clear();
            app.current_world_mut().pending_lines.clear();
            app.current_world_mut().scroll_offset = 0;
            app.current_world_mut().lines_since_pause = 0;
            app.current_world_mut().paused = false;
            // Broadcast flush to WebSocket clients
            let world_index = app.current_world_index;
            app.ws_broadcast(WsMessage::WorldFlushed { world_index });
            app.add_output(&format!("Flushed {} lines from output buffer.", line_count));
        }
        Command::Send { text, all_worlds, target_world, no_newline } => {
            // Send the text
            let send_to_world = |world: &mut World, text: &str, no_newline: bool| -> bool {
                if !world.connected {
                    return false;
                }
                if let Some(tx) = &world.command_tx {
                    let result = if no_newline {
                        tx.try_send(WriteCommand::Raw(text.as_bytes().to_vec()))
                    } else {
                        tx.try_send(WriteCommand::Text(text.to_string()))
                    };
                    if result.is_ok() {
                        world.last_send_time = Some(std::time::Instant::now());
                        return true;
                    }
                }
                false
            };

            if all_worlds {
                // Send to all connected worlds
                let mut sent_count = 0;
                for world in &mut app.worlds {
                    if send_to_world(world, &text, no_newline) {
                        sent_count += 1;
                    }
                }
                if sent_count == 0 {
                    app.add_output("No connected worlds to send to.");
                }
            } else if let Some(world_name) = target_world {
                // Send to specific world
                if let Some(idx) = app.find_world(&world_name) {
                    if !send_to_world(&mut app.worlds[idx], &text, no_newline) {
                        app.add_output(&format!("World '{}' is not connected.", world_name));
                    }
                } else {
                    app.add_output(&format!("World '{}' not found.", world_name));
                }
            } else {
                // Send to current world
                let world = app.current_world_mut();
                if !world.connected {
                    app.add_output("Not connected. Use /worlds to connect.");
                } else if let Some(tx) = &world.command_tx {
                    let result = if no_newline {
                        tx.try_send(WriteCommand::Raw(text.as_bytes().to_vec()))
                    } else {
                        tx.try_send(WriteCommand::Text(text.to_string()))
                    };
                    if result.is_ok() {
                        world.last_send_time = Some(std::time::Instant::now());
                    } else {
                        app.add_output("Failed to send command.");
                    }
                }
            }
        }
        Command::Reload => {
            // First check if we can find the executable (handling " (deleted)" suffix)
            let exe_path = match get_executable_path() {
                Ok((p, _)) => p,
                Err(e) => {
                    app.add_output(&format!("Cannot find executable: {}", e));
                    return false;
                }
            };

            if !exe_path.exists() {
                app.add_output(&format!("Executable not found: {}", exe_path.display()));
                app.add_output("Hot reload requires the binary to exist on disk.");
                app.add_output("If running via 'cargo run', try running the compiled binary directly.");
                return false;
            }

            // Check if there are any TLS connections that will be lost
            let tls_worlds: Vec<_> = app
                .worlds
                .iter()
                .filter(|w| w.connected && w.is_tls)
                .map(|w| w.name.clone())
                .collect();

            if !tls_worlds.is_empty() {
                app.add_output(&format!(
                    "Warning: TLS connections will be closed: {}",
                    tls_worlds.join(", ")
                ));
                app.add_output("These connections will need to be re-established after reload.");
            }

            // Binary path is only shown on failure (see error handler below)

            // Disable raw mode before exec (the new process will re-enable it)
            let _ = crossterm::terminal::disable_raw_mode();
            let _ = crossterm::execute!(
                std::io::stdout(),
                crossterm::terminal::LeaveAlternateScreen
            );

            match exec_reload(app) {
                Ok(()) => {
                    // This should never be reached - exec replaces the process
                    unreachable!();
                }
                Err(e) => {
                    // Restore terminal state if exec failed
                    let _ = crossterm::terminal::enable_raw_mode();
                    let _ = crossterm::execute!(
                        std::io::stdout(),
                        crossterm::terminal::EnterAlternateScreen,
                        crossterm::terminal::Clear(crossterm::terminal::ClearType::All),
                        crossterm::cursor::MoveTo(0, 0)
                    );
                    app.add_output(&format!("Hot reload failed: {}", e));
                    app.add_output(&format!("Executable path: {}", exe_path.display()));
                }
            }
        }
        Command::Gag { pattern } => {
            // TODO: Implement gag patterns
            app.add_output(&format!("Gag pattern set: {}", pattern));
        }
        Command::BanList => {
            // Show current banned hosts
            let bans = app.ban_list.get_ban_info();
            if bans.is_empty() {
                app.add_output("No hosts are currently banned.");
            } else {
                app.add_output("");
                app.add_output("Banned Hosts:");
                app.add_output("".repeat(70).as_str());
                app.add_output(&format!("{:<20} {:<12} {}", "Host", "Type", "Last URL/Reason"));
                app.add_output("".repeat(70).as_str());
                for (ip, ban_type, reason) in bans {
                    let reason_display = if reason.is_empty() { "(unknown)" } else { &reason };
                    app.add_output(&format!("{:<20} {:<12} {}", ip, ban_type, reason_display));
                }
                app.add_output("".repeat(70).as_str());
                app.add_output("Use /unban <host> to remove a ban.");
            }
            // Broadcast to remote clients
            app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
        }
        Command::Unban { host } => {
            if app.ban_list.remove_ban(&host) {
                app.add_output(&format!("Removed ban for: {}", host));
                // Save settings to persist the change
                if app.multiuser_mode {
                    if let Err(e) = save_multiuser_settings(&app) {
                        app.add_output(&format!("Warning: Failed to save settings: {}", e));
                    }
                } else {
                    if let Err(e) = save_settings(&app) {
                        app.add_output(&format!("Warning: Failed to save settings: {}", e));
                    }
                }
                // Broadcast updated ban list to remote clients
                app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                app.ws_broadcast(WsMessage::UnbanResult { success: true, host: host.clone(), error: None });
            } else {
                app.add_output(&format!("No ban found for: {}", host));
                app.ws_broadcast(WsMessage::UnbanResult { success: false, host: host.clone(), error: Some("No ban found".to_string()) });
            }
        }
        Command::TestMusic => {
            // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
            let test_notes = vec![
                ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
            ];
            app.ws_broadcast(WsMessage::AnsiMusic {
                world_index: app.current_world_index,
                notes: test_notes,
            });
            app.add_output("Playing test music (C-D-E-F-G)...");
        }
        Command::ActionCommand { name, args } => {
            // Check if this is an action command (/name)
            let action_found = app.settings.actions.iter()
                .find(|a| a.name.eq_ignore_ascii_case(&name))
                .cloned();

            if let Some(action) = action_found {
                // Execute the action's commands - process each individually
                let commands = split_action_commands(&action.command);
                let mut sent_to_server = false;
                for cmd_str in commands {
                    // Substitute $1-$9 and $* with arguments
                    let cmd_str = substitute_action_args(&cmd_str, &args);

                    // Skip /gag commands when invoked manually
                    if cmd_str.eq_ignore_ascii_case("/gag") || cmd_str.to_lowercase().starts_with("/gag ") {
                        continue;
                    }

                    // If command starts with /, process it as a client command
                    if cmd_str.starts_with('/') {
                        Box::pin(handle_command(&cmd_str, app, event_tx.clone())).await;
                    } else {
                        // Plain text - send to server if connected
                        if let Some(tx) = &app.current_world().command_tx {
                            let _ = tx.try_send(WriteCommand::Text(cmd_str.clone()));
                            sent_to_server = true;
                        } else {
                            app.add_output(&format!("Not connected. Cannot send: {}", cmd_str));
                        }
                    }
                }
                if sent_to_server {
                    app.current_world_mut().last_send_time = Some(std::time::Instant::now());
                }
            } else {
                app.add_output(&format!("Unknown action: /{}", name));
            }
        }
        Command::NotACommand { text } => {
            // Not a command - send to MUD as regular input
            if let Some(tx) = &app.current_world().command_tx {
                let _ = tx.try_send(WriteCommand::Text(text));
                app.current_world_mut().last_send_time = Some(std::time::Instant::now());
            }
        }
        Command::Unknown { cmd } => {
            app.add_output(&format!("Unknown command: {}", cmd));
        }
    }
    false
}

fn ui(f: &mut Frame, app: &mut App) {
    let total_height = f.area().height.max(3);  // Minimum 3 lines for output + separator + input

    // Layout: output area, separator bar (1 line), input area
    let separator_height = 1;
    let input_total_height = app.input_height;
    let output_height = total_height.saturating_sub(separator_height + input_total_height);

    // Store output dimensions for scrolling and more-mode calculations
    // Use max(1) to prevent any division by zero elsewhere
    let new_output_height = output_height.max(1);
    let new_output_width = f.area().width.max(1);
    // Mark output for redraw if dimensions changed (terminal resize)
    if new_output_height != app.output_height || new_output_width != app.output_width {
        app.needs_output_redraw = true;
    }
    app.output_height = new_output_height;
    app.output_width = new_output_width;

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(output_height),
            Constraint::Length(separator_height),
            Constraint::Length(input_total_height),
        ])
        .split(f.area());

    let output_area = chunks[0];
    let separator_area = chunks[1];
    let input_area = chunks[2];

    // Update input dimensions and prompt length for viewport calculation
    app.input.set_dimensions(input_area.width, app.input_height);
    app.input.prompt_len = strip_ansi_codes(&app.current_world().prompt).chars().count();

    // Render output area
    render_output_area(f, app, output_area);

    // Render separator bar
    render_separator_bar(f, app, separator_area);

    // Render input area
    render_input_area(f, app, input_area);

    // Render popups if visible (confirm dialog last so it's on top)
    render_settings_popup(f, app);
    render_web_popup(f, app);
    render_world_selector_popup(f, app);
    render_confirm_dialog(f, app);
    render_worlds_popup(f, app);
    render_filter_popup(f, app);
    render_help_popup(f, app);
    render_menu_popup(f, app);
    render_actions_popup(f, app);
}

/// Render output area using raw crossterm (bypasses ratatui's buggy rendering)
/// Returns early if splash screen or popup is visible (let ratatui handle those)
fn render_output_crossterm(app: &App) {
    use std::io::Write;
    use crossterm::{cursor, style::Print, QueueableCommand};

    // Skip if showing splash screen or any popup is visible (except filter popup)
    let any_popup_visible = app.settings_popup.visible
        || app.world_selector.visible
        || app.confirm_dialog.visible
        || app.worlds_popup.visible
        || app.help_popup.visible
        || app.menu_popup.visible
        || app.actions_popup.visible
        || app.web_popup.visible;
    if app.current_world().showing_splash || any_popup_visible {
        return;
    }

    let mut stdout = std::io::stdout();

    let world = app.current_world();
    let visible_height = (app.output_height as usize).max(1);
    let term_width = (app.output_width as usize).max(1);

    // Calculate visible width of a string (excluding ANSI escape sequences)
    fn visible_width(s: &str) -> usize {
        let mut width = 0;
        let mut in_escape = false;
        for c in s.chars() {
            if c == '\x1b' {
                in_escape = true;
            } else if in_escape {
                if c.is_alphabetic() || c == '~' {
                    in_escape = false;
                }
            } else {
                width += unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);
            }
        }
        width
    }

    // Break characters for word wrapping within long words
    const BREAK_CHARS: &[char] = &['[', ']', '(', ')', ',', '\\', '/', '-', '&', '=', '?', '.', ';'];

    // Wrap a line with ANSI codes by visible width, preferring to break at word boundaries
    // Similar to CSS white-space: pre-wrap; word-wrap: break-word
    // Optimized to track byte positions instead of cloning the full string at every break point
    // (still clones the small active_codes vector, but that's typically 0-5 elements)
    fn wrap_ansi_line(line: &str, max_width: usize) -> Vec<String> {
        if max_width == 0 {
            return vec![line.to_string()];
        }

        let mut result = Vec::new();
        let mut current_line = String::new();
        let mut current_width = 0;
        let mut in_escape = false;
        let mut escape_seq = String::new();
        let mut active_codes: Vec<String> = Vec::new();

        // Track last word boundary (space) for wrapping - byte position instead of string clone
        let mut last_space_byte_pos: usize = 0;
        let mut last_space_width = 0;
        let mut last_space_codes: Vec<String> = Vec::new();  // small vec, ok to clone
        let mut has_space_on_line = false;

        // Track break opportunities within long words (for BREAK_CHARS)
        let mut last_break_byte_pos: usize = 0;
        let mut last_break_width = 0;
        let mut last_break_codes: Vec<String> = Vec::new();

        for c in line.chars() {
            if c == '\x1b' {
                in_escape = true;
                escape_seq.push(c);
            } else if in_escape {
                escape_seq.push(c);
                if c.is_alphabetic() || c == '~' {
                    in_escape = false;
                    current_line.push_str(&escape_seq);
                    if c == 'm' {
                        if escape_seq == "\x1b[0m" || escape_seq == "\x1b[m" {
                            active_codes.clear();
                        } else {
                            active_codes.push(escape_seq.clone());
                        }
                    }
                    escape_seq.clear();
                }
            } else {
                let char_width = unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);

                // Check if we need to wrap before adding this character
                if current_width + char_width > max_width && current_width > 0 {
                    // Prefer break char over space when it's further along (packs more on line)
                    if last_break_width > last_space_width {
                        // Break at period/hyphen/etc within the current word
                        let mut break_line = current_line[..last_break_byte_pos].to_string();
                        break_line.push_str("\x1b[0m");
                        result.push(break_line);

                        let codes_prefix: String = last_break_codes.join("");
                        let remainder = &current_line[last_break_byte_pos..];
                        current_line = codes_prefix + remainder;
                        current_width -= last_break_width;
                    } else if has_space_on_line && last_space_width > 0 {
                        // Break at word boundary - emit up to and including the space
                        let mut break_line = current_line[..last_space_byte_pos].to_string();
                        break_line.push_str("\x1b[0m");
                        result.push(break_line);

                        // Start new line with content after the space
                        let codes_prefix: String = last_space_codes.join("");
                        let remainder = &current_line[last_space_byte_pos..];
                        current_line = codes_prefix + remainder;
                        current_width -= last_space_width;
                    } else {
                        // No break point at all - hard wrap at current position
                        current_line.push_str("\x1b[0m");
                        result.push(current_line);
                        current_line = active_codes.join("");
                        current_width = 0;
                    }

                    // Reset tracking for new line
                    has_space_on_line = false;
                    last_space_byte_pos = 0;
                    last_space_width = 0;
                    last_space_codes.clear();
                    last_break_byte_pos = 0;
                    last_break_width = 0;
                    last_break_codes.clear();
                }

                // Add the character
                current_line.push(c);
                current_width += char_width;

                // Track break opportunities - save byte position (not string clone)
                if c.is_whitespace() {
                    // Save position AFTER the space as a word boundary
                    last_space_byte_pos = current_line.len();
                    last_space_width = current_width;
                    last_space_codes = active_codes.clone();  // small vec
                    has_space_on_line = true;
                    // Reset break char tracking since we have a new word
                    last_break_byte_pos = 0;
                    last_break_width = 0;
                } else if BREAK_CHARS.contains(&c) {
                    // Save as potential break point within a word (after this char)
                    last_break_byte_pos = current_line.len();
                    last_break_width = current_width;
                    last_break_codes = active_codes.clone();
                }
            }
        }

        if !current_line.is_empty() || result.is_empty() {
            result.push(current_line);
        }

        result
    }

    // Collect wrapped lines centered around scroll_offset to fill the screen
    // Each entry is (line_text, should_highlight)
    let mut visual_lines: Vec<(String, bool)> = Vec::new();
    let mut first_line_idx: usize = 0;

    let show_tags = app.show_tags;
    let highlight_actions = app.highlight_actions;
    let world_name = &world.name;
    let actions = &app.settings.actions;

    // Cache "now" for timestamp formatting - compute once per frame, not per line
    let cached_now = CachedNow::new();

    let expand_and_wrap = |line: &OutputLine, term_width: usize, show_tags: bool, highlight: bool, cached_now: &CachedNow| -> Vec<(String, bool)> {
        // Skip gagged lines unless show_tags (F2) is enabled
        if line.gagged && !show_tags {
            return Vec::new();
        }
        // Skip lines that are only ANSI codes (cursor control garbage)
        if is_ansi_only_line(&line.text) {
            return Vec::new();
        }
        // For legitimate blank lines (empty or whitespace-only), render as blank line
        if is_visually_empty(&line.text) {
            return vec![("".to_string(), false)];
        }
        // Convert Discord custom emojis to :name: for console display
        let text = convert_discord_emojis(&line.text);
        // Add "%% " prefix and red color for client-generated messages
        let text = if !line.from_server {
            format!("\x1b[31m%% {}\x1b[0m", text)
        } else {
            text
        };
        let processed = if show_tags {
            // Show timestamp + original text when tags are shown
            // Also convert temperatures (32C -> 32C (90F), etc.)
            let text_with_temps = convert_temperatures(&text);
            format!("\x1b[36m{}\x1b[0m {}", line.format_timestamp_with_now(cached_now), text_with_temps)
        } else {
            strip_mud_tag(&text)
        };
        let expanded = processed.replace('\t', "        ");
        wrap_ansi_line(&expanded, term_width)
            .into_iter()
            .map(|s| (s, highlight))
            .collect()
    };

    // Helper to check if a line should be highlighted
    let should_highlight = |line: &OutputLine| -> bool {
        highlight_actions && line_matches_action(&line.text, world_name, actions)
    };

    // Check if filter popup is active with a non-empty filter
    // If filter is active but no matches, show nothing (don't fall through to normal rendering)
    if app.filter_popup.visible && !app.filter_popup.filter_text.is_empty() {
        // If no matches, visual_lines stays empty - that's correct behavior
        if !app.filter_popup.filtered_indices.is_empty() {
            // Use filtered indices
            let filtered = &app.filter_popup.filtered_indices;
            let end_pos = app.filter_popup.scroll_offset.min(filtered.len().saturating_sub(1));

            // Work backwards from scroll_offset to fill the screen
            for pos in (0..=end_pos).rev() {
                let line_idx = filtered[pos];
                if line_idx < world.output_lines.len() {
                    let line = &world.output_lines[line_idx];
                    let highlight = should_highlight(line);
                    let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                    for w in wrapped.into_iter().rev() {
                        visual_lines.insert(0, w);
                    }

                    if visual_lines.len() >= visible_height {
                        break;
                    }
                }
            }

            // If we still have room, show lines after scroll_offset
            if visual_lines.len() < visible_height {
                for &line_idx in filtered.iter().skip(end_pos + 1) {
                    if line_idx < world.output_lines.len() {
                        let line = &world.output_lines[line_idx];
                        let highlight = should_highlight(line);
                        let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                        for w in wrapped {
                            visual_lines.push(w);
                        }

                        if visual_lines.len() >= visible_height {
                            break;
                        }
                    }
                }
            }
        }
    } else if !world.output_lines.is_empty() {
        // Normal unfiltered rendering
        let end_line = world.scroll_offset.min(world.output_lines.len().saturating_sub(1));

        first_line_idx = end_line;
        for line_idx in (0..=end_line).rev() {
            first_line_idx = line_idx;
            let line = &world.output_lines[line_idx];
            let highlight = should_highlight(line);
            let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

            for w in wrapped.into_iter().rev() {
                visual_lines.insert(0, w);
            }

            if visual_lines.len() >= visible_height {
                break;
            }
        }

        if visual_lines.len() < visible_height && first_line_idx == 0 {
            for line_idx in (end_line + 1)..world.output_lines.len() {
                let line = &world.output_lines[line_idx];
                let highlight = should_highlight(line);
                let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                for w in wrapped {
                    visual_lines.push(w);
                }

                if visual_lines.len() >= visible_height {
                    break;
                }
            }
        }
    }

    let lines_to_show: &[(String, bool)] = if first_line_idx == 0 && visual_lines.len() <= visible_height {
        &visual_lines[..visual_lines.len().min(visible_height)]
    } else {
        let display_start = visual_lines.len().saturating_sub(visible_height);
        &visual_lines[display_start..]
    };

    for (row_idx, (wrapped, highlight)) in lines_to_show.iter().enumerate() {
        let _ = stdout.queue(cursor::MoveTo(0, row_idx as u16));

        // Apply highlight background if this line matches an action
        if *highlight {
            // Dark yellow/brown background for action-matched lines
            // Replace any resets in the line to preserve background color
            let bg_code = "\x1b[48;5;58m";
            let _ = stdout.queue(Print(bg_code));
            // Replace \x1b[0m with \x1b[0m\x1b[48;5;58m to preserve background
            let highlighted = wrapped.replace("\x1b[0m", &format!("\x1b[0m{}", bg_code));
            let _ = stdout.queue(Print(&highlighted));
        } else {
            let _ = stdout.queue(Print(wrapped));
        }

        let line_visible_width = visible_width(wrapped);
        if line_visible_width < term_width {
            let padding = " ".repeat(term_width - line_visible_width);
            let _ = stdout.queue(Print(padding));
        }

        let _ = stdout.queue(Print("\x1b[0m"));
    }

    for row_idx in lines_to_show.len()..visible_height {
        let _ = stdout.queue(cursor::MoveTo(0, row_idx as u16));
        let spaces = " ".repeat(term_width);
        let _ = stdout.queue(Print(spaces));
    }

    // Render filter popup if visible (must be after output so it's on top)
    if app.filter_popup.visible {
        let popup_width = 40usize.min(term_width);
        let x = term_width.saturating_sub(popup_width) as u16;
        let title = " Find [Esc to close] ";
        let dashes_needed = popup_width.saturating_sub(title.len() + 2); // +2 for corners

        // Draw border top
        let _ = stdout.queue(cursor::MoveTo(x, 0));
        let border_top = format!("\x1b[36m{}{}{}\x1b[0m", title, "".repeat(dashes_needed), "");
        let _ = stdout.queue(Print(border_top));

        // Draw content line
        let _ = stdout.queue(cursor::MoveTo(x, 1));
        let mut display_text = app.filter_popup.filter_text.clone();
        display_text.insert(app.filter_popup.cursor, '');
        let label = "Filter: ";
        let content_width = label.len() + display_text.chars().count();
        let inner_width = popup_width.saturating_sub(2); // -2 for side borders
        let padding = inner_width.saturating_sub(content_width);
        let _ = stdout.queue(Print(format!("\x1b[36m\x1b[0m{}{}{}\x1b[36m\x1b[0m", label, display_text, " ".repeat(padding))));

        // Draw border bottom
        let _ = stdout.queue(cursor::MoveTo(x, 2));
        let border_bottom = format!("\x1b[36m{}\x1b[0m", "".repeat(popup_width.saturating_sub(2)));
        let _ = stdout.queue(Print(border_bottom));
    }

    // Calculate and set cursor position in input area
    // This replicates the logic from render_input_area to avoid Save/Restore timing issues
    let prompt = &app.current_world().prompt;
    let prompt_len = strip_ansi_codes(prompt).chars().count();
    let cursor_line = app.input.cursor_line();
    let viewport_line = cursor_line.saturating_sub(app.input.viewport_start_line);

    // Input area starts after output + separator bar (1 line)
    let input_area_y = app.output_height + 1;
    let input_area_width = term_width.max(1);

    if viewport_line < app.input_height as usize {
        let chars_before_cursor = app.input.buffer[..app.input.cursor_position].chars().count();
        let effective_chars = if app.input.viewport_start_line == 0 {
            chars_before_cursor + prompt_len
        } else {
            chars_before_cursor
        };
        let cursor_col = effective_chars % input_area_width;
        let cursor_x = cursor_col as u16;
        let extra_lines = if app.input.viewport_start_line == 0 {
            (chars_before_cursor + prompt_len) / input_area_width
        } else {
            chars_before_cursor / input_area_width
        };
        let cursor_y = input_area_y + (viewport_line + extra_lines - cursor_line) as u16;
        let max_y = input_area_y + app.input_height - 1;
        let _ = stdout.queue(cursor::MoveTo(cursor_x, cursor_y.min(max_y)));
    }

    let _ = stdout.flush();
}

fn render_output_area(f: &mut Frame, app: &App, area: Rect) {
    let world = app.current_world();
    let visible_height = area.height as usize;
    let area_width = area.width as usize;

    // Clear the output area first
    f.render_widget(ratatui::widgets::Clear, area);

    // Check if showing splash screen - ratatui handles splash rendering
    if world.showing_splash {
        let output_text = render_splash_centered(world, visible_height, area_width);
        let output_paragraph = Paragraph::new(output_text);
        f.render_widget(output_paragraph, area);
        return;
    }

    // Check if any popup is visible - ratatui handles output when popups are shown
    let any_popup_visible = app.settings_popup.visible
        || app.world_selector.visible
        || app.confirm_dialog.visible
        || app.worlds_popup.visible
        || app.filter_popup.visible
        || app.help_popup.visible
        || app.menu_popup.visible
        || app.actions_popup.visible
        || app.web_popup.visible;

    // If no popup is visible, raw crossterm will handle output rendering
    // (it provides better ANSI color handling)
    // Just clear the area and return - crossterm will fill it in
    if !any_popup_visible {
        return;
    }

    // Popup is visible - render output with ratatui (crossterm is skipped when popups are shown)
    // First, fill the entire output area with background to cover any crossterm remnants
    let theme = app.settings.theme;
    let background = ratatui::widgets::Block::default().style(Style::default().bg(theme.bg()));
    f.render_widget(background, area);

    // Get lines to display
    let end = world.scroll_offset.saturating_add(1).min(world.output_lines.len());
    let start = end.saturating_sub(visible_height);

    // Build Text with proper ANSI color parsing
    let mut lines: Vec<Line<'_>> = Vec::with_capacity(end - start);

    for line in world.output_lines.iter().skip(start).take(end - start) {
        // Skip lines that are only ANSI codes (cursor control garbage)
        if is_ansi_only_line(&line.text) {
            continue;
        }
        // For legitimate blank lines (empty or whitespace), render as blank line
        if is_visually_empty(&line.text) {
            lines.push(Line::from(""));
            continue;
        }

        // Strip MUD tags if show_tags is disabled, add timestamp if enabled
        let display_line = if app.show_tags {
            // Show timestamp + original text when tags are shown
            format!("\x1b[36m{}\x1b[0m {}", line.format_timestamp(), line.text)
        } else {
            strip_mud_tag(&line.text)
        };

        // Parse ANSI codes and convert to ratatui spans
        match ansi_to_tui::IntoText::into_text(&display_line) {
            Ok(text) => {
                for l in text.lines {
                    lines.push(l);
                }
            }
            Err(_) => {
                lines.push(Line::raw(display_line));
            }
        }
    }

    let output_text = Text::from(lines);
    let output_paragraph = Paragraph::new(output_text).style(Style::default().bg(theme.bg()));
    f.render_widget(output_paragraph, area);
}

fn render_splash_centered<'a>(world: &World, visible_height: usize, area_width: usize) -> Text<'a> {
    let mut lines: Vec<Line<'static>> = Vec::new();

    // Calculate visible width of a string (excluding ANSI escape sequences)
    fn visible_width(s: &str) -> usize {
        let mut width = 0;
        let mut in_escape = false;
        for c in s.chars() {
            if c == '\x1b' {
                in_escape = true;
            } else if in_escape {
                if c == 'm' {
                    in_escape = false;
                }
            } else {
                width += unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);
            }
        }
        width
    }

    // Calculate vertical centering - how many blank lines to add at top
    let content_height = world.output_lines.len();
    let vertical_padding = if visible_height > content_height {
        (visible_height - content_height) / 2
    } else {
        0
    };

    // Add vertical padding
    for _ in 0..vertical_padding {
        lines.push(Line::from(""));
    }

    // Process and center each line
    for line in &world.output_lines {
        let line_width = visible_width(&line.text);
        let padding = if area_width > line_width {
            (area_width - line_width) / 2
        } else {
            0
        };

        // Create padded line
        let padded = format!("{:width$}{}", "", line.text, width = padding);

        // Parse ANSI codes and convert to ratatui spans
        match ansi_to_tui::IntoText::into_text(&padded) {
            Ok(text) => {
                for l in text.lines {
                    lines.push(l);
                }
            }
            Err(_) => {
                lines.push(Line::raw(padded));
            }
        }
    }

    Text::from(lines)
}

fn format_more_count(count: usize) -> String {
    if count <= 9999 {
        format!("{:>4}", count)
    } else if count < 100_000 {
        // 10K, 20K, etc.
        format!("{:>3}K", count / 1000)
    } else if count < 1_000_000 {
        // 100K, 200K, etc. - but only 4 chars, so use 99K+ for anything above
        format!("{:>3}K", (count / 1000).min(999))
    } else {
        "Alot".to_string()
    }
}

fn render_separator_bar(f: &mut Frame, app: &App, area: Rect) {
    let width = area.width as usize;
    let world = app.current_world();
    let theme = app.settings.theme;

    // Build bar components
    let time_str = get_current_time_12hr();

    // Status indicator - always reserve space for "More: XXXX" or "Hist: XXXX" (11 chars)
    // Priority: More (when paused) > Hist (when scrolled back) > underscores
    const STATUS_INDICATOR_LEN: usize = 11;
    let (status_str, status_active) = if world.paused && !world.pending_lines.is_empty() {
        // Show More indicator when paused with pending lines
        (format!("More: {}", format_more_count(world.pending_lines.len())), true)
    } else if !world.is_at_bottom() {
        // Show History indicator when scrolled back
        let lines_back = world.lines_from_bottom();
        (format!("Hist: {}", format_more_count(lines_back)), true)
    } else {
        // Fill with underscores when nothing to show
        ("_".repeat(STATUS_INDICATOR_LEN), false)
    };

    // World name
    let world_display = world.name.clone();

    // Tag indicator (only shown when F2 toggled to show tags)
    let tag_indicator = if app.show_tags { " [tag]" } else { "" };

    // Activity indicator - positioned at column 24
    const ACTIVITY_POSITION: usize = 24;
    let activity_count = app.activity_count();

    // Determine activity string based on available space
    // Full format: "(Activity: X)", Short format: "(Act X)"
    let activity_str = if activity_count > 0 {
        let full_format = format!("(Activity: {})", activity_count);
        let short_format = format!("(Act {})", activity_count);
        // Use short format if screen is narrow (less than 60 chars)
        if width < 60 {
            short_format
        } else {
            full_format
        }
    } else {
        String::new()
    };

    // Time on the right (no space before it, underscores fill to it)
    let time_display = time_str.clone();

    // Create styled spans
    let mut spans = Vec::new();

    // Status indicator on the left (black on red if active, dim underscores if not)
    spans.push(Span::styled(
        status_str.clone(),
        if status_active {
            Style::default().fg(Color::Black).bg(theme.fg_error())
        } else {
            Style::default().fg(theme.fg_dim())
        },
    ));

    // World name
    spans.push(Span::styled(
        world_display.clone(),
        Style::default().fg(theme.fg()),
    ));

    // Tag indicator (cyan, like prompt)
    if !tag_indicator.is_empty() {
        spans.push(Span::styled(
            tag_indicator.to_string(),
            Style::default().fg(theme.fg_accent()),
        ));
    }

    // Calculate current position after status, world name, and tag indicator
    let current_pos = status_str.len() + world_display.len() + tag_indicator.len();

    // Add underscores to reach position 24 (or as close as possible)
    if !activity_str.is_empty() && current_pos < ACTIVITY_POSITION {
        let padding = ACTIVITY_POSITION - current_pos;
        spans.push(Span::styled(
            "_".repeat(padding),
            Style::default().fg(theme.fg_dim()),
        ));
    }

    // Activity indicator (highlight color)
    if !activity_str.is_empty() {
        spans.push(Span::styled(
            activity_str.clone(),
            Style::default()
                .fg(theme.fg_highlight())
                .add_modifier(Modifier::BOLD),
        ));
    }

    // Calculate underscore padding - fill between content and time
    let used_len = if activity_str.is_empty() {
        status_str.len() + world_display.len() + tag_indicator.len()
    } else {
        ACTIVITY_POSITION.max(current_pos) + activity_str.len()
    };
    let underscore_count = width.saturating_sub(used_len + time_display.len());

    spans.push(Span::styled(
        "_".repeat(underscore_count),
        Style::default().fg(theme.fg_dim()),
    ));

    // Time on the right (no spaces around it)
    spans.push(Span::styled(time_display, Style::default().fg(theme.fg())));

    let line = Line::from(spans);
    let paragraph = Paragraph::new(line).style(Style::default().bg(theme.bg()));

    f.render_widget(paragraph, area);
}

fn render_input_area(f: &mut Frame, app: &mut App, area: Rect) {
    // Get prompt for current world only (clone to avoid borrow conflict)
    let prompt = app.current_world().prompt.clone();
    // Use visible length (without ANSI codes) for cursor positioning
    let prompt_len = strip_ansi_codes(&prompt).chars().count();

    let input_text = render_input(app, area.width as usize, &prompt);

    let input_paragraph = Paragraph::new(input_text);
    f.render_widget(input_paragraph, area);

    // Set cursor position (offset by prompt length on first line)
    let cursor_line = app.input.cursor_line();
    let viewport_line = cursor_line.saturating_sub(app.input.viewport_start_line);

    if viewport_line < app.input_height as usize {
        let inner_width = area.width.max(1) as usize;
        // Use character count for cursor column, not byte index
        let chars_before_cursor = app.input.buffer[..app.input.cursor_position].chars().count();
        // Add prompt length offset if on first display line and viewport starts at 0
        let effective_chars = if app.input.viewport_start_line == 0 {
            chars_before_cursor + prompt_len
        } else {
            chars_before_cursor
        };
        let cursor_col = effective_chars % inner_width;
        let cursor_x = area.x + cursor_col as u16;
        // Account for potential line wrap due to prompt
        let extra_lines = if app.input.viewport_start_line == 0 {
            (chars_before_cursor + prompt_len) / inner_width
        } else {
            chars_before_cursor / inner_width
        };
        let cursor_y = area.y + (viewport_line + extra_lines - cursor_line) as u16;
        f.set_cursor_position((cursor_x, cursor_y.min(area.y + area.height - 1)));
    }
}

fn render_input(app: &mut App, width: usize, prompt: &str) -> Text<'static> {
    let misspelled = app.find_misspelled_words();
    let chars: Vec<char> = app.input.buffer.chars().collect();

    // Calculate visible prompt length (without ANSI codes)
    let prompt_visible_len = strip_ansi_codes(prompt).chars().count();

    if width == 0 {
        return Text::default();
    }

    let mut lines: Vec<Line<'static>> = Vec::new();

    // If we're at the start, render the prompt first
    if app.input.viewport_start_line == 0 && !prompt.is_empty() {
        // Check if prompt has ANSI codes
        let has_ansi = prompt.contains("\x1b[");

        if has_ansi {
            // Parse ANSI codes and render with proper styling
            match ansi_to_tui::IntoText::into_text(&prompt) {
                Ok(text) => {
                    // Collect all spans from all lines into a single line
                    let mut all_spans: Vec<Span<'static>> = Vec::new();
                    for line in text.lines {
                        for span in line.spans {
                            all_spans.push(span);
                        }
                    }
                    if !all_spans.is_empty() {
                        lines.push(Line::from(all_spans));
                    }
                }
                Err(_) => {
                    // Fallback to cyan if parsing fails
                    lines.push(Line::from(Span::styled(
                        prompt.to_string(),
                        Style::default().fg(Color::Cyan),
                    )));
                }
            }
        } else {
            // No ANSI codes, use cyan
            lines.push(Line::from(Span::styled(
                prompt.to_string(),
                Style::default().fg(Color::Cyan),
            )));
        }
    }

    // Build a combined first line if prompt doesn't fill the width
    if app.input.viewport_start_line == 0 && !prompt.is_empty() && !lines.is_empty() {
        let prompt_line_chars = prompt_visible_len % width;
        let remaining_width = if prompt_line_chars == 0 && prompt_visible_len > 0 {
            0
        } else {
            width - prompt_line_chars
        };

        if remaining_width > 0 && !chars.is_empty() {
            // Add user input to the same line as prompt
            let input_chars_on_first_line = remaining_width.min(chars.len());
            let first_input: String = chars[..input_chars_on_first_line].iter().collect();

            // Get the last line (which has the prompt) and append user input
            if let Some(last_line) = lines.last_mut() {
                let mut new_spans = last_line.spans.clone();
                // Check for misspellings in this portion
                let misspelled_in_range: Vec<_> = misspelled
                    .iter()
                    .filter(|(s, e)| *s < input_chars_on_first_line || *e <= input_chars_on_first_line)
                    .cloned()
                    .collect();

                if misspelled_in_range.is_empty() {
                    new_spans.push(Span::raw(first_input));
                } else {
                    // Handle misspellings
                    let mut pos = 0;
                    for (start, end) in &misspelled_in_range {
                        let s = (*start).min(input_chars_on_first_line);
                        let e = (*end).min(input_chars_on_first_line);
                        if pos < s {
                            let text: String = chars[pos..s].iter().collect();
                            new_spans.push(Span::raw(text));
                        }
                        if s < e {
                            let text: String = chars[s..e].iter().collect();
                            new_spans.push(Span::styled(text, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)));
                        }
                        pos = e;
                    }
                    if pos < input_chars_on_first_line {
                        let text: String = chars[pos..input_chars_on_first_line].iter().collect();
                        new_spans.push(Span::raw(text));
                    }
                }
                *last_line = Line::from(new_spans);
            }

            // Now handle remaining input on subsequent lines
            let mut char_pos = input_chars_on_first_line;
            while char_pos < chars.len() && lines.len() < app.input_height as usize {
                let line_end = (char_pos + width).min(chars.len());
                let mut spans: Vec<Span<'static>> = Vec::new();
                let mut current_pos = char_pos;

                while current_pos < line_end {
                    let in_misspelled = misspelled
                        .iter()
                        .find(|(s, e)| current_pos >= *s && current_pos < *e);

                    if let Some(&(word_start, word_end)) = in_misspelled {
                        if current_pos > char_pos && spans.is_empty() {
                            let before_end = word_start.min(line_end);
                            if before_end > char_pos {
                                let text: String = chars[char_pos..before_end].iter().collect();
                                spans.push(Span::raw(text));
                            }
                        }
                        let mis_start = word_start.max(char_pos);
                        let mis_end = word_end.min(line_end);
                        let text: String = chars[mis_start..mis_end].iter().collect();
                        spans.push(Span::styled(text, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)));
                        current_pos = mis_end;
                    } else {
                        let next_mis = misspelled
                            .iter()
                            .filter(|(s, _)| *s > current_pos && *s < line_end)
                            .map(|(s, _)| *s)
                            .min();
                        let chunk_end = next_mis.unwrap_or(line_end);
                        let text: String = chars[current_pos..chunk_end].iter().collect();
                        spans.push(Span::raw(text));
                        current_pos = chunk_end;
                    }
                }

                if spans.is_empty() {
                    let text: String = chars[char_pos..line_end].iter().collect();
                    lines.push(Line::from(text));
                } else {
                    lines.push(Line::from(spans));
                }
                char_pos = line_end;
            }
        } else if remaining_width == 0 {
            // Prompt fills the line exactly, user input starts on next line
            let mut char_pos = 0;
            while char_pos < chars.len() && lines.len() < app.input_height as usize {
                let line_end = (char_pos + width).min(chars.len());
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
                char_pos = line_end;
            }
        }
    } else if app.input.viewport_start_line == 0 && prompt.is_empty() {
        // No prompt, just render user input
        let mut char_pos = 0;
        while char_pos < chars.len() && lines.len() < app.input_height as usize {
            let line_end = (char_pos + width).min(chars.len());
            let mut spans: Vec<Span<'static>> = Vec::new();
            let mut current_pos = char_pos;

            while current_pos < line_end {
                let in_misspelled = misspelled
                    .iter()
                    .find(|(s, e)| current_pos >= *s && current_pos < *e);

                if let Some(&(word_start, word_end)) = in_misspelled {
                    if current_pos > char_pos && spans.is_empty() {
                        let before_end = word_start.min(line_end);
                        if before_end > char_pos {
                            let text: String = chars[char_pos..before_end].iter().collect();
                            spans.push(Span::raw(text));
                        }
                    }
                    let mis_start = word_start.max(char_pos);
                    let mis_end = word_end.min(line_end);
                    let text: String = chars[mis_start..mis_end].iter().collect();
                    spans.push(Span::styled(text, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)));
                    current_pos = mis_end;
                } else {
                    let next_mis = misspelled
                        .iter()
                        .filter(|(s, _)| *s > current_pos && *s < line_end)
                        .map(|(s, _)| *s)
                        .min();
                    let chunk_end = next_mis.unwrap_or(line_end);
                    let text: String = chars[current_pos..chunk_end].iter().collect();
                    spans.push(Span::raw(text));
                    current_pos = chunk_end;
                }
            }

            if spans.is_empty() {
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
            } else {
                lines.push(Line::from(spans));
            }
            char_pos = line_end;
        }
    } else {
        // Scrolled down, don't show prompt
        let start_char = app.input.viewport_start_line * width;
        let mut char_pos = start_char;
        while char_pos < chars.len() && lines.len() < app.input_height as usize {
            let line_end = (char_pos + width).min(chars.len());
            let mut spans: Vec<Span<'static>> = Vec::new();
            let mut current_pos = char_pos;

            while current_pos < line_end {
                let in_misspelled = misspelled
                    .iter()
                    .find(|(s, e)| current_pos >= *s && current_pos < *e);

                if let Some(&(word_start, word_end)) = in_misspelled {
                    if current_pos > char_pos && spans.is_empty() {
                        let before_end = word_start.min(line_end);
                        if before_end > char_pos {
                            let text: String = chars[char_pos..before_end].iter().collect();
                            spans.push(Span::raw(text));
                        }
                    }
                    let mis_start = word_start.max(char_pos);
                    let mis_end = word_end.min(line_end);
                    let text: String = chars[mis_start..mis_end].iter().collect();
                    spans.push(Span::styled(text, Style::default().fg(Color::Red).add_modifier(Modifier::BOLD)));
                    current_pos = mis_end;
                } else {
                    let next_mis = misspelled
                        .iter()
                        .filter(|(s, _)| *s > current_pos && *s < line_end)
                        .map(|(s, _)| *s)
                        .min();
                    let chunk_end = next_mis.unwrap_or(line_end);
                    let text: String = chars[current_pos..chunk_end].iter().collect();
                    spans.push(Span::raw(text));
                    current_pos = chunk_end;
                }
            }

            if spans.is_empty() {
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
            } else {
                lines.push(Line::from(spans));
            }
            char_pos = line_end;
        }
    }

    // Pad remaining lines
    while lines.len() < app.input_height as usize {
        lines.push(Line::from(""));
    }

    Text::from(lines)
}

fn render_settings_popup(f: &mut Frame, app: &App) {
    if !app.settings_popup.visible {
        return;
    }

    let area = f.area();
    let popup = &app.settings_popup;
    let theme = app.settings.theme;

    // Helper to get field style
    let field_style = |field: SettingsField| -> Style {
        if field == popup.selected_field {
            if popup.editing {
                Style::default()
                    .fg(theme.fg_success())
                    .add_modifier(Modifier::BOLD)
            } else if field.is_button() {
                // Highlight buttons with background when selected
                Style::default()
                    .fg(theme.button_selected_fg())
                    .bg(theme.button_selected_bg())
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default()
                    .fg(theme.fg_highlight())
                    .add_modifier(Modifier::BOLD)
            }
        } else {
            Style::default().fg(theme.fg())
        }
    };

    // Label widths for alignment (longest label + 1 space)
    // Global: "World Switching:" = 16, so use 17
    // World: "Auto login:" = 11, so use 12
    let global_label_width = 17;
    let world_label_width = 12;

    // Maximum visible width for text field values (for scrolling)
    let max_field_display_width = 35usize;

    // Helper to render a text field with horizontal scrolling support
    let render_text_field = |label: &str, value: &str, field: SettingsField, width: usize| -> Line<'static> {
        let style = field_style(field);
        let display_value = if field == popup.selected_field && popup.editing {
            // Show edit buffer with cursor, applying scroll offset
            let buf = &popup.edit_buffer;
            let cursor = popup.edit_cursor;
            let scroll = popup.edit_scroll_offset;

            // Calculate visible portion
            let visible_width = max_field_display_width.saturating_sub(2); // Leave room for scroll indicators
            let buf_chars: Vec<char> = buf.chars().collect();
            let buf_len = buf_chars.len();

            // Build visible text with cursor
            let start = scroll.min(buf_len);
            let end = (scroll + visible_width).min(buf_len);

            let mut display = String::new();

            // Left scroll indicator
            if scroll > 0 {
                display.push('<');
            } else {
                display.push(' ');
            }

            // Visible text with cursor
            for (i, &c) in buf_chars.iter().enumerate() {
                if i == cursor {
                    display.push('|');
                }
                if i >= start && i < end {
                    display.push(c);
                }
            }
            // Cursor at end
            if cursor >= buf_len && cursor >= start {
                display.push('|');
            }

            // Right scroll indicator
            if end < buf_len {
                display.push('>');
            }

            display
        } else {
            // Not editing - show truncated value if needed
            let val_chars: Vec<char> = value.chars().collect();
            if val_chars.len() > max_field_display_width {
                format!("{}...", val_chars[..max_field_display_width - 3].iter().collect::<String>())
            } else {
                value.to_string()
            }
        };
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", display_value), style),
        ])
    };

    // Helper to render a toggle field
    let render_toggle_field = |label: &str, value: bool, field: SettingsField, width: usize| -> Line<'static> {
        let style = field_style(field);
        let value_str = if value { "on" } else { "off" };
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", value_str), style),
        ])
    };

    // Helper to render input height field
    let render_height_field = |label: &str, value: u16, field: SettingsField, width: usize| -> Line<'static> {
        let style = field_style(field);
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", value), style),
        ])
    };

    // Helper to render a button
    let render_button = |label: &str, field: SettingsField| -> Span<'static> {
        let style = field_style(field);
        Span::styled(format!("[ {} ]", label), style)
    };

    let (lines, title) = if popup.setup_mode {
        // Setup mode: only global settings
        let w = global_label_width;
        let lines = vec![
            Line::from(""),
            render_toggle_field("More mode:", popup.temp_more_mode, SettingsField::MoreMode, w),
            render_toggle_field("Spell check:", popup.temp_spell_check, SettingsField::SpellCheck, w),
            Line::from(vec![
                Span::styled(
                    format!("  {:<w$}", "World Switching:"),
                    field_style(SettingsField::WorldSwitching),
                ),
                Span::styled(
                    format!("[{}]", popup.temp_world_switch_mode.name()),
                    field_style(SettingsField::WorldSwitching),
                ),
            ]),
            render_toggle_field("Debug:", popup.temp_debug_enabled, SettingsField::Debug, w),
            render_toggle_field("Show tags:", popup.temp_show_tags, SettingsField::ShowTags, w),
            render_height_field("Input height:", popup.temp_input_height, SettingsField::InputHeight, w),
            Line::from(vec![
                Span::styled(
                    format!("  {:<w$}", "GUI Theme:"),
                    field_style(SettingsField::GuiTheme),
                ),
                Span::styled(
                    format!("[{}]", popup.temp_gui_theme.name()),
                    field_style(SettingsField::GuiTheme),
                ),
            ]),
            render_toggle_field("TLS Proxy:", popup.temp_tls_proxy_enabled, SettingsField::TLSProxy, w),
            Line::from(""),
            Line::from(vec![
                render_button("Save", SettingsField::SaveSetup),
                Span::raw("  "),
                render_button("Cancel", SettingsField::CancelSetup),
                Span::raw(" "),
            ]).alignment(Alignment::Right),
        ];
        (lines, " Global Settings ")
    } else {
        // World mode: all settings
        let w = world_label_width;
        let connect_text = "Connect";

        let mut lines = vec![
            Line::from(""),
            render_text_field("World:", &popup.temp_world_name, SettingsField::WorldName, w),
            // World type selector
            Line::from(vec![
                Span::styled(
                    format!("  {:<w$}", "Type:"),
                    field_style(SettingsField::WorldType),
                ),
                Span::styled(
                    format!("[{}]", popup.temp_world_type.name()),
                    field_style(SettingsField::WorldType),
                ),
            ]),
        ];

        // Add type-specific fields
        match popup.temp_world_type {
            WorldType::Mud => {
                lines.push(render_text_field("Hostname:", &popup.temp_hostname, SettingsField::Hostname, w));
                lines.push(render_text_field("Port:", &popup.temp_port, SettingsField::Port, w));
                lines.push(render_text_field("User:", &popup.temp_user, SettingsField::User, w));
                lines.push(render_text_field("Password:", &popup.temp_password, SettingsField::Password, w));
                lines.push(render_toggle_field("Use SSL:", popup.temp_use_ssl, SettingsField::UseSsl, w));
                lines.push(render_toggle_field("Logging:", popup.temp_log_enabled, SettingsField::LogFile, w));
                lines.push(Line::from(vec![
                    Span::styled(
                        format!("  {:<w$}", "Encoding:"),
                        field_style(SettingsField::Encoding),
                    ),
                    Span::styled(
                        format!("[{}]", popup.temp_encoding.name()),
                        field_style(SettingsField::Encoding),
                    ),
                ]));
                lines.push(Line::from(vec![
                    Span::styled(
                        format!("  {:<w$}", "Auto login:"),
                        field_style(SettingsField::AutoConnect),
                    ),
                    Span::styled(
                        format!("[{}]", popup.temp_auto_connect_type.name()),
                        field_style(SettingsField::AutoConnect),
                    ),
                ]));
                lines.push(Line::from(vec![
                    Span::styled(
                        format!("  {:<w$}", "Keep-Alive:"),
                        field_style(SettingsField::KeepAlive),
                    ),
                    Span::styled(
                        format!("[{}]", popup.temp_keep_alive_type.name()),
                        field_style(SettingsField::KeepAlive),
                    ),
                ]));
                // Conditionally add Keep-Alive CMD field only when Custom is selected
                if popup.temp_keep_alive_type == KeepAliveType::Custom {
                    lines.push(render_text_field("Keep-Alive CMD:", &popup.temp_keep_alive_cmd, SettingsField::KeepAliveCmd, w));
                }
            }
            WorldType::Slack => {
                lines.push(render_text_field("Token:", &popup.temp_slack_token, SettingsField::SlackToken, w));
                lines.push(render_text_field("Channel:", &popup.temp_slack_channel, SettingsField::SlackChannel, w));
                lines.push(render_text_field("Workspace:", &popup.temp_slack_workspace, SettingsField::SlackWorkspace, w));
                lines.push(render_toggle_field("Logging:", popup.temp_log_enabled, SettingsField::LogFile, w));
            }
            WorldType::Discord => {
                lines.push(render_text_field("Token:", &popup.temp_discord_token, SettingsField::DiscordToken, w));
                lines.push(render_text_field("Guild:", &popup.temp_discord_guild, SettingsField::DiscordGuild, w));
                lines.push(render_text_field("Channel:", &popup.temp_discord_channel, SettingsField::DiscordChannel, w));
                lines.push(render_text_field("DM User:", &popup.temp_discord_dm_user, SettingsField::DiscordDmUser, w));
                lines.push(render_toggle_field("Logging:", popup.temp_log_enabled, SettingsField::LogFile, w));
            }
        }

        lines.push(Line::from(""));
        lines.push(Line::from(vec![
            render_button("Save", SettingsField::SaveWorld),
            Span::raw(" "),
            render_button("Cancel", SettingsField::CancelWorld),
            Span::raw(" "),
            render_button("Delete", SettingsField::DeleteWorld),
            Span::raw(" "),
            render_button(connect_text, SettingsField::Connect),
            Span::raw(" "),
        ]).alignment(Alignment::Right));
        (lines, " World Settings ")
    };

    // Calculate dynamic width based on content
    // Find the maximum line width by summing span widths
    let max_content_width = lines.iter().map(|line| {
        line.spans.iter().map(|span| span.content.chars().count()).sum::<usize>()
    }).max().unwrap_or(20);

    // Add borders (2) and some padding (2)
    let popup_width = ((max_content_width + 4) as u16).min(area.width.saturating_sub(2));

    // Calculate required height for all content + borders
    let required_height = (lines.len() + 2) as u16; // +2 for borders
    // Use full terminal height minus 1 for margin if content doesn't fit
    let max_available_height = area.height.saturating_sub(1);
    let popup_height = required_height.min(max_available_height);

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = if popup_height >= area.height {
        0 // Start at top if popup fills screen
    } else {
        area.height.saturating_sub(popup_height) / 2
    };

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    let popup_block = Block::default()
        .title(title)
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_web_popup(f: &mut Frame, app: &App) {
    if !app.web_popup.visible {
        return;
    }

    let area = f.area();
    let popup = &app.web_popup;
    let theme = app.settings.theme;

    // Helper to get field style
    let field_style = |field: WebField| -> Style {
        if field == popup.selected_field {
            if popup.editing {
                Style::default()
                    .fg(theme.fg_success())
                    .add_modifier(Modifier::BOLD)
            } else if field.is_button() {
                Style::default()
                    .fg(theme.button_selected_fg())
                    .bg(theme.button_selected_bg())
                    .add_modifier(Modifier::BOLD)
            } else {
                Style::default()
                    .fg(theme.fg_highlight())
                    .add_modifier(Modifier::BOLD)
            }
        } else {
            Style::default().fg(theme.fg())
        }
    };

    let label_width = 17; // "WS Nonsecure:" = 13, add padding
    let max_field_display_width = 35usize;

    // Helper to render a text field with horizontal scrolling support
    let render_text_field = |label: &str, value: &str, field: WebField, width: usize| -> Line<'static> {
        let style = field_style(field);
        let display_value = if field == popup.selected_field && popup.editing {
            let buf = &popup.edit_buffer;
            let cursor = popup.edit_cursor;
            let scroll = popup.edit_scroll_offset;
            let visible_width = max_field_display_width.saturating_sub(2);
            let buf_chars: Vec<char> = buf.chars().collect();
            let buf_len = buf_chars.len();
            let start = scroll.min(buf_len);
            let end = (scroll + visible_width).min(buf_len);
            let mut display = String::new();
            if scroll > 0 { display.push('<'); } else { display.push(' '); }
            for (i, &c) in buf_chars.iter().enumerate() {
                if i == cursor { display.push('|'); }
                if i >= start && i < end { display.push(c); }
            }
            if cursor >= buf_len && cursor >= start { display.push('|'); }
            if end < buf_len { display.push('>'); }
            display
        } else {
            let val_chars: Vec<char> = value.chars().collect();
            if val_chars.len() > max_field_display_width {
                format!("{}...", val_chars[..max_field_display_width - 3].iter().collect::<String>())
            } else {
                value.to_string()
            }
        };
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", display_value), style),
        ])
    };

    // Helper to render a toggle field
    let render_toggle_field = |label: &str, value: bool, field: WebField, width: usize| -> Line<'static> {
        let style = field_style(field);
        let value_str = if value { "on" } else { "off" };
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", value_str), style),
        ])
    };

    // Helper to render a button
    let render_button = |label: &str, field: WebField| -> Span<'static> {
        let style = field_style(field);
        Span::styled(format!("[ {} ]", label), style)
    };

    let w = label_width;

    // Build dynamic field labels based on protocol
    let http_label = if popup.temp_web_secure { "HTTPS enabled:" } else { "HTTP enabled:" };
    let http_port_label = if popup.temp_web_secure { "HTTPS port:" } else { "HTTP port:" };
    let ws_label = if popup.temp_web_secure { "WSS enabled:" } else { "WS enabled:" };
    let ws_port_label = if popup.temp_web_secure { "WSS port:" } else { "WS port:" };
    let protocol_value = if popup.temp_web_secure { "Secure" } else { "Non-Secure" };

    // Helper to render protocol toggle (shows as option with current value)
    let render_protocol_field = |label: &str, value: &str, field: WebField, width: usize| -> Line<'static> {
        let style = field_style(field);
        Line::from(vec![
            Span::styled(format!("  {:<width$}", label), style),
            Span::styled(format!("[{}]", value), style),
        ])
    };

    let mut lines = vec![
        Line::from(""),
        render_protocol_field("Protocol:", protocol_value, WebField::Protocol, w),
        Line::from(""),
        Line::from(Span::styled("  -- Web Interface --", Style::default().fg(theme.fg_accent()))),
        render_toggle_field(http_label, popup.temp_http_enabled, WebField::HttpEnabled, w),
        render_text_field(http_port_label, &popup.temp_http_port, WebField::HttpPort, w),
        Line::from(""),
        Line::from(Span::styled("  -- WebSocket Server --", Style::default().fg(theme.fg_accent()))),
        render_toggle_field(ws_label, popup.temp_ws_enabled, WebField::WsEnabled, w),
        render_text_field(ws_port_label, &popup.temp_ws_port, WebField::WsPort, w),
        render_text_field("Password:", &popup.temp_ws_password, WebField::WsPassword, w),
        render_text_field("Allow List:", &popup.temp_ws_allow_list, WebField::WsAllowList, w),
    ];

    // Only show TLS cert/key fields when secure protocol is selected
    if popup.temp_web_secure {
        lines.push(Line::from(""));
        lines.push(Line::from(Span::styled("  -- TLS Settings --", Style::default().fg(theme.fg_accent()))));
        lines.push(render_text_field("TLS cert file:", &popup.temp_ws_cert_file, WebField::WsCertFile, w));
        lines.push(render_text_field("TLS key file:", &popup.temp_ws_key_file, WebField::WsKeyFile, w));
    }

    lines.push(Line::from(""));
    lines.push(Line::from(vec![
        render_button("Save", WebField::SaveWeb),
        Span::raw("  "),
        render_button("Cancel", WebField::CancelWeb),
        Span::raw(" "),
    ]).alignment(Alignment::Right));

    // Calculate dynamic size
    let max_content_width = lines.iter().map(|line| {
        line.spans.iter().map(|span| span.content.chars().count()).sum::<usize>()
    }).max().unwrap_or(20);

    let popup_width = ((max_content_width + 4) as u16).min(area.width.saturating_sub(2));
    let required_height = (lines.len() + 2) as u16;
    let max_available_height = area.height.saturating_sub(1);
    let popup_height = required_height.min(max_available_height);

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = if popup_height >= area.height {
        0
    } else {
        area.height.saturating_sub(popup_height) / 2
    };

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    f.render_widget(ratatui::widgets::Clear, popup_area);

    let popup_block = Block::default()
        .title(" Web Settings ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_confirm_dialog(f: &mut Frame, app: &App) {
    if !app.confirm_dialog.visible {
        return;
    }

    let area = f.area();
    let dialog = &app.confirm_dialog;
    let theme = app.settings.theme;

    // Build button styles with background highlight
    let yes_style = if dialog.yes_selected {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let no_style = if !dialog.yes_selected {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };

    let lines = vec![
        Line::from(""),
        Line::from(Span::styled(dialog.message.clone(), Style::default().fg(theme.fg()))).alignment(Alignment::Center),
        Line::from(""),
        Line::from(vec![
            Span::styled("[ Yes ]", yes_style),
            Span::raw("  "),
            Span::styled("[ No ]", no_style),
        ]).alignment(Alignment::Center),
    ];

    // Calculate dynamic size based on content
    let message_width = dialog.message.chars().count();
    let buttons_width = 17; // "[ Yes ]  [ No ]"
    let content_width = message_width.max(buttons_width);
    let popup_width = ((content_width + 6) as u16).min(area.width.saturating_sub(4)); // +6 for borders and padding
    let popup_height = ((lines.len() + 2) as u16).min(area.height.saturating_sub(2)); // +2 for borders

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    let popup_block = Block::default()
        .title(" Confirm ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.fg_error()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_worlds_popup(f: &mut Frame, app: &App) {
    if !app.worlds_popup.visible {
        return;
    }

    let area = f.area();
    let popup = &app.worlds_popup;
    let theme = app.settings.theme;

    // Calculate popup size based on content
    let content_width = popup.lines.iter().map(|l| l.len()).max().unwrap_or(20).max(20);
    let popup_width = (content_width + 4).min(area.width as usize - 4) as u16;
    let popup_height = (popup.lines.len() + 4).min(area.height as usize - 2) as u16; // +4 for borders and button

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Build content lines
    let mut lines: Vec<Line> = popup.lines.iter()
        .map(|l| Line::from(Span::styled(l.clone(), Style::default().fg(theme.fg()))))
        .collect();

    // Add blank line and OK button
    lines.push(Line::from(""));
    lines.push(Line::from(Span::styled(
        "[ OK ]",
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    )).alignment(Alignment::Center));

    let popup_block = Block::default()
        .title(" Connected Worlds ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.fg()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_filter_popup(f: &mut Frame, app: &App) {
    if !app.filter_popup.visible {
        return;
    }

    let area = f.area();
    let filter = &app.filter_popup;
    let theme = app.settings.theme;

    // Small popup in upper right corner
    let popup_width = 40u16.min(area.width);
    let popup_height = 3u16;

    let x = area.width.saturating_sub(popup_width); // Right edge
    let y = 0; // Top edge, no gap

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Show filter text with cursor
    let mut display_text = filter.filter_text.clone();
    display_text.insert(filter.cursor, '|');

    let lines = vec![
        Line::from(vec![
            Span::styled("Filter: ", Style::default().fg(theme.fg_accent())),
            Span::styled(display_text, Style::default().fg(theme.fg())),
        ]),
    ];

    let popup_block = Block::default()
        .title(" Find [Esc to close] ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_help_popup(f: &mut Frame, app: &App) {
    if !app.help_popup.visible {
        return;
    }

    let area = f.area();
    let help = &app.help_popup;
    let theme = app.settings.theme;

    // Centered popup - wider to fit longest help lines
    let popup_width = 60u16.min(area.width.saturating_sub(4));
    let popup_height = 20u16.min(area.height.saturating_sub(4)).max(10);

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Calculate visible height for content (popup height - 2 borders - 1 blank line - 1 button line)
    let visible_height = (popup_height as usize).saturating_sub(4);

    // Build lines from help content with scrolling
    let mut lines: Vec<Line<'static>> = Vec::new();

    for line in help.lines.iter().skip(help.scroll_offset).take(visible_height) {
        lines.push(Line::from(Span::styled(*line, Style::default().fg(theme.fg()))));
    }

    // Pad if needed
    while lines.len() < visible_height {
        lines.push(Line::from(""));
    }

    // Blank line before button
    lines.push(Line::from(""));

    // OK button (always highlighted since it's the only option)
    let ok_style = Style::default()
        .fg(theme.button_selected_fg())
        .bg(theme.button_selected_bg())
        .add_modifier(Modifier::BOLD);
    lines.push(Line::from(vec![
        Span::styled("[ OK ]", ok_style),
    ]).alignment(Alignment::Center));

    let popup_block = Block::default()
        .title(" Help ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_menu_popup(f: &mut Frame, app: &App) {
    if !app.menu_popup.visible {
        return;
    }

    let area = f.area();
    let menu = &app.menu_popup;
    let theme = app.settings.theme;

    // Small centered popup for menu items
    let items = MenuItem::all();
    let popup_width = 24u16.min(area.width.saturating_sub(4));
    let popup_height = (items.len() as u16 + 4).min(area.height.saturating_sub(4)); // items + 2 borders + 1 blank + 1 button

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Build lines for menu items
    let mut lines: Vec<Line<'static>> = Vec::new();

    for (i, item) in items.iter().enumerate() {
        let is_selected = i == menu.selected;
        let style = if is_selected {
            Style::default()
                .fg(theme.button_selected_fg())
                .bg(theme.button_selected_bg())
                .add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(theme.fg())
        };
        // Pad to full width for selection highlight
        let label = format!(" {:width$}", item.label(), width = popup_width as usize - 4);
        lines.push(Line::from(Span::styled(label, style)));
    }

    // Blank line before hint
    lines.push(Line::from(""));

    // Hint at bottom
    let hint_style = Style::default().fg(theme.fg_dim());
    lines.push(Line::from(Span::styled("  select, Enter open", hint_style)));

    let popup_block = Block::default()
        .title(" Menu ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_world_selector_popup(f: &mut Frame, app: &App) {
    if !app.world_selector.visible {
        return;
    }

    let area = f.area();
    let selector = &app.world_selector;
    let theme = app.settings.theme;

    // Get filtered world indices
    let filtered_indices = selector.filtered_indices(&app.worlds);

    // Calculate dynamic column widths based on actual content
    let name_width = app.worlds.iter()
        .map(|w| w.name.chars().count())
        .max()
        .unwrap_or(5)
        .clamp(5, 20); // Min "World", max 20
    let host_width = app.worlds.iter()
        .map(|w| w.settings.hostname.chars().count())
        .max()
        .unwrap_or(8)
        .clamp(8, 25); // Min "Hostname", max 25
    let port_width = 6; // Fixed for "Port" and typical values
    let user_width = app.worlds.iter()
        .map(|w| w.settings.user.chars().count())
        .max()
        .unwrap_or(4)
        .clamp(4, 15); // Min "User", max 15

    // Calculate total content width: marker(2) + columns + spacing(6) + some padding(4)
    let content_width = 2 + name_width + host_width + port_width + user_width + 6 + 4;
    let buttons_width = 60; // "[ Add ]  [ Edit ]  [ Delete ]  [ Connect ]  [ Cancel ] "
    let min_content_width = content_width.max(buttons_width);

    // Add borders (2) and apply screen limits
    let popup_width = ((min_content_width + 2) as u16).min(area.width.saturating_sub(4));
    let popup_height = ((filtered_indices.len() + 8) as u16).min(area.height.saturating_sub(4)).clamp(10, 20);

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Recalculate content_width based on actual popup_width
    let content_width = popup_width.saturating_sub(2) as usize;

    // Build lines
    let mut lines: Vec<Line<'static>> = Vec::new();

    // Filter line at top
    let filter_label = "Filter: ";
    let filter_display = if selector.editing_filter {
        let mut buf = selector.filter.clone();
        buf.insert(selector.filter_cursor, '|');
        buf
    } else if selector.filter.is_empty() {
        "(type to filter)".to_string()
    } else {
        selector.filter.clone()
    };
    let filter_style = if selector.editing_filter {
        Style::default().fg(theme.fg_success())
    } else {
        Style::default().fg(theme.fg_dim())
    };
    lines.push(Line::from(vec![
        Span::styled(filter_label, Style::default().fg(theme.fg_accent())),
        Span::styled(filter_display, filter_style),
    ]));
    lines.push(Line::from(""));

    // Recalculate host_width to fill remaining space
    let host_width = content_width.saturating_sub(name_width + port_width + user_width + 8); // 8 for marker and spacing

    lines.push(Line::from(vec![
        Span::styled(
            format!("  {:<name_width$} ", "World"),
            Style::default().fg(theme.fg_accent()).add_modifier(Modifier::BOLD),
        ),
        Span::styled(
            format!("{:<host_width$} ", "Hostname"),
            Style::default().fg(theme.fg_accent()).add_modifier(Modifier::BOLD),
        ),
        Span::styled(
            format!("{:<port_width$} ", "Port"),
            Style::default().fg(theme.fg_accent()).add_modifier(Modifier::BOLD),
        ),
        Span::styled(
            format!("{:<user_width$}", "User"),
            Style::default().fg(theme.fg_accent()).add_modifier(Modifier::BOLD),
        ),
    ]));

    // World list (scrollable area)
    // 7 = borders(2) + filter(1) + blank(1) + header(1) + blank-before-buttons(1) + buttons(1)
    let list_height = popup_height.saturating_sub(7) as usize;

    // Find where selected item is in the filtered list
    let selected_pos = filtered_indices
        .iter()
        .position(|&i| i == selector.selected_index)
        .unwrap_or(0);

    // Calculate scroll offset to keep selected visible
    let scroll_offset = if selected_pos >= list_height {
        selected_pos - list_height + 1
    } else {
        0
    };

    for &world_idx in filtered_indices.iter().skip(scroll_offset).take(list_height) {
        let world = &app.worlds[world_idx];
        let is_selected = world_idx == selector.selected_index;
        let is_current = world_idx == app.current_world_index;

        // Truncate hostname if needed
        let hostname = if world.settings.hostname.len() > host_width {
            format!("{}...", &world.settings.hostname[..host_width.saturating_sub(3)])
        } else {
            world.settings.hostname.clone()
        };

        let name_display = if world.name.len() > name_width {
            format!("{}...", &world.name[..name_width.saturating_sub(3)])
        } else {
            world.name.clone()
        };

        let user_display = if world.settings.user.len() > user_width {
            format!("{}...", &world.settings.user[..user_width.saturating_sub(3)])
        } else {
            world.settings.user.clone()
        };

        let marker = if is_current { "*" } else { " " };

        // Calculate highlighted content width (content_width - 2 for marker - 2 for right margin)
        let highlight_width = content_width.saturating_sub(4);

        // Build the content portion (everything after marker)
        let content = format!(
            "{:<name_width$} {:<host_width$} {:<port_width$} {:<user_width$}",
            name_display, hostname, world.settings.port, user_display
        );

        // Pad or truncate to exact highlight width
        let padded_content = if content.len() < highlight_width {
            format!("{:<width$}", content, width = highlight_width)
        } else {
            content[..highlight_width].to_string()
        };

        if is_selected {
            let marker_style = Style::default().fg(theme.fg_highlight()).add_modifier(Modifier::BOLD);
            let highlight_style = Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD);
            lines.push(Line::from(vec![
                Span::styled(format!("{} ", marker), marker_style),
                Span::styled(padded_content, highlight_style),
            ]));
        } else {
            let style = if world.connected {
                Style::default().fg(theme.fg_success())
            } else {
                Style::default().fg(theme.fg())
            };
            lines.push(Line::from(vec![
                Span::styled(format!("{} ", marker), style),
                Span::styled(padded_content, style),
            ]));
        }
    }

    // Pad remaining lines if list is short (subtract 5 for filter, blank, header, blank-before-buttons, buttons)
    while lines.len() < (popup_height as usize).saturating_sub(5) {
        lines.push(Line::from(""));
    }

    // Blank line before buttons
    lines.push(Line::from(""));

    // Button styles based on focus with background highlight
    let add_style = if selector.focus == WorldSelectorFocus::AddButton {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let edit_style = if selector.focus == WorldSelectorFocus::EditButton {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let delete_style = if selector.focus == WorldSelectorFocus::DeleteButton {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let connect_style = if selector.focus == WorldSelectorFocus::ConnectButton {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let cancel_style = if selector.focus == WorldSelectorFocus::CancelButton {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };

    // Buttons at bottom
    lines.push(Line::from(vec![
        Span::styled("[ Add ]", add_style),
        Span::raw("  "),
        Span::styled("[ Edit ]", edit_style),
        Span::raw("  "),
        Span::styled("[ Delete ]", delete_style),
        Span::raw("  "),
        Span::styled("[ Connect ]", connect_style),
        Span::raw("  "),
        Span::styled("[ Cancel ]", cancel_style),
        Span::raw(" "),
    ]).alignment(Alignment::Right));

    let popup_block = Block::default()
        .title(" Select World ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);

    // Render delete confirmation dialog if active
    if selector.confirm_delete {
        let world_name = if selector.selected_index < app.worlds.len() {
            app.worlds[selector.selected_index].name.clone()
        } else {
            "Unknown".to_string()
        };

        let confirm_width: u16 = 40;
        let confirm_height: u16 = 5;
        let confirm_x = area.width.saturating_sub(confirm_width) / 2;
        let confirm_y = area.height.saturating_sub(confirm_height) / 2;
        let confirm_area = Rect::new(confirm_x, confirm_y, confirm_width, confirm_height);

        f.render_widget(ratatui::widgets::Clear, confirm_area);

        let yes_style = if selector.confirm_delete_selected {
            Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(theme.fg())
        };
        let no_style = if !selector.confirm_delete_selected {
            Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
        } else {
            Style::default().fg(theme.fg())
        };

        let confirm_lines = vec![
            Line::from(format!("Delete world '{}'?", world_name)),
            Line::from(""),
            Line::from(vec![
                Span::styled("[ Yes ]", yes_style),
                Span::raw("    "),
                Span::styled("[ No ]", no_style),
            ]),
        ];

        let confirm_block = Block::default()
            .title(" Confirm Delete ")
            .borders(Borders::ALL)
            .border_style(Style::default().fg(theme.popup_border()))
            .style(Style::default().bg(theme.popup_bg()));

        let confirm_text = Paragraph::new(confirm_lines)
            .block(confirm_block)
            .alignment(Alignment::Center);

        f.render_widget(confirm_text, confirm_area);
    }
}

fn render_actions_popup(f: &mut Frame, app: &App) {
    if !app.actions_popup.visible {
        return;
    }

    let area = f.area();
    let popup = &app.actions_popup;
    let theme = app.settings.theme;

    // Common styles
    let label_style = Style::default().fg(theme.fg());
    let value_style = Style::default().fg(theme.fg());
    let selected_style = Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg());
    let button_style = Style::default().fg(theme.fg());
    let button_selected_style = Style::default()
        .fg(theme.button_selected_fg())
        .bg(theme.button_selected_bg())
        .add_modifier(Modifier::BOLD);
    let error_style = Style::default().fg(Color::Red);

    match popup.view {
        ActionsView::List => {
            // List view - show actions with Add/Edit/Delete/Cancel buttons
            // Get filtered indices
            let filtered_indices = popup.filtered_indices();

            let max_action_display = popup.actions.iter().map(|a| {
                let display_len = if a.pattern.is_empty() {
                    if a.world.is_empty() {
                        a.name.chars().count() + 3
                    } else {
                        a.name.chars().count() + a.world.chars().count() + 6
                    }
                } else if a.world.is_empty() {
                    a.name.chars().count() + 25
                } else {
                    a.name.chars().count() + a.world.chars().count() + 25
                };
                display_len
            }).max().unwrap_or(30);

            let buttons_width = 48; // "[ Add ]  [ Edit ]  [ Delete ]  [ Cancel ]"
            let content_width = max_action_display.max(buttons_width).max(40);
            let popup_width = ((content_width + 4) as u16).min(area.width.saturating_sub(4));
            let list_height = 8usize;
            // Extra height for filter line (1) + world filter indicator if present (1)
            let extra_lines = if popup.world_filter.is_empty() { 1 } else { 2 };
            let popup_height = ((list_height + 5 + extra_lines) as u16).min(area.height.saturating_sub(2));

            let x = area.width.saturating_sub(popup_width) / 2;
            let y = area.height.saturating_sub(popup_height) / 2;
            let popup_area = Rect::new(x, y, popup_width, popup_height);

            f.render_widget(ratatui::widgets::Clear, popup_area);

            let mut lines: Vec<Line<'static>> = Vec::new();
            let inner_width = popup_width.saturating_sub(4) as usize;

            // Filter line at top
            let filter_label = "Filter: ";
            let filter_display = if popup.filter_editing {
                let mut buf = popup.filter.clone();
                buf.insert(popup.filter_cursor, '|');
                buf
            } else if popup.filter.is_empty() {
                "(type to filter)".to_string()
            } else {
                popup.filter.clone()
            };
            let filter_style = if popup.filter_editing {
                Style::default().fg(theme.fg_success())
            } else {
                Style::default().fg(theme.fg_dim())
            };
            lines.push(Line::from(vec![
                Span::styled(filter_label, Style::default().fg(theme.fg_accent())),
                Span::styled(filter_display, filter_style),
            ]));

            // World filter indicator if set
            if !popup.world_filter.is_empty() {
                lines.push(Line::from(Span::styled(
                    format!("World: {}", popup.world_filter),
                    Style::default().fg(theme.fg_accent()),
                )));
            }

            lines.push(Line::from(""));

            let scroll = popup.scroll_offset;

            // Calculate scroll offset to keep selection visible
            let selected_pos = filtered_indices
                .iter()
                .position(|&i| i == popup.selected_index)
                .unwrap_or(0);
            let scroll_offset = if selected_pos >= list_height {
                selected_pos - list_height + 1
            } else {
                scroll.min(filtered_indices.len().saturating_sub(list_height))
            };

            // Calculate scrollbar position
            let total_items = filtered_indices.len();
            let scrollbar_chars: Vec<char> = if total_items <= list_height {
                // No scrolling needed - show empty track
                vec![''; list_height]
            } else {
                // Calculate thumb size and position
                let thumb_size = ((list_height as f64 / total_items as f64) * list_height as f64).max(1.0) as usize;
                let thumb_size = thumb_size.max(1).min(list_height);
                let scroll_range = total_items.saturating_sub(list_height);
                let thumb_pos = if scroll_range > 0 {
                    ((scroll_offset as f64 / scroll_range as f64) * (list_height - thumb_size) as f64) as usize
                } else {
                    0
                };
                let thumb_pos = thumb_pos.min(list_height - thumb_size);

                (0..list_height).map(|i| {
                    if i >= thumb_pos && i < thumb_pos + thumb_size {
                        '' // Thumb
                    } else {
                        '' // Track
                    }
                }).collect()
            };

            for i in 0..list_height {
                let filtered_pos = scroll_offset + i;
                let scrollbar_char = scrollbar_chars.get(i).copied().unwrap_or('');

                if filtered_pos < filtered_indices.len() {
                    let action_idx = filtered_indices[filtered_pos];
                    let action = &popup.actions[action_idx];
                    let is_selected = action_idx == popup.selected_index;
                    let marker = if is_selected { ">" } else { " " };
                    let style = if popup.list_field == ActionListField::List && is_selected {
                        selected_style
                    } else if is_selected {
                        Style::default().fg(theme.fg_accent())
                    } else {
                        value_style
                    };

                    let display = if action.pattern.is_empty() {
                        if action.world.is_empty() {
                            format!("{} /{}", marker, action.name)
                        } else {
                            format!("{} /{} ({})", marker, action.name, action.world)
                        }
                    } else if action.world.is_empty() {
                        format!("{} {} [{}]", marker, action.name, truncate_str(&action.pattern, 20))
                    } else {
                        format!("{} {} ({}) [{}]", marker, action.name, action.world, truncate_str(&action.pattern, 15))
                    };

                    // Truncate to leave room for scrollbar
                    let display_width = inner_width.saturating_sub(2);
                    let truncated = truncate_str(&display, display_width);
                    let padding = display_width.saturating_sub(truncated.chars().count());

                    lines.push(Line::from(vec![
                        Span::styled(truncated, style),
                        Span::raw(" ".repeat(padding)),
                        Span::styled(format!(" {}", scrollbar_char), Style::default().fg(theme.fg_dim())),
                    ]));
                } else {
                    // Empty line with scrollbar
                    let padding = inner_width.saturating_sub(2);
                    lines.push(Line::from(vec![
                        Span::raw(" ".repeat(padding)),
                        Span::styled(format!(" {}", scrollbar_char), Style::default().fg(theme.fg_dim())),
                    ]));
                }
            }

            lines.push(Line::from(""));

            // Buttons row
            let add_style = if popup.list_field == ActionListField::AddButton { button_selected_style } else { button_style };
            let edit_style = if popup.list_field == ActionListField::EditButton { button_selected_style } else { button_style };
            let del_style = if popup.list_field == ActionListField::DeleteButton { button_selected_style } else { button_style };
            let cancel_style = if popup.list_field == ActionListField::CancelButton { button_selected_style } else { button_style };

            lines.push(Line::from(vec![
                Span::styled("[ Add ]", add_style),
                Span::raw("  "),
                Span::styled("[ Edit ]", edit_style),
                Span::raw("  "),
                Span::styled("[ Delete ]", del_style),
                Span::raw("  "),
                Span::styled("[ Ok ]", cancel_style),
            ]));

            let popup_block = Block::default()
                .title(" Actions ")
                .borders(Borders::ALL)
                .border_style(Style::default().fg(theme.popup_border()))
                .style(Style::default().bg(theme.popup_bg()));

            let popup_text = Paragraph::new(lines).block(popup_block);
            f.render_widget(popup_text, popup_area);
        }

        ActionsView::Editor => {
            // Editor view - show name/world/match_type/pattern/command with Save/Cancel
            let popup_width = 60u16.min(area.width.saturating_sub(4));
            let popup_height = 20u16.min(area.height.saturating_sub(2));

            let x = area.width.saturating_sub(popup_width) / 2;
            let y = area.height.saturating_sub(popup_height) / 2;
            let popup_area = Rect::new(x, y, popup_width, popup_height);

            f.render_widget(ratatui::widgets::Clear, popup_area);

            let mut lines: Vec<Line<'static>> = Vec::new();
            let inner_width = popup_width.saturating_sub(4) as usize;
            let field_width = inner_width.saturating_sub(12);

            // Format field with cursor and horizontal scrolling
            let format_field_scrolled = |value: &str, cursor_byte: usize, is_current: bool, max_len: usize, scroll: usize| -> String {
                if is_current {
                    let chars: Vec<char> = value.chars().collect();
                    let cursor_char_pos = value[..cursor_byte.min(value.len())].chars().count();
                    let chars_len = chars.len();

                    // Calculate visible portion (leave room for scroll indicators)
                    let visible_width = max_len.saturating_sub(2);
                    let start = scroll.min(chars_len);
                    let end = (scroll + visible_width).min(chars_len);

                    let mut display = String::new();

                    // Left scroll indicator
                    if scroll > 0 {
                        display.push('<');
                    } else {
                        display.push(' ');
                    }

                    // Visible text with cursor
                    for (i, &c) in chars.iter().enumerate() {
                        if i == cursor_char_pos && i >= start && i < end {
                            display.push('|');
                        }
                        if i >= start && i < end {
                            display.push(c);
                        }
                    }
                    // Cursor at end
                    if cursor_char_pos >= chars_len && cursor_char_pos >= start {
                        display.push('|');
                    }

                    // Right scroll indicator
                    if end < chars_len {
                        display.push('>');
                    }

                    display
                } else {
                    // Not current field - just truncate
                    truncate_str(value, max_len).to_string()
                }
            };

            // Use selected_style for label when field is active, value_style for content
            let name_label_style = if popup.editor_field == ActionEditorField::Name { selected_style } else { label_style };
            let world_label_style = if popup.editor_field == ActionEditorField::World { selected_style } else { label_style };
            let match_type_label_style = if popup.editor_field == ActionEditorField::MatchType { selected_style } else { label_style };
            let pattern_label_style = if popup.editor_field == ActionEditorField::Pattern { selected_style } else { label_style };
            let command_label_style = if popup.editor_field == ActionEditorField::Command { selected_style } else { label_style };

            // Get scroll offset only for the current field
            let scroll = popup.edit_scroll_offset;

            lines.push(Line::from(""));

            lines.push(Line::from(vec![
                Span::styled("Name:      ", name_label_style),
                Span::styled(
                    format!("[{}]", format_field_scrolled(&popup.edit_name, popup.cursor_pos, popup.editor_field == ActionEditorField::Name, field_width.saturating_sub(2), if popup.editor_field == ActionEditorField::Name { scroll } else { 0 })),
                    value_style,
                ),
            ]));

            lines.push(Line::from(vec![
                Span::styled("World:     ", world_label_style),
                Span::styled(
                    format!("[{}]", format_field_scrolled(&popup.edit_world, popup.cursor_pos, popup.editor_field == ActionEditorField::World, field_width.saturating_sub(2), if popup.editor_field == ActionEditorField::World { scroll } else { 0 })),
                    value_style,
                ),
            ]));

            // Match Type toggle field
            let match_type_value = format!("< {} >", popup.edit_match_type.as_str());
            lines.push(Line::from(vec![
                Span::styled("Match Type:", match_type_label_style),
                Span::styled(match_type_value, if popup.editor_field == ActionEditorField::MatchType { selected_style } else { value_style }),
            ]));

            lines.push(Line::from(vec![
                Span::styled("Pattern:   ", pattern_label_style),
                Span::styled(
                    format!("[{}]", format_field_scrolled(&popup.edit_pattern, popup.cursor_pos, popup.editor_field == ActionEditorField::Pattern, field_width.saturating_sub(2), if popup.editor_field == ActionEditorField::Pattern { scroll } else { 0 })),
                    value_style,
                ),
            ]));

            // Command field: 5-line mini-editor with viewport scrolling
            lines.push(Line::from(Span::styled("Command:", command_label_style)));

            let cmd_width = inner_width.saturating_sub(6); // Leave room for "  [" and "]"
            let wrapped_lines = popup.wrap_command_lines(cmd_width);
            let (cursor_row, cursor_col) = popup.get_command_cursor_row_col(cmd_width);
            let visible_rows = 5;
            let scroll_row = popup.command_scroll_row;
            let total_rows = wrapped_lines.len();
            let is_command_active = popup.editor_field == ActionEditorField::Command;

            // Show up indicator if scrolled down
            if scroll_row > 0 {
                lines.push(Line::from(vec![
                    Span::styled("  ", label_style),
                    Span::styled(" more above", Style::default().fg(Color::DarkGray)),
                ]));
            }

            // Render visible rows (3 rows)
            for row_idx in 0..visible_rows {
                let actual_row = scroll_row + row_idx;
                let line_text = wrapped_lines.get(actual_row).cloned().unwrap_or_default();

                // Build display string with cursor if this is the active field
                let display = if is_command_active && actual_row == cursor_row {
                    let chars: Vec<char> = line_text.chars().collect();
                    let mut s = String::new();
                    for (i, &c) in chars.iter().enumerate() {
                        if i == cursor_col {
                            s.push('|');
                        }
                        s.push(c);
                    }
                    if cursor_col >= chars.len() {
                        s.push('|');
                    }
                    // Pad to fill the width
                    while s.chars().count() < cmd_width + 1 {
                        s.push(' ');
                    }
                    s
                } else {
                    // Not active or not cursor row - just pad the text
                    let mut s = line_text.clone();
                    while s.chars().count() < cmd_width {
                        s.push(' ');
                    }
                    s
                };

                let bracket_left = if row_idx == 0 { "[" } else { " " };
                let bracket_right = if row_idx == visible_rows - 1 { "]" } else { " " };

                lines.push(Line::from(vec![
                    Span::styled("  ", label_style),
                    Span::styled(bracket_left, label_style),
                    Span::styled(display, value_style),
                    Span::styled(bracket_right, label_style),
                ]));
            }

            // Show down indicator if more rows below
            if scroll_row + visible_rows < total_rows {
                lines.push(Line::from(vec![
                    Span::styled("  ", label_style),
                    Span::styled(" more below", Style::default().fg(Color::DarkGray)),
                ]));
            }

            lines.push(Line::from(""));

            // Error message if any
            if let Some(ref error) = popup.error_message {
                lines.push(Line::from(Span::styled(error.clone(), error_style)));
            } else {
                lines.push(Line::from(""));
            }

            // Buttons row
            let save_style = if popup.editor_field == ActionEditorField::SaveButton { button_selected_style } else { button_style };
            let cancel_style = if popup.editor_field == ActionEditorField::CancelButton { button_selected_style } else { button_style };

            lines.push(Line::from(vec![
                Span::styled("[ Save ]", save_style),
                Span::raw("  "),
                Span::styled("[ Cancel ]", cancel_style),
            ]));

            let title = if popup.editing_index.is_some() { " Edit Action " } else { " New Action " };
            let popup_block = Block::default()
                .title(title)
                .borders(Borders::ALL)
                .border_style(Style::default().fg(theme.popup_border()))
                .style(Style::default().bg(theme.popup_bg()));

            let popup_text = Paragraph::new(lines).block(popup_block);
            f.render_widget(popup_text, popup_area);
        }

        ActionsView::ConfirmDelete => {
            // Confirm delete dialog
            let popup_width = 40u16.min(area.width.saturating_sub(4));
            let popup_height = 6u16.min(area.height.saturating_sub(2));

            let x = area.width.saturating_sub(popup_width) / 2;
            let y = area.height.saturating_sub(popup_height) / 2;
            let popup_area = Rect::new(x, y, popup_width, popup_height);

            f.render_widget(ratatui::widgets::Clear, popup_area);

            let action_name = popup.actions.get(popup.selected_index)
                .map(|a| a.name.as_str())
                .unwrap_or("this action");

            let yes_style = if popup.confirm_selected { button_selected_style } else { button_style };
            let no_style = if !popup.confirm_selected { button_selected_style } else { button_style };

            let lines = vec![
                Line::from(""),
                Line::from(Span::styled(
                    format!("Delete '{}'?", truncate_str(action_name, 20)),
                    label_style,
                )),
                Line::from(""),
                Line::from(vec![
                    Span::styled("[ Yes ]", yes_style),
                    Span::raw("    "),
                    Span::styled("[ No ]", no_style),
                ]),
            ];

            let popup_block = Block::default()
                .title(" Confirm Delete ")
                .borders(Borders::ALL)
                .border_style(Style::default().fg(theme.popup_border()))
                .style(Style::default().bg(theme.popup_bg()));

            let popup_text = Paragraph::new(lines).block(popup_block);
            f.render_widget(popup_text, popup_area);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_insert_char_ascii() {
        let mut input = InputArea::new(3);
        input.insert_char('a');
        input.insert_char('b');
        input.insert_char('c');
        assert_eq!(input.buffer, "abc");
        assert_eq!(input.cursor_position, 3);
    }

    #[test]
    fn test_insert_char_emoji() {
        let mut input = InputArea::new(3);
        input.insert_char('');
        assert_eq!(input.buffer, "");
        assert_eq!(input.cursor_position, 4); // emoji is 4 bytes

        input.insert_char('a');
        assert_eq!(input.buffer, "a");
        assert_eq!(input.cursor_position, 5);
    }

    #[test]
    fn test_insert_char_mixed() {
        let mut input = InputArea::new(3);
        input.insert_char('H');
        input.insert_char('i');
        input.insert_char('');
        input.insert_char('!');
        assert_eq!(input.buffer, "Hi!");
        assert_eq!(input.cursor_position, 7); // 2 + 4 + 1 bytes
    }

    #[test]
    fn test_move_cursor_left_ascii() {
        let mut input = InputArea::new(3);
        input.buffer = "abc".to_string();
        input.cursor_position = 3;

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 2);

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0);

        // Should not go below 0
        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0);
    }

    #[test]
    fn test_move_cursor_left_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 6; // end of string (1 + 4 + 1 bytes)

        input.move_cursor_left(); // move before 'b'
        assert_eq!(input.cursor_position, 5);

        input.move_cursor_left(); // move before emoji (skips all 4 bytes)
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_left(); // move before 'a'
        assert_eq!(input.cursor_position, 0);
    }

    #[test]
    fn test_move_cursor_right_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 0;

        input.move_cursor_right(); // move after 'a'
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_right(); // move after emoji (skips all 4 bytes)
        assert_eq!(input.cursor_position, 5);

        input.move_cursor_right(); // move after 'b'
        assert_eq!(input.cursor_position, 6);

        // Should not go beyond end
        input.move_cursor_right();
        assert_eq!(input.cursor_position, 6);
    }

    #[test]
    fn test_delete_char_ascii() {
        let mut input = InputArea::new(3);
        input.buffer = "abc".to_string();
        input.cursor_position = 3;

        input.delete_char();
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 2);
    }

    #[test]
    fn test_delete_char_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 5; // after emoji

        input.delete_char(); // delete emoji
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 1);
    }

    #[test]
    fn test_delete_char_forward_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 1; // before emoji

        input.delete_char_forward(); // delete emoji
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 1);
    }

    #[test]
    fn test_cursor_line_with_emoji() {
        let mut input = InputArea::new(3);
        input.width = 5;
        // 5 emojis = 5 characters, should wrap to 2 lines
        input.buffer = "".to_string();
        input.cursor_position = input.buffer.len(); // end

        // 5 chars at width 5 = cursor on line 1 (0-indexed)
        assert_eq!(input.cursor_line(), 1);
    }

    #[test]
    fn test_delete_word_before_cursor_with_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "hello  world".to_string();
        input.cursor_position = input.buffer.len();

        input.delete_word_before_cursor(); // delete "world"
        assert_eq!(input.buffer, "hello  ");

        // delete_word skips whitespace first, then deletes non-whitespace
        // so this deletes " " (space + emojis)
        input.delete_word_before_cursor();
        assert_eq!(input.buffer, "hello ");

        input.delete_word_before_cursor(); // delete "hello"
        assert_eq!(input.buffer, "");
    }

    #[test]
    fn test_home_and_end() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 5;

        input.home();
        assert_eq!(input.cursor_position, 0);

        input.end();
        assert_eq!(input.cursor_position, 6);
    }

    #[test]
    fn test_insert_at_middle_with_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 1; // between a and b

        input.insert_char('');
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 5); // 1 + 4 bytes
    }

    #[test]
    fn test_multiple_emojis() {
        let mut input = InputArea::new(3);
        input.insert_char('');
        input.insert_char('');
        input.insert_char('');

        assert_eq!(input.buffer, "");
        assert_eq!(input.cursor_position, 12); // 3 emojis * 4 bytes each

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 8);

        input.delete_char();
        assert_eq!(input.buffer, "");
        assert_eq!(input.cursor_position, 4);
    }

    #[test]
    fn test_unicode_characters() {
        let mut input = InputArea::new(3);
        // Test various unicode: Chinese, emoji, accented
        input.insert_char('');  // 3 bytes
        input.insert_char('');  // 4 bytes
        input.insert_char('');   // 2 bytes

        assert_eq!(input.buffer, "");
        assert_eq!(input.cursor_position, 9); // 3 + 4 + 2

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 7); // before 

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 3); // before 

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0); // before 
    }

    #[test]
    fn test_password_encrypt_decrypt() {
        // Test basic encryption/decryption
        let password = "mysecretpassword";
        let encrypted = encrypt_password(password);
        assert!(encrypted.starts_with("ENC:"));
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_password_empty() {
        // Empty password should stay empty
        let encrypted = encrypt_password("");
        assert_eq!(encrypted, "");
        let decrypted = decrypt_password("");
        assert_eq!(decrypted, "");
    }

    #[test]
    fn test_password_plain_fallback() {
        // Plain passwords (not starting with ENC:) should be returned as-is
        let plain = "plainpassword";
        let decrypted = decrypt_password(plain);
        assert_eq!(decrypted, plain);
    }

    #[test]
    fn test_password_special_chars() {
        // Test password with special characters
        let password = "p@$$w0rd!#$%^&*()";
        let encrypted = encrypt_password(password);
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_password_unicode() {
        // Test password with unicode
        let password = "";
        let encrypted = encrypt_password(password);
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_hash_password() {
        let hash = hash_password("test");
        assert_eq!(hash, "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08");
    }

    #[tokio::test]
    async fn test_websocket_auth() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};

        // Start a minimal WebSocket server on a random port
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        // Expected password hash for "test"
        let server_password = "test";
        let expected_hash = hash_password(server_password);
        println!("Server expects hash: {}", expected_hash);

        // Spawn server task
        let server_hash = expected_hash.clone();
        let server_task = tokio::spawn(async move {
            let (stream, _) = listener.accept().await.unwrap();
            let ws_stream = tokio_tungstenite::accept_async(stream).await.unwrap();
            let (mut ws_sink, mut ws_source) = ws_stream.split();

            while let Some(msg_result) = ws_source.next().await {
                if let Ok(WsRawMessage::Text(text)) = msg_result {
                    println!("Server received: {}", text);
                    if let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) {
                        if let WsMessage::AuthRequest { password_hash: client_hash } = ws_msg {
                            println!("Client hash: {}", client_hash);
                            println!("Server hash: {}", server_hash);
                            let auth_success = client_hash == server_hash;
                            println!("Auth success: {}", auth_success);
                            let response = WsMessage::AuthResponse {
                                success: auth_success,
                                error: if auth_success { None } else { Some("Invalid password".to_string()) },
                            };
                            let json = serde_json::to_string(&response).unwrap();
                            ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();
                            break;
                        }
                    }
                }
            }
        });

        // Give server time to start
        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // Connect client
        let url = format!("ws://127.0.0.1:{}", port);
        let (ws_stream, _) = connect_async(&url).await.unwrap();
        let (mut ws_sink, mut ws_source) = ws_stream.split();

        // Send auth request with correct password hash
        let client_password = "test";
        let client_hash = hash_password(client_password);
        println!("Client sending hash: {}", client_hash);
        let auth_msg = WsMessage::AuthRequest { password_hash: client_hash };
        let json = serde_json::to_string(&auth_msg).unwrap();
        ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();

        // Wait for response
        if let Some(Ok(WsRawMessage::Text(text))) = ws_source.next().await {
            println!("Client received: {}", text);
            let response: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { success, error } = response {
                assert!(success, "Auth should succeed but got error: {:?}", error);
            } else {
                panic!("Expected AuthResponse");
            }
        } else {
            panic!("No response received");
        }

        server_task.abort();
    }

    #[test]
    fn test_world_cycling_all_connected() {
        // Test cycling through multiple connected worlds
        let mut app = App::new();
        app.worlds.clear(); // Remove any default world

        // Create 3 connected worlds with different names
        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // Verify initial state
        assert_eq!(app.worlds[app.current_world_index].name, "alpha");

        // Cycle forward: alpha -> cave
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "After first next_world from alpha, should be on cave");

        // Cycle forward: cave -> zeta
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "After second next_world from cave, should be on zeta");

        // Cycle forward: zeta -> alpha (wrap)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "alpha",
            "After third next_world from zeta, should wrap to alpha");

        // Cycle backward: alpha -> zeta
        app.prev_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "After prev_world from alpha, should be on zeta");

        // Cycle backward: zeta -> cave
        app.prev_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "After prev_world from zeta, should be on cave");
    }

    #[test]
    fn test_world_cycling_with_disconnected() {
        // Test that disconnected worlds without unseen output are skipped
        let mut app = App::new();
        app.worlds.clear();

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_beta = World::new("beta");
        world_beta.connected = false; // Disconnected, no unseen output
        app.worlds.push(world_beta);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        app.worlds.push(world_cave);

        app.current_world_index = 0; // Start on alpha

        // Cycle forward: alpha -> cave (skipping disconnected beta)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "Should skip disconnected beta and go to cave");

        // Cycle forward: cave -> alpha (skipping disconnected beta)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "alpha",
            "Should skip disconnected beta and wrap to alpha");
    }

    #[test]
    fn test_world_cycling_case_insensitive_sort() {
        // Test that world names are sorted case-insensitively
        let mut app = App::new();
        app.worlds.clear();

        let mut world_alpha = World::new("Alpha"); // Capital A
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave"); // lowercase c
        world_cave.connected = true;
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("Zeta"); // Capital Z
        world_zeta.connected = true;
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on Alpha

        // Should cycle: Alpha -> cave -> Zeta (case-insensitive alphabetical)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "Case-insensitive sort: Alpha -> cave");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "Zeta",
            "Case-insensitive sort: cave -> Zeta");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "Alpha",
            "Case-insensitive sort: Zeta -> Alpha (wrap)");
    }

    #[test]
    fn test_world_cycling_unseen_first_no_unseen() {
        // Test world_switch_mode=UnseenFirst when no worlds have unseen output
        let mut app = App::new();
        app.worlds.clear();
        app.settings.world_switch_mode = WorldSwitchMode::UnseenFirst;

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        world_alpha.unseen_lines = 0; // No unseen
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        world_cave.unseen_lines = 0; // No unseen
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        world_zeta.unseen_lines = 0; // No unseen
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // With UnseenFirst ON but no unseen, should cycle alphabetically
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "With UnseenFirst but no unseen, should go to cave");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "With UnseenFirst but no unseen, should go to zeta");
    }

    #[test]
    fn test_world_cycling_unseen_first_with_unseen() {
        // Test world_switch_mode=UnseenFirst prioritizes worlds with unseen output
        let mut app = App::new();
        app.worlds.clear();
        app.settings.world_switch_mode = WorldSwitchMode::UnseenFirst;

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        world_alpha.unseen_lines = 0; // No unseen
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        world_cave.unseen_lines = 5; // Has unseen!
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        world_zeta.unseen_lines = 0; // No unseen
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // With UnseenFirst ON and cave has unseen, should go to cave first
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "With UnseenFirst, should prioritize cave with unseen output");
    }

    #[test]
    fn test_decode_strips_control_chars() {
        // Test that carriage return is stripped
        let input = b"hello\rworld";
        let result = Encoding::Utf8.decode(input);
        assert!(!result.contains('\r'), "Carriage return should be stripped");
        assert_eq!(result, "helloworld", "CR should be removed, text concatenated");

        // Test that other control characters are stripped but tab/newline kept
        let input = b"a\x01b\tc\nd\x7Fe";
        let result = Encoding::Utf8.decode(input);
        assert_eq!(result, "ab\tc\nde", "Control chars stripped except tab/newline");

        // Test that BEL is stripped in final output
        let input = b"hello\x07world";
        let result = Encoding::Utf8.decode(input);
        assert!(!result.contains('\x07'), "BEL should be stripped in final output");
    }

    #[test]
    fn test_strip_non_sgr_sequences() {
        // Test that SGR (color/style) sequences are kept
        let input = "\x1b[31mred text\x1b[0m";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "\x1b[31mred text\x1b[0m", "SGR sequences should be preserved");

        // Test that cursor position (H) inserts newline
        let input = "first\x1b[10;5Hsecond";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "first\nsecond", "Cursor positioning (H) should insert newline");

        // Test that cursor column (G) inserts space
        let input = "before\x1b[10Gafter";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "before after", "Cursor column (G) should insert space");

        // Test that erase sequences are stripped without separator
        let input = "hello\x1b[2Jworld";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "helloworld", "Erase (J) should be stripped");

        // Test that erase line (K) is stripped
        let input = "hello\x1b[Kworld";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "helloworld", "Erase line (K) should be stripped");

        // Test OSC (window title) sequences are stripped
        let input = "before\x1b]0;Window Title\x07after";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "beforeafter", "OSC sequences should be stripped");

        // Test cursor up/down inserts newline
        let input = "line1\x1b[Aline2";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "line1\nline2", "Cursor up (A) should insert newline");

        // Test @ character (insert character)
        let input = "before\x1b[5@after";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "beforeafter", "Insert character (@) should be stripped");

        // Test ~ character (function key)
        let input = "text\x1b[6~more";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "textmore", "Function key sequences (~) should be stripped");

        // Test that consecutive positioning doesn't add multiple separators
        let input = "text\x1b[H\x1b[Hmore";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "text\nmore", "Consecutive H should only add one newline");
    }

    #[test]
    fn test_keep_alive_type_cycling() {
        // Test next() cycling
        assert_eq!(KeepAliveType::None.next(), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::Nop.next(), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::Custom.next(), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::Generic.next(), KeepAliveType::None);

        // Test prev() cycling
        assert_eq!(KeepAliveType::None.prev(), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::Nop.prev(), KeepAliveType::None);
        assert_eq!(KeepAliveType::Custom.prev(), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::Generic.prev(), KeepAliveType::Custom);
    }

    #[test]
    fn test_keep_alive_type_name() {
        assert_eq!(KeepAliveType::None.name(), "None");
        assert_eq!(KeepAliveType::Nop.name(), "NOP");
        assert_eq!(KeepAliveType::Custom.name(), "Custom");
        assert_eq!(KeepAliveType::Generic.name(), "Generic");
    }

    #[test]
    fn test_keep_alive_type_from_name() {
        assert_eq!(KeepAliveType::from_name("None"), KeepAliveType::None);
        assert_eq!(KeepAliveType::from_name("none"), KeepAliveType::None);
        assert_eq!(KeepAliveType::from_name("NOP"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name("nop"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name("Custom"), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::from_name("custom"), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::from_name("Generic"), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::from_name("generic"), KeepAliveType::Generic);
        // Unknown should default to Nop
        assert_eq!(KeepAliveType::from_name("unknown"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name(""), KeepAliveType::Nop);
    }

    #[test]
    fn test_idler_message_filter() {
        // Test that lines containing idler message pattern are detected
        let idler_line = "You don't know how to help commands ###_idler_message_123_###.";
        assert!(idler_line.contains("###_idler_message_") && idler_line.contains("_###"));

        let normal_line = "You say, \"Hello world!\"";
        assert!(!(normal_line.contains("###_idler_message_") && normal_line.contains("_###")));

        // Test partial matches don't trigger
        let partial1 = "###_idler_message_ incomplete";
        assert!(!(partial1.contains("###_idler_message_") && partial1.contains("_###")));

        let partial2 = "incomplete _### suffix only";
        assert!(!(partial2.contains("###_idler_message_") && partial2.contains("_###")));
    }

    #[test]
    fn test_idler_message_replacement() {
        // Test that ##rand## is replaced correctly in custom commands
        let custom_cmd = "look ##rand##";
        let rand_num = 42u32;
        let idler_tag = format!("###_idler_message_{}_###", rand_num);
        let result = custom_cmd.replace("##rand##", &idler_tag);
        assert_eq!(result, "look ###_idler_message_42_###");

        // Test generic command format
        let generic_cmd = format!("help commands ###_idler_message_{}_###", rand_num);
        assert_eq!(generic_cmd, "help commands ###_idler_message_42_###");
    }

    #[test]
    fn test_is_visually_empty() {
        use super::is_visually_empty;

        // Empty string is visually empty
        assert!(is_visually_empty(""));

        // Whitespace-only is visually empty
        assert!(is_visually_empty("   "));
        assert!(is_visually_empty("\t"));
        assert!(is_visually_empty("  \t  "));

        // ANSI codes only are visually empty
        assert!(is_visually_empty("\x1b[0m"));
        assert!(is_visually_empty("\x1b[31m\x1b[0m"));
        assert!(is_visually_empty("\x1b[1;32m"));

        // ANSI codes with whitespace are visually empty
        assert!(is_visually_empty("\x1b[0m   \x1b[31m"));
        assert!(is_visually_empty("  \x1b[0m  "));

        // Visible text is NOT visually empty
        assert!(!is_visually_empty("hello"));
        assert!(!is_visually_empty("  hello  "));
        assert!(!is_visually_empty("\x1b[31mhello\x1b[0m"));
        assert!(!is_visually_empty("a"));
        assert!(!is_visually_empty("\x1b[0m.\x1b[0m"));
    }

    #[test]
    fn test_strip_mud_tag() {
        use super::strip_mud_tag;

        // Basic tag stripping
        assert_eq!(strip_mud_tag("[channel:] hello"), "hello");
        assert_eq!(strip_mud_tag("[chat:] message"), "message");
        assert_eq!(strip_mud_tag("[ooc(player)] text"), "text");

        // With leading whitespace
        assert_eq!(strip_mud_tag("  [channel:] hello"), "  hello");

        // With ANSI color prefix
        assert_eq!(strip_mud_tag("\x1b[31m[channel:] hello"), "\x1b[31mhello");
        assert_eq!(strip_mud_tag("\x1b[1;32m[chat:] text"), "\x1b[1;32mtext");

        // Non-tag brackets should NOT be stripped
        assert_eq!(strip_mud_tag("[hello] world"), "[hello] world");
        assert_eq!(strip_mud_tag("[nochannel] text"), "[nochannel] text");

        // No brackets at start
        assert_eq!(strip_mud_tag("hello world"), "hello world");
        assert_eq!(strip_mud_tag("text [tag:] later"), "text [tag:] later");

        // Empty or only tag
        assert_eq!(strip_mud_tag("[channel:]"), "");
        assert_eq!(strip_mud_tag("[channel:] "), "");
    }
}
