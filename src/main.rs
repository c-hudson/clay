// Module declarations
pub mod encoding;
pub mod telnet;
pub mod spell;
pub mod input;
pub mod util;
pub mod websocket;
pub mod ansi_music;
pub mod tf;
pub mod popup;
pub mod actions;
pub mod http;
pub mod persistence;
pub mod daemon;
pub mod theme;
#[cfg(all(feature = "remote-gui", not(target_os = "android")))]
pub mod remote_gui;
#[cfg(all(feature = "remote-gui", not(target_os = "android")))]
pub mod remote_gui2;
#[cfg(test)]
pub mod testserver;
#[cfg(test)]
pub mod testharness;

// Version information
const VERSION: &str = "1.0.0-alpha";
const BUILD_HASH: &str = env!("BUILD_HASH");

// Custom config file path (set via --conf=<path> argument)
use std::sync::OnceLock;
static CUSTOM_CONFIG_PATH: OnceLock<PathBuf> = OnceLock::new();

/// Set a custom config file path (call early in main before loading settings)
pub fn set_custom_config_path(path: PathBuf) {
    let _ = CUSTOM_CONFIG_PATH.set(path);
}

/// Get the custom config path if one was set
pub fn get_custom_config_path() -> Option<&'static PathBuf> {
    CUSTOM_CONFIG_PATH.get()
}

/// Get the full version string including build hash
pub fn get_version_string() -> String {
    format!("Clay v{} (build {})", VERSION, BUILD_HASH)
}

// Re-export commonly used types from modules
pub use encoding::{Encoding, Theme, WorldSwitchMode, convert_discord_emojis, convert_discord_emojis_with_links, colorize_square_emojis, is_visually_empty, is_ansi_only_line, has_background_color, strip_non_sgr_sequences, wrap_urls_with_osc8};
pub use telnet::{
    WriteCommand, StreamReader, StreamWriter, AutoConnectType, KeepAliveType,
    process_telnet, find_safe_split_point, build_naws_subnegotiation, build_ttype_response, TelnetResult,
    build_gmcp_message, build_msdp_request, build_msdp_set,
    TELNET_IAC, TELNET_NOP, TELNET_GA, TELNET_OPT_NAWS,
};
pub use spell::{SpellChecker, SpellState};
pub use input::{InputArea, display_width, display_width_chars, chars_for_display_width};
pub use util::{get_binary_name, strip_ansi_codes, visual_line_count, get_current_time_12hr, strip_mud_tag, truncate_str, convert_temperatures, parse_discord_timestamps, local_time_from_epoch, local_time_now, color_name_to_ansi_bg};
pub use websocket::{
    WsMessage, WorldStateMsg, WorldSettingsMsg, GlobalSettingsMsg, TimestampedLine,
    WsClientInfo, WebSocketServer,
    hash_password, is_ip_in_allow_list, start_websocket_server,
};
pub use actions::{
    Action, MatchType, ActionTriggerResult,
    split_action_commands, substitute_action_args, substitute_pattern_captures,
    wildcard_to_regex, execute_recall, check_action_triggers,
    compile_action_patterns, line_matches_compiled_patterns,
};
pub use http::{HttpsServer, HttpServer, BanList, start_https_server, start_http_server, log_http_404, log_ws_auth, log_ban};
pub use persistence::{
    encrypt_password, decrypt_password,
    save_settings, load_settings,
    load_multiuser_settings, save_multiuser_settings,
    load_reload_state,
    unescape_string,
};
#[cfg(all(unix, not(target_os = "android")))]
pub use persistence::save_reload_state;
pub use daemon::{
    run_daemon_server, run_multiuser_server,
    generate_splash_strings,
};

use std::io::{self, stdout, Write as IoWrite};
#[cfg(unix)]
use std::os::unix::io::{FromRawFd, RawFd};
#[cfg(all(unix, not(target_os = "android")))]
use std::path::Path;
use std::path::PathBuf;
use std::sync::atomic::{AtomicPtr, AtomicU32, Ordering};
use std::time::{Duration, SystemTime, UNIX_EPOCH};

use async_recursion::async_recursion;
use bytes::BytesMut;
use crossterm::{
    cursor,
    event::{Event, EventStream, KeyCode, KeyEvent, KeyEventKind, KeyModifiers},
    execute,
    terminal::{disable_raw_mode, enable_raw_mode, EnterAlternateScreen, LeaveAlternateScreen, Clear, ClearType},
};
use futures::StreamExt;
use ratatui::{
    backend::CrosstermBackend,
    layout::{Alignment, Constraint, Direction, Layout, Rect},
    style::{Modifier, Style},
    text::{Line, Span, Text},
    widgets::{Block, Borders, Paragraph},
    Frame, Terminal,
};
use tokio::{
    io::{AsyncReadExt, AsyncWriteExt},
    net::TcpStream,
    sync::mpsc,
};
#[cfg(all(unix, not(target_os = "android")))]
use tokio::signal::unix::{signal, SignalKind};
use std::sync::Arc;

// Rustls danger module for accepting invalid certificates (MUD servers often have self-signed certs)
#[cfg(feature = "rustls-backend")]
pub mod danger {
    use rustls::client::danger::{HandshakeSignatureValid, ServerCertVerified, ServerCertVerifier};
    use rustls::pki_types::{CertificateDer, ServerName, UnixTime};
    use rustls::{DigitallySignedStruct, Error, SignatureScheme};

    #[derive(Debug)]
    pub struct NoCertificateVerification;

    impl Default for NoCertificateVerification {
        fn default() -> Self {
            Self::new()
        }
    }

    impl NoCertificateVerification {
        pub fn new() -> Self {
            Self
        }
    }

    impl ServerCertVerifier for NoCertificateVerification {
        fn verify_server_cert(
            &self,
            _end_entity: &CertificateDer<'_>,
            _intermediates: &[CertificateDer<'_>],
            _server_name: &ServerName<'_>,
            _ocsp_response: &[u8],
            _now: UnixTime,
        ) -> Result<ServerCertVerified, Error> {
            Ok(ServerCertVerified::assertion())
        }

        fn verify_tls12_signature(
            &self,
            _message: &[u8],
            _cert: &CertificateDer<'_>,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn verify_tls13_signature(
            &self,
            _message: &[u8],
            _cert: &CertificateDer<'_>,
            _dss: &DigitallySignedStruct,
        ) -> Result<HandshakeSignatureValid, Error> {
            Ok(HandshakeSignatureValid::assertion())
        }

        fn supported_verify_schemes(&self) -> Vec<SignatureScheme> {
            vec![
                SignatureScheme::RSA_PKCS1_SHA256,
                SignatureScheme::RSA_PKCS1_SHA384,
                SignatureScheme::RSA_PKCS1_SHA512,
                SignatureScheme::ECDSA_NISTP256_SHA256,
                SignatureScheme::ECDSA_NISTP384_SHA384,
                SignatureScheme::ECDSA_NISTP521_SHA512,
                SignatureScheme::RSA_PSS_SHA256,
                SignatureScheme::RSA_PSS_SHA384,
                SignatureScheme::RSA_PSS_SHA512,
                SignatureScheme::ED25519,
            ]
        }
    }
}

// ============================================================================
// Web Settings Popup (/web command)
// ============================================================================


pub struct ConfirmDialog {
    visible: bool,
    message: String,
    yes_selected: bool,
    action: ConfirmAction,
}

#[derive(Clone, Copy, PartialEq)]
enum ConfirmAction {
    None,
}

impl ConfirmDialog {
    fn new() -> Self {
        Self {
            visible: false,
            message: String::new(),
            yes_selected: false,
            action: ConfirmAction::None,
        }
    }

    fn close(&mut self) {
        self.visible = false;
        self.action = ConfirmAction::None;
    }
}

pub struct FilterPopup {
    visible: bool,
    filter_text: String,
    cursor: usize,
    filtered_indices: Vec<usize>,  // Indices of matching lines in output_lines
    scroll_offset: usize,          // Scroll position within filtered results
}

impl FilterPopup {
    fn new() -> Self {
        Self {
            visible: false,
            filter_text: String::new(),
            cursor: 0,
            filtered_indices: Vec::new(),
            scroll_offset: 0,
        }
    }

    fn open(&mut self) {
        self.visible = true;
        self.filter_text.clear();
        self.cursor = 0;
        self.filtered_indices.clear();
        self.scroll_offset = 0;
    }

    fn close(&mut self) {
        self.visible = false;
        self.filter_text.clear();
        self.filtered_indices.clear();
        self.scroll_offset = 0;
    }

    fn update_filter(&mut self, output_lines: &[OutputLine]) {
        if self.filter_text.is_empty() {
            self.filtered_indices = (0..output_lines.len()).collect();
        } else {
            // Check if pattern has wildcards
            let has_wildcards = self.filter_text.contains('*') || self.filter_text.contains('?');

            if has_wildcards {
                // Use wildcard matching with regex
                if let Some(regex) = filter_wildcard_to_regex(&self.filter_text) {
                    self.filtered_indices = output_lines
                        .iter()
                        .enumerate()
                        .filter(|(_, line)| {
                            let plain = strip_ansi_codes(&line.text);
                            regex.is_match(&plain)
                        })
                        .map(|(i, _)| i)
                        .collect();
                } else {
                    // Invalid regex, show no matches
                    self.filtered_indices.clear();
                }
            } else {
                // Simple substring matching (case-insensitive)
                let filter_lower = self.filter_text.to_lowercase();
                self.filtered_indices = output_lines
                    .iter()
                    .enumerate()
                    .filter(|(_, line)| {
                        let plain = strip_ansi_codes(&line.text);
                        plain.to_lowercase().contains(&filter_lower)
                    })
                    .map(|(i, _)| i)
                    .collect();
            }
        }
        // Reset scroll to end (most recent matches)
        self.scroll_offset = self.filtered_indices.len().saturating_sub(1);
    }
}

/// Which side of the screen the editor appears on
#[derive(Clone, Copy, PartialEq, Default)]
pub enum EditorSide {
    #[default]
    Left,
    Right,
}

impl EditorSide {
    pub fn name(&self) -> &'static str {
        match self {
            EditorSide::Left => "left",
            EditorSide::Right => "right",
        }
    }

    pub fn from_name(name: &str) -> Self {
        match name.to_lowercase().as_str() {
            "right" => EditorSide::Right,
            _ => EditorSide::Left,
        }
    }
}

/// Which element has focus when editor is open
#[derive(Clone, Copy, PartialEq, Default)]
pub enum EditorFocus {
    #[default]
    Editor,
    Input,
}

/// State for the split-screen text editor
pub struct EditorState {
    /// Whether the editor is currently visible
    pub visible: bool,
    /// Which element has focus (editor or input)
    pub focus: EditorFocus,
    /// The text buffer being edited
    pub buffer: String,
    /// Cursor position in the buffer (character index)
    pub cursor_position: usize,
    /// Current line number (0-indexed)
    pub cursor_line: usize,
    /// Current column number (0-indexed)
    pub cursor_col: usize,
    /// Scroll offset for viewing (line index)
    pub scroll_offset: usize,
    /// Original content (for detecting changes)
    pub original_content: String,
    /// Whether the buffer has been modified
    pub dirty: bool,
    /// File path if editing an external file
    pub file_path: Option<PathBuf>,
    /// World index if editing world notes
    pub world_index: Option<usize>,
}

impl EditorState {
    pub fn new() -> Self {
        Self {
            visible: false,
            focus: EditorFocus::Editor,
            buffer: String::new(),
            cursor_position: 0,
            cursor_line: 0,
            cursor_col: 0,
            scroll_offset: 0,
            original_content: String::new(),
            dirty: false,
            file_path: None,
            world_index: None,
        }
    }

    /// Open editor for world notes
    pub fn open_notes(&mut self, world_index: usize, content: &str) {
        self.visible = true;
        self.focus = EditorFocus::Editor;
        self.buffer = content.to_string();
        self.cursor_position = content.len();
        self.original_content = content.to_string();
        self.dirty = false;
        self.file_path = None;
        self.world_index = Some(world_index);
        self.update_cursor_position();
    }

    /// Open editor for an external file
    pub fn open_file(&mut self, path: PathBuf, content: &str) {
        self.visible = true;
        self.focus = EditorFocus::Editor;
        self.buffer = content.to_string();
        self.cursor_position = content.len();
        self.original_content = content.to_string();
        self.dirty = false;
        self.file_path = Some(path);
        self.world_index = None;
        self.update_cursor_position();
    }

    /// Close the editor
    pub fn close(&mut self) {
        self.visible = false;
        self.buffer.clear();
        self.original_content.clear();
        self.file_path = None;
        self.world_index = None;
        self.cursor_position = 0;
        self.cursor_line = 0;
        self.cursor_col = 0;
        self.scroll_offset = 0;
        self.dirty = false;
    }

    /// Toggle focus between editor and input
    pub fn toggle_focus(&mut self) {
        self.focus = match self.focus {
            EditorFocus::Editor => EditorFocus::Input,
            EditorFocus::Input => EditorFocus::Editor,
        };
    }

    /// Get the title for the editor panel
    pub fn title(&self, world_name: Option<&str>) -> String {
        if let Some(ref path) = self.file_path {
            let filename = path.file_name()
                .map(|n| n.to_string_lossy().to_string())
                .unwrap_or_else(|| path.to_string_lossy().to_string());
            if self.dirty {
                format!("Edit: {} [modified]", filename)
            } else {
                format!("Edit: {}", filename)
            }
        } else if let Some(name) = world_name {
            if self.dirty {
                format!("Notes: {} [modified]", name)
            } else {
                format!("Notes: {}", name)
            }
        } else {
            "Editor".to_string()
        }
    }

    /// Update cursor_line and cursor_col from cursor_position
    fn update_cursor_position(&mut self) {
        let mut line = 0;
        let mut col = 0;
        for (i, c) in self.buffer.chars().enumerate() {
            if i == self.cursor_position {
                break;
            }
            if c == '\n' {
                line += 1;
                col = 0;
            } else {
                col += 1;
            }
        }
        self.cursor_line = line;
        self.cursor_col = col;
    }

    /// Get lines of the buffer
    pub fn lines(&self) -> Vec<&str> {
        self.buffer.split('\n').collect()
    }

    /// Get total line count (logical lines)
    pub fn line_count(&self) -> usize {
        self.buffer.split('\n').count()
    }

    /// Get total visual line count (with wrapping at given width)
    pub fn visual_line_count(&self, width: usize) -> usize {
        if width == 0 {
            return self.line_count();
        }
        let mut count = 0;
        for line in self.buffer.split('\n') {
            let len = line.chars().count();
            if len == 0 {
                count += 1;
            } else {
                count += len.div_ceil(width); // Ceiling division
            }
        }
        count
    }

    /// Get the visual line index where the cursor is (with wrapping at given width)
    pub fn cursor_visual_line(&self, width: usize) -> usize {
        if width == 0 {
            return self.cursor_line;
        }
        let mut visual_line = 0;
        for (line_idx, line) in self.buffer.split('\n').enumerate() {
            let len = line.chars().count();
            if line_idx == self.cursor_line {
                // Cursor is on this logical line
                // Which visual line within this logical line?
                let visual_offset = self.cursor_col / width;
                return visual_line + visual_offset;
            }
            // Count visual lines for this logical line
            if len == 0 {
                visual_line += 1;
            } else {
                visual_line += len.div_ceil(width);
            }
        }
        visual_line
    }

    /// Move cursor up one line
    pub fn cursor_up(&mut self) {
        if self.cursor_line == 0 {
            return;
        }
        let lines = self.lines();
        let target_line = self.cursor_line - 1;
        let target_col = self.cursor_col.min(lines[target_line].chars().count());

        // Calculate new cursor position
        let mut pos = 0;
        for (i, line) in lines.iter().enumerate() {
            if i == target_line {
                pos += target_col;
                break;
            }
            pos += line.chars().count() + 1; // +1 for newline
        }
        self.cursor_position = pos;
        self.update_cursor_position();
    }

    /// Move cursor down one line
    pub fn cursor_down(&mut self) {
        let lines = self.lines();
        if self.cursor_line >= lines.len() - 1 {
            return;
        }
        let target_line = self.cursor_line + 1;
        let target_col = self.cursor_col.min(lines[target_line].chars().count());

        // Calculate new cursor position
        let mut pos = 0;
        for (i, line) in lines.iter().enumerate() {
            if i == target_line {
                pos += target_col;
                break;
            }
            pos += line.chars().count() + 1; // +1 for newline
        }
        self.cursor_position = pos;
        self.update_cursor_position();
    }

    /// Move cursor left one character
    pub fn cursor_left(&mut self) {
        if self.cursor_position > 0 {
            // Move back by one character
            let chars: Vec<char> = self.buffer.chars().collect();
            self.cursor_position = chars[..self.cursor_position].len() - 1;
            // Actually need character count up to new position
            self.cursor_position = self.cursor_position.min(chars.len());
            self.update_cursor_position();
        }
    }

    /// Move cursor right one character
    pub fn cursor_right(&mut self) {
        let char_count = self.buffer.chars().count();
        if self.cursor_position < char_count {
            self.cursor_position += 1;
            self.update_cursor_position();
        }
    }

    /// Move cursor to start of current line
    pub fn cursor_home(&mut self) {
        let lines = self.lines();
        let mut pos = 0;
        for (i, line) in lines.iter().enumerate() {
            if i == self.cursor_line {
                break;
            }
            pos += line.chars().count() + 1;
        }
        self.cursor_position = pos;
        self.update_cursor_position();
    }

    /// Move cursor to end of current line
    pub fn cursor_end(&mut self) {
        let lines = self.lines();
        let mut pos = 0;
        for (i, line) in lines.iter().enumerate() {
            if i == self.cursor_line {
                pos += line.chars().count();
                break;
            }
            pos += line.chars().count() + 1;
        }
        self.cursor_position = pos;
        self.update_cursor_position();
    }

    /// Insert a character at cursor position
    pub fn insert_char(&mut self, c: char) {
        let chars: Vec<char> = self.buffer.chars().collect();
        let pos = self.cursor_position.min(chars.len());
        let before: String = chars[..pos].iter().collect();
        let after: String = chars[pos..].iter().collect();
        self.buffer = format!("{}{}{}", before, c, after);
        self.cursor_position = pos + 1;
        self.dirty = self.buffer != self.original_content;
        self.update_cursor_position();
    }

    /// Delete character before cursor (backspace)
    pub fn delete_backward(&mut self) {
        if self.cursor_position == 0 {
            return;
        }
        let chars: Vec<char> = self.buffer.chars().collect();
        let pos = self.cursor_position.min(chars.len());
        let before: String = chars[..pos - 1].iter().collect();
        let after: String = chars[pos..].iter().collect();
        self.buffer = format!("{}{}", before, after);
        self.cursor_position = pos - 1;
        self.dirty = self.buffer != self.original_content;
        self.update_cursor_position();
    }

    /// Delete character after cursor (delete)
    pub fn delete_forward(&mut self) {
        let chars: Vec<char> = self.buffer.chars().collect();
        let pos = self.cursor_position.min(chars.len());
        if pos >= chars.len() {
            return;
        }
        let before: String = chars[..pos].iter().collect();
        let after: String = chars[pos + 1..].iter().collect();
        self.buffer = format!("{}{}", before, after);
        self.dirty = self.buffer != self.original_content;
        self.update_cursor_position();
    }

    /// Scroll up one page (using visual lines with wrapping)
    pub fn page_up(&mut self, visible_lines: usize, _width: usize) {
        self.scroll_offset = self.scroll_offset.saturating_sub(visible_lines.saturating_sub(1));
    }

    /// Scroll down one page (using visual lines with wrapping)
    pub fn page_down(&mut self, visible_lines: usize, width: usize) {
        let max_scroll = self.visual_line_count(width).saturating_sub(visible_lines);
        self.scroll_offset = (self.scroll_offset + visible_lines.saturating_sub(1)).min(max_scroll);
    }

    /// Ensure cursor is visible (adjust scroll based on visual lines with wrapping)
    pub fn ensure_cursor_visible(&mut self, visible_lines: usize, width: usize) {
        let cursor_visual = self.cursor_visual_line(width);
        if cursor_visual < self.scroll_offset {
            self.scroll_offset = cursor_visual;
        } else if cursor_visual >= self.scroll_offset + visible_lines {
            self.scroll_offset = cursor_visual - visible_lines + 1;
        }
    }
}

impl Default for EditorState {
    fn default() -> Self {
        Self::new()
    }
}

/// Apply TF attributes to text for #substitute command.
/// Attribute string format: C<color> for foreground, B for bold, etc.
/// Examples: "Cred" = red, "Cbold" = bold, "Cgreen" = green
fn apply_tf_attrs(text: &str, attrs: &str) -> String {
    let mut result = String::new();
    let mut has_attr = false;

    // Parse attributes - Cred, Cgreen, Cbold, etc.
    let attrs_lower = attrs.to_lowercase();
    if attrs_lower.contains("cred") || attrs_lower.contains("red") {
        result.push_str("\x1b[1;31m");  // Bold red
        has_attr = true;
    } else if attrs_lower.contains("cgreen") || attrs_lower.contains("green") {
        result.push_str("\x1b[1;32m");  // Bold green
        has_attr = true;
    } else if attrs_lower.contains("cyellow") || attrs_lower.contains("yellow") {
        result.push_str("\x1b[1;33m");  // Bold yellow
        has_attr = true;
    } else if attrs_lower.contains("cblue") || attrs_lower.contains("blue") {
        result.push_str("\x1b[1;34m");  // Bold blue
        has_attr = true;
    } else if attrs_lower.contains("cmagenta") || attrs_lower.contains("magenta") {
        result.push_str("\x1b[1;35m");  // Bold magenta
        has_attr = true;
    } else if attrs_lower.contains("ccyan") || attrs_lower.contains("cyan") {
        result.push_str("\x1b[1;36m");  // Bold cyan
        has_attr = true;
    } else if attrs_lower.contains("cwhite") || attrs_lower.contains("white") {
        result.push_str("\x1b[1;37m");  // Bold white
        has_attr = true;
    } else if attrs_lower.contains("cbold") || attrs_lower.contains("bold") {
        result.push_str("\x1b[1m");  // Bold
        has_attr = true;
    }

    result.push_str(text);

    if has_attr {
        result.push_str("\x1b[0m");  // Reset
    }

    result
}

/// Convert a wildcard filter pattern to regex for F4 filter popup.
/// Always uses "contains" semantics - patterns match anywhere in the line.
/// Supports \* and \? to match literal asterisk and question mark.
/// Examples:
///   "*foo*" matches any line containing "foo"
///   "foo*" matches any line containing "foo" followed by anything
///   "hel?o" matches any line containing "hello", "helao", etc.
///   "what\?" matches any line containing "what?"
fn filter_wildcard_to_regex(pattern: &str) -> Option<regex::Regex> {
    let mut regex = String::with_capacity(pattern.len() * 2 + 4);

    // No anchoring - always "contains" semantics for filter

    let mut chars = pattern.chars().peekable();
    while let Some(c) = chars.next() {
        match c {
            '\\' => {
                // Check for escape sequences
                match chars.peek() {
                    Some('*') | Some('?') | Some('\\') => {
                        // Escaped wildcard or backslash - treat as literal
                        let escaped = chars.next().unwrap();
                        regex.push('\\');
                        regex.push(escaped);
                    }
                    _ => {
                        // Lone backslash - escape it for regex
                        regex.push_str("\\\\");
                    }
                }
            }
            '*' => regex.push_str(".*"),
            '?' => regex.push('.'),
            // Escape regex special characters
            '.' | '+' | '^' | '$' | '|' | '(' | ')' | '[' | ']' | '{' | '}' => {
                regex.push('\\');
                regex.push(c);
            }
            _ => regex.push(c),
        }
    }

    regex::RegexBuilder::new(&regex)
        .case_insensitive(true)
        .build()
        .ok()
}

pub fn get_home_dir() -> String {
    home::home_dir()
        .map(|p| p.to_string_lossy().to_string())
        .unwrap_or_else(|| ".".to_string())
}

/// Returns a dot-prefixed filename on Unix, plain filename on Windows.
/// e.g. clay_filename("clay.dat") â†’ ".clay.dat" on Unix, "clay.dat" on Windows.
pub fn clay_filename(name: &str) -> String {
    #[cfg(unix)]
    { format!(".{}", name) }
    #[cfg(not(unix))]
    { name.to_string() }
}

/// Generate a WAV file from ANSI music notes (square wave, matching web client's oscillator)
fn generate_wav_from_notes(notes: &[crate::ansi_music::MusicNote]) -> Vec<u8> {
    let sample_rate: u32 = 22050;
    let mut samples: Vec<i16> = Vec::new();

    for note in notes {
        let num_samples = (sample_rate as f64 * note.duration_ms as f64 / 1000.0) as usize;
        if note.frequency <= 0.0 {
            // Rest/silence
            samples.extend(std::iter::repeat(0i16).take(num_samples));
        } else {
            let period = sample_rate as f64 / note.frequency as f64;
            for i in 0..num_samples {
                // Square wave: +amplitude for first half of period, -amplitude for second half
                let phase = (i as f64 % period) / period;
                let sample = if phase < 0.5 { 8000i16 } else { -8000i16 };
                samples.push(sample);
            }
        }
    }

    // Build WAV header + data
    let data_size = (samples.len() * 2) as u32;
    let file_size = 36 + data_size;
    let mut wav = Vec::with_capacity(44 + data_size as usize);
    wav.extend_from_slice(b"RIFF");
    wav.extend_from_slice(&file_size.to_le_bytes());
    wav.extend_from_slice(b"WAVE");
    wav.extend_from_slice(b"fmt ");
    wav.extend_from_slice(&16u32.to_le_bytes()); // chunk size
    wav.extend_from_slice(&1u16.to_le_bytes());  // PCM format
    wav.extend_from_slice(&1u16.to_le_bytes());  // mono
    wav.extend_from_slice(&sample_rate.to_le_bytes());
    wav.extend_from_slice(&(sample_rate * 2).to_le_bytes()); // byte rate
    wav.extend_from_slice(&2u16.to_le_bytes());  // block align
    wav.extend_from_slice(&16u16.to_le_bytes()); // bits per sample
    wav.extend_from_slice(b"data");
    wav.extend_from_slice(&data_size.to_le_bytes());
    for s in &samples {
        wav.extend_from_slice(&s.to_le_bytes());
    }
    wav
}

/// Detect available system media player for console audio playback
fn detect_media_player() -> Option<String> {
    for cmd in &["mpv", "ffplay"] {
        if std::process::Command::new("which")
            .arg(cmd)
            .stdout(std::process::Stdio::null())
            .stderr(std::process::Stdio::null())
            .status()
            .map(|s| s.success())
            .unwrap_or(false)
        {
            return Some(cmd.to_string());
        }
    }
    None
}

pub fn enable_tcp_keepalive(tcp_stream: &TcpStream) {
    use socket2::SockRef;
    let keepalive = socket2::TcpKeepalive::new()
        .with_time(std::time::Duration::from_secs(60))
        .with_interval(std::time::Duration::from_secs(10));
    #[cfg(unix)]
    let keepalive = keepalive.with_retries(6);
    let sock_ref = SockRef::from(tcp_stream);
    let _ = sock_ref.set_tcp_keepalive(&keepalive);
}

#[derive(Clone)]
pub struct Settings {
    pub more_mode_enabled: bool,
    spell_check_enabled: bool,
    temp_convert_enabled: bool,  // Temperature conversion (e.g., 32F -> 32F (0C))
    world_switch_mode: WorldSwitchMode,
    debug_enabled: bool,    // Debug logging to clay.debug.log
    ansi_music_enabled: bool, // Enable ANSI music playback (web/GUI only)
    theme: Theme,           // Console theme
    gui_theme: Theme,       // GUI theme (separate from console)
    gui_transparency: f32,  // GUI window transparency (0.0-1.0)
    // Color contrast adjustment for web/GUI (0 = disabled, 1-100 = adjustment percentage)
    color_offset_percent: u8,
    // Remote GUI font settings
    font_name: String,
    font_size: f32,
    // Web interface font sizes (separate settings for phone/tablet/desktop)
    web_font_size_phone: f32,
    web_font_size_tablet: f32,
    web_font_size_desktop: f32,
    // Web server settings (consolidated)
    web_secure: bool,              // Protocol: true=Secure (https/wss), false=Non-Secure (http/ws)
    http_enabled: bool,            // Enable HTTP/HTTPS web server (name depends on web_secure)
    http_port: u16,                // Port for HTTP/HTTPS web interface
    ws_enabled: bool,              // Enable WS/WSS server (name depends on web_secure)
    ws_port: u16,                  // Port for WS/WSS server
    websocket_password: String,
    websocket_allow_list: String,  // CSV list of hosts that can be whitelisted
    websocket_whitelisted_host: Option<String>,  // Currently whitelisted host (authenticated from allow list)
    websocket_cert_file: String,   // Path to TLS certificate file (PEM) - only used when web_secure=true
    websocket_key_file: String,    // Path to TLS private key file (PEM) - only used when web_secure=true
    // Persistent auth keys for passwordless device authentication (generated after successful password auth)
    websocket_auth_keys: Vec<String>,
    // User-defined actions/triggers
    actions: Vec<Action>,
    // TLS proxy for connection preservation over hot reload
    tls_proxy_enabled: bool,
    // Custom dictionary path for spell checking (empty = use system defaults)
    dictionary_path: String,
    // Editor side for split-screen editor (left or right)
    editor_side: EditorSide,
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            more_mode_enabled: true,
            spell_check_enabled: true,
            temp_convert_enabled: false,  // Disabled by default
            world_switch_mode: WorldSwitchMode::UnseenFirst,
            debug_enabled: false,
            ansi_music_enabled: true,  // ANSI music enabled by default
            theme: Theme::Dark,
            gui_theme: Theme::Dark,
            gui_transparency: 1.0,
            color_offset_percent: 0,   // 0 = disabled, 1-100 = adjustment percentage
            font_name: String::new(),  // Empty means use system default
            font_size: 14.0,
            // Web interface font sizes (per device type)
            web_font_size_phone: 10.0,   // Default for phones
            web_font_size_tablet: 14.0,  // Default for tablets
            web_font_size_desktop: 18.0, // Default for desktop
            web_secure: false,         // Default to non-secure
            http_enabled: false,
            http_port: 9000,
            ws_enabled: false,
            ws_port: 9001,
            websocket_password: String::new(),
            websocket_allow_list: String::new(),
            websocket_whitelisted_host: None,
            websocket_cert_file: String::new(),
            websocket_key_file: String::new(),
            websocket_auth_keys: Vec::new(),
            actions: Vec::new(),
            tls_proxy_enabled: false,
            dictionary_path: String::new(),
            editor_side: EditorSide::Left,
        }
    }
}

/// Type of world connection
#[derive(Clone, Debug, PartialEq, Default)]
pub enum WorldType {
    #[default]
    Mud,
    Slack,
    Discord,
}

impl WorldType {
    fn name(&self) -> &'static str {
        match self {
            WorldType::Mud => "mud",
            WorldType::Slack => "slack",
            WorldType::Discord => "discord",
        }
    }

    fn from_name(name: &str) -> Self {
        match name.to_lowercase().as_str() {
            "slack" => WorldType::Slack,
            "discord" => WorldType::Discord,
            _ => WorldType::Mud,
        }
    }

}

#[derive(Clone)]
pub struct WorldSettings {
    pub world_type: WorldType,
    // MUD settings
    pub hostname: String,
    pub port: String,
    pub user: String,
    pub password: String,
    pub use_ssl: bool,
    pub log_enabled: bool,
    pub encoding: Encoding,
    pub auto_connect_type: AutoConnectType,
    pub keep_alive_type: KeepAliveType,
    pub keep_alive_cmd: String,
    // Slack settings
    slack_token: String,
    slack_channel: String,
    slack_workspace: String,
    // Discord settings
    discord_token: String,
    discord_guild: String,
    discord_channel: String,
    discord_dm_user: String, // User ID for DM (creates DM channel on connect)
    // User notes (stored per-world, edited with /edit command)
    pub notes: String,
    // GMCP packages to request (comma-separated, e.g. "Client.Media 1, Char.Vitals 1")
    pub gmcp_packages: String,
}

impl Default for WorldSettings {
    fn default() -> Self {
        Self {
            world_type: WorldType::Mud,
            hostname: String::new(),
            port: String::new(),
            user: String::new(),
            password: String::new(),
            use_ssl: false,
            log_enabled: false,
            encoding: Encoding::Utf8,
            auto_connect_type: AutoConnectType::Connect,
            keep_alive_type: KeepAliveType::Nop,
            keep_alive_cmd: String::new(),
            slack_token: String::new(),
            slack_channel: String::new(),
            slack_workspace: String::new(),
            discord_token: String::new(),
            discord_guild: String::new(),
            discord_channel: String::new(),
            discord_dm_user: String::new(),
            notes: String::new(),
            gmcp_packages: "Client.Media 1".to_string(),
        }
    }
}

impl WorldSettings {
    /// Check if this world has enough settings to attempt a connection
    fn has_connection_settings(&self) -> bool {
        match self.world_type {
            WorldType::Mud => !self.hostname.is_empty() && !self.port.is_empty(),
            WorldType::Slack => !self.slack_token.is_empty(),
            WorldType::Discord => !self.discord_token.is_empty(),
        }
    }
}


/// User account for multiuser mode
#[derive(Clone, Debug)]
pub struct User {
    pub name: String,
    pub password: String,  // Stored encrypted in file, decrypted in memory
}

impl User {
    fn new(name: &str, password: &str) -> Self {
        Self {
            name: name.to_string(),
            password: password.to_string(),
        }
    }
}

/// Tracks a WebSocket client's view state for synchronized more-mode
#[derive(Clone, Debug)]
pub struct ClientViewState {
    /// Which world the client is viewing
    pub world_index: usize,
    /// Number of visible output lines in the client's display
    pub visible_lines: usize,
    /// Client's output area dimensions (width, height) for NAWS
    pub dimensions: Option<(u16, u16)>,
}

// ============================================================================
// Shared Command Parsing
// ============================================================================

/// Parsed command representation - shared across console, GUI, and web interfaces
#[derive(Debug, Clone, PartialEq)]
#[allow(clippy::enum_variant_names)]
pub enum Command {
    /// /help - show help popup
    Help,
    /// /help tf - show TF commands help
    HelpTf,
    /// /version - show version info
    Version,
    /// /quit - exit application
    Quit,
    /// /reload - hot reload binary
    Reload,
    /// /setup - show global settings popup
    Setup,
    /// /web - show web settings popup
    Web,
    /// /actions [world] - show actions popup, optionally filtered by world
    Actions { world: Option<String> },
    /// /connections or /l - show connected worlds list
    WorldsList,
    /// /worlds (no args) - show world selector
    WorldSelector,
    /// /worlds -e [name] - edit world settings
    WorldEdit { name: Option<String> },
    /// /worlds -l <name> - connect without auto-login
    WorldConnectNoLogin { name: String },
    /// /worlds <name> - switch to or connect to named world
    WorldSwitch { name: String },
    /// /connect [host port [ssl]] - connect to server
    Connect { host: Option<String>, port: Option<String>, ssl: bool },
    /// /disconnect or /dc - disconnect current world
    Disconnect,
    /// /flush - clear output buffer for current world
    Flush,
    /// /menu - show menu popup to select windows/popups
    Menu,
    /// /send [-W] [-w<world>] [-n] <text> - send text
    Send { text: String, all_worlds: bool, target_world: Option<String>, no_newline: bool },
    /// /keepalive - show keepalive settings
    Keepalive,
    /// /gag <pattern> - gag lines matching pattern
    Gag { pattern: String },
    /// /ban - show banned hosts
    BanList,
    /// /unban <host> - remove ban for host
    Unban { host: String },
    /// /testmusic - play a test ANSI music sequence
    TestMusic,
    /// /dump - dump all scrollback buffers to ~/.clay.dmp.log
    Dump,
    /// /notify <message> - send notification to mobile clients
    Notify { message: String },
    /// /addworld - add or update a world definition
    AddWorld {
        name: String,
        host: Option<String>,
        port: Option<String>,
        user: Option<String>,
        password: Option<String>,
        use_ssl: bool,
    },
    /// /edit [filename] - open split-screen editor for world notes or file
    Edit { filename: Option<String> },
    /// /tag - toggle MUD tag display (same as F2)
    Tag,
    /// /dict <prefix> <word> - look up word definition and send with prefix
    Dict { prefix: String, word: String },
    /// /dict usage error
    DictUsage,
    /// /urban <prefix> <word> - look up Urban Dictionary definition and send with prefix
    Urban { prefix: String, word: String },
    /// /urban usage error
    UrbanUsage,
    /// /translate <lang> <prefix> <text> - translate text and send with prefix
    Translate { lang: String, prefix: String, text: String },
    /// /translate usage error
    TranslateUsage,
    /// /<action_name> [args] - execute action
    ActionCommand { name: String, args: String },
    /// Not a command (regular text to send to MUD)
    NotACommand { text: String },
    /// Unknown/invalid command
    Unknown { cmd: String },
}

/// Parse a command string into a Command enum
pub fn parse_command(input: &str) -> Command {
    let trimmed = input.trim();

    // Not a command if doesn't start with /
    if !trimmed.starts_with('/') {
        return Command::NotACommand { text: trimmed.to_string() };
    }

    let parts: Vec<&str> = trimmed.split_whitespace().collect();
    if parts.is_empty() {
        return Command::NotACommand { text: trimmed.to_string() };
    }

    let cmd = parts[0].to_lowercase();
    let args = &parts[1..];

    match cmd.as_str() {
        "/help" => {
            if !args.is_empty() && args[0].eq_ignore_ascii_case("tf") {
                Command::HelpTf
            } else {
                Command::Help
            }
        }
        "/version" => Command::Version,
        "/quit" => Command::Quit,
        "/reload" => Command::Reload,
        "/setup" => Command::Setup,
        "/web" => Command::Web,
        "/actions" => {
            let world = if args.is_empty() {
                None
            } else {
                Some(args.join(" "))
            };
            Command::Actions { world }
        }
        "/connections" | "/l" => Command::WorldsList,
        "/worlds" | "/world" => parse_world_command(args),
        "/connect" => parse_connect_command(args),  // Internal use only (Connect buttons)
        "/disconnect" | "/dc" => Command::Disconnect,
        "/flush" => Command::Flush,
        "/menu" => Command::Menu,
        "/send" => parse_send_command(args, trimmed),
        "/keepalive" => Command::Keepalive,
        "/gag" => {
            if args.is_empty() {
                Command::Unknown { cmd: trimmed.to_string() }
            } else {
                Command::Gag { pattern: args.join(" ") }
            }
        }
        "/ban" => Command::BanList,
        "/unban" => {
            if args.is_empty() {
                Command::Unknown { cmd: trimmed.to_string() }
            } else {
                Command::Unban { host: args[0].to_string() }
            }
        }
        "/testmusic" => Command::TestMusic,
        "/dump" => Command::Dump,
        "/notify" => {
            if args.is_empty() {
                Command::Unknown { cmd: trimmed.to_string() }
            } else {
                Command::Notify { message: args.join(" ") }
            }
        }
        "/addworld" => parse_addworld_command(args),
        "/edit" => {
            if args.is_empty() {
                Command::Edit { filename: None }
            } else {
                Command::Edit { filename: Some(args.join(" ")) }
            }
        }
        "/tag" | "/tags" => Command::Tag,
        "/dict" => {
            if args.len() >= 2 {
                Command::Dict {
                    prefix: args[0].to_string(),
                    word: args[1..].join(" "),
                }
            } else {
                Command::DictUsage
            }
        }
        "/urban" => {
            if args.len() >= 2 {
                Command::Urban {
                    prefix: args[0].to_string(),
                    word: args[1..].join(" "),
                }
            } else {
                Command::UrbanUsage
            }
        }
        "/translate" | "/tr" => {
            if args.len() >= 3 {
                Command::Translate {
                    lang: args[0].to_string(),
                    prefix: args[1].to_string(),
                    text: args[2..].join(" "),
                }
            } else {
                Command::TranslateUsage
            }
        }
        _ => {
            // Check if it's an action command (starts with / but not a known command)
            let action_name = cmd.trim_start_matches('/');
            if !action_name.is_empty() {
                Command::ActionCommand {
                    name: action_name.to_string(),
                    args: args.join(" "),
                }
            } else {
                Command::Unknown { cmd: trimmed.to_string() }
            }
        }
    }
}

/// Parse /worlds command with its various forms
fn parse_world_command(args: &[&str]) -> Command {
    if args.is_empty() {
        return Command::WorldSelector;
    }

    match args[0] {
        "-e" => {
            // /worlds -e [name] - edit world
            let name = if args.len() > 1 {
                Some(args[1..].join(" "))
            } else {
                None
            };
            Command::WorldEdit { name }
        }
        "-l" => {
            // /worlds -l <name> - connect without auto-login
            if args.len() > 1 {
                Command::WorldConnectNoLogin { name: args[1..].join(" ") }
            } else {
                Command::Unknown { cmd: "/worlds -l".to_string() }
            }
        }
        _ => {
            // /worlds <name> - switch to or connect to named world
            Command::WorldSwitch { name: args.join(" ") }
        }
    }
}

/// Parse /connect command
fn parse_connect_command(args: &[&str]) -> Command {
    if args.is_empty() {
        return Command::Connect { host: None, port: None, ssl: false };
    }

    let host = Some(args[0].to_string());
    let port = args.get(1).map(|s| s.to_string());
    let ssl = args.get(2).map(|s| s.to_lowercase() == "ssl").unwrap_or(false);

    Command::Connect { host, port, ssl }
}

/// Parse /addworld command (TF-compatible world creation)
///
/// Formats:
///   /addworld [-xe] [-Ttype] name [char pass] host port
///   /addworld [-Ttype] name
///
/// Options:
///   -x  Use SSL/TLS
///   -e  Echo (ignored)
///   -Ttype  World type (ignored, defaults to MUD)
///   -p  No proxy (ignored)
fn parse_addworld_command(args: &[&str]) -> Command {
    if args.is_empty() {
        return Command::Unknown { cmd: "/addworld".to_string() };
    }

    let mut use_ssl = false;
    let mut remaining_args: Vec<&str> = Vec::new();

    // Parse options
    for arg in args {
        if let Some(flags) = arg.strip_prefix('-') {
            // Parse option flags
            for c in flags.chars() {
                match c {
                    'x' => use_ssl = true,
                    'e' | 'p' => {} // Ignored: echo, proxy
                    'T' => break,   // -Ttype: skip the rest of this arg
                    _ => {}
                }
            }
        } else {
            remaining_args.push(arg);
        }
    }

    // Remaining args interpretation:
    // 1 arg:  name (connectionless world)
    // 3 args: name host port
    // 5 args: name char pass host port

    match remaining_args.len() {
        0 => Command::Unknown { cmd: "/addworld".to_string() },
        1 => {
            // Just name - connectionless world
            Command::AddWorld {
                name: remaining_args[0].to_string(),
                host: None,
                port: None,
                user: None,
                password: None,
                use_ssl,
            }
        }
        2 => {
            // name host (assume default port or error)
            Command::AddWorld {
                name: remaining_args[0].to_string(),
                host: Some(remaining_args[1].to_string()),
                port: None,
                user: None,
                password: None,
                use_ssl,
            }
        }
        3 => {
            // name host port
            Command::AddWorld {
                name: remaining_args[0].to_string(),
                host: Some(remaining_args[1].to_string()),
                port: Some(remaining_args[2].to_string()),
                user: None,
                password: None,
                use_ssl,
            }
        }
        4 => {
            // Could be: name char host port (missing pass) or name char pass host (missing port)
            // Assume: name char host port (user without password)
            Command::AddWorld {
                name: remaining_args[0].to_string(),
                host: Some(remaining_args[2].to_string()),
                port: Some(remaining_args[3].to_string()),
                user: Some(remaining_args[1].to_string()),
                password: None,
                use_ssl,
            }
        }
        _ => {
            // 5+ args: name char pass host port [file]
            Command::AddWorld {
                name: remaining_args[0].to_string(),
                host: Some(remaining_args[3].to_string()),
                port: Some(remaining_args[4].to_string()),
                user: Some(remaining_args[1].to_string()),
                password: Some(remaining_args[2].to_string()),
                use_ssl,
            }
        }
    }
}

/// Parse /send command with flags
fn parse_send_command(args: &[&str], full_cmd: &str) -> Command {
    let mut all_worlds = false;
    let mut target_world: Option<String> = None;
    let mut no_newline = false;
    let mut text_start = 0;

    for (i, arg) in args.iter().enumerate() {
        if *arg == "-W" {
            all_worlds = true;
            text_start = i + 1;
        } else if let Some(world) = arg.strip_prefix("-w") {
            target_world = Some(world.to_string());
            text_start = i + 1;
        } else if *arg == "-n" {
            no_newline = true;
            text_start = i + 1;
        } else {
            break;
        }
    }

    // Get the text after flags - use original string to preserve spacing
    let text = if text_start < args.len() {
        // Find position of first non-flag argument in original string
        let mut pos = 0;
        let mut found_flags = 0;
        for c in full_cmd.chars() {
            if found_flags > text_start { // +1 for /send itself
                break;
            }
            if c.is_whitespace() && pos > 0 {
                // Check if we just finished a word
                let prev_nonws = full_cmd[..pos].chars().rev().find(|c| !c.is_whitespace());
                if prev_nonws.is_some() {
                    found_flags += 1;
                }
            }
            pos += c.len_utf8();
        }
        // Skip whitespace after last flag
        while pos < full_cmd.len() && full_cmd[pos..].starts_with(char::is_whitespace) {
            pos += 1;
        }
        full_cmd[pos..].to_string()
    } else {
        String::new()
    };

    Command::Send { text, all_worlds, target_world, no_newline }
}

#[cfg(all(unix, not(target_os = "android")))]
const RELOAD_FDS_ENV: &str = "CLAY_RELOAD_FDS";
const CRASH_COUNT_ENV: &str = "CLAY_CRASH_COUNT";
#[cfg(all(unix, not(target_os = "android")))]
const MAX_CRASH_RESTARTS: u32 = 2;

// Static pointer to App for crash recovery - set when app is running
static APP_PTR: AtomicPtr<App> = AtomicPtr::new(std::ptr::null_mut());
// Track current crash count to avoid re-reading env var
static CRASH_COUNT: AtomicU32 = AtomicU32::new(0);

fn get_reload_state_path() -> PathBuf {
    let home = get_home_dir();
    PathBuf::from(home).join(clay_filename("clay.reload"))
}

/// Get the current crash count from environment variable
fn get_crash_count() -> u32 {
    std::env::var(CRASH_COUNT_ENV)
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(0)
}

/// Clear the crash count (called after successful operation)
fn clear_crash_count() {
    std::env::remove_var(CRASH_COUNT_ENV);
    CRASH_COUNT.store(0, Ordering::SeqCst);
}

/// Set the global app pointer for crash recovery
fn set_app_ptr(app: *mut App) {
    APP_PTR.store(app, Ordering::SeqCst);
}

/// Get the global app pointer
#[cfg(all(unix, not(target_os = "android")))]
fn get_app_ptr() -> *mut App {
    APP_PTR.load(Ordering::SeqCst)
}

/// Attempt to restart after a crash (not available on Android or Windows)
#[cfg(all(unix, not(target_os = "android")))]
fn crash_restart() {
    // Read crash count directly from env var, not from atomic
    // This ensures correct count even if crash happens before atomic is initialized
    let crash_count = std::env::var(CRASH_COUNT_ENV)
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(0);
    if crash_count >= MAX_CRASH_RESTARTS {
        // Already crashed too many times, don't restart
        eprintln!("Maximum crash restarts ({}) reached, not restarting.", MAX_CRASH_RESTARTS);
        return;
    }

    // Try to save state from the app pointer
    let app_ptr = get_app_ptr();
    if !app_ptr.is_null() {
        // SAFETY: We set this pointer in run_app and it remains valid until run_app returns
        let app = unsafe { &*app_ptr };

        // Try to save state
        if let Err(e) = persistence::save_reload_state(app) {
            eprintln!("Failed to save state during crash: {}", e);
        }

        // Clear CLOEXEC on socket fds so they survive exec
        for world in &app.worlds {
            if let Some(fd) = world.socket_fd {
                let _ = clear_cloexec(fd);
            }
        }

        // Pass fd list via environment
        let fds_str: String = app.worlds
            .iter()
            .filter_map(|w| w.socket_fd)
            .map(|fd| fd.to_string())
            .collect::<Vec<_>>()
            .join(",");
        std::env::set_var(RELOAD_FDS_ENV, &fds_str);
    }

    // Increment crash count in env
    let new_count = crash_count + 1;
    std::env::set_var(CRASH_COUNT_ENV, new_count.to_string());

    // Try to exec the binary
    if let Ok((exe, _)) = get_executable_path() {
        use std::os::unix::process::CommandExt;
        let mut args: Vec<String> = std::env::args()
            .skip(1)
            .filter(|a| a != "--reload" && a != "--crash")
            .collect();
        args.push("--crash".to_string());

        // This replaces the current process if successful
        let _ = std::process::Command::new(&exe).args(&args).exec();
    }
}

/// Set up the crash handler (panic hook) - not available on Android or Windows
#[cfg(all(unix, not(target_os = "android")))]
fn setup_crash_handler() {
    let default_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        // Restore terminal first to ensure output is visible
        let _ = disable_raw_mode();
        let _ = execute!(std::io::stdout(), LeaveAlternateScreen);

        // Log crash to debug file (always log crashes regardless of debug setting)
        let panic_msg = format!("CRASH: {}", panic_info);
        debug_log(true, &panic_msg);

        // Also log backtrace if available
        let backtrace = std::backtrace::Backtrace::capture();
        let bt_str = format!("{}", backtrace);
        if !bt_str.is_empty() && !bt_str.contains("disabled") {
            debug_log(true, &format!("BACKTRACE:\n{}", bt_str));
        }

        // Print the panic info using the default handler
        eprintln!("\n\nClay crashed! Attempting to restart...\n");
        default_hook(panic_info);

        // Attempt to restart
        crash_restart();

        // If we get here, restart failed - exit normally
    }));
}

/// Get current time as seconds since Unix epoch (for WebSocket timestamps)
pub fn current_timestamp_secs() -> u64 {
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_secs()
}

/// Format a Duration for display (short format)
pub fn format_duration_short(d: std::time::Duration) -> String {
    let total_secs = d.as_secs_f64();
    if total_secs < 60.0 {
        if total_secs == total_secs.floor() {
            format!("{}s", total_secs as u64)
        } else {
            format!("{:.1}s", total_secs)
        }
    } else if total_secs < 3600.0 {
        let mins = (total_secs / 60.0) as u64;
        let secs = (total_secs % 60.0) as u64;
        format!("{}m{}s", mins, secs)
    } else {
        let hours = (total_secs / 3600.0) as u64;
        let mins = ((total_secs % 3600.0) / 60.0) as u64;
        format!("{}h{}m", hours, mins)
    }
}

/// Output line with timestamp for F2/show tags feature
#[derive(Clone)]
pub struct OutputLine {
    pub text: String,
    pub timestamp: SystemTime,
    pub from_server: bool,  // true if from MUD server, false if client-generated
    pub gagged: bool,       // true if line was gagged by an action (only shown with F2)
    pub seq: u64,           // Unique sequential number within the world (for debugging out-of-order issues)
    pub highlight_color: Option<String>, // Optional highlight color from /highlight action command
}

/// Maximum characters per output line (prevents performance issues with extremely long lines)
const MAX_LINE_LENGTH: usize = 10_000;

impl OutputLine {
    /// Truncate text if it exceeds MAX_LINE_LENGTH to prevent performance issues
    fn truncate_if_needed(text: String) -> String {
        if text.len() > MAX_LINE_LENGTH {
            // Find a safe truncation point (don't split UTF-8 or ANSI sequences)
            let mut truncate_at = MAX_LINE_LENGTH;
            // Walk back to find a safe character boundary
            while truncate_at > 0 && !text.is_char_boundary(truncate_at) {
                truncate_at -= 1;
            }
            // Also avoid truncating in the middle of an ANSI escape sequence
            // Look for incomplete escape: \x1b[ without terminating letter
            let prefix = &text[..truncate_at];
            if let Some(last_esc) = prefix.rfind('\x1b') {
                // Check if there's a terminating letter after the escape
                let after_esc = &prefix[last_esc..];
                let has_terminator = after_esc.chars().skip(1).any(|c| c.is_ascii_alphabetic());
                if !has_terminator {
                    // Truncate before the incomplete escape sequence
                    truncate_at = last_esc;
                }
            }
            let mut result = text[..truncate_at].to_string();
            result.push_str("\x1b[0m\x1b[33m... [truncated]\x1b[0m");
            result
        } else {
            text
        }
    }

    pub fn new(text: String, seq: u64) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: true,  // Default to server output
            gagged: false,
            seq,
            highlight_color: None,
        }
    }

    pub fn new_client(text: String, seq: u64) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: false,
            gagged: false,
            seq,
            highlight_color: None,
        }
    }

    fn new_gagged(text: String, seq: u64) -> Self {
        Self {
            text: Self::truncate_if_needed(text),
            timestamp: SystemTime::now(),
            from_server: true,
            gagged: true,
            seq,
            highlight_color: None,
        }
    }

    fn new_with_timestamp(text: String, timestamp: SystemTime, seq: u64) -> Self {
        Self { text: Self::truncate_if_needed(text), timestamp, from_server: true, gagged: false, seq, highlight_color: None }
    }

    /// Format timestamp for display based on whether it's from today
    /// Same day: HH:MM>
    /// Previous days: DD/MM HH:MM>
    fn format_timestamp(&self) -> String {
        self.format_timestamp_with_now(&CachedNow::new())
    }

    /// Format timestamp using a pre-computed "now" value for batch rendering
    fn format_timestamp_with_now(&self, _now: &CachedNow) -> String {
        let ts_secs = self.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs() as i64;
        let lt = local_time_from_epoch(ts_secs);

        // Always show day/month for debugging ordering issues
        format!("{:02}/{:02} {:02}:{:02}>", lt.day, lt.month, lt.hour, lt.minute)
    }
}

/// Cached "now" time for batch timestamp formatting
/// Computing localtime_r once per frame instead of once per line
struct CachedNow;

impl CachedNow {
    fn new() -> Self {
        Self
    }
}

pub struct World {
    pub name: String,
    pub output_lines: Vec<OutputLine>,
    pub scroll_offset: usize,
    pub connected: bool,
    pub command_tx: Option<mpsc::Sender<WriteCommand>>,
    pub unseen_lines: usize,
    pub paused: bool,
    pub pending_lines: Vec<OutputLine>,
    pub pending_count: usize, // For remote client mode: daemon's pending line count (not in pending_lines)
    pub lines_since_pause: usize,
    pub settings: WorldSettings,
    log_handle: Option<std::sync::Arc<std::sync::Mutex<std::fs::File>>>,
    log_date: Option<String>,    // Current log file date (MMDDYY) for day rollover detection
    #[cfg(unix)]
    socket_fd: Option<RawFd>,    // Store fd for hot reload (plain TCP only, Unix only)
    #[cfg(not(unix))]
    socket_fd: Option<i64>,      // Placeholder on non-Unix (never used)
    #[cfg(unix)]
    proxy_socket_fd: Option<RawFd>, // Store Unix socket fd to TLS proxy for hot reload
    #[cfg(not(unix))]
    proxy_socket_fd: Option<i64>,   // Placeholder on non-Unix (never used)
    is_tls: bool,                // Track if using TLS
    telnet_mode: bool,           // True if telnet negotiation detected
    pub prompt: String,              // Current prompt detected via telnet GA
    pub prompt_count: usize,         // Number of prompts received since connect (for auto-login)
    last_send_time: Option<std::time::Instant>, // For keepalive timing
    last_receive_time: Option<std::time::Instant>, // Last time server data was received
    last_nop_time: Option<std::time::Instant>,     // Last time NOP keepalive was sent
    last_user_command_time: Option<std::time::Instant>, // Last time user sent a command
    pub partial_line: String,        // Buffer for incomplete lines (no trailing newline)
    pub partial_in_pending: bool,    // True if partial_line is in pending_lines (vs output_lines)
    trigger_partial_line: String, // Buffer for incomplete lines for action trigger checking
    just_filtered_idler: bool,   // True if we just filtered an idler message (for filtering trailing newline)
    wont_echo_time: Option<std::time::Instant>, // When WONT ECHO was seen (for timeout-based prompt detection)
    uses_wont_echo_prompt: bool, // True if this world uses WONT ECHO for prompts (auto-detected)
    pub is_initial_world: bool,      // True for the auto-created world before first connection
    pub was_connected: bool,         // True if world has ever been connected (for world cycling)
    pub skip_auto_login: bool,       // True to skip auto-login on next connect (for /worlds -l)
    pub showing_splash: bool,        // True when showing startup splash (for centering)
    needs_redraw: bool,          // True when terminal needs full redraw (after splash clear)
    pending_since: Option<std::time::Instant>, // When pending output first appeared (for Alt-w)
    pub first_unseen_at: Option<std::time::Instant>, // When unseen output first arrived (for Unseen First switching)
    last_pending_broadcast: Option<std::time::Instant>, // Last time pending count was broadcast (for 2s timer)
    last_pending_count_broadcast: usize, // Last pending count that was broadcast (to detect changes)
    owner: Option<String>,       // Username who owns this world (multiuser mode)
    proxy_pid: Option<u32>,      // PID of TLS proxy process (if using TLS proxy)
    proxy_socket_path: Option<std::path::PathBuf>, // Unix socket path for TLS proxy
    naws_enabled: bool,          // True if NAWS telnet option was negotiated
    naws_sent_size: Option<(u16, u16)>, // Last sent window size (width, height) to avoid duplicates
    pub next_seq: u64,               // Next sequence number for output lines (for debugging)
    reader_name: Option<String>, // Name used by active reader task (for lookup after rename)
    pub gmcp_enabled: bool,          // True if GMCP was negotiated with the server
    pub msdp_enabled: bool,          // True if MSDP was negotiated with the server
    pub gmcp_supported_packages: Vec<String>, // GMCP packages we told the server we support
    pub msdp_variables: std::collections::HashMap<String, String>, // MSDP var -> JSON value
    pub gmcp_data: std::collections::HashMap<String, String>, // GMCP package -> last JSON data
    pub mcmp_default_url: String,    // MCMP default URL from Client.Media.Default
    pub active_media: std::collections::HashMap<String, String>, // key -> Client.Media.Play JSON (for restart on world switch)
    pub gmcp_user_enabled: bool,     // True if user has enabled GMCP processing (F9 toggle)
    pub connection_id: u64,          // Incremented on each connection, used to ignore stale disconnect events
}

impl World {
    pub fn new(name: &str) -> Self {
        Self::new_with_splash(name, false)
    }

    pub fn new_with_splash(name: &str, show_splash: bool) -> Self {
        let output_lines = if show_splash {
            Self::generate_splash_lines()
        } else {
            Vec::new()
        };
        let scroll_offset = output_lines.len().saturating_sub(1);
        Self {
            name: name.to_string(),
            output_lines,
            scroll_offset,
            connected: false,
            command_tx: None,
            unseen_lines: 0,
            paused: false,
            pending_lines: Vec::new(),
            pending_count: 0,
            lines_since_pause: 0,
            settings: WorldSettings::default(),
            log_handle: None,
            log_date: None,
            socket_fd: None,
            proxy_socket_fd: None,
            is_tls: false,
            telnet_mode: false,
            prompt: String::new(),
            prompt_count: 0,
            last_send_time: None,
            last_receive_time: None,
            last_nop_time: None,
            last_user_command_time: None,
            partial_line: String::new(),
            partial_in_pending: false,
            trigger_partial_line: String::new(),
            just_filtered_idler: false,
            wont_echo_time: None,
            uses_wont_echo_prompt: false,
            is_initial_world: false,
            was_connected: false,
            skip_auto_login: false,
            showing_splash: show_splash,
            needs_redraw: false,
            pending_since: None,
            first_unseen_at: None,
            last_pending_broadcast: None,
            last_pending_count_broadcast: 0,
            owner: None,
            proxy_pid: None,
            proxy_socket_path: None,
            naws_enabled: false,
            naws_sent_size: None,
            next_seq: 0,
            reader_name: None,
            gmcp_enabled: false,
            msdp_enabled: false,
            gmcp_supported_packages: Vec::new(),
            msdp_variables: std::collections::HashMap::new(),
            gmcp_data: std::collections::HashMap::new(),
            mcmp_default_url: String::new(),
            active_media: std::collections::HashMap::new(),
            gmcp_user_enabled: false,
            connection_id: 0,
        }
    }

    /// Get the current date as MMDDYY string for log file naming
    fn get_current_date_string() -> String {
        let lt = local_time_now();
        format!("{:02}{:02}{:02}", lt.month, lt.day, lt.year % 100)
    }

    /// Get the path to the logs directory, creating it if needed
    fn get_logs_dir() -> std::path::PathBuf {
        let home = get_home_dir();
        let logs_dir = std::path::PathBuf::from(home).join(clay_filename("clay")).join("logs");
        if !logs_dir.exists() {
            let _ = std::fs::create_dir_all(&logs_dir);
        }
        logs_dir
    }

    /// Get the full path to this world's log file for the current date
    fn get_log_path(&self) -> std::path::PathBuf {
        let date_str = Self::get_current_date_string();
        // Sanitize world name for use in filename (replace invalid chars with _)
        let safe_name: String = self.name.chars()
            .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
            .collect();
        Self::get_logs_dir().join(format!("{}.{}.log", safe_name, date_str))
    }

    /// Open the log file for this world (creates logs directory if needed)
    fn open_log_file(&mut self) -> bool {
        if !self.settings.log_enabled {
            return false;
        }

        let date_str = Self::get_current_date_string();
        let log_path = self.get_log_path();

        match std::fs::OpenOptions::new()
            .create(true)
            .append(true)
            .open(&log_path)
        {
            Ok(file) => {
                self.log_handle = Some(std::sync::Arc::new(std::sync::Mutex::new(file)));
                self.log_date = Some(date_str);
                true
            }
            Err(_) => false,
        }
    }

    /// Close the log file
    fn close_log_file(&mut self) {
        self.log_handle = None;
        self.log_date = None;
    }

    /// Clear connection state when disconnecting
    /// Optionally removes the proxy socket file and clears the prompt
    fn clear_connection_state(&mut self, remove_socket: bool, clear_prompt: bool) {
        if remove_socket {
            if let Some(ref socket_path) = self.proxy_socket_path {
                let _ = std::fs::remove_file(socket_path);
            }
        }
        self.proxy_pid = None;
        self.proxy_socket_path = None;
        self.proxy_socket_fd = None;
        self.command_tx = None;
        self.connected = false;
        self.socket_fd = None;
        self.telnet_mode = false;
        self.naws_enabled = false;
        self.naws_sent_size = None;
        self.reader_name = None;
        // Reset skip_auto_login so next fresh connection triggers auto-login
        self.skip_auto_login = false;
        // Clear active media tracking (processes already killed by stop_world_media)
        self.active_media.clear();
        if clear_prompt {
            self.close_log_file();
            self.prompt.clear();
        }
    }

    /// Write a line to the log file with timestamp prefix
    /// Handles day rollover (opens new file if date changed)
    fn write_log_line(&mut self, line: &str) {
        if !self.settings.log_enabled {
            return;
        }

        // Check for day rollover
        let current_date = Self::get_current_date_string();
        if self.log_date.as_ref() != Some(&current_date) {
            // Date changed, close old file and open new one
            self.close_log_file();
            if !self.open_log_file() {
                return;
            }
        }

        if let Some(ref handle) = self.log_handle {
            if let Ok(mut file) = handle.lock() {
                let lt = local_time_now();

                // Format: [HH:MM:SS] line
                let _ = writeln!(file, "[{:02}:{:02}:{:02}] {}",
                    lt.hour, lt.minute, lt.second, line);
            }
        }
    }

    #[allow(clippy::too_many_arguments)]
    pub fn add_output(
        &mut self,
        text: &str,
        is_current: bool,
        settings: &Settings,
        output_height: u16,
        output_width: u16,
        clear_splash: bool,
        from_server: bool,
    ) {

        // Handle splash mode transitions
        if self.showing_splash && clear_splash {
            // MUD server data: clear splash mode AND clear buffer
            self.showing_splash = false;
            self.needs_redraw = true; // Signal terminal needs full redraw
            self.output_lines.clear();
            self.scroll_offset = 0;
        }
        let max_lines = (output_height as usize).saturating_sub(2);

        // If we have a partial line from before, combine it with new text
        let had_partial = !self.partial_line.is_empty();
        let partial_was_in_pending = self.partial_in_pending;
        let combined = if had_partial {
            let mut s = std::mem::take(&mut self.partial_line);
            s.push_str(text);
            self.partial_in_pending = false;
            s
        } else {
            text.to_string()
        };

        // Parse Discord timestamps (e.g., <t:1234567890:f>)
        let combined = parse_discord_timestamps(&combined);

        // Check if text ends with newline (all lines complete) or not (last line is partial)
        let ends_with_newline = combined.ends_with('\n');

        // Collect lines
        let lines: Vec<&str> = combined.lines().collect();
        if lines.is_empty() {
            return;
        }

        // If we had a partial line, update it in the correct list
        let start_idx = if had_partial {
            let completed_line = lines[0];
            // Check if the completed line should be filtered
            let should_filter = (completed_line.contains("###_idler_message_") && completed_line.contains("_###"))
                || is_visually_empty(completed_line);

            if should_filter {
                // Remove the partial line instead of updating it
                if partial_was_in_pending {
                    self.pending_lines.pop();
                } else {
                    self.output_lines.pop();
                }
            } else {
                // Update the partial line with combined content
                if partial_was_in_pending {
                    if let Some(last) = self.pending_lines.last_mut() {
                        last.text = completed_line.to_string();
                    }
                } else if let Some(last) = self.output_lines.last_mut() {
                    last.text = completed_line.to_string();
                }
            }

            // If the combined text is still partial (no trailing newline) and there's
            // only one line, we need to preserve the partial tracking. The for loop below
            // won't run (skip(1) with 1 line), so partial_line must be restored here.
            if !ends_with_newline && lines.len() == 1 && !should_filter {
                self.partial_line = completed_line.to_string();
                self.partial_in_pending = partial_was_in_pending;
            }

            1 // Skip first line since we handled it
        } else {
            0
        };

        // Process remaining lines
        let line_count = lines.len();
        for (i, line) in lines.iter().enumerate().skip(start_idx) {
            let is_last = i == line_count - 1;
            let is_partial = is_last && !ends_with_newline;

            // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
            let uses_idler_keepalive = matches!(
                self.settings.keep_alive_type,
                KeepAliveType::Custom | KeepAliveType::Generic
            );
            if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                continue;
            }

            // Write to log file if enabled (only for complete lines)
            if !is_partial {
                self.write_log_line(line);
            }

            // Calculate visual lines FIRST (before pause check) to properly handle long wrapped lines
            let visual_lines = visual_line_count(line, output_width as usize);

            // Track if this line goes to pending (for partial tracking)
            let goes_to_pending = self.paused && settings.more_mode_enabled;
            // Use projected line count (current + this line's visual lines) for pause trigger
            let triggers_pause = !goes_to_pending
                && settings.more_mode_enabled
                && (self.lines_since_pause + visual_lines) > max_lines;

            // Pre-wrap oversized lines: call wrap_ansi_line once and store each visual
            // line as a separate OutputLine. This caches the wrap result so the renderer
            // doesn't need to re-wrap, and allows more-mode to paginate per visual line.
            let needs_split = !is_partial
                && settings.more_mode_enabled
                && max_lines > 0
                && visual_lines > max_lines;

            if needs_split {
                let wrapped = wrap_ansi_line(line, output_width as usize);

                if goes_to_pending {
                    // All visual lines go to pending
                    if self.pending_lines.is_empty() {
                        self.pending_since = Some(std::time::Instant::now());
                        if !is_current && self.first_unseen_at.is_none() {
                            self.first_unseen_at = Some(std::time::Instant::now());
                        }
                    }
                    for vl in &wrapped {
                        let seq = self.next_seq; self.next_seq += 1;
                        let cl = if from_server { OutputLine::new(vl.clone(), seq) }
                                 else { OutputLine::new_client(vl.clone(), seq) };
                        self.pending_lines.push(cl);
                    }
                    if !is_current { self.unseen_lines += wrapped.len(); }
                } else {
                    // First max_lines visual lines -> output, rest -> pending
                    for vl in wrapped.iter().take(max_lines) {
                        let seq = self.next_seq; self.next_seq += 1;
                        let fl = if from_server { OutputLine::new(vl.clone(), seq) }
                                 else { OutputLine::new_client(vl.clone(), seq) };
                        self.output_lines.push(fl);
                        self.lines_since_pause += 1; // each pre-wrapped line is 1 visual line
                    }
                    if !is_current {
                        if self.unseen_lines == 0 && self.first_unseen_at.is_none() {
                            self.first_unseen_at = Some(std::time::Instant::now());
                        }
                        self.unseen_lines += wrapped.len().min(max_lines);
                    }
                    self.scroll_to_bottom();
                    self.paused = true;

                    // Remaining visual lines -> pending
                    if wrapped.len() > max_lines {
                        if self.pending_lines.is_empty() {
                            self.pending_since = Some(std::time::Instant::now());
                        }
                        for vl in wrapped.iter().skip(max_lines) {
                            let seq = self.next_seq; self.next_seq += 1;
                            let cl = if from_server { OutputLine::new(vl.clone(), seq) }
                                     else { OutputLine::new_client(vl.clone(), seq) };
                            self.pending_lines.push(cl);
                            if !is_current { self.unseen_lines += 1; }
                        }
                    }
                }
                continue;
            }

            // Create OutputLine with appropriate from_server flag
            let seq = self.next_seq;
            self.next_seq += 1;
            let new_line = if from_server {
                OutputLine::new(line.to_string(), seq)
            } else {
                OutputLine::new_client(line.to_string(), seq)
            };

            if goes_to_pending {
                // Track when pending output first appeared
                if self.pending_lines.is_empty() {
                    self.pending_since = Some(std::time::Instant::now());
                    // Also track first unseen timestamp
                    if self.first_unseen_at.is_none() {
                        self.first_unseen_at = Some(std::time::Instant::now());
                    }
                }

                self.pending_lines.push(new_line);
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = true;
                }
            } else if triggers_pause {
                // Add line to output_lines BEFORE pausing so it's visible when we scroll to bottom
                self.output_lines.push(new_line);
                self.lines_since_pause += visual_lines;
                if !is_current {
                    if self.unseen_lines == 0 && self.first_unseen_at.is_none() {
                        self.first_unseen_at = Some(std::time::Instant::now());
                    }
                    self.unseen_lines += 1;
                }
                // Scroll to show the triggering line, then pause for subsequent lines
                self.scroll_to_bottom();
                self.paused = true;
                // Note: pending_since will be set when the NEXT line arrives and goes to pending_lines
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = false; // It went to output_lines, not pending
                }
            } else {

                self.output_lines.push(new_line);
                self.lines_since_pause += visual_lines;
                if !is_current {
                    // Track when first unseen output arrived
                    if self.unseen_lines == 0 && self.first_unseen_at.is_none() {
                        self.first_unseen_at = Some(std::time::Instant::now());
                    }
                    self.unseen_lines += 1;
                }
                if is_partial {
                    self.partial_line = line.to_string();
                    self.partial_in_pending = false;
                }
            }
        }
        // If more mode is off, always unpause, release pending, and scroll to bottom
        if !settings.more_mode_enabled {
            self.paused = false;
            // Release any pending lines immediately
            if !self.pending_lines.is_empty() {
                self.output_lines.append(&mut self.pending_lines);
            }
        }
        // Always scroll to bottom unless paused (and more mode is on)
        if !self.paused {
            self.scroll_to_bottom();
        }
    }

    fn scroll_to_bottom(&mut self) {
        self.scroll_offset = self.output_lines.len().saturating_sub(1);
    }

    pub fn mark_seen(&mut self) {
        self.unseen_lines = 0;
        self.first_unseen_at = None;
    }

    /// Returns true if this world has activity (unseen lines or pending output)
    fn has_activity(&self) -> bool {
        self.unseen_lines > 0 || !self.pending_lines.is_empty()
    }

    /// Release pending lines, counting by VISUAL lines (wrapped line count) to fill
    /// approximately one screenful. Always releases at least one logical line.
    pub fn release_pending(&mut self, visual_budget: usize, output_width: usize) {
        if self.pending_lines.is_empty() {
            self.paused = false;
            self.lines_since_pause = 0;
            return;
        }
        let width = output_width.max(1);
        let mut visual_total = 0;
        let mut logical_count = 0;

        for line in &self.pending_lines {
            let vl = visual_line_count(&line.text, width);
            // If adding this line would exceed budget AND we already have at least one,
            // stop before adding it. Always release at least 1 line.
            if visual_total > 0 && visual_total + vl > visual_budget {
                break;
            }
            visual_total += vl;
            logical_count += 1;
            if visual_total >= visual_budget {
                break;
            }
        }

        // Always release at least 1 line
        if logical_count == 0 {
            logical_count = 1;
        }

        let to_release: Vec<OutputLine> = self
            .pending_lines
            .drain(..logical_count.min(self.pending_lines.len()))
            .collect();
        for line in to_release {
            self.output_lines.push(line);
        }
        if self.pending_lines.is_empty() {
            self.paused = false;
            self.pending_since = None;

            self.lines_since_pause = 0;
            // If partial was in pending, it's now in output
            if self.partial_in_pending {
                self.partial_in_pending = false;
            }
        } else {
            // Reset counter for next batch

            self.lines_since_pause = 0;
        }
        self.scroll_to_bottom();
    }

    pub fn release_all_pending(&mut self) {

        self.output_lines.append(&mut self.pending_lines);
        self.paused = false;
        self.lines_since_pause = 0;
        self.pending_since = None; // Clear pending timestamp
        // If partial was in pending, it's now in output
        if self.partial_in_pending {
            self.partial_in_pending = false;
        }
        self.scroll_to_bottom();
    }

    /// Filter output to only keep lines from the MUD server (remove client-generated lines)
    fn filter_to_server_output(&mut self) {
        self.output_lines.retain(|line| line.from_server);
        self.pending_lines.retain(|line| line.from_server);
        // Adjust scroll offset if it's now past the end
        if self.scroll_offset > 0 && self.scroll_offset >= self.output_lines.len() {
            self.scroll_offset = self.output_lines.len().saturating_sub(1);
        }
    }

    fn is_at_bottom(&self) -> bool {
        self.scroll_offset >= self.output_lines.len().saturating_sub(1)
    }

    fn lines_from_bottom(&self) -> usize {
        self.output_lines
            .len()
            .saturating_sub(1)
            .saturating_sub(self.scroll_offset)
    }

    fn generate_splash_lines() -> Vec<OutputLine> {
        // Splash content without centering - will be centered at render time
        // Dog art:
        //           (\/\__o
        //   __      `-/ `_/
        //  `--\______/  |
        //     /        /
        //  -`/_------'\_.
        let now = SystemTime::now();
        // Splash lines use seq 0-11 (will be cleared when real MUD data arrives)
        vec![
            OutputLine::new_with_timestamp("".to_string(), now, 0),
            OutputLine::new_with_timestamp("\x1b[38;5;180m          (\\/\\__o     \x1b[38;5;209m â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—\x1b[0m".to_string(), now, 1),
            OutputLine::new_with_timestamp("\x1b[38;5;180m  __      `-/ `_/     \x1b[38;5;208mâ–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•\x1b[0m".to_string(), now, 2),
            OutputLine::new_with_timestamp("\x1b[38;5;180m `--\\______/  |       \x1b[38;5;215mâ–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• \x1b[0m".to_string(), now, 3),
            OutputLine::new_with_timestamp("\x1b[38;5;180m    /        /        \x1b[38;5;216mâ–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  \x1b[0m".to_string(), now, 4),
            OutputLine::new_with_timestamp("\x1b[38;5;180m -`/_------'\\_.       \x1b[38;5;217mâ•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   \x1b[0m".to_string(), now, 5),
            OutputLine::new_with_timestamp("\x1b[38;5;218m                       â•šâ•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•   â•šâ•â•   \x1b[0m".to_string(), now, 6),
            OutputLine::new_with_timestamp("".to_string(), now, 7),
            OutputLine::new_with_timestamp("\x1b[38;5;213mâœ¨ A 90dies mud client written today âœ¨\x1b[0m".to_string(), now, 8),
            OutputLine::new_with_timestamp("".to_string(), now, 9),
            OutputLine::new_with_timestamp("\x1b[38;5;244m/help for how to use clay\x1b[0m".to_string(), now, 10),
            OutputLine::new_with_timestamp("".to_string(), now, 11),
        ]
    }
}

pub struct App {
    pub worlds: Vec<World>,
    pub current_world_index: usize,
    pub previous_world_index: Option<usize>, // For Alt+w fallback when no unseen/pending
    pub input: InputArea,
    pub input_height: u16,
    pub output_height: u16,
    pub output_width: u16,
    pub spell_checker: SpellChecker,
    pub spell_state: SpellState,
    pub last_input_was_delete: bool, // Track if last input action was backspace/delete (for spell check)
    pub skip_temp_conversion: Option<String>, // Temperature to skip re-converting (after user undid conversion)
    pub cached_misspelled: Vec<(usize, usize)>, // Cached misspelled word ranges (char positions)
    pub suggestion_message: Option<String>,
    pub settings: Settings,
    pub confirm_dialog: ConfirmDialog,
    pub filter_popup: FilterPopup,
    /// Split-screen text editor for notes and files
    pub editor: EditorState,
    /// New unified popup manager (gradual migration from old popup types)
    pub popup_manager: popup::PopupManager,
    pub last_ctrl_c: Option<std::time::Instant>,
    pub last_escape: Option<std::time::Instant>, // For Escape+key sequences (Alt emulation)
    pub show_tags: bool, // F2 toggles - false = hide tags (default), true = show tags
    pub highlight_actions: bool, // F8 toggles - highlight lines matching action patterns
    // WebSocket server (ws:// or wss:// depending on web_secure setting)
    pub ws_server: Option<WebSocketServer>,
    // HTTP web interface server (no TLS)
    pub http_server: Option<HttpServer>,
    // HTTPS web interface server
    #[cfg(feature = "native-tls-backend")]
    pub https_server: Option<HttpsServer>,
    #[cfg(feature = "rustls-backend")]
    pub https_server: Option<HttpsServer>,
    // Track if popup was visible last frame (for terminal clear on transition)
    pub popup_was_visible: bool,
    /// Cache of each WS client's view state (for activity indicator and more-mode)
    /// Maps client_id -> ClientViewState (world_index + visible_lines)
    pub ws_client_worlds: std::collections::HashMap<u64, ClientViewState>,
    /// True if this is the master client (runs WS server or WS disabled).
    /// Only master should save settings or initiate connections.
    pub is_master: bool,
    /// True if this session started from a hot reload (suppress server startup messages)
    pub is_reload: bool,
    /// True if the output area needs to be redrawn (optimization to avoid unnecessary redraws)
    pub needs_output_redraw: bool,
    /// True if terminal needs full clear (for Ctrl+L redraw in --console mode)
    pub needs_terminal_clear: bool,
    /// True if running in multiuser mode (--multiuser flag)
    pub multiuser_mode: bool,
    /// User accounts (multiuser mode only)
    pub users: Vec<User>,
    /// Ban list for HTTP/WebSocket security
    pub ban_list: BanList,
    /// Per-user connections in multiuser mode: (world_index, username) -> UserConnection
    pub user_connections: std::collections::HashMap<(usize, String), UserConnection>,
    /// TinyFugue scripting engine
    pub tf_engine: tf::TfEngine,
    /// Loaded theme colors from ~/clay.theme.dat
    pub theme_file: theme::ThemeFile,
    /// Remote client mode: WebSocket transmitter for sending commands to server
    pub ws_client_tx: Option<mpsc::UnboundedSender<WsMessage>>,
    /// Activity count from server (used in remote client mode, i.e. --console)
    pub server_activity_count: usize,
    /// Master GUI mode: channel to send messages to the embedded GUI
    pub gui_tx: Option<mpsc::UnboundedSender<WsMessage>>,
    /// Console media player command ("mpv", "ffplay", or None)
    pub media_player_cmd: Option<String>,
    /// Directory for cached media files
    pub media_cache_dir: PathBuf,
    /// Running media processes keyed by identifier (for Stop) - value is (world_idx, child)
    pub media_processes: std::collections::HashMap<String, (usize, std::process::Child)>,
    /// Current music process key (only one music track at a time) - (world_idx, key)
    pub media_music_key: Option<(usize, String)>,
    /// Event channel sender for async media process delivery
    pub event_tx: Option<mpsc::Sender<AppEvent>>,
    /// Test-only: log of all messages passed to ws_broadcast() and ws_broadcast_to_world()
    #[cfg(test)]
    pub ws_broadcast_log: std::sync::Arc<std::sync::Mutex<Vec<WsMessage>>>,
}

impl App {
    #[allow(clippy::new_without_default)]
    pub fn new() -> Self {
        Self {
            worlds: Vec::new(),
            current_world_index: 0,
            previous_world_index: None,
            input: InputArea::new(3),
            input_height: 3,
            output_height: 20, // Will be updated by ui()
            output_width: 80,  // Will be updated by ui()
            spell_checker: SpellChecker::new(""),
            spell_state: SpellState::new(),
            last_input_was_delete: false,
            skip_temp_conversion: None,
            cached_misspelled: Vec::new(),
            suggestion_message: None,
            settings: Settings::default(),
            confirm_dialog: ConfirmDialog::new(),
            filter_popup: FilterPopup::new(),
            editor: EditorState::new(),
            popup_manager: popup::PopupManager::new(),
            last_ctrl_c: None,
            last_escape: None,
            show_tags: false, // Default: hide tags
            highlight_actions: false, // Default: don't highlight action matches
            ws_server: None,
            http_server: None,
            #[cfg(feature = "native-tls-backend")]
            https_server: None,
            #[cfg(feature = "rustls-backend")]
            https_server: None,
            popup_was_visible: false,
            ws_client_worlds: std::collections::HashMap::new(),
            is_master: true, // Console app is always master (remote GUI is separate execution path)
            is_reload: false, // Set to true in run_app if started from hot reload
            needs_output_redraw: true, // Start with true to ensure initial render
            needs_terminal_clear: false, // Set to true by Ctrl+L in --console mode
            multiuser_mode: false, // Set to true in main if started with --multiuser
            users: Vec::new(),
            ban_list: BanList::new(),
            user_connections: std::collections::HashMap::new(),
            tf_engine: tf::TfEngine::new(),
            theme_file: theme::ThemeFile::with_defaults(),
            ws_client_tx: None, // Set when running as remote client (--console mode)
            server_activity_count: 0, // Activity count from server (remote client mode)
            gui_tx: None, // Set when running in master GUI mode (--gui)
            media_player_cmd: detect_media_player(),
            media_cache_dir: {
                let home = get_home_dir();
                PathBuf::from(home).join(clay_filename("clay")).join("media")
            },
            media_processes: std::collections::HashMap::new(),
            media_music_key: None,
            event_tx: None,
            #[cfg(test)]
            ws_broadcast_log: std::sync::Arc::new(std::sync::Mutex::new(Vec::new())),
        }
        // Note: No initial world created here - it will be created after persistence::load_settings()
        // if no worlds are configured
    }

    /// Get theme colors for the current console theme
    pub fn theme_colors(&self) -> &theme::ThemeColors {
        self.theme_file.get(self.settings.theme.name())
    }

    /// Get theme colors for the current GUI theme
    pub fn gui_theme_colors(&self) -> &theme::ThemeColors {
        self.theme_file.get(self.settings.gui_theme.name())
    }

    /// Build a GlobalSettingsMsg from current app state
    pub fn build_global_settings_msg(&self) -> GlobalSettingsMsg {
        GlobalSettingsMsg {
            more_mode_enabled: self.settings.more_mode_enabled,
            spell_check_enabled: self.settings.spell_check_enabled,
            temp_convert_enabled: self.settings.temp_convert_enabled,
            world_switch_mode: self.settings.world_switch_mode.name().to_string(),
            debug_enabled: self.settings.debug_enabled,
            show_tags: self.show_tags,
            ansi_music_enabled: self.settings.ansi_music_enabled,
            console_theme: self.settings.theme.name().to_string(),
            gui_theme: self.settings.gui_theme.name().to_string(),
            gui_transparency: self.settings.gui_transparency,
            color_offset_percent: self.settings.color_offset_percent,
            input_height: self.input_height,
            font_name: self.settings.font_name.clone(),
            font_size: self.settings.font_size,
            web_font_size_phone: self.settings.web_font_size_phone,
            web_font_size_tablet: self.settings.web_font_size_tablet,
            web_font_size_desktop: self.settings.web_font_size_desktop,
            ws_allow_list: self.settings.websocket_allow_list.clone(),
            web_secure: self.settings.web_secure,
            http_enabled: self.settings.http_enabled,
            http_port: self.settings.http_port,
            ws_enabled: self.settings.ws_enabled,
            ws_port: self.settings.ws_port,
            ws_cert_file: self.settings.websocket_cert_file.clone(),
            ws_key_file: self.settings.websocket_key_file.clone(),
            tls_proxy_enabled: self.settings.tls_proxy_enabled,
            dictionary_path: self.settings.dictionary_path.clone(),
            theme_colors_json: self.gui_theme_colors().to_json(),
        }
    }

    /// Ensure there's at least one world (creates initial world if needed)
    /// Also adds splash screen to current world if it has no output
    fn ensure_has_world(&mut self) {
        if self.worlds.is_empty() {
            let mut initial_world = World::new_with_splash(&get_binary_name(), true);
            initial_world.is_initial_world = true;
            self.worlds.push(initial_world);
        } else {
            // Add splash to current world if it has no output yet
            let current = &mut self.worlds[self.current_world_index];
            if current.output_lines.is_empty() && !current.connected {
                current.output_lines = World::generate_splash_lines();
                current.showing_splash = true;
                current.scroll_offset = current.output_lines.len().saturating_sub(1);
            }
        }
    }

    pub fn current_world(&self) -> &World {
        // Safety: clamp index to valid range to prevent panic
        let idx = if self.worlds.is_empty() {
            0  // Will panic below, but ensure_has_world() should prevent this
        } else {
            self.current_world_index.min(self.worlds.len() - 1)
        };
        &self.worlds[idx]
    }

    pub fn current_world_mut(&mut self) -> &mut World {
        // Safety: clamp index to valid range to prevent panic
        let idx = if self.worlds.is_empty() {
            0  // Will panic below, but ensure_has_world() should prevent this
        } else {
            self.current_world_index.min(self.worlds.len() - 1)
        };
        &mut self.worlds[idx]
    }

    /// Sync world info to TfEngine for TF functions (fg_world, world_info, nactive)
    fn sync_tf_world_info(&mut self) {
        // Set current world name
        self.tf_engine.current_world = if !self.worlds.is_empty() {
            Some(self.worlds[self.current_world_index].name.clone())
        } else {
            None
        };

        // Build world info cache
        self.tf_engine.world_info_cache.clear();
        for world in &self.worlds {
            self.tf_engine.world_info_cache.push(tf::WorldInfoCache {
                name: world.name.clone(),
                host: world.settings.hostname.clone(),
                port: world.settings.port.clone(),
                user: world.settings.user.clone(),
                password: world.settings.password.clone(),
                is_connected: world.connected,
                use_ssl: world.settings.use_ssl,
            });
        }

        // Sync keyboard buffer state
        self.tf_engine.keyboard_state = tf::KeyboardBufferState {
            buffer: self.input.buffer.clone(),
            cursor_position: self.input.cursor_position,
        };
    }

    /// Process pending keyboard operations from TF functions
    fn process_pending_keyboard_ops(&mut self) {
        let ops: Vec<tf::PendingKeyboardOp> = self.tf_engine.pending_keyboard_ops.drain(..).collect();
        for op in ops {
            match op {
                tf::PendingKeyboardOp::Goto(pos) => {
                    let max_pos = self.input.buffer.chars().count();
                    self.input.cursor_position = pos.min(max_pos);
                }
                tf::PendingKeyboardOp::Delete(count) => {
                    if count > 0 {
                        // Delete forward
                        let chars: Vec<char> = self.input.buffer.chars().collect();
                        let pos = self.input.cursor_position;
                        let end = (pos + count as usize).min(chars.len());
                        let new_buffer: String = chars[..pos].iter().chain(chars[end..].iter()).collect();
                        self.input.buffer = new_buffer;
                    } else if count < 0 {
                        // Delete backward
                        let chars: Vec<char> = self.input.buffer.chars().collect();
                        let pos = self.input.cursor_position;
                        let start = pos.saturating_sub((-count) as usize);
                        let new_buffer: String = chars[..start].iter().chain(chars[pos..].iter()).collect();
                        self.input.buffer = new_buffer;
                        self.input.cursor_position = start;
                    }
                }
                tf::PendingKeyboardOp::WordLeft => {
                    let chars: Vec<char> = self.input.buffer.chars().collect();
                    let mut pos = self.input.cursor_position;
                    // Skip whitespace
                    while pos > 0 && !chars[pos - 1].is_alphanumeric() {
                        pos -= 1;
                    }
                    // Skip word
                    while pos > 0 && chars[pos - 1].is_alphanumeric() {
                        pos -= 1;
                    }
                    self.input.cursor_position = pos;
                }
                tf::PendingKeyboardOp::WordRight => {
                    let chars: Vec<char> = self.input.buffer.chars().collect();
                    let mut pos = self.input.cursor_position;
                    // Skip word
                    while pos < chars.len() && chars[pos].is_alphanumeric() {
                        pos += 1;
                    }
                    // Skip whitespace
                    while pos < chars.len() && !chars[pos].is_alphanumeric() {
                        pos += 1;
                    }
                    self.input.cursor_position = pos;
                }
                tf::PendingKeyboardOp::Insert(text) => {
                    let chars: Vec<char> = self.input.buffer.chars().collect();
                    let pos = self.input.cursor_position.min(chars.len());
                    let before: String = chars[..pos].iter().collect();
                    let after: String = chars[pos..].iter().collect();
                    self.input.buffer = format!("{}{}{}", before, text, after);
                    self.input.cursor_position = pos + text.chars().count();
                }
            }
        }
    }

    /// Check if a new-style popup is currently visible
    fn has_new_popup(&self) -> bool {
        self.popup_manager.current().map(|s| s.visible).unwrap_or(false)
    }

    /// Open the help popup using the new unified popup system
    fn open_help_popup_new(&mut self) {
        use popup::definitions::help::{create_help_popup, HELP_FIELD_CONTENT};
        self.popup_manager.open(create_help_popup());
        // Select the content field so arrow keys can scroll
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_field(HELP_FIELD_CONTENT);
        }
    }

    /// Close the current new-style popup
    fn close_new_popup(&mut self) {
        self.popup_manager.close();
    }

    /// Open the menu popup using the new unified popup system
    fn open_menu_popup_new(&mut self) {
        use popup::definitions::menu::create_menu_popup;
        self.popup_manager.open(create_menu_popup());
    }

    /// Open a confirm dialog for deleting a world
    fn open_delete_world_confirm(&mut self, world_name: &str, world_index: usize) {
        use popup::definitions::confirm::{create_delete_world_dialog, CONFIRM_BTN_NO};
        let mut def = create_delete_world_dialog(world_name);
        // Store the world index in custom_data for retrieval on confirm
        def.custom_data.insert("world_index".to_string(), world_index.to_string());
        self.popup_manager.open(def);
        // Select No by default for safety
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_button(CONFIRM_BTN_NO);
        }
    }

    /// Open the world selector popup using the new unified popup system
    fn open_world_selector_new(&mut self) {
        use popup::definitions::world_selector::{create_world_selector_popup, WorldInfo, SELECTOR_FIELD_LIST};

        let worlds: Vec<WorldInfo> = self.worlds.iter().enumerate().map(|(i, w)| {
            WorldInfo {
                name: w.name.clone(),
                hostname: w.settings.hostname.clone(),
                port: w.settings.port.to_string(),
                user: w.settings.user.clone(),
                is_connected: w.connected,
                is_current: i == self.current_world_index,
            }
        }).collect();

        let visible_height = 10.min(worlds.len().max(3));
        let def = create_world_selector_popup(&worlds, visible_height);
        self.popup_manager.open(def);

        // Select current world in the list
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_field(SELECTOR_FIELD_LIST);
            // Set selection to current world
            if let Some(field) = state.field_mut(SELECTOR_FIELD_LIST) {
                if let popup::FieldKind::List { selected_index, .. } = &mut field.kind {
                    *selected_index = self.current_world_index;
                }
            }
        }
    }

    /// Open the new setup popup for global settings
    fn open_setup_popup_new(&mut self) {
        use popup::definitions::setup::{create_setup_popup, SETUP_FIELD_MORE_MODE};

        let world_switching = match self.settings.world_switch_mode {
            WorldSwitchMode::UnseenFirst => "unseen_first",
            WorldSwitchMode::Alphabetical => "alphabetical",
        };

        let def = create_setup_popup(
            self.settings.more_mode_enabled,
            self.settings.spell_check_enabled,
            self.settings.temp_convert_enabled,
            world_switching,
            self.settings.debug_enabled,
            self.input_height as i64,
            self.settings.gui_theme.name(),
            self.settings.tls_proxy_enabled,
            &self.settings.dictionary_path,
            self.settings.editor_side.name(),
        );
        self.popup_manager.open(def);

        // Select first field
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_field(SETUP_FIELD_MORE_MODE);
        }
    }

    /// Open the new web settings popup
    fn open_web_popup_new(&mut self) {
        use popup::definitions::web::{create_web_popup, WEB_FIELD_PROTOCOL};

        let def = create_web_popup(
            self.settings.web_secure,
            self.settings.http_enabled,
            &self.settings.http_port.to_string(),
            self.settings.ws_enabled,
            &self.settings.ws_port.to_string(),
            &self.settings.websocket_password,
            &self.settings.websocket_allow_list,
            &self.settings.websocket_cert_file,
            &self.settings.websocket_key_file,
        );
        self.popup_manager.open(def);

        // Select first field
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_field(WEB_FIELD_PROTOCOL);
        }
    }

    /// Open the world editor popup for a specific world
    fn open_world_editor_popup_new(&mut self, world_index: usize) {
        use popup::definitions::world_editor::{
            create_world_editor_popup, WorldSettings as PopupWorldSettings, WORLD_FIELD_NAME,
        };

        let world = &self.worlds[world_index];

        // Map auto_connect type to lowercase value for popup
        let auto_connect = match world.settings.auto_connect_type {
            AutoConnectType::Connect => "connect",
            AutoConnectType::Prompt => "prompt",
            AutoConnectType::MooPrompt => "moo_prompt",
            AutoConnectType::NoLogin => "none",
        };

        // Map keep_alive type to lowercase value for popup
        let keep_alive = match world.settings.keep_alive_type {
            KeepAliveType::None => "none",
            KeepAliveType::Nop => "nop",
            KeepAliveType::Custom => "custom",
            KeepAliveType::Generic => "generic",
        };

        let settings = PopupWorldSettings {
            name: world.name.clone(),
            world_type: world.settings.world_type.name().to_string(),
            hostname: world.settings.hostname.clone(),
            port: world.settings.port.clone(),
            user: world.settings.user.clone(),
            password: world.settings.password.clone(),
            use_ssl: world.settings.use_ssl,
            log_enabled: world.settings.log_enabled,
            encoding: world.settings.encoding.name().to_string(),
            auto_connect: auto_connect.to_string(),
            keep_alive: keep_alive.to_string(),
            keep_alive_cmd: world.settings.keep_alive_cmd.clone(),
            gmcp_packages: world.settings.gmcp_packages.clone(),
            slack_token: world.settings.slack_token.clone(),
            slack_channel: world.settings.slack_channel.clone(),
            slack_workspace: world.settings.slack_workspace.clone(),
            discord_token: world.settings.discord_token.clone(),
            discord_guild: world.settings.discord_guild.clone(),
            discord_channel: world.settings.discord_channel.clone(),
            discord_dm_user: world.settings.discord_dm_user.clone(),
        };

        let def = create_world_editor_popup(&settings);
        self.popup_manager.open(def);

        // Store world index in popup custom state and select first field
        if let Some(state) = self.popup_manager.current_mut() {
            state.set_custom("world_index", world_index.to_string());
            state.select_field(WORLD_FIELD_NAME);
            // Auto-start editing on the name field
            state.start_edit();
        }
    }

    /// Open the actions list popup
    fn open_actions_list_popup(&mut self) {
        self.open_actions_list_popup_with_filter("");
    }

    /// Open the actions list popup with optional world filter
    fn open_actions_list_popup_with_filter(&mut self, world_filter: &str) {
        use popup::definitions::actions::ACTIONS_FIELD_LIST;

        // Build items with indices for the popup
        let mut items: Vec<popup::ListItem> = self.settings.actions.iter().enumerate()
            .filter(|(_, a)| {
                if world_filter.is_empty() {
                    true
                } else {
                    a.world.to_lowercase().contains(&world_filter.to_lowercase())
                }
            })
            .map(|(idx, a)| {
                #[cfg(not(windows))]
                let status = if a.enabled { "[âœ“]" } else { "[ ]" };
                #[cfg(windows)]
                let status = if a.enabled { "[x]" } else { "[ ]" };
                let world_part = if a.world.is_empty() {
                    String::new()
                } else {
                    format!("({})", a.world)
                };
                let pattern_preview = if a.pattern.len() > 30 {
                    format!("{}...", &a.pattern[..27])
                } else {
                    a.pattern.clone()
                };
                popup::ListItem {
                    id: idx.to_string(),  // Store original index as ID
                    columns: vec![
                        format!("{} {}", status, a.name),
                        world_part,
                        pattern_preview,
                    ],
                    style: popup::ListItemStyle {
                        is_disabled: !a.enabled,
                        ..Default::default()
                    },
                }
            })
            .collect();

        // Sort alphabetically by action name (case-insensitive)
        items.sort_by(|a, b| {
            // Extract name from first column: "[x] name" or "[ ] name"
            let name_a = a.columns[0].get(4..).unwrap_or("").to_lowercase();
            let name_b = b.columns[0].get(4..).unwrap_or("").to_lowercase();
            name_a.cmp(&name_b)
        });

        let visible_height = 10.min(items.len().max(3));

        // Create the popup with the filtered actions
        let def = popup::PopupDefinition::new(popup::PopupId("actions_list"), "Actions")
            .with_field(popup::Field::new(
                popup::definitions::actions::ACTIONS_FIELD_FILTER,
                "Filter",
                popup::FieldKind::text_with_placeholder("", "Type to filter..."),
            ))
            .with_field(popup::Field::new(
                ACTIONS_FIELD_LIST,
                "",
                popup::FieldKind::list(items, visible_height),
            ))
            .with_button(popup::Button::new(popup::definitions::actions::ACTIONS_BTN_DELETE, "Delete").danger().with_shortcut('D').left_align())
            .with_button(popup::Button::new(popup::definitions::actions::ACTIONS_BTN_ADD, "Add").with_shortcut('A'))
            .with_button(popup::Button::new(popup::definitions::actions::ACTIONS_BTN_EDIT, "Edit").with_shortcut('E'))
            .with_button(popup::Button::new(popup::definitions::actions::ACTIONS_BTN_CANCEL, "Ok").primary().with_shortcut('O'))
            .with_layout(popup::PopupLayout {
                label_width: 8,
                min_width: 70,
                max_width_percent: 85,
                center_horizontal: true,
                center_vertical: true,
                modal: true,
                buttons_right_align: false,
                blank_line_before_list: false,
                tab_buttons_only: false,
            });

        self.popup_manager.open(def);

        // Select the list field
        if let Some(state) = self.popup_manager.current_mut() {
            state.select_field(ACTIONS_FIELD_LIST);
        }
    }

    /// Open the action editor popup
    fn open_action_editor_popup(&mut self, editing_index: Option<usize>) {
        use popup::definitions::actions::{
            create_action_editor_popup, ActionSettings,
            EDITOR_FIELD_NAME,
        };

        let settings = if let Some(idx) = editing_index {
            if idx < self.settings.actions.len() {
                let action = &self.settings.actions[idx];
                ActionSettings {
                    name: action.name.clone(),
                    world: action.world.clone(),
                    match_type: action.match_type.as_str().to_string(),
                    pattern: action.pattern.clone(),
                    command: action.command.clone(),
                    enabled: action.enabled,
                    startup: action.startup,
                }
            } else {
                ActionSettings::default()
            }
        } else {
            ActionSettings::default()
        };

        let is_new = editing_index.is_none();
        let def = create_action_editor_popup(&settings, is_new);

        self.popup_manager.open(def);

        // Store editing index in custom state
        if let Some(state) = self.popup_manager.current_mut() {
            if let Some(idx) = editing_index {
                state.set_custom("editing_index", idx.to_string());
            }
            state.select_field(EDITOR_FIELD_NAME);
        }
    }

    /// Open delete action confirmation dialog
    fn open_delete_action_confirm(&mut self, name: &str, index: usize) {
        use popup::definitions::confirm::create_delete_action_dialog;
        let mut def = create_delete_action_dialog(name);
        def.custom_data.insert("action_index".to_string(), index.to_string());
        self.popup_manager.push(def);
    }

    /// Handle incoming WebSocket message when running as remote client
    fn handle_remote_ws_message(&mut self, msg: WsMessage) {
        match msg {
            WsMessage::ServerData { world_index, data, from_server, .. } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    // Check if user was at bottom before adding lines
                    let was_at_bottom = world.is_at_bottom();

                    for line in data.lines() {
                        // Preserve from_server flag for Ctrl+L filtering
                        let seq = world.next_seq;
                        world.next_seq += 1;
                        let output_line = if from_server {
                            OutputLine::new(line.to_string(), seq)
                        } else {
                            OutputLine::new_client(line.to_string(), seq)
                        };
                        world.output_lines.push(output_line);
                    }

                    // Keep scroll at bottom if user was viewing latest output
                    // For console client, daemon controls more-mode so always scroll if at bottom
                    // (paused only affects the indicator, not scrolling)
                    if was_at_bottom {
                        world.scroll_offset = world.output_lines.len().saturating_sub(1);
                    }

                    if world_index != self.current_world_index {
                        world.unseen_lines += data.lines().count();
                    }
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::WorldConnected { world_index, .. } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.connected = true;
                    world.was_connected = true;
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::WorldDisconnected { world_index } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.connected = false;
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::WorldSwitched { new_index } => {
                self.current_world_index = new_index;
                self.needs_output_redraw = true;
            }
            WsMessage::PromptUpdate { world_index, prompt } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.prompt = prompt;
                }
            }
            WsMessage::UnseenCleared { world_index } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.unseen_lines = 0;
                }
            }
            WsMessage::UnseenUpdate { world_index, count } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.unseen_lines = count;
                }
            }
            WsMessage::PendingLinesUpdate { world_index, count } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    // Track pending count from daemon (no actual lines stored client-side)
                    world.pending_count = count;
                    world.paused = count > 0;
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::PendingReleased { world_index, count: _ } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    // Pending lines released - daemon will send ServerData and PendingLinesUpdate
                    // Just ensure we scroll to bottom to show new content
                    world.scroll_to_bottom();
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::WorldStateResponse { world_index, pending_count, prompt, scroll_offset, recent_lines } => {
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.scroll_offset = scroll_offset;
                    world.prompt = prompt;
                    world.pending_count = pending_count;
                    world.paused = pending_count > 0;
                    // Append recent lines
                    for tl in recent_lines {
                        let seq = world.next_seq;
                        world.next_seq += 1;
                        world.output_lines.push(OutputLine {
                            text: tl.text,
                            timestamp: std::time::UNIX_EPOCH + std::time::Duration::from_secs(tl.ts),
                            from_server: true,
                            gagged: tl.gagged,
                            seq,
                            highlight_color: tl.highlight_color,
                        });
                    }
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::WorldFlushed { world_index } => {
                // World's output buffer was cleared (e.g., splash screen replaced with MUD data)
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.output_lines.clear();
                    world.pending_count = 0;
                    world.paused = false;
                    world.scroll_offset = 0;
                    world.partial_line.clear();
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::CalculatedWorld { index: Some(idx) } => {
                // Server calculated next/prev world for us - switch to it
                if idx < self.worlds.len() {
                    self.current_world_index = idx;
                    // Clear unseen for the world we're switching to
                    if let Some(world) = self.worlds.get_mut(idx) {
                        world.unseen_lines = 0;
                    }
                    self.needs_output_redraw = true;
                    // Send MarkWorldSeen to notify server
                    if let Some(ref tx) = self.ws_client_tx {
                        let _ = tx.send(WsMessage::MarkWorldSeen { world_index: idx });
                    }
                }
            }
            WsMessage::CalculatedWorld { index: None } => {}
            WsMessage::ActivityUpdate { count } => {
                // Server's activity count changed - update our copy
                self.server_activity_count = count;
                self.needs_output_redraw = true;
            }
            WsMessage::ShowTagsChanged { show_tags } => {
                // Server toggled show_tags (F2 or /tag command)
                self.show_tags = show_tags;
                self.needs_output_redraw = true;
            }
            WsMessage::GmcpUserToggled { world_index, enabled } => {
                if world_index < self.worlds.len() {
                    self.worlds[world_index].gmcp_user_enabled = enabled;
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::SetInputBuffer { text } => {
                self.input.buffer = text;
                self.input.cursor_position = self.input.buffer.chars().count();
                self.needs_output_redraw = true;
            }
            WsMessage::ConnectionsListResponse { lines } => {
                // Display the connections list from server
                let was_at_bottom = self.current_world().is_at_bottom();
                for line in lines {
                    let seq = self.current_world().next_seq;
                    let world = self.current_world_mut();
                    world.next_seq = seq + 1;
                    world.output_lines.push(OutputLine::new_client(line, seq));
                }
                if was_at_bottom {
                    self.current_world_mut().scroll_to_bottom();
                }
                self.needs_output_redraw = true;
            }
            WsMessage::ExecuteLocalCommand { command } => {
                // Server wants us to execute a command locally (from action)
                let parsed = parse_command(&command);
                match parsed {
                    Command::WorldSelector => {
                        self.open_world_selector_new();
                    }
                    Command::WorldsList => {
                        // Request connections list from server
                        if let Some(ref tx) = self.ws_client_tx {
                            let _ = tx.send(WsMessage::RequestConnectionsList);
                        }
                    }
                    Command::Help => {
                        self.open_help_popup_new();
                    }
                    Command::Setup => {
                        self.open_setup_popup_new();
                    }
                    Command::Web => {
                        self.open_web_popup_new();
                    }
                    Command::Actions { world } => {
                        if let Some(world_name) = world {
                            self.open_actions_list_popup_with_filter(&world_name);
                        } else {
                            self.open_actions_list_popup();
                        }
                    }
                    Command::Menu => {
                        self.open_menu_popup_new();
                    }
                    _ => {
                        // Unknown local command - ignore or log
                    }
                }
            }
            WsMessage::WorldSwitchResult { world_index, world_name: _, pending_count, paused } => {
                // Response to CycleWorld - update local world index and state
                if world_index < self.worlds.len() {
                    self.current_world_index = world_index;
                    if let Some(world) = self.worlds.get_mut(world_index) {
                        world.pending_count = pending_count;
                        world.paused = paused;
                        world.unseen_lines = 0;
                    }
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::OutputLines { world_index, lines, is_initial: _ } => {
                // Batch of output lines from server
                if let Some(world) = self.worlds.get_mut(world_index) {
                    let was_at_bottom = world.is_at_bottom();
                    for line in lines {
                        let output_line = OutputLine {
                            text: line.text,
                            timestamp: std::time::UNIX_EPOCH + std::time::Duration::from_secs(line.ts),
                            from_server: line.from_server,
                            gagged: line.gagged,
                            seq: line.seq,
                            highlight_color: line.highlight_color,
                        };
                        world.output_lines.push(output_line);
                        if line.seq >= world.next_seq {
                            world.next_seq = line.seq + 1;
                        }
                    }
                    if was_at_bottom {
                        world.scroll_to_bottom();
                    }
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::PendingCountUpdate { world_index, count } => {
                // Periodic pending count update from server
                if let Some(world) = self.worlds.get_mut(world_index) {
                    world.pending_count = count;
                    world.paused = count > 0;
                    self.needs_output_redraw = true;
                }
            }
            WsMessage::ScrollbackLines { world_index, lines } => {
                // Response to RequestScrollback - prepend lines to output
                if let Some(world) = self.worlds.get_mut(world_index) {
                    // Insert at the beginning of output_lines
                    let new_lines: Vec<OutputLine> = lines.into_iter().map(|line| {
                        OutputLine {
                            text: line.text,
                            timestamp: std::time::UNIX_EPOCH + std::time::Duration::from_secs(line.ts),
                            from_server: line.from_server,
                            gagged: line.gagged,
                            seq: line.seq,
                            highlight_color: line.highlight_color,
                        }
                    }).collect();
                    let prepended_count = new_lines.len();
                    let mut combined = new_lines;
                    combined.append(&mut world.output_lines);
                    world.output_lines = combined;
                    // Adjust scroll_offset to keep viewing the same content
                    world.scroll_offset += prepended_count;
                    self.needs_output_redraw = true;
                }
            }
            _ => {}
        }
    }

    /// Initialize App state from InitialState message (remote client mode)
    fn init_from_initial_state(
        &mut self,
        worlds: Vec<WorldStateMsg>,
        current_world_index: usize,
        settings: GlobalSettingsMsg,
        splash_lines: Vec<String>,
    ) {
        self.worlds = worlds.into_iter().map(|w| {
            let mut world = World::new(&w.name);
            world.connected = w.connected;
            world.was_connected = w.was_connected;
            // Set proxy_pid sentinel if server reports proxy (actual PID not needed for display)
            world.proxy_pid = if w.is_proxy { Some(0) } else { None };
            let output_lines_count = w.output_lines_ts.len();
            world.output_lines = w.output_lines_ts.into_iter().map(|tl| {
                OutputLine {
                    text: tl.text,
                    timestamp: std::time::UNIX_EPOCH + std::time::Duration::from_secs(tl.ts),
                    from_server: tl.from_server,
                    gagged: tl.gagged,
                    seq: tl.seq,
                    highlight_color: tl.highlight_color,
                }
            }).collect();
            // Update next_seq to continue from highest seq in output_lines
            world.next_seq = world.output_lines.iter().map(|l| l.seq).max().unwrap_or(0).saturating_add(1);
            world.unseen_lines = w.unseen_lines;
            // Use server's scroll_offset, or set to end of buffer if showing splash
            world.scroll_offset = if w.showing_splash {
                output_lines_count.saturating_sub(1)
            } else {
                w.scroll_offset
            };
            world.pending_lines = w.pending_lines_ts.into_iter().map(|tl| {
                OutputLine {
                    text: tl.text,
                    timestamp: std::time::UNIX_EPOCH + std::time::Duration::from_secs(tl.ts),
                    from_server: tl.from_server,
                    gagged: tl.gagged,
                    seq: tl.seq,
                    highlight_color: tl.highlight_color,
                }
            }).collect();
            // Update next_seq if pending_lines have higher seq values
            if let Some(max_pending_seq) = world.pending_lines.iter().map(|l| l.seq).max() {
                world.next_seq = world.next_seq.max(max_pending_seq.saturating_add(1));
            }
            world.paused = w.paused;
            world.prompt = w.prompt;
            world.showing_splash = w.showing_splash;
            world.gmcp_user_enabled = w.gmcp_user_enabled;
            world.settings = WorldSettings {
                hostname: w.settings.hostname,
                port: w.settings.port,
                user: w.settings.user,
                password: String::new(), // Don't receive passwords from server
                use_ssl: w.settings.use_ssl,
                log_enabled: w.settings.log_enabled,
                encoding: Encoding::from_name(&w.settings.encoding),
                auto_connect_type: AutoConnectType::from_name(&w.settings.auto_connect_type),
                keep_alive_type: KeepAliveType::from_name(&w.settings.keep_alive_type),
                keep_alive_cmd: w.settings.keep_alive_cmd,
                ..WorldSettings::default()
            };
            world
        }).collect();
        self.current_world_index = current_world_index;
        self.settings.more_mode_enabled = settings.more_mode_enabled;
        self.settings.spell_check_enabled = settings.spell_check_enabled;
        self.settings.temp_convert_enabled = settings.temp_convert_enabled;
        self.show_tags = settings.show_tags;
        self.input_height = settings.input_height;
        self.is_master = false; // Remote client is never master

        // If current world has no output, add splash screen
        if !splash_lines.is_empty() {
            if let Some(world) = self.worlds.get_mut(current_world_index) {
                if world.output_lines.is_empty() && !world.connected {
                    world.output_lines = splash_lines.into_iter()
                        .enumerate()
                        .map(|(i, line)| {
                            let seq = world.next_seq + i as u64;
                            OutputLine::new(line, seq)
                        })
                        .collect();
                    world.next_seq += world.output_lines.len() as u64;
                    world.showing_splash = true;
                    world.scroll_offset = world.output_lines.len().saturating_sub(1);
                }
            }
        }
    }

    /// Find world index by name (case-insensitive), also checks reader_name for renamed worlds
    pub fn find_world_index(&self, name: &str) -> Option<usize> {
        self.worlds.iter().position(|w| {
            w.name.eq_ignore_ascii_case(name) ||
            w.reader_name.as_ref().is_some_and(|rn| rn.eq_ignore_ascii_case(name))
        })
    }

    pub fn switch_world(&mut self, index: usize) {
        if index < self.worlds.len() && index != self.current_world_index {
            // Stop media for old world (audio only plays for current world)
            self.stop_world_media(self.current_world_index);
            // Reset lines_since_pause for the old world if more-mode hasn't triggered
            let old_index = self.current_world_index;
            if self.worlds[old_index].pending_lines.is_empty() {
                self.worlds[old_index].lines_since_pause = 0;
            }
            // Track previous world for Alt+w fallback
            self.previous_world_index = Some(self.current_world_index);
            self.current_world_index = index;
            // Note: mark_seen() is NOT called here - lines are only marked seen when displayed
            // Mark output for redraw since we switched worlds
            self.needs_output_redraw = true;
            // Broadcast activity count since switching worlds changes which world is "current"
            // and activity_count() excludes the current world
            self.broadcast_activity();
            // Restart active media for the new world
            self.restart_world_media(index);
        }
    }

    /// Switch to a world with activity (Alt-w)
    /// Priority: 1) oldest pending output, 2) any unseen output, 3) previous world
    /// Returns true if switched, false if nowhere to switch
    fn switch_to_oldest_pending(&mut self) -> bool {
        // First, check for worlds with pending output (paused lines)
        let mut oldest_idx: Option<usize> = None;
        let mut oldest_time: Option<std::time::Instant> = None;

        for (idx, world) in self.worlds.iter().enumerate() {
            // Skip current world and worlds without pending output
            if idx == self.current_world_index || world.pending_lines.is_empty() {
                continue;
            }
            if let Some(pending_time) = world.pending_since {
                if oldest_time.is_none() || pending_time < oldest_time.unwrap() {
                    oldest_time = Some(pending_time);
                    oldest_idx = Some(idx);
                }
            }
        }

        if let Some(idx) = oldest_idx {
            self.switch_world(idx);
            return true;
        }

        // Second, check for worlds with unseen output (activity indicator)
        for (idx, world) in self.worlds.iter().enumerate() {
            if idx != self.current_world_index && world.unseen_lines > 0 {
                self.switch_world(idx);
                return true;
            }
        }

        // Third, fall back to previous world if it exists and is different
        if let Some(prev_idx) = self.previous_world_index {
            if prev_idx < self.worlds.len() && prev_idx != self.current_world_index {
                self.switch_world(prev_idx);
                return true;
            }
        }

        false
    }

    /// Calculate minimum output dimensions across all connected instances (console + web clients)
    /// Returns (width, height) or None if no instances are connected
    fn get_minimum_dimensions(&self) -> Option<(u16, u16)> {
        let mut min_width: Option<u16> = None;
        let mut min_height: Option<u16> = None;

        // Console dimensions (always present)
        if self.output_width > 0 && self.output_height > 0 {
            min_width = Some(self.output_width);
            min_height = Some(self.output_height);
        }

        // WebSocket client dimensions
        for state in self.ws_client_worlds.values() {
            if let Some((w, h)) = state.dimensions {
                if w > 0 && h > 0 {
                    min_width = Some(min_width.map_or(w, |mw| mw.min(w)));
                    min_height = Some(min_height.map_or(h, |mh| mh.min(h)));
                }
            }
        }

        match (min_width, min_height) {
            (Some(w), Some(h)) => Some((w, h)),
            _ => None,
        }
    }

    /// Send NAWS subnegotiation to a world if dimensions changed
    /// Returns true if NAWS was sent
    fn send_naws_if_changed(&mut self, world_index: usize) -> bool {
        if world_index >= self.worlds.len() {
            return false;
        }

        let world = &self.worlds[world_index];
        if !world.naws_enabled || !world.connected {
            return false;
        }

        if let Some((width, height)) = self.get_minimum_dimensions() {
            // Check if dimensions changed
            if self.worlds[world_index].naws_sent_size != Some((width, height)) {
                // Send NAWS subnegotiation
                if let Some(ref tx) = self.worlds[world_index].command_tx {
                    let naws_msg = build_naws_subnegotiation(width, height);
                    let _ = tx.try_send(WriteCommand::Raw(naws_msg));
                    self.worlds[world_index].naws_sent_size = Some((width, height));
                    return true;
                }
            }
        }
        false
    }

    /// Send NAWS updates to all connected worlds that have NAWS enabled
    fn send_naws_to_all_worlds(&mut self) {
        let world_count = self.worlds.len();
        for idx in 0..world_count {
            self.send_naws_if_changed(idx);
        }
    }

    fn next_world(&mut self) {
        // Build world info for shared function
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
                first_unseen_at: w.first_unseen_at,
            })
            .collect();

        if let Some(next_idx) = crate::util::calculate_next_world(
            &world_info,
            self.current_world_index,
            self.settings.world_switch_mode,
        ) {
            self.switch_world(next_idx);
        }
    }

    fn prev_world(&mut self) {
        // Build world info for shared function
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
                first_unseen_at: w.first_unseen_at,
            })
            .collect();

        if let Some(prev_idx) = crate::util::calculate_prev_world(
            &world_info,
            self.current_world_index,
            self.settings.world_switch_mode,
        ) {
            self.switch_world(prev_idx);
        }
    }

    fn find_world(&self, name: &str) -> Option<usize> {
        self.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name))
    }

    fn find_or_create_world(&mut self, name: &str) -> usize {
        if let Some(idx) = self.find_world(name) {
            idx
        } else {
            self.worlds.push(World::new(name));
            self.worlds.len() - 1
        }
    }

    /// Calculate the next world index from a given starting point (without switching)
    fn calculate_next_world_from(&self, from_index: usize) -> Option<usize> {
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
                first_unseen_at: w.first_unseen_at,
            })
            .collect();
        crate::util::calculate_next_world(&world_info, from_index, self.settings.world_switch_mode)
    }

    /// Calculate the previous world index from a given starting point (without switching)
    fn calculate_prev_world_from(&self, from_index: usize) -> Option<usize> {
        let world_info: Vec<crate::util::WorldSwitchInfo> = self.worlds.iter()
            .map(|w| crate::util::WorldSwitchInfo {
                name: w.name.clone(),
                connected: w.connected,
                unseen_lines: w.unseen_lines,
                pending_lines: w.pending_lines.len(),
                first_unseen_at: w.first_unseen_at,
            })
            .collect();
        crate::util::calculate_prev_world(&world_info, from_index, self.settings.world_switch_mode)
    }

    pub fn activity_count(&self) -> usize {
        self.worlds
            .iter()
            .enumerate()
            .filter(|(i, w)| *i != self.current_world_index && w.has_activity())
            .count()
    }

    /// Broadcast current activity count to all WebSocket clients
    pub(crate) fn broadcast_activity(&self) {
        self.ws_broadcast(WsMessage::ActivityUpdate {
            count: self.activity_count(),
        });
    }

    /// Discard the initial "fake" world if it exists and is not connected.
    /// Called after first successful connection to a real world.
    fn discard_initial_world(&mut self) {
        // Find index of initial world that's not connected
        if let Some(idx) = self.worlds.iter().position(|w| w.is_initial_world && !w.connected) {
            // Don't discard if it's the only world or if it's the current world
            if self.worlds.len() > 1 && idx != self.current_world_index {
                self.worlds.remove(idx);
                // Adjust current_world_index if needed
                if self.current_world_index > idx {
                    self.current_world_index -= 1;
                }
                // Adjust previous_world_index if needed
                if let Some(prev) = self.previous_world_index {
                    if prev >= self.worlds.len() {
                        self.previous_world_index = Some(self.worlds.len().saturating_sub(1));
                    } else if prev > idx {
                        self.previous_world_index = Some(prev - 1);
                    }
                }
            }
        }
    }

    fn add_output(&mut self, text: &str) {
        let is_current = true;
        let settings = self.settings.clone();
        let output_height = self.output_height;
        let output_width = self.output_width;
        let world_idx = self.current_world_index;
        // Ensure client-generated messages are complete lines (end with newline)
        let text_with_newline = if text.ends_with('\n') || text.is_empty() {
            text.to_string()
        } else {
            format!("{}\n", text)
        };
        self.current_world_mut()
            .add_output(&text_with_newline, is_current, &settings, output_height, output_width, false, false);

        // Broadcast to WebSocket clients viewing this world
        self.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
            world_index: world_idx,
            data: text_with_newline,
            is_viewed: true,
            ts: current_timestamp_secs(),
            from_server: false,  // Client-generated message
        });

        // Mark output for redraw since we added content
        self.needs_output_redraw = true;
    }

    /// Add TF command output (does NOT get % prefix, but is client-generated so Ctrl+L filters it)
    fn add_tf_output(&mut self, text: &str) {
        let is_current = true;
        let settings = self.settings.clone();
        let output_height = self.output_height;
        let output_width = self.output_width;
        let text_with_newline = if text.ends_with('\n') || text.is_empty() {
            text.to_string()
        } else {
            format!("{}\n", text)
        };
        self.current_world_mut()
            .add_output(&text_with_newline, is_current, &settings, output_height, output_width, false, false);
        self.needs_output_redraw = true;
    }

    /// Add output to a specific world by index (for background connection events)
    /// Also broadcasts to WebSocket clients viewing the world
    fn add_output_to_world(&mut self, world_idx: usize, text: &str) {
        if world_idx >= self.worlds.len() {
            return;
        }
        let is_current = world_idx == self.current_world_index || self.ws_client_viewing(world_idx);
        let settings = self.settings.clone();
        let output_height = self.output_height;
        let output_width = self.output_width;
        let text_with_newline = if text.ends_with('\n') || text.is_empty() {
            text.to_string()
        } else {
            format!("{}\n", text)
        };
        self.worlds[world_idx]
            .add_output(&text_with_newline, is_current, &settings, output_height, output_width, false, false);

        // Broadcast to WebSocket clients viewing this world
        self.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
            world_index: world_idx,
            data: text_with_newline,
            is_viewed: is_current,
            ts: current_timestamp_secs(),
            from_server: false,  // Client-generated message
        });

        if world_idx == self.current_world_index {
            self.needs_output_redraw = true;
        }
    }

    /// Handle GMCP Client.Media.* messages (MCMP protocol)
    /// When play_audio is false, only tracks state in active_media without spawning processes
    fn handle_gmcp_media(&mut self, world_idx: usize, package: &str, json_data: &str, play_audio: bool) {
        match package {
            "Client.Media.Default" => {
                // Store default URL for resolving relative media paths
                if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(json_data) {
                    if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                        self.worlds[world_idx].mcmp_default_url = url.to_string();
                    }
                }
            }
            "Client.Media.Play" | "Client.Media.Stop" | "Client.Media.Load" => {
                let action = package.rsplit('.').next().unwrap_or("Play").to_string();
                let default_url = self.worlds[world_idx].mcmp_default_url.clone();
                // Parse JSON unconditionally - we always track state in active_media
                if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(json_data) {
                    let name = parsed.get("name").and_then(|v| v.as_str()).unwrap_or("");
                    let url = parsed.get("url").and_then(|v| v.as_str()).unwrap_or("");
                    let media_type = parsed.get("type").and_then(|v| v.as_str()).unwrap_or("sound");
                    let key = parsed.get("key").and_then(|v| v.as_str()).unwrap_or(name);
                    let volume = parsed.get("volume").and_then(|v| v.as_i64()).unwrap_or(50);
                    let loops = parsed.get("loops").and_then(|v| v.as_i64()).unwrap_or(1);
                    let cont = parsed.get("continue").and_then(|v| v.as_bool()).unwrap_or(false);

                    match action.as_str() {
                        "Play" => {
                            // Resolve full URL
                            let full_url = if !url.is_empty() {
                                format!("{}{}", url, name)
                            } else if !default_url.is_empty() {
                                format!("{}{}", default_url, name)
                            } else if !name.is_empty() {
                                name.to_string()
                            } else {
                                return;
                            };

                            // Always track looping media for restart on world switch/F9 toggle
                            if loops == -1 || loops > 1 {
                                self.worlds[world_idx].active_media.insert(key.to_string(), json_data.to_string());
                            }

                            // Only spawn audio processes when play_audio is true and a player is available
                            #[allow(clippy::collapsible_if)]
                            if play_audio {
                                if let Some(ref player_cmd) = self.media_player_cmd {
                                    // For music type: stop previous music (unless continue)
                                    if media_type == "music" {
                                        if cont {
                                            if self.media_music_key.as_ref().map(|(_, k)| k.as_str()) == Some(key) {
                                                return;
                                            }
                                        }
                                        if let Some((_, prev_key)) = self.media_music_key.take() {
                                            if let Some((_, mut child)) = self.media_processes.remove(&prev_key) {
                                                let _ = child.kill();
                                            }
                                        }
                                    }

                                    let _ = std::fs::create_dir_all(&self.media_cache_dir);
                                    let safe_name = full_url.replace(|c: char| !c.is_alphanumeric() && c != '.', "_");
                                    let cache_path = self.media_cache_dir.join(&safe_name);
                                    let player = player_cmd.clone();
                                    let key_owned = key.to_string();
                                    let cache_path_str = cache_path.to_string_lossy().to_string();
                                    let vol = volume;
                                    let loop_count = loops;
                                    let is_music = media_type == "music";
                                    let event_tx = self.event_tx.clone();

                                    std::thread::spawn(move || {
                                        if !cache_path.exists() {
                                            let output = std::process::Command::new("curl")
                                                .args(["-sL", "-o", &cache_path_str, &full_url])
                                                .output();
                                            if output.is_err() || !cache_path.exists() {
                                                return;
                                            }
                                        }
                                        let mut cmd = std::process::Command::new(&player);
                                        match player.as_str() {
                                            "mpv" => {
                                                cmd.args(["--no-video", "--no-terminal"]);
                                                cmd.arg(format!("--volume={}", vol));
                                                if loop_count == -1 {
                                                    cmd.arg("--loop=inf");
                                                } else if loop_count > 1 {
                                                    cmd.arg(format!("--loop={}", loop_count));
                                                }
                                            }
                                            "ffplay" => {
                                                cmd.args(["-nodisp", "-autoexit"]);
                                                cmd.arg("-volume").arg(format!("{}", vol));
                                                if loop_count == -1 || loop_count > 1 {
                                                    cmd.arg("-loop").arg(
                                                        if loop_count == -1 { "0".to_string() }
                                                        else { loop_count.to_string() }
                                                    );
                                                }
                                            }
                                            _ => {}
                                        }
                                        cmd.arg(&cache_path_str);
                                        cmd.stdout(std::process::Stdio::null());
                                        cmd.stderr(std::process::Stdio::null());
                                        if let Ok(child) = cmd.spawn() {
                                            if let Some(tx) = event_tx {
                                                let _ = tx.blocking_send(AppEvent::MediaProcessReady(
                                                    world_idx, key_owned, child, is_music,
                                                ));
                                            }
                                        }
                                    });
                                }
                            }
                        }
                        "Stop" => {
                            // Always update tracking state and kill processes
                            if !key.is_empty() {
                                if let Some((_, mut child)) = self.media_processes.remove(key) {
                                    let _ = child.kill();
                                }
                                self.worlds[world_idx].active_media.remove(key);
                                if self.media_music_key.as_ref().map(|(_, k)| k.as_str()) == Some(key) {
                                    self.media_music_key = None;
                                }
                            } else if media_type == "music" {
                                if let Some((_, mk)) = self.media_music_key.take() {
                                    self.worlds[world_idx].active_media.remove(&mk);
                                    if let Some((_, mut child)) = self.media_processes.remove(&mk) {
                                        let _ = child.kill();
                                    }
                                }
                            }
                        }
                        "Load" => {
                            // Pre-cache only, no playback
                            let full_url = if !url.is_empty() {
                                format!("{}{}", url, name)
                            } else if !default_url.is_empty() {
                                format!("{}{}", default_url, name)
                            } else {
                                return;
                            };
                            let _ = std::fs::create_dir_all(&self.media_cache_dir);
                            let safe_name = full_url.replace(|c: char| !c.is_alphanumeric() && c != '.', "_");
                            let cache_path_str = self.media_cache_dir.join(&safe_name).to_string_lossy().to_string();
                            std::thread::spawn(move || {
                                let _ = std::process::Command::new("curl")
                                    .args(["-sL", "-o", &cache_path_str, &full_url])
                                    .stdout(std::process::Stdio::null())
                                    .stderr(std::process::Stdio::null())
                                    .status();
                            });
                        }
                        _ => {}
                    }
                }
            }
            _ => {} // Other GMCP packages handled by hook system
        }
    }

    /// Stop all media processes for a specific world
    fn stop_world_media(&mut self, world_idx: usize) {
        // Kill media processes belonging to this world
        let keys_to_remove: Vec<String> = self.media_processes.iter()
            .filter(|(_, (idx, _))| *idx == world_idx)
            .map(|(k, _)| k.clone())
            .collect();
        for key in keys_to_remove {
            if let Some((_, mut child)) = self.media_processes.remove(&key) {
                let _ = child.kill();
            }
        }
        // Clear music key if it belongs to this world
        if let Some((idx, _)) = &self.media_music_key {
            if *idx == world_idx {
                self.media_music_key = None;
            }
        }
    }

    /// Restart active media for a world (called when switching back to it)
    fn restart_world_media(&mut self, world_idx: usize) {
        if !self.worlds[world_idx].gmcp_user_enabled {
            return;
        }
        let default_url = self.worlds[world_idx].mcmp_default_url.clone();
        let plays: Vec<(String, String)> = self.worlds[world_idx].active_media.iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect();
        for (_key, json_data) in plays {
            // Restart console media (ffplay/mpv) - play_audio=true since restart implies enabled
            self.handle_gmcp_media(world_idx, "Client.Media.Play", &json_data, true);
            // Broadcast to web/GUI clients
            self.ws_broadcast_to_world(world_idx, WsMessage::McmpMedia {
                world_index: world_idx,
                action: "Play".to_string(),
                data: json_data,
                default_url: default_url.clone(),
            });
        }
    }

    /// Broadcast a message to all authenticated WebSocket clients and the embedded GUI (if any)
    pub(crate) fn ws_broadcast(&self, msg: WsMessage) {
        #[cfg(test)]
        {
            if let Ok(mut log) = self.ws_broadcast_log.lock() {
                log.push(msg.clone());
            }
        }
        // Send to embedded GUI channel (master GUI mode)
        if let Some(ref tx) = self.gui_tx {
            let _ = tx.send(msg.clone());
        }
        // Broadcast to WebSocket server
        if let Some(ref server) = self.ws_server {
            // Use synchronous try_read to avoid spawning a task
            if let Ok(clients_guard) = server.clients.try_read() {
                let mut sent_count = 0;
                for client in clients_guard.values() {
                    if client.authenticated {
                        let _ = client.tx.send(msg.clone());
                        sent_count += 1;
                    }
                }
                // Log if we didn't send to anyone (for debugging)
                if sent_count == 0 && !clients_guard.is_empty() {
                    // Clients connected but none authenticated
                    use std::io::Write;
                    if let Ok(mut f) = std::fs::OpenOptions::new()
                        .create(true).append(true)
                        .open("clay.output.debug")
                    {
                        let _ = writeln!(f, "ws_broadcast: {} clients connected, 0 authenticated", clients_guard.len());
                    }
                }
            } else {
                // Lock contention - fall back to async broadcast
                let clients = server.clients.clone();
                tokio::spawn(async move {
                    let clients_guard = clients.read().await;
                    for client in clients_guard.values() {
                        if client.authenticated {
                            let _ = client.tx.send(msg.clone());
                        }
                    }
                });
            }
        }
    }

    /// Send a message to a specific WebSocket client (or embedded GUI if client_id == 0)
    fn ws_send_to_client(&self, client_id: u64, msg: WsMessage) {
        // client_id 0 is the embedded GUI in master GUI mode
        if client_id == 0 {
            if let Some(ref tx) = self.gui_tx {
                let _ = tx.send(msg);
            }
            return;
        }
        if let Some(ref server) = self.ws_server {
            let clients = server.clients.clone();
            tokio::spawn(async move {
                let clients_guard = clients.read().await;
                if let Some(client) = clients_guard.get(&client_id) {
                    let _ = client.tx.send(msg);
                }
            });
        }
    }

    /// Send active media for a world to a specific client (for world switch restart)
    fn ws_send_active_media_to_client(&self, client_id: u64, world_idx: usize) {
        if world_idx >= self.worlds.len() || !self.worlds[world_idx].gmcp_user_enabled {
            return;
        }
        let default_url = self.worlds[world_idx].mcmp_default_url.clone();
        for json_data in self.worlds[world_idx].active_media.values() {
            self.ws_send_to_client(client_id, WsMessage::McmpMedia {
                world_index: world_idx,
                action: "Play".to_string(),
                data: json_data.clone(),
                default_url: default_url.clone(),
            });
        }
    }

    /// Mark a client as having received its InitialState
    /// After this, the client will receive broadcasts (prevents duplicate messages)
    fn ws_mark_initial_state_sent(&self, client_id: u64) {
        // client_id 0 is the embedded GUI - doesn't need this tracking
        if client_id == 0 {
            return;
        }
        if let Some(ref server) = self.ws_server {
            server.mark_initial_state_sent(client_id);
        }
    }

    /// Set the client type for a connected WebSocket client
    fn ws_set_client_type(&self, client_id: u64, client_type: websocket::RemoteClientType) {
        if client_id == 0 {
            return;  // Embedded GUI doesn't need this
        }
        if let Some(ref server) = self.ws_server {
            server.set_client_type(client_id, client_type);
        }
    }

    /// Set the current world being viewed by a WebSocket client
    fn ws_set_client_world(&self, client_id: u64, world_index: Option<usize>) {
        if client_id == 0 {
            return;  // Embedded GUI tracks its own world
        }
        if let Some(ref server) = self.ws_server {
            server.set_client_world(client_id, world_index);
        }
    }

    /// Set the authenticated status for a WebSocket client
    fn ws_set_client_authenticated(&self, client_id: u64, authenticated: bool) {
        if let Some(ref server) = self.ws_server {
            server.set_client_authenticated(client_id, authenticated);
        }
    }

    /// Get the client type for a connected WebSocket client
    fn ws_get_client_type(&self, client_id: u64) -> Option<websocket::RemoteClientType> {
        if client_id == 0 {
            return Some(websocket::RemoteClientType::RemoteGUI);  // Embedded GUI
        }
        if let Some(ref server) = self.ws_server {
            server.get_client_type(client_id)
        } else {
            None
        }
    }

    /// Broadcast a message only to clients viewing a specific world
    fn ws_broadcast_to_world(&self, world_index: usize, msg: WsMessage) {
        #[cfg(test)]
        {
            if let Ok(mut log) = self.ws_broadcast_log.lock() {
                log.push(msg.clone());
            }
        }
        // Send to embedded GUI if it's viewing this world
        if let Some(ref tx) = self.gui_tx {
            // For embedded GUI, always send (it tracks its own current world)
            let _ = tx.send(msg.clone());
        }
        // Broadcast to WebSocket clients viewing this world
        if let Some(ref server) = self.ws_server {
            server.broadcast_to_world_viewers(world_index, msg);
        }
    }

    /// Check if any WS client is currently viewing a specific world
    fn ws_client_viewing(&self, world_index: usize) -> bool {
        self.ws_client_worlds.values().any(|v| v.world_index == world_index)
    }

    /// Get the minimum visible lines among all viewers of a world (for more-mode threshold)
    /// Returns None if no WS clients are viewing the world (use console output_height)
    fn min_viewer_lines(&self, world_index: usize) -> Option<usize> {
        let ws_min = self.ws_client_worlds
            .values()
            .filter(|v| v.world_index == world_index && v.visible_lines > 0)
            .map(|v| v.visible_lines)
            .min();
        ws_min
    }

    /// Process incoming server data - shared logic for both console and daemon modes
    /// Returns commands that need to be executed (for trigger processing)
    pub fn process_server_data(
        &mut self,
        world_idx: usize,
        bytes: &[u8],
        console_height: u16,
        console_width: u16,
        is_daemon_mode: bool,
    ) -> Vec<String> {
        self.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());

        // Consider "current" if console OR any web/GUI client is viewing this world
        let is_current = world_idx == self.current_world_index || self.ws_client_viewing(world_idx);
        let decoded_data = self.worlds[world_idx].settings.encoding.decode(bytes);

        // Extract ANSI music sequences FIRST, before any other processing
        let (data, music_sequences) = if self.settings.ansi_music_enabled {
            ansi_music::extract_music(&decoded_data)
        } else {
            (decoded_data, Vec::new())
        };

        // Broadcast music to WebSocket clients (web/GUI play audio)
        for notes in &music_sequences {
            self.ws_broadcast(WsMessage::AnsiMusic {
                world_index: world_idx,
                notes: notes.clone(),
            });
        }

        // Console ANSI music playback via system player
        if !music_sequences.is_empty() {
            if let Some(ref player_cmd) = self.media_player_cmd {
                for notes in &music_sequences {
                    let wav_data = generate_wav_from_notes(notes);
                    let _ = std::fs::create_dir_all(&self.media_cache_dir);
                    let wav_path = self.media_cache_dir.join("ansi_music.wav");
                    if std::fs::write(&wav_path, &wav_data).is_ok() {
                        let wav_path_str = wav_path.to_string_lossy().to_string();
                        let player = player_cmd.clone();
                        std::thread::spawn(move || {
                            let mut cmd = std::process::Command::new(&player);
                            match player.as_str() {
                                "mpv" => { cmd.args(["--no-video", "--no-terminal", &wav_path_str]); }
                                "ffplay" => { cmd.args(["-nodisp", "-autoexit", &wav_path_str]); }
                                _ => { cmd.arg(&wav_path_str); }
                            }
                            cmd.stdout(std::process::Stdio::null());
                            cmd.stderr(std::process::Stdio::null());
                            let _ = cmd.status();
                        });
                    }
                }
            }
        }

        let world_name_for_triggers = self.worlds[world_idx].name.clone();
        let actions = self.settings.actions.clone();

        // Combine with any partial line from previous data chunk
        let had_trigger_partial = !self.worlds[world_idx].trigger_partial_line.is_empty();
        let combined_data = if had_trigger_partial {
            let mut s = std::mem::take(&mut self.worlds[world_idx].trigger_partial_line);
            s.push_str(&data);
            s
        } else {
            data.clone()
        };

        // Process action triggers on complete lines
        // Track lines with gagged flag and highlight color: (line, is_gagged, highlight_color)
        let mut processed_lines: Vec<(&str, bool, Option<String>)> = Vec::new();
        let mut commands_to_execute: Vec<String> = Vec::new();
        let mut tf_commands_to_execute: Vec<String> = Vec::new();
        let mut tf_messages: Vec<String> = Vec::new();
        let ends_with_newline = combined_data.ends_with('\n');
        let lines: Vec<&str> = combined_data.lines().collect();
        let line_count = lines.len();
        let mut has_partial = false;
        // Use persistent flag to track idler filtering across TCP packets
        let mut just_filtered_idler = self.worlds[world_idx].just_filtered_idler;

        for (i, line) in lines.iter().enumerate() {
            let is_last = i == line_count - 1;
            let is_partial = is_last && !ends_with_newline;

            // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
            let uses_idler_keepalive = matches!(
                self.worlds[world_idx].settings.keep_alive_type,
                KeepAliveType::Custom | KeepAliveType::Generic
            );
            if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                just_filtered_idler = true;
                continue;
            }

            // Filter blank lines that immediately follow an idler message
            if just_filtered_idler && is_visually_empty(line) {
                just_filtered_idler = false; // Reset after filtering the blank
                continue;
            }
            just_filtered_idler = false;

            // Check triggers on complete lines only
            if is_partial {
                // Store partial line for next chunk - don't process yet
                self.worlds[world_idx].trigger_partial_line = line.to_string();
                has_partial = true;
            } else {
                let mut is_gagged = false;
                let mut highlight_color: Option<String> = None;
                // Check Clay action triggers
                if let Some(result) = check_action_triggers(line, &world_name_for_triggers, &actions) {
                    // Collect commands to execute
                    commands_to_execute.extend(result.commands);
                    is_gagged = result.should_gag;
                    highlight_color = result.highlight_color;
                }
                // Check TF triggers
                let tf_result = tf::bridge::process_line(&mut self.tf_engine, line, Some(&world_name_for_triggers));
                commands_to_execute.extend(tf_result.send_commands);
                tf_commands_to_execute.extend(tf_result.clay_commands);
                tf_messages.extend(tf_result.messages);
                is_gagged = is_gagged || tf_result.should_gag;
                // Handle substitution: gag original, output substitute
                if let Some((sub_text, sub_attrs)) = tf_result.substitution {
                    is_gagged = true;  // Gag the original line
                    // Add the substituted text as a message with attributes
                    let sub_with_attrs = if sub_attrs.contains('C') || sub_attrs.contains('B') {
                        // Apply attributes - Cred means bold red, etc.
                        apply_tf_attrs(&sub_text, &sub_attrs)
                    } else {
                        sub_text
                    };
                    tf_messages.push(sub_with_attrs);
                }
                // Only add complete lines with gagged flag and highlight color
                processed_lines.push((line, is_gagged, highlight_color));
            }
        }

        // Save the idler filter state for next packet
        self.worlds[world_idx].just_filtered_idler = just_filtered_idler;

        // If we have a partial line and world uses WONT ECHO prompts, start timeout
        if has_partial && self.worlds[world_idx].prompt.is_empty()
            && self.worlds[world_idx].uses_wont_echo_prompt {
            self.worlds[world_idx].wont_echo_time = Some(std::time::Instant::now());
        }

        // Separate gagged and non-gagged lines, tracking highlight colors
        let non_gagged_lines: Vec<(&str, Option<String>)> = processed_lines.iter()
            .filter(|(_, gagged, _)| !gagged)
            .map(|(line, _, highlight)| (*line, highlight.clone()))
            .collect();
        let gagged_lines: Vec<(&str, Option<String>)> = processed_lines.iter()
            .filter(|(_, gagged, _)| *gagged)
            .map(|(line, _, highlight)| (*line, highlight.clone()))
            .collect();
        // Create a map of line content to highlight color for non-gagged lines
        let highlight_map: std::collections::HashMap<String, Option<String>> = non_gagged_lines.iter()
            .filter(|(_, hl)| hl.is_some())
            .map(|(line, hl)| (line.to_string(), hl.clone()))
            .collect();

        // Rebuild data for non-gagged lines
        // Add trailing newline if original ended with newline OR if we have a partial
        // (because a partial means there was a newline before it that we need to preserve)
        let filtered_data = if non_gagged_lines.is_empty() {
            String::new()
        } else {
            let lines_only: Vec<&str> = non_gagged_lines.iter().map(|(line, _)| *line).collect();
            let mut result = lines_only.join("\n");
            if ends_with_newline || has_partial {
                result.push('\n');
            }
            result
        };

        // Add non-gagged output to world
        if !filtered_data.is_empty() {
            let settings = self.settings.clone();

            // Calculate minimum visible lines among all viewers for synchronized more-mode
            // Console counts as a viewer if it's viewing this world (unless daemon mode)
            let console_viewing = !is_daemon_mode && world_idx == self.current_world_index;
            let ws_min = self.min_viewer_lines(world_idx);
            let output_height = match (console_viewing, ws_min) {
                (true, Some(ws)) => console_height.min(ws as u16),
                (true, None) => console_height,
                (false, Some(ws)) => ws as u16,
                (false, None) => {
                    // Daemon mode with no viewers - use minimum across all clients
                    self.ws_client_worlds.values()
                        .map(|s| s.visible_lines)
                        .min()
                        .unwrap_or(24) as u16
                }
            };

            // Track pending count before add_output for synchronized more-mode
            let pending_before = self.worlds[world_idx].pending_lines.len();
            let output_before = self.worlds[world_idx].output_lines.len();
            let was_showing_splash = self.worlds[world_idx].showing_splash;

            self.worlds[world_idx].add_output(&filtered_data, is_current, &settings, output_height, console_width, true, true);

            // Check if splash was cleared (output_lines was reset)
            let splash_was_cleared = was_showing_splash && !self.worlds[world_idx].showing_splash;

            // Calculate what went where
            let pending_after = self.worlds[world_idx].pending_lines.len();
            let output_after = self.worlds[world_idx].output_lines.len();

            // If splash was cleared, output_lines was reset, so we need to broadcast ALL output lines
            // (not just the difference from before)
            let (lines_to_output, skip_count) = if splash_was_cleared {
                // Broadcast all output lines since buffer was cleared
                (output_after, 0)
            } else {
                // Normal case: broadcast only newly added lines
                (output_after.saturating_sub(output_before), output_before)
            };
            let lines_to_pending = pending_after.saturating_sub(pending_before);

            // Apply highlight colors to newly added lines
            if !highlight_map.is_empty() {
                // Apply to output_lines
                for line in self.worlds[world_idx].output_lines.iter_mut().skip(output_before) {
                    let plain_text = strip_ansi_codes(&line.text);
                    if let Some(hl) = highlight_map.get(&plain_text) {
                        line.highlight_color = hl.clone();
                    }
                }
                // Apply to pending_lines
                for line in self.worlds[world_idx].pending_lines.iter_mut().skip(pending_before) {
                    let plain_text = strip_ansi_codes(&line.text);
                    if let Some(hl) = highlight_map.get(&plain_text) {
                        line.highlight_color = hl.clone();
                    }
                }
            }

            // Mark output for redraw if this is the current world
            if world_idx == self.current_world_index {
                self.needs_output_redraw = true;
            }

            // If splash was cleared, tell clients to flush their buffers first
            if splash_was_cleared {
                self.ws_broadcast(WsMessage::WorldFlushed { world_index: world_idx });
            }

            // For synchronized more-mode: only broadcast lines that went to output_lines
            // Lines that went to pending_lines will be broadcast when released
            // Only send to clients viewing this world (Phase 2 output routing)
            if lines_to_output > 0 {
                // Get only the lines that went to output_lines
                let output_lines_to_broadcast: Vec<String> = self.worlds[world_idx]
                    .output_lines
                    .iter()
                    .skip(skip_count)
                    .take(lines_to_output)
                    .map(|line| line.text.replace('\r', ""))
                    .collect();
                let ws_data = output_lines_to_broadcast.join("\n") + "\n";

                // Route output only to clients viewing this world
                self.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                    world_index: world_idx,
                    data: ws_data,
                    is_viewed: true,  // Clients viewing this world consider it "viewed"
                    ts: current_timestamp_secs(),
                    from_server: true,
                });
            }

            // Broadcast pending count update if it changed (for synchronized more-mode indicator)
            // Use filtered broadcast to skip clients that received pending in InitialState
            if lines_to_pending > 0 || pending_after != pending_before {
                self.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: pending_after });
            }

            // Broadcast updated unseen count so all clients stay in sync
            let unseen_count = self.worlds[world_idx].unseen_lines;
            if unseen_count > 0 {
                self.ws_broadcast(WsMessage::UnseenUpdate {
                    world_index: world_idx,
                    count: unseen_count,
                });
            }

            // Broadcast activity count to keep all clients in sync
            self.broadcast_activity();
        }

        // Add gagged lines to output (they'll only show with F2)
        for (line, highlight) in gagged_lines {
            let seq = self.worlds[world_idx].next_seq;
            self.worlds[world_idx].next_seq += 1;
            let mut output_line = OutputLine::new_gagged(line.to_string(), seq);
            output_line.highlight_color = highlight;
            self.worlds[world_idx].output_lines.push(output_line);
        }
        // Keep scroll at bottom if we added gagged lines
        if !self.worlds[world_idx].paused {
            self.worlds[world_idx].scroll_to_bottom();
        }

        // Display TF trigger messages (from #echo commands)
        for msg in tf_messages {
            self.add_tf_output(&msg);
        }

        // Merge TF commands into commands_to_execute
        commands_to_execute.extend(tf_commands_to_execute);
        commands_to_execute
    }

    /// Build initial state message for a newly authenticated client.
    /// Only sends output_lines (not pending_lines) - clients see the More indicator
    /// and release pending via PgDn/Tab, avoiding duplicate line bugs.
    fn build_initial_state(&self) -> WsMessage {
        // Cap output lines to prevent massive InitialState messages that exceed WebSocket limits.
        // 5000 lines per world keeps the message well under the 16MB frame size.
        const MAX_INITIAL_LINES: usize = 5000;

        let worlds: Vec<WorldStateMsg> = self.worlds.iter().enumerate().map(|(idx, world)| {
            // Create timestamped versions (add sparkle prefix for client-generated messages)
            // Only include output_lines - pending_lines stay on the server and are
            // released via PgDn/Tab, then broadcast to clients normally.
            let total_lines = world.output_lines.len();
            let skip = total_lines.saturating_sub(MAX_INITIAL_LINES);
            let output_lines_ts: Vec<TimestampedLine> = world.output_lines.iter()
                .skip(skip)
                .map(|s| {
                    let text = s.text.replace('\r', "");
                    let text = if !s.from_server {
                        format!("âœ¨ {}", text)
                    } else {
                        text
                    };
                    TimestampedLine {
                        text,
                        ts: s.timestamp.duration_since(UNIX_EPOCH).unwrap_or_default().as_secs(),
                        gagged: s.gagged,
                        from_server: s.from_server,
                        seq: s.seq,
                        highlight_color: s.highlight_color.clone(),
                    }
                })
                .collect();
            let output_len = output_lines_ts.len();
            let pending_lines_ts: Vec<TimestampedLine> = Vec::new();
            WorldStateMsg {
                index: idx,
                name: world.name.clone(),
                connected: world.connected,
                // Legacy output_lines left empty - all clients prefer output_lines_ts
                output_lines: Vec::new(),
                pending_lines: Vec::new(),
                output_lines_ts,
                pending_lines_ts,
                prompt: world.prompt.replace('\r', ""),
                // Set scroll_offset to end of output lines so client starts at bottom
                scroll_offset: output_len.saturating_sub(1),
                // Report server's paused state so client shows More indicator
                paused: world.paused,
                unseen_lines: world.unseen_lines,
                settings: WorldSettingsMsg {
                    hostname: world.settings.hostname.clone(),
                    port: world.settings.port.clone(),
                    user: world.settings.user.clone(),
                    password: world.settings.password.clone(),
                    use_ssl: world.settings.use_ssl,
                    log_enabled: world.settings.log_enabled,
                    encoding: world.settings.encoding.name().to_string(),
                    auto_connect_type: world.settings.auto_connect_type.name().to_string(),
                    keep_alive_type: world.settings.keep_alive_type.name().to_string(),
                    keep_alive_cmd: world.settings.keep_alive_cmd.clone(),
                    gmcp_packages: world.settings.gmcp_packages.clone(),
                },
                last_send_secs: world.last_send_time.map(|t| t.elapsed().as_secs()),
                last_recv_secs: world.last_receive_time.map(|t| t.elapsed().as_secs()),
                last_nop_secs: world.last_nop_time.map(|t| t.elapsed().as_secs()),
                keep_alive_type: world.settings.keep_alive_type.name().to_string(),
                showing_splash: world.showing_splash,
                was_connected: world.was_connected,
                is_proxy: world.proxy_pid.is_some(),
                gmcp_user_enabled: world.gmcp_user_enabled,
            }
        }).collect();

        let settings = GlobalSettingsMsg {
            more_mode_enabled: self.settings.more_mode_enabled,
            spell_check_enabled: self.settings.spell_check_enabled,
            temp_convert_enabled: self.settings.temp_convert_enabled,
            world_switch_mode: self.settings.world_switch_mode.name().to_string(),
            debug_enabled: self.settings.debug_enabled,
            show_tags: self.show_tags,
            ansi_music_enabled: self.settings.ansi_music_enabled,
            console_theme: self.settings.theme.name().to_string(),
            gui_theme: self.settings.gui_theme.name().to_string(),
            gui_transparency: self.settings.gui_transparency,
            color_offset_percent: self.settings.color_offset_percent,
            input_height: self.input_height,
            font_name: self.settings.font_name.clone(),
            font_size: self.settings.font_size,
            web_font_size_phone: self.settings.web_font_size_phone,
            web_font_size_tablet: self.settings.web_font_size_tablet,
            web_font_size_desktop: self.settings.web_font_size_desktop,
            ws_allow_list: self.settings.websocket_allow_list.clone(),
            web_secure: self.settings.web_secure,
            http_enabled: self.settings.http_enabled,
            http_port: self.settings.http_port,
            ws_enabled: self.settings.ws_enabled,
            ws_port: self.settings.ws_port,
            ws_cert_file: self.settings.websocket_cert_file.clone(),
            ws_key_file: self.settings.websocket_key_file.clone(),
            tls_proxy_enabled: self.settings.tls_proxy_enabled,
            dictionary_path: self.settings.dictionary_path.clone(),
            theme_colors_json: self.gui_theme_colors().to_json(),
        };

        WsMessage::InitialState {
            worlds,
            settings,
            current_world_index: self.current_world_index,
            actions: self.settings.actions.clone(),
            splash_lines: generate_splash_strings(),
        }
    }

    fn increase_input_height(&mut self) {
        if self.input_height < 15 {
            self.input_height += 1;
            self.input.visible_height = self.input_height;
        }
    }

    fn decrease_input_height(&mut self) {
        if self.input_height > 1 {
            self.input_height -= 1;
            self.input.visible_height = self.input_height;
            self.input.adjust_viewport();
        }
    }

    fn handle_spell_check(&mut self) {
        if !self.spell_state.showing_suggestions {
            if let Some((start, end, word)) = self.input.current_word() {
                if !self.spell_checker.is_valid(&word) {
                    let mut suggestions = self.spell_checker.suggestions(&word, 6);
                    if !suggestions.is_empty() {
                        // Store original word and add it to the end for cycling
                        self.spell_state.original_word = word.clone();
                        suggestions.push(word);  // Add original word at the end

                        // Output suggestions to the output area (excluding the original word)
                        let display_suggestions: Vec<_> = suggestions[..suggestions.len()-1].to_vec();
                        self.add_output(&format!(
                            "Suggestions for '{}': {}",
                            self.spell_state.original_word,
                            display_suggestions.join(", ")
                        ));

                        self.spell_state.suggestions = suggestions;
                        self.spell_state.suggestion_index = 0;
                        self.spell_state.word_start = start;
                        self.spell_state.word_end = end;
                        self.spell_state.showing_suggestions = true;
                        self.suggestion_message = Some(format!(
                            "Press Ctrl+Q to cycle: {}",
                            self.spell_state.suggestions[0]
                        ));
                    }
                    // If no suggestions found or word is correctly spelled, do nothing
                }
                // If word is spelled correctly, do nothing
            }
            // If no word at cursor, do nothing
        } else if !self.spell_state.suggestions.is_empty() {
            // Cycle through suggestions (including original word at the end)
            let replacement = self.spell_state.suggestions[self.spell_state.suggestion_index].clone();
            self.input.replace_word(
                self.spell_state.word_start,
                self.spell_state.word_end,
                &replacement,
            );
            self.spell_state.word_end = self.spell_state.word_start + replacement.chars().count();
            self.spell_state.suggestion_index =
                (self.spell_state.suggestion_index + 1) % self.spell_state.suggestions.len();

            let next_word = &self.spell_state.suggestions[self.spell_state.suggestion_index];
            if next_word == &self.spell_state.original_word {
                self.suggestion_message = Some(format!(
                    "Applied '{}'. Next: '{}' (original)",
                    replacement, next_word
                ));
            } else {
                self.suggestion_message = Some(format!(
                    "Applied '{}'. Next: '{}'",
                    replacement, next_word
                ));
            }
        }
    }

    fn check_word_ended(&mut self) {
        if self.spell_state.showing_suggestions {
            // Convert byte cursor to character position for comparison
            let cursor_char_pos = self.input.buffer[..self.input.cursor_position].chars().count();
            let chars: Vec<char> = self.input.buffer.chars().collect();

            // Allow cursor to be one position past the word if there's a non-word character there
            // This handles "thiss |" where user typed a space after the misspelled word
            let effective_word_end = if self.spell_state.word_end < chars.len()
                && !chars[self.spell_state.word_end].is_alphabetic()
            {
                self.spell_state.word_end + 1
            } else {
                self.spell_state.word_end
            };

            if cursor_char_pos < self.spell_state.word_start || cursor_char_pos > effective_word_end {
                self.spell_state.reset();
                self.suggestion_message = None;
            }
        }
    }

    /// Check for temperature patterns and convert them when followed by a separator.
    /// Patterns: 32F, 32f, 100C, 100c, 32Â°F, 32.5F, -10C, etc.
    /// When detected, inserts conversion in parentheses: "32F " -> "32F (0C) "
    fn check_temp_conversion(&mut self) {
        // Only convert temperatures when enabled
        if !self.settings.temp_convert_enabled {
            return;
        }

        // Don't convert when user is deleting (backspace/delete) - allows undoing conversion
        if self.last_input_was_delete {
            return;
        }

        let chars: Vec<char> = self.input.buffer.chars().collect();
        if chars.is_empty() {
            return;
        }

        // Only check when cursor is at the end (just typed a character)
        let cursor_char_pos = self.input.buffer[..self.input.cursor_position].chars().count();
        if cursor_char_pos != chars.len() {
            return;
        }

        // Check if we just typed a separator after a temperature
        let last_char = chars[chars.len() - 1];
        if !last_char.is_whitespace() && !matches!(last_char, '.' | ',' | '!' | '?' | ';' | ':' | ')' | ']' | '}') {
            return;
        }

        // Look backwards for a temperature pattern before the separator
        // Pattern: optional minus, digits, optional decimal+digits, optional Â°, F or C
        let end = chars.len() - 1; // Position of the separator
        if end == 0 {
            return;
        }

        // Find the F/C unit character
        let unit_pos = end - 1;
        let unit_char = chars[unit_pos].to_ascii_uppercase();
        if unit_char != 'F' && unit_char != 'C' {
            return;
        }

        // Check for optional degree symbol before the unit
        let mut num_end = unit_pos;
        if num_end > 0 && chars[num_end - 1] == 'Â°' {
            num_end -= 1;
        }

        // Find the start of the number (digits, optional decimal, optional leading minus)
        let mut num_start = num_end;
        let mut found_digit = false;
        let mut found_decimal = false;

        while num_start > 0 {
            let c = chars[num_start - 1];
            if c.is_ascii_digit() {
                found_digit = true;
                num_start -= 1;
            } else if c == '.' && !found_decimal {
                found_decimal = true;
                num_start -= 1;
            } else if c == '-' {
                // Allow minus at the very start of the number
                num_start -= 1;
                break;
            } else {
                break;
            }
        }

        // Check we have at least one digit
        if !found_digit {
            return;
        }

        // Make sure the character before the number isn't part of the "word"
        // (e.g., "abc32F" shouldn't trigger, but "test 32F" should)
        if num_start > 0 {
            let prev_char = chars[num_start - 1];
            if prev_char.is_alphanumeric() || prev_char == '_' {
                return;
            }
        }

        // Build the full temperature string (e.g., "21F", "-5.5Â°C")
        let temp_str: String = chars[num_start..=unit_pos].iter().collect();

        // Check if this temperature was already converted and undone - skip if so
        if let Some(ref skip) = self.skip_temp_conversion {
            if skip == &temp_str {
                return;
            }
        }

        // Parse the number
        let num_str: String = chars[num_start..num_end].iter().collect();
        let temp: f64 = match num_str.parse() {
            Ok(t) => t,
            Err(_) => return,
        };

        // Convert temperature
        let (converted, converted_unit) = if unit_char == 'F' {
            // Fahrenheit to Celsius: (F - 32) * 5/9
            ((temp - 32.0) * 5.0 / 9.0, 'C')
        } else {
            // Celsius to Fahrenheit: C * 9/5 + 32
            (temp * 9.0 / 5.0 + 32.0, 'F')
        };

        // Format the conversion - use integer if whole number, else one decimal
        // No space before the parenthesis - the separator the user typed goes after
        let converted_str = if (converted - converted.round()).abs() < 0.05 {
            format!("({:.0}{})", converted, converted_unit)
        } else {
            format!("({:.1}{})", converted, converted_unit)
        };

        // Remember this temperature so we don't re-convert if user undoes it
        self.skip_temp_conversion = Some(temp_str);

        // Insert the conversion before the separator
        // Build new buffer: [before separator] + conversion + [separator]
        let before_sep: String = chars[..end].iter().collect();
        let sep: String = chars[end..].iter().collect();
        self.input.buffer = format!("{}{}{}", before_sep, converted_str, sep);

        // Move cursor to after the conversion and separator
        self.input.cursor_position = self.input.buffer.len();
    }

    fn find_misspelled_words(&mut self) -> Vec<(usize, usize)> {
        let mut misspelled = Vec::new();
        let chars: Vec<char> = self.input.buffer.chars().collect();
        let mut i = 0;

        // Helper to check if a character at position is part of a word
        // (alphabetic, or apostrophe between alphabetic characters)
        let is_word_char = |pos: usize| -> bool {
            if pos >= chars.len() {
                return false;
            }
            let c = chars[pos];
            if c.is_alphabetic() {
                return true;
            }
            // Include apostrophe if between alphabetic characters (contractions)
            if c == '\'' {
                let has_alpha_before = pos > 0 && chars[pos - 1].is_alphabetic();
                let has_alpha_after = pos + 1 < chars.len() && chars[pos + 1].is_alphabetic();
                return has_alpha_before && has_alpha_after;
            }
            false
        };

        // Convert byte cursor to character position
        let cursor_char_pos = self.input.buffer[..self.input.cursor_position].chars().count();
        let cached = &self.cached_misspelled;

        // Helper to check if a word overlaps with any cached misspelled range
        let is_cached_misspelled = |start: usize, end: usize| -> bool {
            cached.iter().any(|(cs, ce)| start < *ce && end > *cs)
        };

        // Helper to check if followed by separator
        let has_separator = |end_pos: usize| -> bool {
            if end_pos >= chars.len() {
                return false;
            }
            let next_char = chars[end_pos];
            next_char.is_whitespace() || matches!(next_char, '.' | ',' | '!' | '?' | ';' | ':' | ')' | ']' | '}' | '"' | '%' | '@' | '#' | '$' | '^' | '&' | '*' | '(' | '[' | '{')
        };

        while i < chars.len() {
            // Skip non-word characters
            while i < chars.len() && !chars[i].is_alphabetic() {
                i += 1;
            }
            if i >= chars.len() {
                break;
            }

            let start = i;
            // Continue while we have word characters (including internal apostrophes)
            while i < chars.len() && is_word_char(i) {
                i += 1;
            }
            let end = i;

            let word: String = chars[start..end].iter().collect();
            // Don't check if cursor is inside the word (actively typing)
            let cursor_in_word = cursor_char_pos >= start && cursor_char_pos < end;

            if cursor_in_word {
                // Cursor inside word - don't flag
                continue;
            }

            let at_end_of_input = end >= chars.len();
            let cursor_at_word_end = cursor_char_pos == end;

            if at_end_of_input && cursor_at_word_end {
                // Word at end of input with cursor right at the end
                // Use cached state - if word overlaps with cached misspelled, keep it flagged
                // This keeps words flagged while typing/backspacing until completed again
                if is_cached_misspelled(start, end) {
                    misspelled.push((start, end));
                }
                // If not in cache, don't flag - user is typing a fresh word
            } else if at_end_of_input {
                // Word at end of input but cursor moved away - check spelling
                if !self.spell_checker.is_valid(&word) {
                    misspelled.push((start, end));
                }
            } else if has_separator(end) {
                // Word followed by separator - check spelling
                if !self.spell_checker.is_valid(&word) {
                    misspelled.push((start, end));
                }
            }
            // else: word not followed by separator and not at end - don't check
        }

        // Update cache with current result
        self.cached_misspelled = misspelled.clone();
        misspelled
    }

    fn scroll_output_up(&mut self) {
        let more_mode = self.settings.more_mode_enabled;
        let target_visual_lines = (self.output_height as usize).saturating_sub(2).max(1);
        let visible_height = (self.output_height as usize).max(1);
        let width = (self.output_width as usize).max(1);
        let world = self.current_world_mut();

        // Calculate the minimum scroll_offset where line 0 is at the top
        // This is where all content from line 0 to scroll_offset fits in visible_height
        let mut min_offset = 0usize;
        let mut visual_lines = 0usize;
        for (idx, line) in world.output_lines.iter().enumerate() {
            visual_lines += visual_line_count(&line.text, width);
            if visual_lines >= visible_height {
                min_offset = idx;
                break;
            }
            min_offset = idx;
        }

        // If already at or past the minimum, don't scroll further
        if world.scroll_offset <= min_offset {
            // Still enable pause mode if more_mode is on
            if more_mode && !world.paused {
                world.paused = true;
            }
            return;
        }

        // Count lines being scrolled off (from scroll_offset going backwards)
        // These are the lines that will disappear from the bottom
        let mut visual_lines_moved = 0;
        let mut new_offset = world.scroll_offset;

        while visual_lines_moved < target_visual_lines {
            visual_lines_moved += visual_line_count(&world.output_lines[new_offset].text, width);
            if new_offset == 0 {
                break;
            }
            new_offset -= 1;
        }

        // Clamp to minimum offset
        world.scroll_offset = new_offset.max(min_offset);
        if more_mode && !world.paused {
            world.paused = true;
        }
        // Mark output for redraw
        self.needs_output_redraw = true;
    }

    fn scroll_output_down(&mut self) {
        let target_visual_lines = (self.output_height as usize).saturating_sub(2).max(1);
        let width = (self.output_width as usize).max(1);
        let world = self.current_world_mut();
        let max_scroll = world.output_lines.len().saturating_sub(1);

        if world.scroll_offset >= max_scroll {
            return; // Already at bottom
        }

        // Count lines being scrolled in (from scroll_offset+1 going forwards)
        // These are the lines that will appear at the bottom
        let mut visual_lines_moved = 0;
        let mut new_offset = world.scroll_offset + 1;

        while new_offset <= max_scroll && visual_lines_moved < target_visual_lines {
            visual_lines_moved += visual_line_count(&world.output_lines[new_offset].text, width);
            new_offset += 1;
        }

        // new_offset is one past the last line counted, so subtract 1
        world.scroll_offset = (new_offset - 1).min(max_scroll);

        // Mark output for redraw
        self.needs_output_redraw = true;
    }

    /// Release one screenful of pending lines and broadcast to WebSocket clients.
    /// Used by both Tab and PgDn when at the bottom and paused.
    pub(crate) fn release_pending_screenful(&mut self) {
        let visual_budget = (self.output_height as usize).saturating_sub(2);
        let output_width = self.output_width as usize;
        let world_idx = self.current_world_index;

        // Pre-calculate how many logical lines fit in the visual budget
        // (mirrors the logic in release_pending so we can collect lines for broadcasting)
        let width = output_width.max(1);
        let mut visual_total = 0;
        let mut logical_count = 0;
        for line in &self.worlds[world_idx].pending_lines {
            let vl = visual_line_count(&line.text, width);
            if visual_total > 0 && visual_total + vl > visual_budget {
                break;
            }
            visual_total += vl;
            logical_count += 1;
            if visual_total >= visual_budget {
                break;
            }
        }
        if logical_count == 0 && !self.worlds[world_idx].pending_lines.is_empty() {
            logical_count = 1;
        }

        // Get the lines that will be released (for broadcasting as ServerData)
        let lines_to_broadcast: Vec<String> = self.worlds[world_idx]
            .pending_lines
            .iter()
            .take(logical_count)
            .map(|line| line.text.replace('\r', ""))
            .collect();

        let pending_before = self.worlds[world_idx].pending_lines.len();
        self.current_world_mut().release_pending(visual_budget, output_width);
        let released = pending_before - self.worlds[world_idx].pending_lines.len();

        // Broadcast the released lines to clients viewing this world
        if !lines_to_broadcast.is_empty() {
            let ws_data = lines_to_broadcast.join("\n") + "\n";
            self.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                world_index: world_idx,
                data: ws_data,
                is_viewed: true,
                ts: current_timestamp_secs(),
                from_server: true,
            });
        }

        // Broadcast release event so other clients sync
        self.ws_broadcast(WsMessage::PendingReleased { world_index: world_idx, count: released });
        let pending = self.worlds[world_idx].pending_lines.len();
        self.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: pending });
        // Broadcast activity count since pending lines changed
        self.broadcast_activity();
        self.needs_output_redraw = true;
    }
}

pub enum AppEvent {
    ServerData(String, Vec<u8>),  // world_name, raw bytes
    Disconnected(String, u64),     // world_name, connection_id
    TelnetDetected(String),       // world_name - telnet negotiation detected
    Prompt(String, Vec<u8>),      // world_name, prompt bytes (from telnet GA)
    WontEchoSeen(String),         // world_name - IAC WONT ECHO detected (for timeout-based prompts)
    NawsRequested(String),        // world_name - server sent DO NAWS (we should send window size)
    TtypeRequested(String),       // world_name - server sent SB TTYPE SEND (we should send terminal type)
    SystemMessage(String),       // message to display in current world's output
    Sigusr1Received,             // SIGUSR1 received - trigger hot reload (not available on Android)
    // Background connection events
    ConnectionSuccess(String, mpsc::Sender<WriteCommand>, Option<i32>, bool),  // world_name, cmd_tx, socket_fd, is_tls
    ConnectionFailed(String, String),  // world_name, error_message
    // WebSocket events
    WsClientConnected(u64),                    // client_id
    WsClientDisconnected(u64),                 // client_id
    WsClientMessage(u64, Box<WsMessage>),      // client_id, message
    WsAuthKeyValidation(u64, Box<WsMessage>, String),   // client_id, AuthRequest with auth_key, client_ip
    WsKeyRequest(u64),                         // client_id - generate and send new auth key
    WsKeyRevoke(u64, String),                  // client_id, auth_key to revoke
    // Multiuser mode events (include username for per-user connection isolation)
    ConnectWorldRequest(usize, String),  // world_index, requesting username
    MultiuserServerData(usize, String, Vec<u8>),  // world_index, username, raw bytes
    MultiuserDisconnected(usize, String),         // world_index, username
    MultiuserTelnetDetected(usize, String),       // world_index, username
    MultiuserPrompt(usize, String, Vec<u8>),      // world_index, username, prompt bytes
    // Slack/Discord events
    SlackMessage(String, String), // world_name, formatted message
    DiscordMessage(String, String), // world_name, formatted message
    // GMCP/MSDP events
    GmcpNegotiated(String),                   // world_name
    MsdpNegotiated(String),                   // world_name
    GmcpReceived(String, String, String),     // world_name, package, json_data
    MsdpReceived(String, String, String),     // world_name, variable, value_json
    // Media process ready from background download/spawn thread
    MediaProcessReady(usize, String, std::process::Child, bool),  // world_idx, key, child, is_music
    // API lookup result (dict/urban/translate) from spawned task
    ApiLookupResult(u64, usize, Result<String, String>),  // client_id, world_index, Ok(input_text) or Err(error)
}

/// Per-user connection state for multiuser mode
/// Each user has their own independent connection to each world
#[derive(Clone)]
pub struct UserConnection {
    pub connected: bool,
    pub command_tx: Option<mpsc::Sender<WriteCommand>>,
    output_lines: Vec<OutputLine>,
    pending_lines: Vec<OutputLine>,
    pub scroll_offset: usize,
    pub unseen_lines: usize,
    pub paused: bool,
    pub lines_since_pause: usize,
    pub telnet_mode: bool,
    pub prompt: String,
    pub prompt_count: usize,
    pub last_send_time: Option<std::time::Instant>,
    pub last_receive_time: Option<std::time::Instant>,
    pub partial_line: String,
    pub partial_in_pending: bool,
}

impl Default for UserConnection {
    fn default() -> Self {
        Self::new()
    }
}

impl UserConnection {
    pub fn new() -> Self {
        Self {
            connected: false,
            command_tx: None,
            output_lines: Vec::new(),
            pending_lines: Vec::new(),
            scroll_offset: 0,
            unseen_lines: 0,
            paused: false,
            lines_since_pause: 0,
            telnet_mode: false,
            prompt: String::new(),
            prompt_count: 0,
            last_send_time: None,
            last_receive_time: None,
            partial_line: String::new(),
            partial_in_pending: false,
        }
    }
}

pub fn get_settings_path() -> PathBuf {
    // Use custom config path if set via --conf=<path>
    if let Some(custom_path) = get_custom_config_path() {
        return custom_path.clone();
    }
    let home = get_home_dir();
    PathBuf::from(home).join(clay_filename("clay.dat"))
}

pub fn get_multiuser_settings_path() -> PathBuf {
    let home = get_home_dir();
    PathBuf::from(home).join(clay_filename("clay.multiuser.dat"))
}

fn get_debug_log_path() -> PathBuf {
    let home = get_home_dir();
    PathBuf::from(home).join("clay.debug.log")
}

/// Write a debug message to clay.debug.log if debug is enabled
fn debug_log(debug_enabled: bool, message: &str) {
    if !debug_enabled {
        return;
    }
    use std::io::Write;
    let path = get_debug_log_path();
    match std::fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(&path)
    {
        Ok(mut file) => {
            let lt = local_time_now();
            let timestamp = format!(
                "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                lt.year, lt.month, lt.day,
                lt.hour, lt.minute, lt.second
            );
            let _ = writeln!(file, "[{}] {}", timestamp, message);
        }
        Err(e) => {
            eprintln!("Failed to open debug log {:?}: {}", path, e);
        }
    }
}

/// Load theme file from ~/clay.theme.dat into app.theme_file
/// If the file doesn't exist, generates a default one and loads defaults
fn load_theme_file(app: &mut App) {
    let home = std::env::var("HOME").unwrap_or_else(|_| ".".to_string());
    let theme_path = std::path::Path::new(&home).join("clay.theme.dat");
    if !theme_path.exists() {
        // Generate default theme file
        let content = theme::ThemeFile::generate_default_file();
        let _ = std::fs::write(&theme_path, content);
    }
    app.theme_file = theme::ThemeFile::load(&theme_path);
}

// Hot reload helper - not available on Android/Termux
#[cfg(all(unix, not(target_os = "android")))]
fn clear_cloexec(fd: RawFd) -> io::Result<()> {
    // Clear the FD_CLOEXEC flag so the fd survives exec
    unsafe {
        let flags = libc::fcntl(fd, libc::F_GETFD);
        if flags == -1 {
            return Err(io::Error::last_os_error());
        }
        let new_flags = flags & !libc::FD_CLOEXEC;
        if libc::fcntl(fd, libc::F_SETFD, new_flags) == -1 {
            return Err(io::Error::last_os_error());
        }
    }
    Ok(())
}

/// Check if a process with the given PID is still alive
#[cfg(all(unix, not(target_os = "android")))]
fn is_process_alive(pid: u32) -> bool {
    // Use waitpid with WNOHANG to check without blocking
    // A return of 0 means the process is still running
    // A return of -1 with ECHILD means the process doesn't exist (not our child)
    // Use kill with signal 0 instead - this works for any process we can signal
    unsafe {
        libc::kill(pid as libc::pid_t, 0) == 0
    }
}

/// Stub for Android/Windows - TLS proxy processes don't exist on these platforms
#[cfg(any(target_os = "android", not(unix)))]
fn is_process_alive(_pid: u32) -> bool {
    false  // Always return false since we never spawn proxy processes on this platform
}

/// Reap any zombie child processes to prevent defunct processes from accumulating.
/// This should be called periodically from the main event loop.
#[cfg(all(unix, not(target_os = "android")))]
pub fn reap_zombie_children() {
    // Call waitpid with -1 (any child) and WNOHANG (don't block) to reap zombies
    // Keep calling until no more zombies are found
    unsafe {
        loop {
            let mut status: libc::c_int = 0;
            let result = libc::waitpid(-1, &mut status, libc::WNOHANG);
            if result <= 0 {
                // No more zombies to reap (0 = no status available, -1 = error/no children)
                break;
            }
            // Successfully reaped a zombie, continue to check for more
        }
    }
}

/// Generate a unique socket path for the TLS proxy.
/// Uses $XDG_RUNTIME_DIR (typically /run/user/<uid> with mode 0700) for security,
/// falling back to /tmp if not available.
#[cfg(all(unix, not(target_os = "android")))]
fn get_proxy_socket_path(world_name: &str) -> PathBuf {
    let sanitized_name = world_name
        .chars()
        .map(|c| if c.is_alphanumeric() || c == '-' || c == '_' { c } else { '_' })
        .collect::<String>();

    // Prefer XDG_RUNTIME_DIR for security (typically /run/user/<uid> with mode 0700)
    let base_dir = std::env::var("XDG_RUNTIME_DIR")
        .ok()
        .map(PathBuf::from)
        .filter(|p| p.exists())
        .unwrap_or_else(|| PathBuf::from("/tmp"));

    base_dir.join(format!(
        "clay-tls-{}-{}.sock",
        std::process::id(),
        sanitized_name
    ))
}

/// Get the config file path for a TLS proxy (derived from socket path)
#[cfg(all(unix, not(target_os = "android")))]
fn get_proxy_config_path(socket_path: &Path) -> PathBuf {
    let mut config_path = socket_path.to_path_buf();
    config_path.set_extension("conf");
    config_path
}

/// Spawn a TLS proxy process for a world connection.
/// Returns (proxy_pid, socket_path) on success.
/// The proxy process handles the TLS connection to the MUD server and exposes
/// a Unix socket for the main client to connect to.
#[cfg(all(unix, not(target_os = "android")))]
fn spawn_tls_proxy(
    world_name: &str,
    host: &str,
    port: &str,
) -> io::Result<(u32, PathBuf)> {
    use std::process::{Command, Stdio};
    use std::io::Write;

    let socket_path = get_proxy_socket_path(world_name);
    let config_path = get_proxy_config_path(&socket_path);

    // Remove any existing socket and config files
    let _ = std::fs::remove_file(&socket_path);
    let _ = std::fs::remove_file(&config_path);

    // Write connection info to config file (keeps host:port out of process list)
    {
        let mut file = std::fs::File::create(&config_path)?;
        writeln!(file, "{}:{}", host, port)?;
        writeln!(file, "{}", socket_path.display())?;
    }

    // Get the current executable path
    let exe_path = std::env::current_exe()?;

    // Spawn the proxy with just the config file path (no host:port visible in ps)
    let proxy_arg = format!("--tls-proxy={}", config_path.display());

    let child = Command::new(&exe_path)
        .arg(&proxy_arg)
        .stdin(Stdio::null())
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()?;

    let child_pid = child.id();

    // Wait up to 10 seconds for the socket to appear
    let start = std::time::Instant::now();
    let timeout = std::time::Duration::from_secs(10);

    while start.elapsed() < timeout {
        if socket_path.exists() {
            // Socket exists, proxy is ready
            return Ok((child_pid, socket_path));
        }

        // Check if child process died
        if !is_process_alive(child_pid) {
            return Err(io::Error::other(
                "TLS proxy process exited unexpectedly",
            ));
        }

        std::thread::sleep(std::time::Duration::from_millis(50));
    }

    // Timeout - kill the child and return error
    unsafe {
        libc::kill(child_pid as libc::pid_t, libc::SIGTERM);
    }
    Err(io::Error::new(
        io::ErrorKind::TimedOut,
        "TLS proxy socket not created in time",
    ))
}

/// Async implementation of the TLS proxy main loop (runs in separate process via --tls-proxy)
#[cfg(all(unix, not(target_os = "android")))]
async fn run_tls_proxy_async(host: &str, port: &str, socket_path: &PathBuf) {
    use tokio::net::UnixListener;

    // Ignore SIGUSR1 - the main clay process uses this for reload, but the proxy
    // should not be affected by reload signals (it stays running across reloads)
    unsafe {
        libc::signal(libc::SIGUSR1, libc::SIG_IGN);
    }

    // Step 1: Connect to the MUD server with TLS
    let tcp_stream = match TcpStream::connect(format!("{}:{}", host, port)).await {
        Ok(s) => s,
        Err(_) => return,
    };

    // Enable TCP keepalive to detect dead connections faster
    enable_tcp_keepalive(&tcp_stream);

    // Establish TLS connection
    #[cfg(feature = "rustls-backend")]
    let tls_stream = {
        use rustls::RootCertStore;
        use tokio_rustls::TlsConnector;
        use rustls::pki_types::ServerName;

        // Create a config that accepts invalid certs (common for MUD servers)
        let mut root_store = RootCertStore::empty();
        root_store.roots = webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| { rustls::pki_types::TrustAnchor { subject: ta.subject.into(), subject_public_key_info: ta.spki.into(), name_constraints: ta.name_constraints.map(|nc| nc.into()), } }).collect();

        let config = rustls::ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
            .with_no_client_auth();

        let connector = TlsConnector::from(Arc::new(config));
        let server_name = match ServerName::try_from(host.to_string()) {
            Ok(sn) => sn,
            Err(_) => return,
        };

        match connector.connect(server_name, tcp_stream).await {
            Ok(s) => s,
            Err(_) => return,
        }
    };

    #[cfg(feature = "native-tls-backend")]
    let tls_stream = {
        let connector = match native_tls::TlsConnector::builder()
            .danger_accept_invalid_certs(true)
            .build()
        {
            Ok(c) => c,
            Err(_) => return,
        };
        let connector = tokio_native_tls::TlsConnector::from(connector);

        match connector.connect(host, tcp_stream).await {
            Ok(s) => s,
            Err(_) => return,
        }
    };

    #[cfg(not(any(feature = "native-tls-backend", feature = "rustls-backend")))]
    {
        // No TLS backend available
        return;
    }

    // Step 2: Create Unix socket listener with restrictive permissions
    // Set umask to 0o077 before binding so socket is created with 0o600 atomically
    // (prevents race condition where socket exists briefly with permissive mode)
    let old_umask = unsafe { libc::umask(0o077) };
    let listener = match UnixListener::bind(socket_path) {
        Ok(l) => {
            unsafe { libc::umask(old_umask) }; // Restore original umask
            l
        }
        Err(_) => {
            unsafe { libc::umask(old_umask) }; // Restore original umask
            return;
        }
    };

    // Get our UID for peer credential verification
    let our_uid = unsafe { libc::getuid() };

    // Step 3: Main loop - accept clients and relay data
    // Supports reconnection: when client disconnects, wait for new client (for hot reload)
    let (mut tls_read, mut tls_write) = tokio::io::split(tls_stream);

    loop {
        // Wait for client connection with timeout (60 seconds for reconnection)
        let client_stream = match tokio::time::timeout(
            std::time::Duration::from_secs(60),
            listener.accept()
        ).await {
            Ok(Ok((stream, _))) => stream,
            Ok(Err(_)) => break,
            Err(_) => break,
        };

        // Verify peer credentials - only accept connections from the same user
        // This prevents other users from hijacking the connection
        let peer_uid = {
            use std::os::unix::io::AsRawFd;
            let fd = client_stream.as_raw_fd();

            #[cfg(target_os = "linux")]
            {
                let mut cred: libc::ucred = unsafe { std::mem::zeroed() };
                let mut len = std::mem::size_of::<libc::ucred>() as libc::socklen_t;
                let ret = unsafe {
                    libc::getsockopt(
                        fd,
                        libc::SOL_SOCKET,
                        libc::SO_PEERCRED,
                        &mut cred as *mut _ as *mut libc::c_void,
                        &mut len,
                    )
                };
                if ret == 0 { Some(cred.uid) } else { None }
            }

            #[cfg(target_os = "macos")]
            {
                let mut euid: libc::uid_t = 0;
                let mut egid: libc::gid_t = 0;
                let ret = unsafe { libc::getpeereid(fd, &mut euid, &mut egid) };
                if ret == 0 { Some(euid) } else { None }
            }

            #[cfg(not(any(target_os = "linux", target_os = "macos")))]
            {
                None // Other Unix platforms: skip peer check
            }
        };

        // Reject connections from different users
        if peer_uid != Some(our_uid) {
            // Close connection silently and wait for next
            continue;
        }

        let (mut client_read, mut client_write) = client_stream.into_split();

        // Track why we exited the relay loop
        let mut tls_server_disconnected = false;

        // Relay data between client and TLS server
        let mut client_buf = [0u8; 8192];
        let mut tls_buf = [0u8; 8192];

        loop {
            tokio::select! {
                // Client -> TLS
                result = client_read.read(&mut client_buf) => {
                    match result {
                        Ok(0) => break, // Client disconnected, wait for new client
                        Ok(n) => {
                            if tls_write.write_all(&client_buf[..n]).await.is_err() {
                                tls_server_disconnected = true;
                                break;
                            }
                        }
                        Err(_) => break,
                    }
                }
                // TLS -> Client
                result = tls_read.read(&mut tls_buf) => {
                    match result {
                        Ok(0) => {
                            tls_server_disconnected = true;
                            break;
                        }
                        Ok(n) => {
                            if client_write.write_all(&tls_buf[..n]).await.is_err() {
                                break; // Client write failed, wait for new client
                            }
                        }
                        Err(_) => {
                            tls_server_disconnected = true;
                            break;
                        }
                    }
                }
            }
        }

        // If TLS server disconnected, exit the proxy
        if tls_server_disconnected {
            break;
        }
        // Otherwise, loop back to accept a new client (for hot reload)
    }

    // Clean up socket file
    let _ = std::fs::remove_file(socket_path);
}

/// Strip " (deleted)" suffix from a path string if present.
#[cfg(all(unix, not(target_os = "android")))]
fn strip_deleted_suffix(path_str: &str) -> String {
    // Try common variations of the deleted marker
    for suffix in [" (deleted)", "(deleted)"] {
        if let Some(stripped) = path_str.strip_suffix(suffix) {
            return stripped.to_string();
        }
    }
    path_str.to_string()
}

/// Get the executable path, handling the case where binary was updated.
/// On Linux, if the binary was replaced, /proc/self/exe shows " (deleted)".
/// We strip that suffix to get the path to the new binary.
/// Returns (path, debug_info) for better error messages.
#[cfg(all(unix, not(target_os = "android")))]
fn get_executable_path() -> io::Result<(PathBuf, String)> {
    let proc_exe = PathBuf::from("/proc/self/exe");
    let link_target = std::fs::read_link(&proc_exe)?;
    let target_str = link_target.to_string_lossy().to_string();
    let clean_path = strip_deleted_suffix(&target_str);
    let debug_info = format!(
        "raw='{}', cleaned='{}', exists={}",
        target_str,
        clean_path,
        PathBuf::from(&clean_path).exists()
    );
    Ok((PathBuf::from(clean_path), debug_info))
}

#[cfg(all(unix, not(target_os = "android")))]
fn exec_reload(app: &App) -> io::Result<()> {
    debug_log(true, "RELOAD: Starting exec_reload");

    // Save the current state
    debug_log(true, "RELOAD: Saving state...");
    persistence::save_reload_state(app)?;
    debug_log(true, "RELOAD: State saved successfully");

    // Collect socket fds that need to survive exec (plain TCP only)
    // TLS proxy connections reconnect via Unix socket path after reload
    let mut fds_to_keep: Vec<RawFd> = Vec::new();
    for world in &app.worlds {
        // Plain TCP socket - skip if FD is stale (connection closed but fd not cleared)
        if let Some(fd) = world.socket_fd {
            if clear_cloexec(fd).is_ok() {
                fds_to_keep.push(fd);
            }
            // If clear_cloexec fails, the FD is stale - just skip it
        }
    }
    debug_log(true, &format!("RELOAD: Keeping {} fds", fds_to_keep.len()));

    // Get the executable path with debug info
    let (exe, debug_info) = get_executable_path()?;
    debug_log(true, &format!("RELOAD: Executable path: {} ({})", exe.display(), debug_info));

    // Verify the executable exists
    if !exe.exists() {
        return Err(io::Error::other(format!(
            "Executable not found. Debug: {}",
            debug_info
        )));
    }

    // Pass fd list via environment (fds must survive exec)
    let fds_str: String = fds_to_keep
        .iter()
        .map(|fd| fd.to_string())
        .collect::<Vec<_>>()
        .join(",");
    std::env::set_var(RELOAD_FDS_ENV, &fds_str);

    debug_log(true, &format!("RELOAD: About to exec with fds={}", fds_str));

    // Execute the new binary with --reload argument
    use std::os::unix::process::CommandExt;
    let mut args: Vec<String> = std::env::args().skip(1).filter(|a| a != "--reload").collect();
    args.push("--reload".to_string());
    let err = std::process::Command::new(&exe)
        .args(&args)
        .exec();

    // If we get here, exec failed
    Err(io::Error::other(format!("exec failed: {} (path: {})", err, exe.display())))
}

/// Run as console client connecting to remote daemon (--console=host:port)
/// Uses the same App struct and ui() function as the normal console interface
async fn run_console_client(addr: &str) -> io::Result<()> {
    use tokio_tungstenite::{connect_async, tungstenite::Message};
    use futures::SinkExt;

    // Parse address - add wss:// prefix if not present (try secure first)
    let (ws_url, try_fallback) = if addr.starts_with("ws://") || addr.starts_with("wss://") {
        (addr.to_string(), false)
    } else {
        // Default to wss:// for security, will fall back to ws:// if it fails
        (format!("wss://{}", addr), true)
    };

    println!("Connecting to {}...", ws_url);

    // Connect to WebSocket server - for wss:// we need to configure TLS to accept self-signed certs
    #[cfg(feature = "rustls-backend")]
    let connect_result = if ws_url.starts_with("wss://") {
        // Configure rustls to accept self-signed/invalid certificates
        let tls_config = rustls::ClientConfig::builder()
            .dangerous()
            .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
            .with_no_client_auth();
        let connector = tokio_tungstenite::Connector::Rustls(Arc::new(tls_config));
        tokio_tungstenite::connect_async_tls_with_config(
            &ws_url,
            None,
            false,
            Some(connector),
        ).await
    } else {
        connect_async(&ws_url).await
    };

    #[cfg(not(feature = "rustls-backend"))]
    let connect_result = connect_async(&ws_url).await;

    let (ws_stream, _) = match connect_result {
        Ok(result) => result,
        Err(e) if try_fallback => {
            // wss:// failed, try ws:// fallback
            let fallback_url = format!("ws://{}", addr);
            eprintln!("Secure connection failed ({}), trying {}...", e, fallback_url);
            match connect_async(&fallback_url).await {
                Ok(result) => result,
                Err(e2) => {
                    eprintln!("Failed to connect to {}: {}", fallback_url, e2);
                    return Ok(());
                }
            }
        }
        Err(e) => {
            eprintln!("Failed to connect to {}: {}", ws_url, e);
            return Ok(());
        }
    };

    let (mut ws_write, mut ws_read) = ws_stream.split();

    // Create a channel for sending messages to the WebSocket
    let (ws_tx, mut ws_rx) = mpsc::unbounded_channel::<WsMessage>();

    // Spawn task to forward messages to WebSocket
    let ws_write_handle = tokio::spawn(async move {
        while let Some(msg) = ws_rx.recv().await {
            if let Ok(json) = serde_json::to_string(&msg) {
                if ws_write.send(Message::Text(json)).await.is_err() {
                    break;
                }
            }
        }
    });

    // Wait for ServerHello to know if we're in multiuser mode
    let multiuser_mode = loop {
        match ws_read.next().await {
            Some(Ok(Message::Text(text))) => {
                if let Ok(WsMessage::ServerHello { multiuser_mode: is_multiuser }) = serde_json::from_str::<WsMessage>(&text) {
                    break is_multiuser;
                }
            }
            Some(Ok(Message::Close(_))) | None => {
                eprintln!("Connection closed before authentication");
                return Ok(());
            }
            _ => {}
        }
    };

    // Prompt for username if in multiuser mode
    let mut username: Option<String> = None;
    if multiuser_mode {
        print!("Username? ");
        let _ = io::stdout().flush();

        let mut user_input = String::new();
        enable_raw_mode()?;
        let mut event_stream = EventStream::new();
        loop {
            if let Some(Ok(Event::Key(key))) = event_stream.next().await {
                if key.kind != KeyEventKind::Press { continue; }
                match key.code {
                    KeyCode::Enter => {
                        disable_raw_mode()?;
                        println!();
                        username = Some(user_input);
                        break;
                    }
                    KeyCode::Char(c) => {
                        user_input.push(c);
                        print!("{}", c);
                        let _ = io::stdout().flush();
                    }
                    KeyCode::Backspace => {
                        if user_input.pop().is_some() {
                            print!("\x08 \x08"); // Backspace, space, backspace
                            let _ = io::stdout().flush();
                        }
                    }
                    KeyCode::Esc => {
                        disable_raw_mode()?;
                        println!();
                        return Ok(());
                    }
                    _ => {}
                }
            }
        }
    }

    // Prompt for password
    print!("Password? ");
    let _ = io::stdout().flush();

    // Read password with raw mode for character-by-character input
    let mut password = String::new();
    enable_raw_mode()?;
    let mut event_stream = EventStream::new();
    loop {
        tokio::select! {
            maybe_event = event_stream.next() => {
                if let Some(Ok(Event::Key(key))) = maybe_event {
                    if key.kind != KeyEventKind::Press { continue; }
                    match key.code {
                        KeyCode::Enter => {
                            disable_raw_mode()?;
                            println!(); // Move to next line after password
                            // Send authentication
                            let password_hash = hash_password(&password);
                            let _ = ws_tx.send(WsMessage::AuthRequest { password_hash, username, current_world: None, auth_key: None, request_key: false });
                            break;
                        }
                        KeyCode::Char(c) => {
                            password.push(c);
                        }
                        KeyCode::Backspace => {
                            password.pop();
                        }
                        KeyCode::Esc => {
                            disable_raw_mode()?;
                            println!();
                            return Ok(());
                        }
                        _ => {}
                    }
                }
            }
            msg = ws_read.next() => {
                match msg {
                    Some(Ok(Message::Text(text))) => {
                        if let Ok(WsMessage::AuthResponse { success, error, .. }) = serde_json::from_str::<WsMessage>(&text) {
                            if !success {
                                disable_raw_mode()?;
                                println!();
                                eprintln!("Authentication failed: {}", error.unwrap_or_default());
                                return Ok(());
                            }
                            // Auth success - continue to wait for InitialState
                            break;
                        }
                    }
                    Some(Ok(Message::Close(_))) | None => {
                        disable_raw_mode()?;
                        println!();
                        eprintln!("Connection closed");
                        return Ok(());
                    }
                    _ => {}
                }
            }
        }
    }

    // Create App struct and set it up for remote client mode
    let mut app = App::new();
    app.ws_client_tx = Some(ws_tx.clone());
    app.is_master = false;

    // Now set up the terminal for the main UI
    enable_raw_mode()?;
    let mut stdout = io::stdout();
    execute!(
        stdout,
        EnterAlternateScreen,
        crossterm::terminal::Clear(crossterm::terminal::ClearType::All),
        crossterm::cursor::MoveTo(0, 0)
    )?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    terminal.clear()?;

    // Wait for InitialState
    loop {
        if let Some(Ok(Message::Text(text))) = ws_read.next().await {
            if let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) {
                match ws_msg {
                    WsMessage::AuthResponse { success, error, .. } => {
                        if !success {
                            disable_raw_mode()?;
                            execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
                            eprintln!("Authentication failed: {}", error.unwrap_or_default());
                            return Ok(());
                        }
                        // Auth success - continue waiting for InitialState
                    }
                    WsMessage::InitialState { worlds, current_world_index, settings, splash_lines, .. } => {
                        // Initialize app state from server
                        app.init_from_initial_state(worlds, current_world_index, settings, splash_lines);
                        // Declare client type to server (RemoteConsole for TUI clients)
                        let _ = ws_tx.send(WsMessage::ClientTypeDeclaration {
                            client_type: websocket::RemoteClientType::RemoteConsole,
                        });
                        // Send initial view state for more-mode sync
                        let (_, height) = crossterm::terminal::size().unwrap_or((80, 24));
                        let visible_lines = height.saturating_sub(4) as usize; // Account for input area and separator
                        let _ = ws_tx.send(WsMessage::UpdateViewState {
                            world_index: current_world_index,
                            visible_lines,
                        });
                        break;
                    }
                    _ => {}
                }
            }
        } else {
            disable_raw_mode()?;
            execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
            eprintln!("Connection closed while waiting for initial state");
            return Ok(());
        }
    }

    // Main event loop - use the same ui() function as the normal console
    app.needs_output_redraw = true;
    let mut needs_redraw = true;

    // Track popup visibility for transition detection
    let mut popup_was_visible = false;

    loop {
        // Draw if needed
        if needs_redraw || app.needs_output_redraw {
            // Check current popup visibility
            let any_popup_visible = app.has_new_popup() || app.confirm_dialog.visible;

            // Only clear when TRANSITIONING to a popup (not on every frame)
            // This prevents slow performance from excessive redraws
            if any_popup_visible && !popup_was_visible {
                // Use crossterm directly to ensure screen is cleared
                execute!(
                    std::io::stdout(),
                    crossterm::terminal::Clear(crossterm::terminal::ClearType::All)
                )?;
                terminal.clear()?;
            }
            popup_was_visible = any_popup_visible;

            // Handle Ctrl+L terminal clear request
            if app.needs_terminal_clear {
                execute!(
                    std::io::stdout(),
                    crossterm::terminal::Clear(crossterm::terminal::ClearType::All)
                )?;
                terminal.clear()?;
                app.needs_terminal_clear = false;
            }

            terminal.draw(|f| ui(f, &mut app))?;
            // Render output with crossterm (bypasses ratatui's buggy ANSI handling)
            render_output_crossterm(&app);
            needs_redraw = false;
            app.needs_output_redraw = false;
        }

        tokio::select! {
            maybe_event = event_stream.next() => {
                if let Some(Ok(event)) = maybe_event {
                    match event {
                        Event::Key(key) if key.kind == KeyEventKind::Press => {
                            // Handle Ctrl+C with double-press to quit
                            if key.modifiers == KeyModifiers::CONTROL && key.code == KeyCode::Char('c') {
                                if let Some(last_time) = app.last_ctrl_c {
                                    if last_time.elapsed() < std::time::Duration::from_secs(15) {
                                        break; // Second Ctrl+C within 15 seconds - quit
                                    }
                                }
                                // First Ctrl+C or timeout - show message and record time
                                app.last_ctrl_c = Some(std::time::Instant::now());
                                let world = app.current_world_mut();
                                world.showing_splash = false; // Clear splash when adding output
                                let seq = world.next_seq;
                                world.next_seq += 1;
                                world.output_lines.push(
                                    OutputLine::new_client("Press Ctrl+C again within 15 seconds to exit, or use /quit".to_string(), seq)
                                );
                                // Keep scroll at bottom
                                world.scroll_offset = world.output_lines.len().saturating_sub(1);
                                needs_redraw = true;
                                continue;
                            }

                            // Handle remote client key events
                            if handle_remote_client_key(&mut app, key, &ws_tx) {
                                break; // Quit requested
                            }
                            needs_redraw = true;
                        }
                        Event::Resize(_, height) => {
                            // Send updated view state for more-mode sync
                            let visible_lines = height.saturating_sub(4) as usize;
                            let _ = ws_tx.send(WsMessage::UpdateViewState {
                                world_index: app.current_world_index,
                                visible_lines,
                            });
                            needs_redraw = true;
                        }
                        _ => {}
                    }
                }
            }
            msg = ws_read.next() => {
                match msg {
                    Some(Ok(Message::Text(text))) => {
                        if let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) {
                            app.handle_remote_ws_message(ws_msg);
                            needs_redraw = true;
                        }
                    }
                    Some(Ok(Message::Ping(_))) => {
                        // Respond to ping - handled by tungstenite automatically
                    }
                    Some(Ok(Message::Close(_))) | None => {
                        break;
                    }
                    _ => {}
                }
            }
        }
    }

    // Cleanup
    ws_write_handle.abort();
    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    Ok(())
}

/// Handle key events for remote console client mode
/// Returns true if quit was requested
fn handle_remote_client_key(
    app: &mut App,
    key: KeyEvent,
    ws_tx: &mpsc::UnboundedSender<WsMessage>,
) -> bool {
    use KeyCode::*;

    // New unified popup system - handles help popup and others
    if app.has_new_popup() {
        match handle_new_popup_key(app, key) {
            NewPopupAction::Command(cmd) => {
                // Menu command selected - parse and execute locally
                let parsed = parse_command(&cmd);
                match parsed {
                    Command::Help => {
                        app.open_help_popup_new();
                    }
                    Command::Version => {
                        app.add_output(&get_version_string());
                    }
                    Command::Menu => {
                        app.open_menu_popup_new();
                    }
                    Command::Setup => {
                        app.open_setup_popup_new();
                    }
                    Command::Web => {
                        app.open_web_popup_new();
                    }
                    Command::WorldSelector => {
                        app.open_world_selector_new();
                    }
                    Command::WorldsList => {
                        let _ = ws_tx.send(WsMessage::RequestConnectionsList);
                    }
                    Command::Actions { world } => {
                        if let Some(world_name) = world {
                            app.open_actions_list_popup_with_filter(&world_name);
                        } else {
                            app.open_actions_list_popup();
                        }
                    }
                    _ => {
                        // Other commands - send to server
                        let _ = ws_tx.send(WsMessage::SendCommand {
                            world_index: app.current_world_index,
                            command: cmd,
                        });
                    }
                }
            }
            NewPopupAction::Confirm(data) => {
                // Handle action deletion confirm
                if let Some(action_index_str) = data.get("action_index") {
                    if let Ok(action_index) = action_index_str.parse::<usize>() {
                        if action_index < app.settings.actions.len() {
                            let action_name = app.settings.actions[action_index].name.clone();
                            app.settings.actions.remove(action_index);
                            app.add_output(&format!("Action '{}' deleted.", action_name));
                            // Send UpdateActions to daemon
                            let _ = ws_tx.send(WsMessage::UpdateActions {
                                actions: app.settings.actions.clone()
                            });
                            // Reopen actions list to show updated list
                            app.open_actions_list_popup();
                        }
                    }
                }
            }
            NewPopupAction::ConfirmCancelled(data) => {
                // Reopen the parent list popup when confirm dialog is cancelled
                if data.contains_key("world_index") {
                    app.open_world_selector_new();
                } else if data.contains_key("action_index") {
                    app.open_actions_list_popup();
                }
            }
            NewPopupAction::WorldSelector(_action) => {
                // World selector action - remote client doesn't handle locally
            }
            NewPopupAction::WorldSelectorFilter => {
                // Filter changed - remote client doesn't handle locally
            }
            NewPopupAction::SetupSaved(settings) => {
                // Send settings update to master daemon
                // Update local app settings first
                app.settings.more_mode_enabled = settings.more_mode;
                app.settings.spell_check_enabled = settings.spell_check;
                app.settings.temp_convert_enabled = settings.temp_convert;
                app.settings.world_switch_mode = WorldSwitchMode::from_name(&settings.world_switching);
                // Note: show_tags is not in setup anymore - controlled by F2 or /tag
                app.input_height = settings.input_height as u16;
                app.input.visible_height = app.input_height;
                app.settings.gui_theme = Theme::from_name(&settings.gui_theme);
                app.settings.tls_proxy_enabled = settings.tls_proxy;
                if app.settings.dictionary_path != settings.dictionary_path {
                    app.settings.dictionary_path = settings.dictionary_path.clone();
                    app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
                }
                app.settings.editor_side = EditorSide::from_name(&settings.editor_side);

                // Send UpdateGlobalSettings to daemon
                let _ = ws_tx.send(WsMessage::UpdateGlobalSettings {
                    more_mode_enabled: app.settings.more_mode_enabled,
                    spell_check_enabled: app.settings.spell_check_enabled,
                    temp_convert_enabled: app.settings.temp_convert_enabled,
                    world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                    show_tags: app.show_tags,
                    debug_enabled: app.settings.debug_enabled,
                    ansi_music_enabled: app.settings.ansi_music_enabled,
                    console_theme: app.settings.theme.name().to_string(),
                    gui_theme: app.settings.gui_theme.name().to_string(),
                    gui_transparency: app.settings.gui_transparency,
                    color_offset_percent: app.settings.color_offset_percent,
                    input_height: app.input_height,
                    font_name: app.settings.font_name.clone(),
                    font_size: app.settings.font_size,
                    web_font_size_phone: app.settings.web_font_size_phone,
                    web_font_size_tablet: app.settings.web_font_size_tablet,
                    web_font_size_desktop: app.settings.web_font_size_desktop,
                    ws_allow_list: app.settings.websocket_allow_list.clone(),
                    web_secure: app.settings.web_secure,
                    http_enabled: app.settings.http_enabled,
                    http_port: app.settings.http_port,
                    ws_enabled: app.settings.ws_enabled,
                    ws_port: app.settings.ws_port,
                    ws_cert_file: app.settings.websocket_cert_file.clone(),
                    ws_key_file: app.settings.websocket_key_file.clone(),
                    tls_proxy_enabled: app.settings.tls_proxy_enabled,
                    dictionary_path: app.settings.dictionary_path.clone(),
                });
            }
            NewPopupAction::WebSaved(settings) => {
                // Update local web settings
                app.settings.web_secure = settings.web_secure;
                app.settings.http_enabled = settings.http_enabled;
                app.settings.http_port = settings.http_port.parse().unwrap_or(9000);
                app.settings.ws_enabled = settings.ws_enabled;
                app.settings.ws_port = settings.ws_port.parse().unwrap_or(9002);
                app.settings.websocket_allow_list = settings.ws_allow_list.clone();
                app.settings.websocket_cert_file = settings.ws_cert_file.clone();
                app.settings.websocket_key_file = settings.ws_key_file.clone();
                // Password update handled separately if changed

                // Send UpdateGlobalSettings to daemon
                let _ = ws_tx.send(WsMessage::UpdateGlobalSettings {
                    more_mode_enabled: app.settings.more_mode_enabled,
                    spell_check_enabled: app.settings.spell_check_enabled,
                    temp_convert_enabled: app.settings.temp_convert_enabled,
                    world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                    show_tags: app.show_tags,
                    debug_enabled: app.settings.debug_enabled,
                    ansi_music_enabled: app.settings.ansi_music_enabled,
                    console_theme: app.settings.theme.name().to_string(),
                    gui_theme: app.settings.gui_theme.name().to_string(),
                    gui_transparency: app.settings.gui_transparency,
                    color_offset_percent: app.settings.color_offset_percent,
                    input_height: app.input_height,
                    font_name: app.settings.font_name.clone(),
                    font_size: app.settings.font_size,
                    web_font_size_phone: app.settings.web_font_size_phone,
                    web_font_size_tablet: app.settings.web_font_size_tablet,
                    web_font_size_desktop: app.settings.web_font_size_desktop,
                    ws_allow_list: app.settings.websocket_allow_list.clone(),
                    web_secure: app.settings.web_secure,
                    http_enabled: app.settings.http_enabled,
                    http_port: app.settings.http_port,
                    ws_enabled: app.settings.ws_enabled,
                    ws_port: app.settings.ws_port,
                    ws_cert_file: app.settings.websocket_cert_file.clone(),
                    ws_key_file: app.settings.websocket_key_file.clone(),
                    tls_proxy_enabled: app.settings.tls_proxy_enabled,
                    dictionary_path: app.settings.dictionary_path.clone(),
                });
            }
            NewPopupAction::ConnectionsClose => {
                // Connections popup closed - no action needed
            }
            NewPopupAction::ActionsList(action) => {
                match action {
                    ActionsListAction::Add => {
                        app.open_action_editor_popup(None);
                    }
                    ActionsListAction::Edit(idx) => {
                        if idx < app.settings.actions.len() {
                            app.open_action_editor_popup(Some(idx));
                        }
                    }
                    ActionsListAction::Delete(idx) => {
                        if idx < app.settings.actions.len() {
                            let name = app.settings.actions[idx].name.clone();
                            app.open_delete_action_confirm(&name, idx);
                        }
                    }
                    ActionsListAction::Toggle(idx) => {
                        if idx < app.settings.actions.len() {
                            app.settings.actions[idx].enabled = !app.settings.actions[idx].enabled;
                            // Send UpdateActions to daemon
                            let _ = ws_tx.send(WsMessage::UpdateActions {
                                actions: app.settings.actions.clone()
                            });
                            // Update the list display in the popup
                            use popup::definitions::actions::{ActionInfo, filter_actions, ACTIONS_FIELD_FILTER, ACTIONS_FIELD_LIST};
                            if let Some(state) = app.popup_manager.current_mut() {
                                let filter_text = if state.editing && state.is_field_selected(ACTIONS_FIELD_FILTER) {
                                    state.edit_buffer.clone()
                                } else {
                                    state.get_text(ACTIONS_FIELD_FILTER).unwrap_or("").to_string()
                                };
                                let all_actions: Vec<ActionInfo> = app.settings.actions
                                    .iter()
                                    .enumerate()
                                    .map(|(i, a)| ActionInfo {
                                        name: a.name.clone(),
                                        world: a.world.clone(),
                                        pattern: a.pattern.clone(),
                                        enabled: a.enabled,
                                        index: i,
                                    })
                                    .collect();
                                let mut filtered = filter_actions(&all_actions, &filter_text);
                                filtered.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                                if let Some(field) = state.field_mut(ACTIONS_FIELD_LIST) {
                                    if let popup::FieldKind::List { items, .. } = &mut field.kind {
                                        *items = filtered.iter().map(|info| {
                                                #[cfg(not(windows))]
                                                let status = if info.enabled { "[âœ“]" } else { "[ ]" };
                                                #[cfg(windows)]
                                                let status = if info.enabled { "[x]" } else { "[ ]" };
                                                let world_part = if info.world.is_empty() {
                                                    String::new()
                                                } else {
                                                    format!("({})", info.world)
                                                };
                                                let pattern_preview = if info.pattern.len() > 30 {
                                                    format!("{}...", &info.pattern[..27])
                                                } else {
                                                    info.pattern.clone()
                                                };
                                                popup::ListItem {
                                                    id: info.index.to_string(),
                                                    columns: vec![
                                                        format!("{} {}", status, info.name),
                                                        world_part,
                                                        pattern_preview,
                                                    ],
                                                    style: popup::ListItemStyle {
                                                        is_disabled: !info.enabled,
                                                        ..Default::default()
                                                    },
                                                }
                                        }).collect();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            NewPopupAction::ActionsListFilter => {
                // Filter changed - update the actions list locally
                use popup::definitions::actions::{ActionInfo, filter_actions, ACTIONS_FIELD_FILTER, ACTIONS_FIELD_LIST};
                if let Some(state) = app.popup_manager.current_mut() {
                    let filter_text = if state.editing && state.is_field_selected(ACTIONS_FIELD_FILTER) {
                        state.edit_buffer.clone()
                    } else {
                        state.get_text(ACTIONS_FIELD_FILTER).unwrap_or("").to_string()
                    };
                    let all_actions: Vec<ActionInfo> = app.settings.actions
                        .iter()
                        .enumerate()
                        .map(|(i, a)| ActionInfo {
                            name: a.name.clone(),
                            world: a.world.clone(),
                            pattern: a.pattern.clone(),
                            enabled: a.enabled,
                            index: i,
                        })
                        .collect();
                    let mut filtered = filter_actions(&all_actions, &filter_text);
                    filtered.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                    if let Some(field) = state.field_mut(ACTIONS_FIELD_LIST) {
                        if let popup::FieldKind::List { items, selected_index, scroll_offset, .. } = &mut field.kind {
                            let old_len = items.len();
                            *items = filtered.iter().map(|info| {
                                    #[cfg(not(windows))]
                                    let status = if info.enabled { "[âœ“]" } else { "[ ]" };
                                    #[cfg(windows)]
                                    let status = if info.enabled { "[x]" } else { "[ ]" };
                                    let world_part = if info.world.is_empty() {
                                        String::new()
                                    } else {
                                        format!("({})", info.world)
                                    };
                                    let pattern_preview = if info.pattern.len() > 30 {
                                        format!("{}...", &info.pattern[..27])
                                    } else {
                                        info.pattern.clone()
                                    };
                                    popup::ListItem {
                                        id: info.index.to_string(),
                                        columns: vec![
                                            format!("{} {}", status, info.name),
                                            world_part,
                                            pattern_preview,
                                        ],
                                        style: popup::ListItemStyle {
                                            is_disabled: !info.enabled,
                                            ..Default::default()
                                        },
                                    }
                            }).collect();
                            if items.is_empty() {
                                *selected_index = 0;
                                *scroll_offset = 0;
                            } else if *selected_index >= items.len() {
                                *selected_index = items.len().saturating_sub(1);
                            }
                            if old_len != items.len() {
                                *scroll_offset = 0;
                            }
                        }
                    }
                }
            }
            NewPopupAction::ActionEditorSave { action, editing_index } => {
                // Update local actions list
                if let Some(idx) = editing_index {
                    if idx < app.settings.actions.len() {
                        app.settings.actions[idx] = action;
                    }
                } else {
                    app.settings.actions.push(action);
                }
                // Send UpdateActions to daemon
                let _ = ws_tx.send(WsMessage::UpdateActions {
                    actions: app.settings.actions.clone()
                });
            }
            NewPopupAction::WorldEditorSaved(settings) => {
                // Update local world settings
                let idx = settings.world_index;
                if idx < app.worlds.len() {
                    app.worlds[idx].name = settings.name.clone();
                    app.worlds[idx].settings.hostname = settings.hostname.clone();
                    app.worlds[idx].settings.port = settings.port.clone();
                    app.worlds[idx].settings.user = settings.user.clone();
                    app.worlds[idx].settings.password = settings.password.clone();
                    app.worlds[idx].settings.use_ssl = settings.use_ssl;
                    app.worlds[idx].settings.log_enabled = settings.log_enabled;
                    app.worlds[idx].settings.encoding = Encoding::from_name(&settings.encoding);
                    app.worlds[idx].settings.auto_connect_type = AutoConnectType::from_name(&settings.auto_connect);
                    app.worlds[idx].settings.keep_alive_type = KeepAliveType::from_name(&settings.keep_alive);
                    app.worlds[idx].settings.keep_alive_cmd = settings.keep_alive_cmd.clone();
                    app.worlds[idx].settings.gmcp_packages = settings.gmcp_packages.clone();

                    // Send UpdateWorldSettings to daemon
                    let _ = ws_tx.send(WsMessage::UpdateWorldSettings {
                        world_index: idx,
                        name: settings.name,
                        hostname: settings.hostname,
                        port: settings.port,
                        user: settings.user,
                        password: settings.password,
                        use_ssl: settings.use_ssl,
                        log_enabled: settings.log_enabled,
                        encoding: settings.encoding,
                        auto_login: settings.auto_connect,
                        keep_alive_type: settings.keep_alive,
                        keep_alive_cmd: settings.keep_alive_cmd,
                        gmcp_packages: settings.gmcp_packages,
                    });
                }
            }
            NewPopupAction::WorldEditorDelete(idx) => {
                // Send delete request to daemon
                let _ = ws_tx.send(WsMessage::DeleteWorld { world_index: idx });
            }
            NewPopupAction::WorldEditorConnect(idx) => {
                // Send connect request to daemon
                let _ = ws_tx.send(WsMessage::ConnectWorld { world_index: idx });
            }
            NewPopupAction::None => {}
        }
        return false;
    }
    if app.filter_popup.visible {
        handle_remote_filter_popup_key(app, key);
        return false;
    }

    // Helper to check if escape was pressed recently (for Escape+key sequences)
    let recent_escape = app.last_escape
        .map(|t| t.elapsed() < std::time::Duration::from_millis(500))
        .unwrap_or(false);

    // Track bare Escape key presses for Escape+key sequences
    if key.code == Esc && key.modifiers.is_empty() {
        app.last_escape = Some(std::time::Instant::now());
        return false;
    }

    // Handle Escape+j (Alt+j) to jump to end - release all pending
    if key.code == Char('j') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None;
        let has_pending = !app.current_world().pending_lines.is_empty() || app.current_world().pending_count > 0;
        if app.current_world().paused && has_pending {
            // Send release all (count=0 means release all)
            // Server will broadcast PendingLinesUpdate to sync all clients
            let _ = ws_tx.send(WsMessage::ReleasePending {
                world_index: app.current_world_index,
                count: 0,
            });
        }
        // Also scroll to bottom
        app.current_world_mut().scroll_to_bottom();
        app.needs_output_redraw = true;
        return false;
    }

    // Handle Escape+w (Alt+w) to switch to world with oldest pending
    if key.code == Char('w') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None;
        // Request oldest pending world from server
        let _ = ws_tx.send(WsMessage::CalculateOldestPending { current_index: app.current_world_index });
        return false;
    }

    match (key.modifiers, key.code) {
        (KeyModifiers::CONTROL, Char('u')) => {
            app.input.clear();
        }
        (KeyModifiers::CONTROL, Char('w')) => {
            app.input.delete_word_before_cursor();
        }
        (KeyModifiers::CONTROL, Char('a')) | (_, Home) => {
            app.input.home();
        }
        (_, End) => {
            app.input.end();
        }
        (KeyModifiers::CONTROL, Char('p')) => {
            app.input.history_prev();
        }
        (KeyModifiers::CONTROL, Char('n')) => {
            app.input.history_next();
        }
        (KeyModifiers::CONTROL, Char('b')) | (_, Left) => {
            app.input.move_cursor_left();
        }
        (KeyModifiers::CONTROL, Char('f')) | (_, Right) => {
            app.input.move_cursor_right();
        }
        (KeyModifiers::CONTROL, Char('l')) => {
            // Redraw screen - filter output to only show server data
            app.current_world_mut().filter_to_server_output();
            // Signal main loop to clear terminal and redraw everything
            app.needs_terminal_clear = true;
            app.needs_output_redraw = true;
        }
        (KeyModifiers::CONTROL, Up) => {
            app.input.move_cursor_up();
        }
        (KeyModifiers::CONTROL, Down) => {
            app.input.move_cursor_down();
        }
        (KeyModifiers::ALT, Up) => {
            // Resize input area smaller
            if app.input_height > 1 {
                app.input_height -= 1;
            }
        }
        (KeyModifiers::ALT, Down) => {
            // Resize input area larger
            if app.input_height < 15 {
                app.input_height += 1;
            }
        }
        (_, Up) => {
            // Request previous active world from server
            let _ = ws_tx.send(WsMessage::CalculatePrevWorld { current_index: app.current_world_index });
        }
        (_, Down) => {
            // Request next active world from server
            let _ = ws_tx.send(WsMessage::CalculateNextWorld { current_index: app.current_world_index });
        }
        (_, PageUp) => {
            // Scroll up (towards older content) = decrease scroll_offset
            let scroll_amount = app.output_height.saturating_sub(2) as usize;
            let current_offset = app.current_world().scroll_offset;
            let new_offset = current_offset.saturating_sub(scroll_amount.max(1));
            app.current_world_mut().scroll_offset = new_offset;

            // If we're at or near the top, request more scrollback from server
            if new_offset == 0 {
                // Get the oldest sequence number we have
                let before_seq = app.current_world().output_lines.first().map(|l| l.seq);
                let _ = ws_tx.send(WsMessage::RequestScrollback {
                    world_index: app.current_world_index,
                    count: scroll_amount.max(1),
                    before_seq,
                });
            }
            app.needs_output_redraw = true;
        }
        (_, PageDown) => {
            // Scroll down (towards newer content) = increase scroll_offset
            let scroll_amount = app.output_height.saturating_sub(2) as usize;
            let max_offset = app.current_world().output_lines.len().saturating_sub(1);
            app.current_world_mut().scroll_offset = (app.current_world().scroll_offset + scroll_amount.max(1)).min(max_offset);
            app.needs_output_redraw = true;
        }
        (_, Tab) => {
            // Release pending lines or scroll down
            // Use pending_count for console mode (synced from daemon), pending_lines for daemon mode
            let has_pending = !app.current_world().pending_lines.is_empty() || app.current_world().pending_count > 0;
            if app.current_world().paused && has_pending {
                // Send release request - server will broadcast PendingLinesUpdate to sync all clients
                let release_count = app.output_height.saturating_sub(2) as usize;
                let _ = ws_tx.send(WsMessage::ReleasePending {
                    world_index: app.current_world_index,
                    count: release_count,
                });
            } else if !app.current_world().is_at_bottom() {
                // Scroll down (towards newer content) = increase scroll_offset
                let scroll_amount = app.output_height.saturating_sub(2) as usize;
                let max_offset = app.current_world().output_lines.len().saturating_sub(1);
                app.current_world_mut().scroll_offset = (app.current_world().scroll_offset + scroll_amount.max(1)).min(max_offset);
                app.needs_output_redraw = true;
            }
        }
        (_, Backspace) => {
            app.input.delete_char();
            app.last_input_was_delete = true;
        }
        (_, Delete) => {
            app.input.delete_char_forward();
            app.last_input_was_delete = true;
        }
        (_, Enter) => {
            let cmd = app.input.take_input();
            if cmd.is_empty() {
                // Send empty command to server (some MUDs use this for "look")
                let _ = ws_tx.send(WsMessage::SendCommand {
                    world_index: app.current_world_index,
                    command: cmd,
                });
            } else {
                // Parse command to handle local commands
                let parsed = parse_command(&cmd);
                match parsed {
                    Command::Quit => return true,
                    Command::Help => {
                        app.open_help_popup_new();
                    }
                    Command::Version => {
                        app.add_output(&get_version_string());
                    }
                    Command::Menu => {
                        app.open_menu_popup_new();
                    }
                    Command::Setup => {
                        app.open_setup_popup_new();
                    }
                    Command::Web => {
                        app.open_web_popup_new();
                    }
                    Command::WorldSelector => {
                        app.open_world_selector_new();
                    }
                    Command::WorldsList => {
                        // Request connections list from server (includes timing info)
                        let _ = ws_tx.send(WsMessage::RequestConnectionsList);
                    }
                    Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                        // /worlds <name> - switch to world if it exists
                        if let Some(idx) = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                            app.current_world_index = idx;
                            let _ = ws_tx.send(WsMessage::MarkWorldSeen { world_index: idx });
                            // If not connected, request connection
                            if !app.worlds[idx].connected {
                                let _ = ws_tx.send(WsMessage::ConnectWorld { world_index: idx });
                            }
                        } else {
                            // World doesn't exist - could create it, but for now just show message
                            let ci = app.current_world_index;
                            let seq = app.worlds[ci].next_seq;
                            app.worlds[ci].next_seq += 1;
                            app.worlds[ci].output_lines.push(
                                OutputLine::new_client(format!("World '{}' not found.", name), seq)
                            );
                        }
                    }
                    Command::WorldEdit { ref name } => {
                        // /worlds -e [name] - open world editor using new popup
                        let idx = if let Some(ref n) = name {
                            app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(n))
                                .unwrap_or(app.current_world_index)
                        } else {
                            app.current_world_index
                        };
                        if idx < app.worlds.len() {
                            app.open_world_editor_popup_new(idx);
                        }
                    }
                    Command::Actions { world } => {
                        if let Some(world_name) = world {
                            app.open_actions_list_popup_with_filter(&world_name);
                        } else {
                            app.open_actions_list_popup();
                        }
                    }
                    Command::Connect { .. } => {
                        let _ = ws_tx.send(WsMessage::ConnectWorld {
                            world_index: app.current_world_index,
                        });
                    }
                    Command::Disconnect => {
                        let _ = ws_tx.send(WsMessage::DisconnectWorld {
                            world_index: app.current_world_index,
                        });
                    }
                    Command::NotACommand { text } => {
                        // Regular text - send to server
                        let _ = ws_tx.send(WsMessage::SendCommand {
                            world_index: app.current_world_index,
                            command: text,
                        });
                    }
                    _ => {
                        // Other commands - send to server for processing
                        let _ = ws_tx.send(WsMessage::SendCommand {
                            world_index: app.current_world_index,
                            command: cmd,
                        });
                    }
                }
            }
            // Reset lines_since_pause for more-mode
            app.current_world_mut().lines_since_pause = 0;
            // Clear splash on first user input (same as server data)
            if app.current_world().showing_splash {
                let world = app.current_world_mut();
                world.showing_splash = false;
                world.needs_redraw = true;
                world.output_lines.clear();
                world.scroll_offset = 0;
                app.needs_output_redraw = true;
            }
        }
        (_, KeyCode::F(1)) => {
            // Toggle help popup (using new unified popup system)
            if app.has_new_popup() {
                app.close_new_popup();
            } else {
                app.open_help_popup_new();
            }
        }
        (_, KeyCode::F(2)) => {
            // Toggle show_tags
            app.show_tags = !app.show_tags;
            app.needs_output_redraw = true;
        }
        (_, KeyCode::F(4)) => {
            // Toggle filter popup
            if app.filter_popup.visible {
                app.filter_popup.visible = false;
            } else {
                app.filter_popup.open();
            }
        }
        (_, KeyCode::F(8)) => {
            // Toggle action highlighting
            app.highlight_actions = !app.highlight_actions;
            app.needs_output_redraw = true;
        }
        (_, KeyCode::F(9)) => {
            // Toggle GMCP user processing for current world
            let idx = app.current_world_index;
            app.worlds[idx].gmcp_user_enabled = !app.worlds[idx].gmcp_user_enabled;
            app.ws_broadcast(WsMessage::GmcpUserToggled {
                world_index: idx,
                enabled: app.worlds[idx].gmcp_user_enabled,
            });
            if app.worlds[idx].gmcp_user_enabled {
                app.restart_world_media(idx);
            } else {
                app.stop_world_media(idx);
            }
            app.needs_output_redraw = true;
        }
        (_, Char(c)) => {
            app.input.insert_char(c);
            app.last_input_was_delete = false;
            app.check_temp_conversion();
        }
        _ => {}
    }
    false
}

/// Result from handling a new popup key
enum NewPopupAction {
    None,
    /// Execute a command (from menu selection)
    Command(String),
    /// Confirm action with custom_data from the popup
    Confirm(std::collections::HashMap<String, String>),
    /// Confirm dialog cancelled (No/Esc) with custom_data from the popup
    ConfirmCancelled(std::collections::HashMap<String, String>),
    /// World selector action
    WorldSelector(WorldSelectorAction),
    /// World selector filter changed - need to update the list
    WorldSelectorFilter,
    /// Setup (global settings) saved
    SetupSaved(SetupSettings),
    /// Web settings saved
    WebSaved(WebSettings),
    /// Connections popup closed (just close, no action needed)
    ConnectionsClose,
    /// Actions list action (Add, Edit, Delete)
    ActionsList(ActionsListAction),
    /// Actions list filter changed
    ActionsListFilter,
    /// Action editor saved
    ActionEditorSave { action: Action, editing_index: Option<usize> },
    /// World editor saved
    WorldEditorSaved(Box<WorldEditorSettings>),
    /// World editor delete requested
    WorldEditorDelete(usize),
    /// World editor connect requested
    WorldEditorConnect(usize),
}

/// Settings from the setup popup
struct SetupSettings {
    more_mode: bool,
    spell_check: bool,
    temp_convert: bool,
    world_switching: String,
    debug: bool,
    input_height: i64,
    gui_theme: String,
    tls_proxy: bool,
    dictionary_path: String,
    editor_side: String,
}

/// Settings from the web popup
struct WebSettings {
    web_secure: bool,
    http_enabled: bool,
    http_port: String,
    ws_enabled: bool,
    ws_port: String,
    ws_password: String,
    ws_allow_list: String,
    ws_cert_file: String,
    ws_key_file: String,
}

/// Settings from the world editor popup
struct WorldEditorSettings {
    world_index: usize,  // Which world is being edited
    name: String,
    world_type: String,
    // MUD fields
    hostname: String,
    port: String,
    user: String,
    password: String,
    use_ssl: bool,
    log_enabled: bool,
    encoding: String,
    auto_connect: String,
    keep_alive: String,
    keep_alive_cmd: String,
    gmcp_packages: String,
    // Slack fields
    slack_token: String,
    slack_channel: String,
    slack_workspace: String,
    // Discord fields
    discord_token: String,
    discord_guild: String,
    discord_channel: String,
    discord_dm_user: String,
}

/// Actions from the world selector popup
enum WorldSelectorAction {
    Connect(String),      // Connect to world by name
    Edit(String),         // Edit world by name
    Delete(String),       // Delete world by name
    Add,                  // Add new world
}

/// Actions from the actions list popup
enum ActionsListAction {
    Add,                  // Add new action
    Edit(usize),          // Edit action at index
    Delete(usize),        // Delete action at index
    Toggle(usize),        // Toggle enable/disable action at index
}

/// Handle input for new unified popup system
fn handle_new_popup_key(app: &mut App, key: KeyEvent) -> NewPopupAction {
    use crossterm::event::KeyCode::*;
    use popup::definitions::help::HELP_BTN_OK;
    use popup::definitions::confirm::{CONFIRM_BTN_YES, CONFIRM_BTN_NO};
    use popup::ElementSelection;
    use popup::definitions::world_selector::{
        SELECTOR_FIELD_FILTER,
        SELECTOR_BTN_ADD, SELECTOR_BTN_EDIT, SELECTOR_BTN_DELETE,
        SELECTOR_BTN_CONNECT, SELECTOR_BTN_CANCEL,
    };
    use popup::definitions::setup::{
        SETUP_FIELD_MORE_MODE, SETUP_FIELD_SPELL_CHECK, SETUP_FIELD_TEMP_CONVERT,
        SETUP_FIELD_WORLD_SWITCHING, SETUP_FIELD_DEBUG,
        SETUP_FIELD_INPUT_HEIGHT, SETUP_FIELD_GUI_THEME, SETUP_FIELD_TLS_PROXY,
        SETUP_FIELD_DICTIONARY, SETUP_FIELD_EDITOR_SIDE, SETUP_BTN_SAVE, SETUP_BTN_CANCEL,
    };
    use popup::definitions::web::{
        WEB_FIELD_PROTOCOL, WEB_FIELD_HTTP_ENABLED, WEB_FIELD_HTTP_PORT,
        WEB_FIELD_WS_ENABLED, WEB_FIELD_WS_PORT, WEB_FIELD_WS_PASSWORD,
        WEB_FIELD_WS_ALLOW_LIST, WEB_FIELD_WS_CERT_FILE, WEB_FIELD_WS_KEY_FILE,
        WEB_BTN_SAVE, WEB_BTN_CANCEL, update_tls_visibility,
    };
    use popup::definitions::actions::{
        ACTIONS_FIELD_FILTER, ACTIONS_FIELD_LIST,
        ACTIONS_BTN_ADD, ACTIONS_BTN_EDIT, ACTIONS_BTN_DELETE, ACTIONS_BTN_CANCEL,
        EDITOR_FIELD_NAME, EDITOR_FIELD_WORLD, EDITOR_FIELD_MATCH_TYPE,
        EDITOR_FIELD_PATTERN, EDITOR_FIELD_COMMAND, EDITOR_FIELD_ENABLED, EDITOR_FIELD_STARTUP,
        EDITOR_BTN_SAVE, EDITOR_BTN_CANCEL,
    };
    use popup::definitions::world_editor::{
        WORLD_FIELD_NAME, WORLD_FIELD_TYPE, WORLD_FIELD_HOSTNAME, WORLD_FIELD_PORT,
        WORLD_FIELD_USER, WORLD_FIELD_PASSWORD, WORLD_FIELD_USE_SSL, WORLD_FIELD_LOG_ENABLED,
        WORLD_FIELD_ENCODING, WORLD_FIELD_AUTO_CONNECT, WORLD_FIELD_KEEP_ALIVE, WORLD_FIELD_KEEP_ALIVE_CMD,
        WORLD_FIELD_GMCP_PACKAGES,
        WORLD_FIELD_SLACK_TOKEN, WORLD_FIELD_SLACK_CHANNEL, WORLD_FIELD_SLACK_WORKSPACE,
        WORLD_FIELD_DISCORD_TOKEN, WORLD_FIELD_DISCORD_GUILD, WORLD_FIELD_DISCORD_CHANNEL, WORLD_FIELD_DISCORD_DM_USER,
        WORLD_BTN_SAVE, WORLD_BTN_CANCEL, WORLD_BTN_DELETE, WORLD_BTN_CONNECT,
        WorldType as PopupWorldType, update_field_visibility,
    };

    let popup_id = app.popup_manager.current().map(|s| s.definition.id.clone());
    let is_menu = popup_id == Some(popup::PopupId("menu"));
    let is_confirm = popup_id.as_ref().map(|id| id.0.starts_with("delete_")).unwrap_or(false);
    let is_world_selector = popup_id == Some(popup::PopupId("world_selector"));
    let is_setup = popup_id == Some(popup::PopupId("setup"));
    let is_web = popup_id == Some(popup::PopupId("web"));
    let is_connections = popup_id == Some(popup::PopupId("connections"));
    let is_actions_list = popup_id == Some(popup::PopupId("actions_list"));
    let is_action_editor = popup_id == Some(popup::PopupId("action_editor"));
    let is_world_editor = popup_id == Some(popup::PopupId("world_editor"));

    if let Some(state) = app.popup_manager.current_mut() {
        // World selector has special handling
        if is_world_selector {
            // Get selected world name before any state mutations
            let get_selected = || state.get_selected_list_item().map(|item| item.id.clone());

            // Check if we're editing the filter field
            let is_editing_filter = state.editing && state.is_field_selected(SELECTOR_FIELD_FILTER);

            // When editing filter, handle text input
            if is_editing_filter {
                match key.code {
                    Esc => {
                        state.commit_edit();
                        // Apply filter after editing
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    Tab => {
                        // Tab exits filter field and goes to buttons
                        state.commit_edit();
                        state.cycle_field_buttons();
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    Enter => {
                        state.commit_edit();
                        // Apply filter and stay in popup
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    Backspace => {
                        state.backspace();
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    Delete => {
                        state.delete_char();
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    Left => {
                        state.cursor_left();
                    }
                    Right => {
                        state.cursor_right();
                    }
                    Home => {
                        state.cursor_home();
                    }
                    End => {
                        state.cursor_end();
                    }
                    Char(c) => {
                        // Insert character into filter
                        state.insert_char(c);
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    _ => {}
                }
                return NewPopupAction::None;
            }

            // Not editing - handle normal navigation and shortcuts
            match key.code {
                Esc => {
                    app.popup_manager.close();
                }
                Enter => {
                    if state.is_on_button() {
                        if state.is_button_focused(SELECTOR_BTN_CONNECT) {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Connect(name));
                            }
                        } else if state.is_button_focused(SELECTOR_BTN_EDIT) {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Edit(name));
                            }
                        } else if state.is_button_focused(SELECTOR_BTN_DELETE) {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Delete(name));
                            }
                        } else if state.is_button_focused(SELECTOR_BTN_ADD) {
                            app.popup_manager.close();
                            return NewPopupAction::WorldSelector(WorldSelectorAction::Add);
                        } else if state.is_button_focused(SELECTOR_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else if state.is_field_selected(SELECTOR_FIELD_FILTER) {
                        // Start editing filter field
                        state.start_edit();
                    } else {
                        // On list - connect to selected world
                        if let Some(name) = get_selected() {
                            app.popup_manager.close();
                            return NewPopupAction::WorldSelector(WorldSelectorAction::Connect(name));
                        }
                    }
                }
                Up => {
                    state.list_select_up();
                }
                Down => {
                    state.list_select_down();
                }
                Tab => {
                    // Cycle between filter field and buttons
                    state.cycle_field_buttons();
                }
                BackTab => {
                    // Cycle backwards
                    state.cycle_field_buttons();
                }
                Char(c) => {
                    // Check if filter field is selected - if so, start editing and add char
                    if state.is_field_selected(SELECTOR_FIELD_FILTER) {
                        state.start_edit();
                        state.insert_char(c);
                        return NewPopupAction::WorldSelectorFilter;
                    }
                    // Otherwise handle as shortcuts
                    match c {
                        'f' | 'F' => {
                            // Select filter field and start editing
                            state.select_field(SELECTOR_FIELD_FILTER);
                            state.start_edit();
                        }
                        'a' | 'A' => {
                            app.popup_manager.close();
                            return NewPopupAction::WorldSelector(WorldSelectorAction::Add);
                        }
                        'e' | 'E' => {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Edit(name));
                            }
                        }
                        'd' | 'D' => {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Delete(name));
                            }
                        }
                        'o' | 'O' => {
                            if let Some(name) = get_selected() {
                                app.popup_manager.close();
                                return NewPopupAction::WorldSelector(WorldSelectorAction::Connect(name));
                            }
                        }
                        'c' | 'C' => {
                            app.popup_manager.close();
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // Setup popup handling
        if is_setup {
            // Helper to extract settings before closing
            let extract_settings = || -> SetupSettings {
                SetupSettings {
                    more_mode: state.get_bool(SETUP_FIELD_MORE_MODE).unwrap_or(true),
                    spell_check: state.get_bool(SETUP_FIELD_SPELL_CHECK).unwrap_or(true),
                    temp_convert: state.get_bool(SETUP_FIELD_TEMP_CONVERT).unwrap_or(false),
                    world_switching: state.get_selected(SETUP_FIELD_WORLD_SWITCHING)
                        .unwrap_or("unseen_first").to_string(),
                    debug: state.get_bool(SETUP_FIELD_DEBUG).unwrap_or(false),
                    input_height: state.get_number(SETUP_FIELD_INPUT_HEIGHT).unwrap_or(3),
                    gui_theme: state.get_selected(SETUP_FIELD_GUI_THEME)
                        .unwrap_or("dark").to_string(),
                    tls_proxy: state.get_bool(SETUP_FIELD_TLS_PROXY).unwrap_or(false),
                    dictionary_path: state.get_text(SETUP_FIELD_DICTIONARY)
                        .unwrap_or("").to_string(),
                    editor_side: state.get_selected(SETUP_FIELD_EDITOR_SIDE)
                        .unwrap_or("left").to_string(),
                }
            };

            // Check if current field is a text field
            let is_text_field = state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false);

            match key.code {
                Esc => {
                    if state.editing {
                        state.cancel_edit();
                    } else {
                        app.popup_manager.close();
                    }
                }
                Enter => {
                    if state.editing {
                        state.commit_edit();
                    } else if state.is_on_button() {
                        if state.is_button_focused(SETUP_BTN_SAVE) {
                            let settings = extract_settings();
                            app.popup_manager.close();
                            return NewPopupAction::SetupSaved(settings);
                        } else if state.is_button_focused(SETUP_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else {
                        // Toggle current field or start editing text field
                        if is_text_field {
                            state.start_edit();
                        } else {
                            state.toggle_current();
                        }
                    }
                }
                Char(' ') => {
                    if state.editing {
                        state.insert_char(' ');
                    } else if state.is_on_button() {
                        if state.is_button_focused(SETUP_BTN_SAVE) {
                            let settings = extract_settings();
                            app.popup_manager.close();
                            return NewPopupAction::SetupSaved(settings);
                        } else if state.is_button_focused(SETUP_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else {
                        // Toggle current field
                        state.toggle_current();
                    }
                }
                Up => {
                    // Commit any current edit before moving
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        // Go back to last field from button row
                        state.select_last_field();
                    } else {
                        state.prev_field();
                    }
                    // Auto-start editing if new field is text
                    if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Down => {
                    // Commit any current edit before moving
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        // Go back to last field from button row
                        state.select_last_field();
                    } else {
                        // Move to next field (don't go to buttons)
                        state.next_field();
                    }
                    // Auto-start editing if new field is text
                    if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Left => {
                    if is_text_field {
                        // Text field: move cursor (start editing if needed)
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_left();
                    } else {
                        // Decrease number or cycle select
                        state.decrease_current();
                    }
                }
                Right => {
                    if is_text_field {
                        // Text field: move cursor (start editing if needed)
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_right();
                    } else {
                        // Increase number or cycle select
                        state.increase_current();
                    }
                }
                Tab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.next_button();
                    } else {
                        state.select_first_button();
                    }
                }
                BackTab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.prev_button();
                    } else {
                        state.select_last_field();
                        // Auto-start editing if new field is text
                        if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                            state.start_edit();
                        }
                    }
                }
                Backspace => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.backspace();
                    }
                }
                Delete => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.delete_char();
                    }
                }
                Home => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_home();
                    }
                }
                End => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_end();
                    }
                }
                Char('s') | Char('S') if !state.editing && !is_text_field => {
                    let settings = extract_settings();
                    app.popup_manager.close();
                    return NewPopupAction::SetupSaved(settings);
                }
                Char('c') | Char('C') if !state.editing && !is_text_field => {
                    app.popup_manager.close();
                }
                Char(c) => {
                    if state.editing {
                        state.insert_char(c);
                    } else if is_text_field {
                        // Start editing and insert character
                        state.start_edit();
                        state.insert_char(c);
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // Web popup handling
        if is_web {
            // Helper to extract settings before closing
            let extract_settings = || -> WebSettings {
                WebSettings {
                    web_secure: state.get_selected(WEB_FIELD_PROTOCOL) == Some("secure"),
                    http_enabled: state.get_bool(WEB_FIELD_HTTP_ENABLED).unwrap_or(false),
                    http_port: state.get_text(WEB_FIELD_HTTP_PORT).unwrap_or("9000").to_string(),
                    ws_enabled: state.get_bool(WEB_FIELD_WS_ENABLED).unwrap_or(false),
                    ws_port: state.get_text(WEB_FIELD_WS_PORT).unwrap_or("9002").to_string(),
                    ws_password: state.get_text(WEB_FIELD_WS_PASSWORD).unwrap_or("").to_string(),
                    ws_allow_list: state.get_text(WEB_FIELD_WS_ALLOW_LIST).unwrap_or("").to_string(),
                    ws_cert_file: state.get_text(WEB_FIELD_WS_CERT_FILE).unwrap_or("").to_string(),
                    ws_key_file: state.get_text(WEB_FIELD_WS_KEY_FILE).unwrap_or("").to_string(),
                }
            };

            // Check if current field is a text field
            let is_text_field = state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false);

            match key.code {
                Esc => {
                    if state.editing {
                        state.cancel_edit();
                    } else {
                        app.popup_manager.close();
                    }
                }
                Enter => {
                    if state.editing {
                        state.commit_edit();
                    } else if state.is_on_button() {
                        if state.is_button_focused(WEB_BTN_SAVE) {
                            let settings = extract_settings();
                            app.popup_manager.close();
                            return NewPopupAction::WebSaved(settings);
                        } else if state.is_button_focused(WEB_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else if is_text_field {
                        state.start_edit();
                    } else {
                        // Toggle current field
                        state.toggle_current();
                        // Update TLS visibility when protocol changes
                        if let ElementSelection::Field(id) = &state.selected {
                            if *id == WEB_FIELD_PROTOCOL {
                                update_tls_visibility(state);
                            }
                        }
                    }
                }
                Char(' ') => {
                    if !state.editing {
                        // Toggle for non-text fields
                        state.toggle_current();
                        // Update TLS visibility when protocol changes
                        if let ElementSelection::Field(id) = &state.selected {
                            if *id == WEB_FIELD_PROTOCOL {
                                update_tls_visibility(state);
                            }
                        }
                    } else {
                        state.insert_char(' ');
                    }
                }
                Up => {
                    // Commit any current edit before moving
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        // Go back to last field from button row
                        state.select_last_field();
                    } else {
                        state.prev_field();
                    }
                    // Auto-start editing if new field is text
                    if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Down => {
                    // Commit any current edit before moving
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        // Go back to last field from button row
                        state.select_last_field();
                    } else {
                        // Move to next field (don't go to buttons)
                        state.next_field();
                    }
                    // Auto-start editing if new field is text
                    if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Left => {
                    if is_text_field {
                        // Text field: move cursor (start editing if needed)
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_left();
                    } else {
                        state.decrease_current();
                        // Update TLS visibility when protocol changes
                        if let ElementSelection::Field(id) = &state.selected {
                            if *id == WEB_FIELD_PROTOCOL {
                                update_tls_visibility(state);
                            }
                        }
                    }
                }
                Right => {
                    if is_text_field {
                        // Text field: move cursor (start editing if needed)
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_right();
                    } else {
                        state.increase_current();
                        // Update TLS visibility when protocol changes
                        if let ElementSelection::Field(id) = &state.selected {
                            if *id == WEB_FIELD_PROTOCOL {
                                update_tls_visibility(state);
                            }
                        }
                    }
                }
                Tab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.next_button();
                    } else {
                        state.select_first_button();
                    }
                }
                BackTab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.prev_button();
                    } else {
                        state.select_last_field();
                        // Auto-start editing if new field is text
                        if state.selected_field().map(|f| f.kind.is_text()).unwrap_or(false) {
                            state.start_edit();
                        }
                    }
                }
                Backspace => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.backspace();
                    }
                }
                Delete => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.delete_char();
                    }
                }
                Home => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_home();
                    }
                }
                End => {
                    if is_text_field {
                        if !state.editing {
                            state.start_edit();
                        }
                        state.cursor_end();
                    }
                }
                Char('s') | Char('S') if !state.editing && !is_text_field => {
                    let settings = extract_settings();
                    app.popup_manager.close();
                    return NewPopupAction::WebSaved(settings);
                }
                Char('c') | Char('C') if !state.editing && !is_text_field => {
                    app.popup_manager.close();
                }
                Char(c) => {
                    if state.editing {
                        state.insert_char(c);
                    } else if is_text_field {
                        // Start editing and insert character
                        state.start_edit();
                        state.insert_char(c);
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // Connections popup handling (simple - just close on any key)
        if is_connections {
            match key.code {
                Esc | Enter | Char(' ') => {
                    app.popup_manager.close();
                    return NewPopupAction::ConnectionsClose;
                }
                Char('o') | Char('O') => {
                    // OK shortcut
                    app.popup_manager.close();
                    return NewPopupAction::ConnectionsClose;
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // Actions list popup handling
        if is_actions_list {
            // Get selected action index before any state mutations
            let get_selected_index = || {
                if let Some(field) = state.field(ACTIONS_FIELD_LIST) {
                    if let popup::FieldKind::List { items, selected_index, .. } = &field.kind {
                        if !items.is_empty() && *selected_index < items.len() {
                            // Parse the action index from the item id (which is just the index as string)
                            return items.get(*selected_index).and_then(|item| item.id.parse::<usize>().ok());
                        }
                    }
                }
                None
            };

            // Check if we're editing the filter field
            let is_editing_filter = state.editing && state.is_field_selected(ACTIONS_FIELD_FILTER);

            // When editing filter, handle text input
            if is_editing_filter {
                match key.code {
                    Esc => {
                        state.commit_edit();
                        return NewPopupAction::ActionsListFilter;
                    }
                    Tab => {
                        state.commit_edit();
                        state.cycle_field_buttons();
                        return NewPopupAction::ActionsListFilter;
                    }
                    Enter => {
                        state.commit_edit();
                        return NewPopupAction::ActionsListFilter;
                    }
                    Backspace => {
                        state.backspace();
                        return NewPopupAction::ActionsListFilter;
                    }
                    Delete => {
                        state.delete_char();
                        return NewPopupAction::ActionsListFilter;
                    }
                    Left => {
                        state.cursor_left();
                    }
                    Right => {
                        state.cursor_right();
                    }
                    Home => {
                        state.cursor_home();
                    }
                    End => {
                        state.cursor_end();
                    }
                    Char(c) => {
                        state.insert_char(c);
                        return NewPopupAction::ActionsListFilter;
                    }
                    _ => {}
                }
                return NewPopupAction::None;
            }

            // Not editing - handle normal navigation and shortcuts
            match key.code {
                Esc => {
                    app.popup_manager.close();
                }
                Enter => {
                    if state.is_on_button() {
                        if state.is_button_focused(ACTIONS_BTN_ADD) {
                            app.popup_manager.close();
                            return NewPopupAction::ActionsList(ActionsListAction::Add);
                        } else if state.is_button_focused(ACTIONS_BTN_EDIT) {
                            if let Some(idx) = get_selected_index() {
                                app.popup_manager.close();
                                return NewPopupAction::ActionsList(ActionsListAction::Edit(idx));
                            }
                        } else if state.is_button_focused(ACTIONS_BTN_DELETE) {
                            if let Some(idx) = get_selected_index() {
                                app.popup_manager.close();
                                return NewPopupAction::ActionsList(ActionsListAction::Delete(idx));
                            }
                        } else if state.is_button_focused(ACTIONS_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else if state.is_field_selected(ACTIONS_FIELD_FILTER) {
                        // Start editing filter field
                        state.start_edit();
                    } else {
                        // On list - edit selected action
                        if let Some(idx) = get_selected_index() {
                            app.popup_manager.close();
                            return NewPopupAction::ActionsList(ActionsListAction::Edit(idx));
                        }
                    }
                }
                Up => {
                    state.list_select_up();
                }
                Down => {
                    state.list_select_down();
                }
                Tab => {
                    state.cycle_field_buttons();
                }
                BackTab => {
                    state.cycle_field_buttons();
                }
                Char(c) => {
                    // Check if filter field is selected - start editing
                    if state.is_field_selected(ACTIONS_FIELD_FILTER) {
                        state.start_edit();
                        state.insert_char(c);
                        return NewPopupAction::ActionsListFilter;
                    }
                    // Otherwise handle shortcuts
                    match c {
                        ' ' => {
                            // Space toggles enable/disable for selected action
                            if let Some(idx) = get_selected_index() {
                                // Don't close popup - stay on list for more toggles
                                return NewPopupAction::ActionsList(ActionsListAction::Toggle(idx));
                            }
                        }
                        'f' | 'F' | '/' => {
                            state.select_field(ACTIONS_FIELD_FILTER);
                            state.start_edit();
                        }
                        'a' | 'A' => {
                            app.popup_manager.close();
                            return NewPopupAction::ActionsList(ActionsListAction::Add);
                        }
                        'e' | 'E' => {
                            if let Some(idx) = get_selected_index() {
                                app.popup_manager.close();
                                return NewPopupAction::ActionsList(ActionsListAction::Edit(idx));
                            }
                        }
                        'd' | 'D' => {
                            if let Some(idx) = get_selected_index() {
                                app.popup_manager.close();
                                return NewPopupAction::ActionsList(ActionsListAction::Delete(idx));
                            }
                        }
                        'c' | 'C' | 'o' | 'O' => {
                            app.popup_manager.close();
                        }
                        _ => {}
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // Action editor popup handling
        if is_action_editor {
            let is_text_field = state.selected_field()
                .map(|f| f.kind.is_text_editable())
                .unwrap_or(false);
            let is_multiline = state.selected_field()
                .map(|f| matches!(&f.kind, popup::FieldKind::MultilineText { .. }))
                .unwrap_or(false);
            let is_toggle = state.selected_field()
                .map(|f| matches!(&f.kind, popup::FieldKind::Toggle { .. }))
                .unwrap_or(false);
            let is_select = state.selected_field()
                .map(|f| matches!(&f.kind, popup::FieldKind::Select { .. }))
                .unwrap_or(false);

            match key.code {
                Esc => {
                    if state.editing {
                        state.cancel_edit();
                    } else {
                        app.popup_manager.close();
                    }
                }
                Enter => {
                    if state.editing && is_multiline {
                        // In multiline field, Enter inserts a newline
                        state.insert_newline();
                        state.ensure_multiline_cursor_visible();
                    } else if state.editing {
                        state.commit_edit();
                        state.next_field();
                    } else if state.is_on_button() {
                        if state.is_button_focused(EDITOR_BTN_SAVE) {
                            // Extract action data and save
                            let name = state.get_text(EDITOR_FIELD_NAME).unwrap_or("").to_string();
                            let world = state.get_text(EDITOR_FIELD_WORLD).unwrap_or("").to_string();
                            let match_type_str = state.get_selected(EDITOR_FIELD_MATCH_TYPE).unwrap_or("regexp");
                            let pattern = state.get_text(EDITOR_FIELD_PATTERN).unwrap_or("").to_string();
                            let command = state.get_text(EDITOR_FIELD_COMMAND).unwrap_or("").to_string();
                            let enabled = state.get_bool(EDITOR_FIELD_ENABLED).unwrap_or(true);
                            let startup = state.get_bool(EDITOR_FIELD_STARTUP).unwrap_or(false);
                            let editing_index = state.get_custom("editing_index").and_then(|s| s.parse::<usize>().ok());

                            let match_type = if match_type_str == "wildcard" {
                                MatchType::Wildcard
                            } else {
                                MatchType::Regexp
                            };

                            let action = Action {
                                name,
                                world,
                                match_type,
                                pattern,
                                command,
                                owner: None,
                                enabled,
                                startup,
                            };

                            app.popup_manager.close();
                            return NewPopupAction::ActionEditorSave { action, editing_index };
                        } else if state.is_button_focused(EDITOR_BTN_CANCEL) {
                            app.popup_manager.close();
                        }
                    } else if is_toggle || is_select {
                        state.toggle_current();
                    } else if is_text_field {
                        state.start_edit();
                    }
                }
                Tab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    state.cycle_field_buttons();
                }
                BackTab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    // Go to previous element
                    if !state.prev_field() {
                        state.select_last_field();
                    }
                }
                Up => {
                    if state.editing && is_multiline {
                        // In multiline field, Up moves cursor up
                        state.cursor_up();
                        state.ensure_multiline_cursor_visible();
                    } else {
                        if state.editing {
                            state.commit_edit();
                        }
                        state.prev_field();
                    }
                }
                Down => {
                    if state.editing && is_multiline {
                        // In multiline field, Down moves cursor down
                        state.cursor_down();
                        state.ensure_multiline_cursor_visible();
                    } else {
                        if state.editing {
                            state.commit_edit();
                        }
                        if !state.next_field() {
                            state.select_first_button();
                        }
                    }
                }
                Left => {
                    if state.editing {
                        state.cursor_left();
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    } else if is_select || is_toggle {
                        state.decrease_current();
                    } else if state.is_on_button() {
                        state.prev_button();
                    }
                }
                Right => {
                    if state.editing {
                        state.cursor_right();
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    } else if is_select || is_toggle {
                        state.increase_current();
                    } else if state.is_on_button() {
                        state.next_button();
                    }
                }
                Backspace => {
                    if state.editing {
                        state.backspace();
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    }
                }
                Delete => {
                    if state.editing {
                        state.delete_char();
                    }
                }
                Home => {
                    if state.editing {
                        state.cursor_home();
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    }
                }
                End => {
                    if state.editing {
                        state.cursor_end();
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    }
                }
                Char('s') | Char('S') if !state.editing && !is_text_field => {
                    // Save shortcut (only when not on a text field)
                    state.select_button(EDITOR_BTN_SAVE);
                }
                Char('c') | Char('C') if !state.editing && !is_text_field => {
                    app.popup_manager.close();
                }
                Char(' ') if !state.editing && (is_toggle || is_select) => {
                    // Space toggles current toggle/select field
                    state.toggle_current();
                }
                Char(c) => {
                    if state.editing {
                        state.insert_char(c);
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    } else if is_text_field {
                        state.start_edit();
                        state.insert_char(c);
                        if is_multiline {
                            state.ensure_multiline_cursor_visible();
                        }
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        // World editor popup handling
        if is_world_editor {
            // Get world index from custom state
            let world_index: usize = state.get_custom("world_index")
                .and_then(|s| s.parse().ok())
                .unwrap_or(0);

            // Helper to extract settings before closing
            let extract_settings = || -> WorldEditorSettings {
                WorldEditorSettings {
                    world_index,
                    name: state.get_text(WORLD_FIELD_NAME).unwrap_or("").to_string(),
                    world_type: state.get_selected(WORLD_FIELD_TYPE).unwrap_or("mud").to_string(),
                    hostname: state.get_text(WORLD_FIELD_HOSTNAME).unwrap_or("").to_string(),
                    port: state.get_text(WORLD_FIELD_PORT).unwrap_or("").to_string(),
                    user: state.get_text(WORLD_FIELD_USER).unwrap_or("").to_string(),
                    password: state.get_text(WORLD_FIELD_PASSWORD).unwrap_or("").to_string(),
                    use_ssl: state.get_bool(WORLD_FIELD_USE_SSL).unwrap_or(false),
                    log_enabled: state.get_bool(WORLD_FIELD_LOG_ENABLED).unwrap_or(false),
                    encoding: state.get_selected(WORLD_FIELD_ENCODING).unwrap_or("utf8").to_string(),
                    auto_connect: state.get_selected(WORLD_FIELD_AUTO_CONNECT).unwrap_or("connect").to_string(),
                    keep_alive: state.get_selected(WORLD_FIELD_KEEP_ALIVE).unwrap_or("nop").to_string(),
                    keep_alive_cmd: state.get_text(WORLD_FIELD_KEEP_ALIVE_CMD).unwrap_or("").to_string(),
                    gmcp_packages: state.get_text(WORLD_FIELD_GMCP_PACKAGES).unwrap_or("Client.Media 1").to_string(),
                    slack_token: state.get_text(WORLD_FIELD_SLACK_TOKEN).unwrap_or("").to_string(),
                    slack_channel: state.get_text(WORLD_FIELD_SLACK_CHANNEL).unwrap_or("").to_string(),
                    slack_workspace: state.get_text(WORLD_FIELD_SLACK_WORKSPACE).unwrap_or("").to_string(),
                    discord_token: state.get_text(WORLD_FIELD_DISCORD_TOKEN).unwrap_or("").to_string(),
                    discord_guild: state.get_text(WORLD_FIELD_DISCORD_GUILD).unwrap_or("").to_string(),
                    discord_channel: state.get_text(WORLD_FIELD_DISCORD_CHANNEL).unwrap_or("").to_string(),
                    discord_dm_user: state.get_text(WORLD_FIELD_DISCORD_DM_USER).unwrap_or("").to_string(),
                }
            };

            // Check field type
            let is_text_field = state.selected_field()
                .map(|f| f.kind.is_text_editable())
                .unwrap_or(false);
            let is_toggle = state.selected_field()
                .map(|f| matches!(&f.kind, popup::FieldKind::Toggle { .. }))
                .unwrap_or(false);
            let is_select = state.selected_field()
                .map(|f| matches!(&f.kind, popup::FieldKind::Select { .. }))
                .unwrap_or(false);

            // Macro to update visibility when type or keep_alive changes
            // (We can't use a closure because of borrow conflicts)
            macro_rules! update_visibility {
                ($state:expr) => {{
                    // Extract values first to avoid borrow conflicts
                    let world_type_str = $state.get_selected(WORLD_FIELD_TYPE).unwrap_or("mud").to_string();
                    let keep_alive_str = $state.get_selected(WORLD_FIELD_KEEP_ALIVE).unwrap_or("nop").to_string();
                    update_field_visibility(
                        &mut $state.definition,
                        PopupWorldType::parse(&world_type_str),
                        keep_alive_str == "custom",
                    );
                }};
            }

            match key.code {
                Esc => {
                    if state.editing {
                        state.cancel_edit();
                    } else {
                        app.popup_manager.close();
                    }
                }
                Enter => {
                    if state.editing {
                        state.commit_edit();
                        state.next_field();
                        // Auto-start editing on text/password fields
                        if state.selected_field().map(|f| f.kind.is_text_editable()).unwrap_or(false) {
                            state.start_edit();
                        }
                    } else if state.is_on_button() {
                        if state.is_button_focused(WORLD_BTN_SAVE) {
                            let settings = extract_settings();
                            app.popup_manager.close();
                            return NewPopupAction::WorldEditorSaved(Box::new(settings));
                        } else if state.is_button_focused(WORLD_BTN_CANCEL) {
                            app.popup_manager.close();
                        } else if state.is_button_focused(WORLD_BTN_DELETE) {
                            app.popup_manager.close();
                            return NewPopupAction::WorldEditorDelete(world_index);
                        } else if state.is_button_focused(WORLD_BTN_CONNECT) {
                            let _settings = extract_settings();
                            app.popup_manager.close();
                            // First save, then connect
                            return NewPopupAction::WorldEditorConnect(world_index);
                        }
                    } else if is_toggle {
                        state.toggle_current();
                    } else if is_select {
                        state.toggle_current();
                        update_visibility!(state);
                    } else if is_text_field {
                        state.start_edit();
                    }
                }
                Char(' ') => {
                    if state.editing {
                        state.insert_char(' ');
                    } else if is_toggle {
                        state.toggle_current();
                    } else if is_select {
                        state.toggle_current();
                        update_visibility!(state);
                    }
                }
                Tab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    state.cycle_field_buttons();
                    // Auto-start editing on text/password fields
                    if state.selected_field().map(|f| f.kind.is_text_editable()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                BackTab => {
                    if state.editing {
                        state.commit_edit();
                    }
                    // Go to previous element
                    if !state.prev_field() {
                        state.select_last_field();
                    }
                    // Auto-start editing on text/password fields
                    if state.selected_field().map(|f| f.kind.is_text_editable()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Up => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.select_last_field();
                    } else {
                        state.prev_field();
                    }
                    // Auto-start editing on text/password fields
                    if state.selected_field().map(|f| f.kind.is_text_editable()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Down => {
                    if state.editing {
                        state.commit_edit();
                    }
                    if state.is_on_button() {
                        state.select_last_field();
                    } else {
                        // Only move between fields, never to buttons
                        state.next_field();
                    }
                    // Auto-start editing on text/password fields
                    if state.selected_field().map(|f| f.kind.is_text_editable()).unwrap_or(false) {
                        state.start_edit();
                    }
                }
                Left => {
                    if state.editing {
                        state.cursor_left();
                    } else if is_select || is_toggle {
                        state.decrease_current();
                        update_visibility!(state);
                    } else if state.is_on_button() {
                        state.prev_button();
                    }
                }
                Right => {
                    if state.editing {
                        state.cursor_right();
                    } else if is_select || is_toggle {
                        state.increase_current();
                        update_visibility!(state);
                    } else if state.is_on_button() {
                        state.next_button();
                    }
                }
                Backspace => {
                    if state.editing {
                        state.backspace();
                    }
                }
                Delete => {
                    if state.editing {
                        state.delete_char();
                    }
                }
                Home => {
                    if state.editing {
                        state.cursor_home();
                    }
                }
                End => {
                    if state.editing {
                        state.cursor_end();
                    }
                }
                Char('s') | Char('S') if !state.editing && !is_text_field => {
                    let settings = extract_settings();
                    app.popup_manager.close();
                    return NewPopupAction::WorldEditorSaved(Box::new(settings));
                }
                Char('c') | Char('C') if !state.editing && !is_text_field => {
                    app.popup_manager.close();
                }
                Char('d') | Char('D') if !state.editing && !is_text_field => {
                    app.popup_manager.close();
                    return NewPopupAction::WorldEditorDelete(world_index);
                }
                Char('o') | Char('O') if !state.editing && !is_text_field => {
                    let _settings = extract_settings();
                    app.popup_manager.close();
                    return NewPopupAction::WorldEditorConnect(world_index);
                }
                Char(c) => {
                    if state.editing {
                        state.insert_char(c);
                    } else if is_text_field {
                        state.start_edit();
                        state.insert_char(c);
                    }
                }
                _ => {}
            }
            return NewPopupAction::None;
        }

        match key.code {
            Esc => {
                if is_confirm {
                    let data = state.definition.custom_data.clone();
                    app.popup_manager.close();
                    return NewPopupAction::ConfirmCancelled(data);
                }
                app.popup_manager.close();
            }
            Enter => {
                // Check popup type
                if is_menu {
                    // For menu popup, get selected command and close
                    if let Some(item) = state.get_selected_list_item() {
                        let cmd = item.id.clone();
                        app.popup_manager.close();
                        return NewPopupAction::Command(cmd);
                    }
                } else if is_confirm {
                    // For confirm dialog, check which button is selected
                    if state.is_button_focused(CONFIRM_BTN_YES) {
                        let data = state.definition.custom_data.clone();
                        app.popup_manager.close();
                        return NewPopupAction::Confirm(data);
                    }
                    // No button - cancel
                    let data = state.definition.custom_data.clone();
                    app.popup_manager.close();
                    return NewPopupAction::ConfirmCancelled(data);
                }
                // For other popups, Enter closes
                app.popup_manager.close();
            }
            Up | Down => {
                if is_menu {
                    if matches!(key.code, Up) {
                        state.list_select_up();
                    } else {
                        state.list_select_down();
                    }
                } else if is_confirm {
                    // Toggle between Yes and No
                    if state.is_button_focused(CONFIRM_BTN_YES) {
                        state.select_button(CONFIRM_BTN_NO);
                    } else {
                        state.select_button(CONFIRM_BTN_YES);
                    }
                } else {
                    // Scrollable content (help popup)
                    if matches!(key.code, Up) {
                        state.scroll_up(1);
                    } else {
                        state.scroll_down(1);
                    }
                }
            }
            Left | Right | Tab => {
                if is_confirm {
                    // Toggle between Yes and No
                    if state.is_button_focused(CONFIRM_BTN_YES) {
                        state.select_button(CONFIRM_BTN_NO);
                    } else {
                        state.select_button(CONFIRM_BTN_YES);
                    }
                }
                // For other popups like help, Left/Right/Tab do nothing
            }
            PageUp => {
                state.scroll_up(5);
            }
            PageDown => {
                state.scroll_down(5);
            }
            Char('y') | Char('Y') => {
                if is_confirm {
                    let data = state.definition.custom_data.clone();
                    app.popup_manager.close();
                    return NewPopupAction::Confirm(data);
                }
            }
            Char('n') | Char('N') => {
                if is_confirm {
                    let data = state.definition.custom_data.clone();
                    app.popup_manager.close();
                    return NewPopupAction::ConfirmCancelled(data);
                }
            }
            Char('o') | Char('O') => {
                // Shortcut for OK button (help popup)
                state.select_button(HELP_BTN_OK);
            }
            Char('c') | Char('C') => {
                // Cancel shortcut
                if is_confirm {
                    let data = state.definition.custom_data.clone();
                    app.popup_manager.close();
                    return NewPopupAction::ConfirmCancelled(data);
                }
                app.popup_manager.close();
            }
            _ => {}
        }
    }
    NewPopupAction::None
}

/// Handle filter popup input for remote client
fn handle_remote_filter_popup_key(app: &mut App, key: KeyEvent) {
    use KeyCode::*;

    match key.code {
        Esc | KeyCode::F(4) => {
            app.filter_popup.close();
            app.needs_output_redraw = true;
        }
        Backspace => {
            if app.filter_popup.cursor > 0 {
                app.filter_popup.cursor -= 1;
                app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                app.needs_output_redraw = true;
            }
        }
        Delete => {
            if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                app.needs_output_redraw = true;
            }
        }
        Left => {
            if app.filter_popup.cursor > 0 {
                app.filter_popup.cursor -= 1;
            }
        }
        Right => {
            if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                app.filter_popup.cursor += 1;
            }
        }
        Home => {
            app.filter_popup.cursor = 0;
        }
        End => {
            app.filter_popup.cursor = app.filter_popup.filter_text.len();
        }
        Char(c) => {
            app.filter_popup.filter_text.insert(app.filter_popup.cursor, c);
            app.filter_popup.cursor += 1;
            app.needs_output_redraw = true;
        }
        _ => {}
    }
}

#[tokio::main]
async fn main() -> io::Result<()> {
    // Check for -v or --version to show version and exit
    if std::env::args().any(|a| a == "-v" || a == "--version") {
        println!("{}", get_version_string());
        return Ok(());
    }

    // Check for --conf=<path> to use a custom config file
    if let Some(conf_arg) = std::env::args().find(|a| a.starts_with("--conf=")) {
        let conf_path = conf_arg.strip_prefix("--conf=").unwrap();
        set_custom_config_path(PathBuf::from(conf_path));
    }

    // Log startup for debugging reload/crash issues
    let is_reload_arg = std::env::args().any(|a| a == "--reload");
    let is_crash_arg = std::env::args().any(|a| a == "--crash");
    debug_log(true, &format!("STARTUP: {} (reload={}, crash={})", get_version_string(), is_reload_arg, is_crash_arg));

    // Check for --tls-proxy=config_path argument for TLS proxy mode (not available on Android)
    // This is used internally when spawning TLS proxy processes
    // Config file contains host:port on first line, socket_path on second line
    #[cfg(all(unix, not(target_os = "android")))]
    if let Some(proxy_arg) = std::env::args().find(|a| a.starts_with("--tls-proxy=")) {
        let config_path = proxy_arg.strip_prefix("--tls-proxy=").unwrap();
        if let Ok(contents) = std::fs::read_to_string(config_path) {
            let lines: Vec<&str> = contents.lines().collect();
            if lines.len() >= 2 {
                let host_port: Vec<&str> = lines[0].splitn(2, ':').collect();
                if host_port.len() == 2 {
                    let host = host_port[0];
                    let port = host_port[1];
                    let socket_path = PathBuf::from(lines[1]);
                    // Delete the config file now that we've read it (cleanup)
                    let _ = std::fs::remove_file(config_path);
                    run_tls_proxy_async(host, port, &socket_path).await;
                }
            }
        }
        return Ok(());
    }

    // Check for --multiuser mode
    if std::env::args().any(|a| a == "--multiuser") {
        return run_multiuser_server().await;
    }

    // Check for -D (daemon mode) - run as background server only
    let daemon_mode = std::env::args().any(|a| a == "-D");
    if daemon_mode {
        return run_daemon_server().await;
    }

    // Parse --gui or --gui=host:port
    let gui_arg = std::env::args()
        .find(|a| a == "--gui" || a.starts_with("--gui="))
        .and_then(|a| {
            if a == "--gui" {
                Some(None)
            } else {
                a.strip_prefix("--gui=").map(|addr| Some(addr.to_string()))
            }
        });

    // Parse --console or --console=host:port
    let console_arg = std::env::args()
        .find(|a| a == "--console" || a.starts_with("--console="))
        .and_then(|a| {
            if a == "--console" {
                Some(None)
            } else {
                a.strip_prefix("--console=").map(|addr| Some(addr.to_string()))
            }
        });

    if gui_arg.is_some() && console_arg.is_some() {
        eprintln!("Error: --gui and --console are mutually exclusive.");
        return Ok(());
    }

    let has_gui_flag = gui_arg.is_some();
    let (use_gui, remote_addr) = if let Some(addr_opt) = gui_arg {
        (true, addr_opt)
    } else if let Some(addr_opt) = console_arg {
        (false, addr_opt)
    } else {
        // Default: Mac/Windows -> GUI (if feature available), others -> Console
        let default_gui = (cfg!(target_os = "macos") || cfg!(windows))
            && cfg!(feature = "remote-gui")
            && !cfg!(target_os = "android");
        (default_gui, None)
    };

    // Fall back to console if GUI not available
    let use_gui = use_gui && cfg!(feature = "remote-gui") && !cfg!(target_os = "android");
    if has_gui_flag && !use_gui {
        #[cfg(target_os = "android")]
        {
            eprintln!("Warning: --gui is not available on Android/Termux. Falling back to console.");
        }
        #[cfg(not(target_os = "android"))]
        {
            #[cfg(not(feature = "remote-gui"))]
            {
                eprintln!("Warning: --gui requires the 'remote-gui' feature. Falling back to console.");
                eprintln!("Rebuild with: cargo build --features remote-gui");
            }
        }
    }

    // On Windows, detach from the console window when running in GUI mode
    #[cfg(windows)]
    if use_gui {
        extern "system" {
            fn FreeConsole() -> i32;
        }
        unsafe { FreeConsole(); }
    }

    // Dispatch based on (interface, connection_mode)
    match (use_gui, remote_addr) {
        // Remote GUI: connect to a running Clay instance via WebSocket
        (true, Some(ref addr)) => {
            #[cfg(all(feature = "remote-gui", not(target_os = "android")))]
            {
                return remote_gui2::run_remote_gui(addr);
            }
            #[cfg(not(all(feature = "remote-gui", not(target_os = "android"))))]
            {
                let _ = addr;
                unreachable!("use_gui should be false when remote-gui feature is not available");
            }
        }
        // Master GUI: run App in-process with egui GUI
        (true, None) => {
            #[cfg(all(feature = "remote-gui", not(target_os = "android")))]
            {
                return remote_gui2::run_master_gui();
            }
            #[cfg(not(all(feature = "remote-gui", not(target_os = "android"))))]
            {
                unreachable!("use_gui should be false when remote-gui feature is not available");
            }
        }
        // Remote console: connect to a running Clay instance via WebSocket
        (false, Some(ref addr)) => {
            return run_console_client(addr).await;
        }
        // Master console: default TUI mode (falls through to existing code below)
        (false, None) => {}
    }

    // Set up signal handlers for crash debugging (not available on Android or Windows)
    #[cfg(all(unix, not(target_os = "android")))]
    unsafe {
        extern "C" fn sigfpe_handler(_: libc::c_int) {
            // Restore terminal before printing
            let _ = disable_raw_mode();
            let _ = execute!(std::io::stdout(), LeaveAlternateScreen);
            debug_log(true, "CRASH: SIGFPE (Floating Point Exception)");
            eprintln!("\n\n=== SIGFPE (Floating Point Exception) detected! ===");
            eprintln!("This is typically caused by division by zero.");
            eprintln!("Please report this bug with the steps to reproduce.");

            // Try to print a backtrace
            eprintln!("\nBacktrace:");
            let bt = std::backtrace::Backtrace::force_capture();
            let bt_str = format!("{}", bt);
            debug_log(true, &format!("BACKTRACE:\n{}", bt_str));
            eprintln!("{}", bt);

            std::process::exit(136);  // 128 + 8 (SIGFPE)
        }
        libc::signal(libc::SIGFPE, sigfpe_handler as libc::sighandler_t);

        extern "C" fn sigsegv_handler(_: libc::c_int) {
            let _ = disable_raw_mode();
            let _ = execute!(std::io::stdout(), LeaveAlternateScreen);
            debug_log(true, "CRASH: SIGSEGV (Segmentation Fault)");
            eprintln!("\n\n=== SIGSEGV (Segmentation Fault) detected! ===");
            let bt = std::backtrace::Backtrace::force_capture();
            let bt_str = format!("{}", bt);
            debug_log(true, &format!("BACKTRACE:\n{}", bt_str));
            eprintln!("{}", bt);
            std::process::exit(139);  // 128 + 11 (SIGSEGV)
        }
        libc::signal(libc::SIGSEGV, sigsegv_handler as libc::sighandler_t);

        extern "C" fn sigbus_handler(_: libc::c_int) {
            let _ = disable_raw_mode();
            let _ = execute!(std::io::stdout(), LeaveAlternateScreen);
            debug_log(true, "CRASH: SIGBUS (Bus Error)");
            eprintln!("\n\n=== SIGBUS (Bus Error) detected! ===");
            let bt = std::backtrace::Backtrace::force_capture();
            let bt_str = format!("{}", bt);
            debug_log(true, &format!("BACKTRACE:\n{}", bt_str));
            eprintln!("{}", bt);
            std::process::exit(135);  // 128 + 7 (SIGBUS)
        }
        libc::signal(libc::SIGBUS, sigbus_handler as libc::sighandler_t);

        extern "C" fn sigabrt_handler(_: libc::c_int) {
            let _ = disable_raw_mode();
            let _ = execute!(std::io::stdout(), LeaveAlternateScreen);
            debug_log(true, "CRASH: SIGABRT (Abort)");
            eprintln!("\n\n=== SIGABRT (Abort) detected! ===");
            let bt = std::backtrace::Backtrace::force_capture();
            let bt_str = format!("{}", bt);
            debug_log(true, &format!("BACKTRACE:\n{}", bt_str));
            eprintln!("{}", bt);
            std::process::exit(134);  // 128 + 6 (SIGABRT)
        }
        libc::signal(libc::SIGABRT, sigabrt_handler as libc::sighandler_t);
    }

    // Set up crash handler for automatic recovery (not available on Android or Windows)
    #[cfg(all(unix, not(target_os = "android")))]
    setup_crash_handler();

    enable_raw_mode()?;
    let mut stdout = stdout();
    // Use explicit cursor positioning and clearing for Windows 11 compatibility
    execute!(
        stdout,
        EnterAlternateScreen,
        Clear(ClearType::All),
        cursor::MoveTo(0, 0)
    )?;
    let backend = CrosstermBackend::new(stdout);
    let mut terminal = Terminal::new(backend)?;
    terminal.clear()?;

    let result = run_app(&mut terminal).await;

    disable_raw_mode()?;
    execute!(terminal.backend_mut(), LeaveAlternateScreen)?;
    terminal.show_cursor()?;

    if let Err(err) = result {
        eprintln!("Error: {err}");
    }

    Ok(())
}

/// Run the App headlessly (no terminal UI) for master GUI mode.
/// The App communicates with the embedded GUI via channels.
pub async fn run_app_headless(
    gui_tx: mpsc::UnboundedSender<WsMessage>,
    mut gui_rx: mpsc::UnboundedReceiver<WsMessage>,
) -> io::Result<()> {
    let mut app = App::new();
    app.gui_tx = Some(gui_tx.clone());

    // Check if we're in reload mode (via --reload command line argument)
    let is_reload = std::env::args().any(|a| a == "--reload");
    app.is_reload = is_reload;
    let is_crash = std::env::args().any(|a| a == "--crash");

    // Initialize crash count from environment variable
    let crash_count = get_crash_count();
    CRASH_COUNT.store(crash_count, Ordering::SeqCst);

    let should_load_state = is_reload || is_crash;

    if should_load_state {
        debug_log(true, "HEADLESS STARTUP: Loading reload state...");
        match persistence::load_reload_state(&mut app) {
            Ok(true) => {
                debug_log(true, "HEADLESS STARTUP: Reload state loaded successfully");
            }
            Ok(false) => {
                debug_log(true, "HEADLESS STARTUP: No reload state found");
                if let Err(e) = persistence::load_settings(&mut app) {
                    eprintln!("Warning: Could not load settings: {}", e);
                }
            }
            Err(e) => {
                debug_log(true, &format!("HEADLESS STARTUP: Failed to load reload state: {}", e));
                if let Err(e) = persistence::load_settings(&mut app) {
                    eprintln!("Warning: Could not load settings: {}", e);
                }
            }
        }
    } else {
        // Normal startup - load settings
        if let Err(e) = persistence::load_settings(&mut app) {
            eprintln!("Warning: Could not load settings: {}", e);
        }
        // Clear runtime state on fresh start
        for world in &mut app.worlds {
            world.connected = false;
            world.command_tx = None;
            world.socket_fd = None;
            world.pending_lines.clear();
            world.pending_since = None;
            world.paused = false;
            world.unseen_lines = 0;
            world.first_unseen_at = None;
            world.lines_since_pause = 0;
        }
    }

    // Load theme file (~/clay.theme.dat)
    load_theme_file(&mut app);

    app.ensure_has_world();

    // Re-create spell checker with custom dictionary path if configured
    if !app.settings.dictionary_path.is_empty() {
        app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
    }

    let (event_tx, mut event_rx) = mpsc::channel::<AppEvent>(100);
    app.event_tx = Some(event_tx.clone());

    // Reconstruct connections from saved fds if in reload/crash mode
    #[cfg(unix)]
    if should_load_state {
        debug_log(true, "HEADLESS STARTUP: Reconstructing connections...");
        // First pass: disconnect TLS worlds without proxy
        let mut tls_disconnect_worlds: Vec<usize> = Vec::new();
        for (world_idx, world) in app.worlds.iter().enumerate() {
            if world.connected && world.is_tls && world.proxy_pid.is_none() {
                tls_disconnect_worlds.push(world_idx);
            }
        }
        let tls_msg = if is_crash {
            "TLS connection was closed during crash recovery. Use /worlds to reconnect."
        } else {
            "TLS connection was closed during reload. Use /worlds to reconnect."
        };
        for world_idx in tls_disconnect_worlds {
            app.worlds[world_idx].connected = false;
            app.worlds[world_idx].command_tx = None;
            app.worlds[world_idx].socket_fd = None;
            let seq = app.worlds[world_idx].next_seq;
            app.worlds[world_idx].next_seq += 1;
            app.worlds[world_idx].output_lines.push(OutputLine::new_client(tls_msg.to_string(), seq));
            if world_idx != app.current_world_index {
                if app.worlds[world_idx].unseen_lines == 0 {
                    app.worlds[world_idx].first_unseen_at = Some(std::time::Instant::now());
                }
                app.worlds[world_idx].unseen_lines += 1;
            }
        }

        // Second pass: reconstruct plain TCP connections
        for world_idx in 0..app.worlds.len() {
            let world = &app.worlds[world_idx];
            if world.connected && world.socket_fd.is_some() && !world.is_tls {
                let fd = world.socket_fd.unwrap();
                let tcp_stream = unsafe { std::net::TcpStream::from_raw_fd(fd) };
                tcp_stream.set_nonblocking(true)?;
                let tcp_stream = TcpStream::from_std(tcp_stream)?;
                let (r, w) = tcp_stream.into_split();
                let mut read_half = StreamReader::Plain(r);
                let mut write_half = StreamWriter::Plain(w);
                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                app.worlds[world_idx].skip_auto_login = true;
                app.worlds[world_idx].open_log_file();
                let _telnet_tx = cmd_tx;
                let world_name = app.worlds[world_idx].name.clone();
                app.worlds[world_idx].connection_id += 1;
                app.worlds[world_idx].reader_name = Some(world_name.clone());

                // Spawn reader task
                let reader_tx = event_tx.clone();
                let reader_world_name = world_name.clone();
                let reader_conn_id = app.worlds[world_idx].connection_id;
                tokio::spawn(async move {
                    let mut buf = vec![0u8; 4096];
                    loop {
                        match read_half.read(&mut buf).await {
                            Ok(0) => {
                                let _ = reader_tx.send(AppEvent::Disconnected(reader_world_name, reader_conn_id)).await;
                                break;
                            }
                            Ok(n) => {
                                let data = buf[..n].to_vec();
                                let _ = reader_tx.send(AppEvent::ServerData(reader_world_name.clone(), data)).await;
                            }
                            Err(_) => {
                                let _ = reader_tx.send(AppEvent::Disconnected(reader_world_name, reader_conn_id)).await;
                                break;
                            }
                        }
                    }
                });

                // Spawn writer task
                tokio::spawn(async move {
                    while let Some(cmd) = cmd_rx.recv().await {
                        match cmd {
                            WriteCommand::Text(text) => {
                                let data = format!("{}\r\n", text);
                                if write_half.write_all(data.as_bytes()).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Raw(data) => {
                                if write_half.write_all(&data).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Shutdown => break,
                        }
                    }
                });
            }

            // Reconstruct TLS proxy connections
            #[cfg(all(unix, not(target_os = "android")))]
            {
                let world = &app.worlds[world_idx];
                if world.connected && world.is_tls && world.proxy_pid.is_some() {
                    if let Some(ref socket_path) = world.proxy_socket_path {
                        match tokio::net::UnixStream::connect(socket_path).await {
                            Ok(unix_stream) => {
                                let (r, w) = unix_stream.into_split();
                                let mut read_half = StreamReader::Proxy(r);
                                let mut write_half = StreamWriter::Proxy(w);
                                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                                app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                                app.worlds[world_idx].skip_auto_login = true;
                                app.worlds[world_idx].open_log_file();
                                let world_name = app.worlds[world_idx].name.clone();
                                app.worlds[world_idx].connection_id += 1;
                                app.worlds[world_idx].reader_name = Some(world_name.clone());

                                let reader_tx = event_tx.clone();
                                let reader_world_name = world_name.clone();
                                let reader_conn_id = app.worlds[world_idx].connection_id;
                                tokio::spawn(async move {
                                    let mut buf = vec![0u8; 4096];
                                    loop {
                                        match read_half.read(&mut buf).await {
                                            Ok(0) => {
                                                let _ = reader_tx.send(AppEvent::Disconnected(reader_world_name, reader_conn_id)).await;
                                                break;
                                            }
                                            Ok(n) => {
                                                let data = buf[..n].to_vec();
                                                let _ = reader_tx.send(AppEvent::ServerData(reader_world_name.clone(), data)).await;
                                            }
                                            Err(_) => {
                                                let _ = reader_tx.send(AppEvent::Disconnected(reader_world_name, reader_conn_id)).await;
                                                break;
                                            }
                                        }
                                    }
                                });

                                tokio::spawn(async move {
                                    while let Some(cmd) = cmd_rx.recv().await {
                                        match cmd {
                                            WriteCommand::Text(text) => {
                                                let data = format!("{}\r\n", text);
                                                if write_half.write_all(data.as_bytes()).await.is_err() {
                                                    break;
                                                }
                                            }
                                            WriteCommand::Raw(data) => {
                                                if write_half.write_all(&data).await.is_err() {
                                                    break;
                                                }
                                            }
                                            WriteCommand::Shutdown => break,
                                        }
                                    }
                                });
                            }
                            Err(e) => {
                                debug_log(true, &format!("HEADLESS: Failed to reconnect proxy for {}: {}", app.worlds[world_idx].name, e));
                                app.worlds[world_idx].clear_connection_state(false, false);
                            }
                        }
                    }
                }
            }
        }

        // Cleanup: mark disconnected worlds that claim to be connected but have no command channel
        for world in &mut app.worlds {
            if world.connected && world.command_tx.is_none() {
                world.connected = false;
                world.pending_lines.clear();
                world.paused = false;
            }
        }
    }

    // Start WebSocket server if enabled
    if app.settings.ws_enabled && !app.settings.websocket_password.is_empty() {
        let mut server = WebSocketServer::new(
            &app.settings.websocket_password,
            app.settings.ws_port,
            &app.settings.websocket_allow_list,
            app.settings.websocket_whitelisted_host.clone(),
            false,
            app.ban_list.clone(),
        );

        #[cfg(feature = "native-tls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => { eprintln!("Warning: Failed to configure WSS TLS: {}", e); false }
            }
        } else { false };
        #[cfg(feature = "rustls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => { eprintln!("Warning: Failed to configure WSS TLS: {}", e); false }
            }
        } else { false };

        if let Err(e) = start_websocket_server(&mut server, event_tx.clone()).await {
            let err_str = e.to_string();
            if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                eprintln!("Warning: Failed to start WebSocket server: {}", e);
            }
        } else {
            if !app.is_reload {
                let protocol = if tls_configured { "wss" } else { "ws" };
                debug_log(true, &format!("WebSocket server started on port {} ({})", app.settings.ws_port, protocol));
            }
            app.ws_server = Some(server);
        }
    }

    // Start HTTP/HTTPS server if enabled
    if app.settings.http_enabled {
        if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            #[cfg(feature = "native-tls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true,
                    app.gui_theme_colors().to_css_vars(),
                ).await {
                    Ok(()) => { app.https_server = Some(https_server); }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            eprintln!("Warning: Failed to start HTTPS server: {}", e);
                        }
                    }
                }
            }
            #[cfg(feature = "rustls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true,
                    app.gui_theme_colors().to_css_vars(),
                ).await {
                    Ok(()) => { app.https_server = Some(https_server); }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            eprintln!("Warning: Failed to start HTTPS server: {}", e);
                        }
                    }
                }
            }
        } else {
            let mut http_server = HttpServer::new(app.settings.http_port);
            match start_http_server(
                &mut http_server,
                app.settings.ws_port,
                false,
                app.ban_list.clone(),
                app.gui_theme_colors().to_css_vars(),
            ).await {
                Ok(()) => { app.http_server = Some(http_server); }
                Err(e) => {
                    let err_str = e.to_string();
                    if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                        eprintln!("Warning: Failed to start HTTP server: {}", e);
                    }
                }
            }
        }
    }

    // Re-set gui_tx after potential reload state load (reload clears it)
    app.gui_tx = Some(gui_tx);

    // Send initial state to the GUI
    let initial_state = app.build_initial_state();
    app.ws_broadcast(initial_state);

    // Keepalive interval
    const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(5 * 60);
    let mut keepalive_interval = tokio::time::interval(Duration::from_secs(60));
    keepalive_interval.tick().await;

    // Prompt timeout detection
    let mut prompt_check_interval = tokio::time::interval(Duration::from_millis(150));
    prompt_check_interval.tick().await;

    // TF repeat process ticks
    let mut process_tick_interval = tokio::time::interval(Duration::from_secs(1));
    process_tick_interval.tick().await;

    // Pending count update interval (2 seconds) for Phase 3 output routing
    let mut pending_update_interval = tokio::time::interval(Duration::from_secs(2));
    pending_update_interval.tick().await;

    // SIGUSR1 handler for hot reload
    #[cfg(all(unix, not(target_os = "android")))]
    {
        let sigusr1_tx = event_tx.clone();
        tokio::spawn(async move {
            let mut sigusr1 = match signal(SignalKind::user_defined1()) {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Failed to set up SIGUSR1 handler: {}", e);
                    return;
                }
            };
            loop {
                sigusr1.recv().await;
                let _ = sigusr1_tx.send(AppEvent::Sigusr1Received).await;
            }
        });
    }

    // Run startup actions (including on reload/crash recovery)
    // Note: In headless mode, we only support TF commands (#...) for startup actions
    // since handle_command isn't compatible with spawned tasks
    {
        let startup_actions: Vec<String> = app.settings.actions.iter()
            .filter(|a| a.startup && a.enabled)
            .map(|a| a.command.clone())
            .collect();
        for cmd_str in startup_actions {
            // Split by semicolons and execute each command
            for single_cmd in cmd_str.split(';') {
                let single_cmd = single_cmd.trim();
                if single_cmd.is_empty() { continue; }
                if single_cmd.starts_with('/') {
                    // Unified command system - route through TF parser
                    app.sync_tf_world_info();
                    let _ = app.tf_engine.execute(single_cmd);
                } else {
                    // Plain text can't be run at startup in headless mode
                    debug_log(true, &format!("[Startup] Skipped command (headless): {}", single_cmd));
                }
            }
        }
    }

    debug_log(true, "HEADLESS: Entering main event loop");

    // Main event loop
    loop {
        #[cfg(all(unix, not(target_os = "android")))]
        reap_zombie_children();

        tokio::select! {
            // App events (server data, disconnects, WS client messages)
            Some(event) = event_rx.recv() => {
                match event {
                    AppEvent::ServerData(ref world_name, ref bytes) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            let commands = app.process_server_data(
                                world_idx, bytes, 24, 80, true,
                            );
                            let saved_current_world = app.current_world_index;
                            app.current_world_index = world_idx;
                            for cmd in commands {
                                if cmd.starts_with('/') {
                                    // Unified command system - route through TF parser
                                    app.sync_tf_world_info();
                                    match app.tf_engine.execute(&cmd) {
                                        tf::TfCommandResult::SendToMud(text) => {
                                            if let Some(tx) = &app.worlds[world_idx].command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(text));
                                            }
                                        }
                                        tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                            // Handle Clay-specific commands in daemon mode
                                            let parsed = parse_command(&clay_cmd);
                                            match parsed {
                                                Command::Send { text, target_world, .. } => {
                                                    let target_idx = if let Some(ref w) = target_world {
                                                        app.find_world_index(w)
                                                    } else { Some(world_idx) };
                                                    if let Some(idx) = target_idx {
                                                        if let Some(tx) = &app.worlds[idx].command_tx {
                                                            let _ = tx.send(WriteCommand::Text(text)).await;
                                                        }
                                                    }
                                                }
                                                Command::Notify { message } => {
                                                    let title = if world_idx < app.worlds.len() {
                                                        app.worlds[world_idx].name.clone()
                                                    } else {
                                                        "Clay".to_string()
                                                    };
                                                    app.ws_broadcast(WsMessage::Notification {
                                                        title,
                                                        message: message.clone(),
                                                    });
                                                }
                                                _ => {}
                                            }
                                        }
                                        tf::TfCommandResult::RepeatProcess(process) => {
                                            app.tf_engine.processes.push(process);
                                        }
                                        _ => {}
                                    }
                                } else if let Some(tx) = &app.worlds[world_idx].command_tx {
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                }
                            }
                            app.current_world_index = saved_current_world;
                        }
                    }
                    AppEvent::Disconnected(ref world_name, conn_id) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Ignore stale disconnect from a previous connection
                            if conn_id != app.worlds[world_idx].connection_id {
                                continue;
                            }
                            // Fire TF DISCONNECT hook
                            let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Disconnect);
                            for cmd in hook_result.clay_commands {
                                let _ = app.tf_engine.execute(&cmd);
                            }

                            // Push prompt to output before clearing
                            if !app.worlds[world_idx].prompt.is_empty() {
                                let prompt_text = app.worlds[world_idx].prompt.trim().to_string();
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_text, seq));
                            }
                            app.worlds[world_idx].clear_connection_state(true, true);
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            let disconnect_msg = OutputLine::new_client("Disconnected.".to_string(), seq);
                            app.worlds[world_idx].output_lines.push(disconnect_msg.clone());

                            if world_idx != app.current_world_index {
                                if app.worlds[world_idx].unseen_lines == 0 {
                                    app.worlds[world_idx].first_unseen_at = Some(std::time::Instant::now());
                                }
                                app.worlds[world_idx].unseen_lines += 1;
                            }

                            app.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                                world_index: world_idx,
                                data: "Disconnected.\n".to_string(),
                                is_viewed: true,
                                ts: disconnect_msg.timestamp.duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
                                from_server: false,
                            });
                            app.ws_broadcast(WsMessage::WorldDisconnected { world_index: world_idx });
                        }
                    }
                    AppEvent::WsClientMessage(client_id, msg) => {
                        if let WsMessage::AuthRequest { current_world, .. } = &*msg {
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                            // Mark client as having received initial state so it receives broadcasts
                            app.ws_mark_initial_state_sent(client_id);
                            // Use client's world if provided, otherwise default to console's world
                            let world_idx = current_world
                                .filter(|&w| w < app.worlds.len())
                                .unwrap_or(app.current_world_index);
                            // Set client's initial world so broadcast_to_world_viewers works immediately
                            app.ws_set_client_world(client_id, Some(world_idx));
                            // Also update ws_client_worlds cache for ws_client_viewing()
                            app.ws_client_worlds.insert(client_id, ClientViewState {
                                world_index: world_idx,
                                visible_lines: 0,
                                dimensions: None,
                            });
                        } else {
                            daemon::handle_daemon_ws_message(&mut app, client_id, *msg, &event_tx).await;
                        }
                    }
                    AppEvent::WsClientConnected(_client_id) => {}
                    AppEvent::WsClientDisconnected(client_id) => {
                        app.ws_client_worlds.remove(&client_id);
                    }
                    AppEvent::WsAuthKeyValidation(client_id, msg, client_ip) => {
                        // Validate auth key from AuthRequest
                        if let WsMessage::AuthRequest { auth_key: Some(key), current_world, .. } = *msg {
                            let is_valid = app.settings.websocket_auth_keys.contains(&key);
                            if is_valid {
                                // Key is valid - authenticate the client
                                app.ws_set_client_authenticated(client_id, true);
                                app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                    success: true,
                                    error: None,
                                    username: None,
                                    multiuser_mode: false,
                                });
                                // Send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                                app.ws_mark_initial_state_sent(client_id);
                                // Set client's world
                                let world_idx = current_world
                                    .filter(|&w| w < app.worlds.len())
                                    .unwrap_or(app.current_world_index);
                                app.ws_set_client_world(client_id, Some(world_idx));
                                app.ws_client_worlds.insert(client_id, ClientViewState {
                                    world_index: world_idx,
                                    visible_lines: 0,
                                    dimensions: None,
                                });
                            } else {
                                // Invalid key - record ban violation
                                app.ban_list.record_violation(&client_ip, "WebSocket: failed auth key");
                                app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                    success: false,
                                    error: Some("Invalid auth key".to_string()),
                                    username: None,
                                    multiuser_mode: false,
                                });
                            }
                        }
                    }
                    AppEvent::WsKeyRequest(client_id) => {
                        // Generate a new auth key for the client using SHA256 hash
                        use sha2::{Sha256, Digest};
                        let mut hasher = Sha256::new();
                        hasher.update(std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_nanos()
                            .to_le_bytes());
                        hasher.update(std::process::id().to_le_bytes());
                        hasher.update(client_id.to_le_bytes());
                        // Add number of existing keys for additional uniqueness
                        hasher.update(app.settings.websocket_auth_keys.len().to_le_bytes());
                        let key = hex::encode(hasher.finalize());
                        // Store the key
                        app.settings.websocket_auth_keys.push(key.clone());
                        let _ = persistence::save_settings(&app);
                        // Send to client
                        app.ws_send_to_client(client_id, WsMessage::KeyGenerated { auth_key: key });
                    }
                    AppEvent::WsKeyRevoke(_client_id, key) => {
                        // Remove the key from stored keys
                        app.settings.websocket_auth_keys.retain(|k| k != &key);
                        let _ = persistence::save_settings(&app);
                    }
                    AppEvent::SystemMessage(msg) => {
                        // Add to current world's output and broadcast
                        let seq = app.current_world().next_seq;
                        let world_idx = app.current_world_index;
                        app.worlds[world_idx].next_seq += 1;
                        app.worlds[world_idx].output_lines.push(OutputLine::new_client(msg.clone(), seq));
                        app.ws_broadcast(WsMessage::ServerData {
                            world_index: world_idx,
                            data: format!("{}\n", msg),
                            is_viewed: true,
                            ts: current_timestamp_secs(),
                            from_server: false,
                        });
                    }
                    AppEvent::Sigusr1Received => {
                        #[cfg(all(unix, not(target_os = "android")))]
                        {
                            debug_log(true, "HEADLESS: Received SIGUSR1, triggering reload");
                            app.ws_broadcast(WsMessage::ServerReloading);
                            exec_reload(&app)?;
                            return Ok(());
                        }
                    }
                    // Background connection completed successfully
                    AppEvent::ConnectionSuccess(world_name, cmd_tx, socket_fd, is_tls) => {
                        if let Some(world_idx) = app.find_world_index(&world_name) {
                            app.worlds[world_idx].connected = true;
                            app.worlds[world_idx].was_connected = true;
                            app.worlds[world_idx].prompt_count = 0;
                            let now = std::time::Instant::now();
                            app.worlds[world_idx].last_send_time = Some(now);
                            app.worlds[world_idx].last_receive_time = Some(now);
                            app.worlds[world_idx].is_initial_world = false;
                            app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                            #[cfg(unix)]
                            { app.worlds[world_idx].socket_fd = socket_fd; }
                            app.worlds[world_idx].is_tls = is_tls;

                            // Discard any unused initial world
                            app.discard_initial_world();

                            // Open log file if enabled
                            if app.worlds[world_idx].settings.log_enabled {
                                if app.worlds[world_idx].open_log_file() {
                                    let log_path = app.worlds[world_idx].get_log_path();
                                    app.add_output_to_world(world_idx, &format!("Logging to: {}", log_path.display()));
                                } else {
                                    app.add_output_to_world(world_idx, "Warning: Could not open log file");
                                }
                            }

                            // Fire TF CONNECT hook
                            let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Connect);
                            for cmd in hook_result.send_commands {
                                let _ = cmd_tx.try_send(WriteCommand::Text(cmd));
                            }
                            for cmd in hook_result.clay_commands {
                                let _ = app.tf_engine.execute(&cmd);
                            }

                            // Send auto-login if configured
                            let skip_login = app.worlds[world_idx].skip_auto_login;
                            app.worlds[world_idx].skip_auto_login = false;
                            let user = app.worlds[world_idx].settings.user.clone();
                            let password = app.worlds[world_idx].settings.password.clone();
                            let auto_connect_type = app.worlds[world_idx].settings.auto_connect_type;
                            if !skip_login && !user.is_empty() && !password.is_empty() && auto_connect_type == AutoConnectType::Connect {
                                let connect_cmd = format!("connect {} {}", user, password);
                                let _ = cmd_tx.try_send(WriteCommand::Text(connect_cmd));
                            }

                            // Broadcast connection status
                            app.ws_broadcast(WsMessage::WorldConnected { world_index: world_idx, name: app.worlds[world_idx].name.clone() });
                        }
                    }
                    // Background connection failed
                    AppEvent::ConnectionFailed(world_name, error) => {
                        if let Some(world_idx) = app.find_world_index(&world_name) {
                            app.add_output_to_world(world_idx, &format!("Connection failed: {}", error));
                        }
                    }
                    AppEvent::GmcpNegotiated(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].gmcp_enabled = true;
                            let packages_str = app.worlds[world_idx].settings.gmcp_packages.clone();
                            let packages: Vec<String> = packages_str
                                .split(',')
                                .map(|s| s.trim().to_string())
                                .filter(|s| !s.is_empty())
                                .collect();
                            app.worlds[world_idx].gmcp_supported_packages = packages.clone();
                            if let Some(ref tx) = app.worlds[world_idx].command_tx {
                                let hello = build_gmcp_message("Core.Hello", &format!(
                                    "{{\"client\":\"Clay\",\"version\":\"{}\"}}",
                                    VERSION
                                ));
                                let _ = tx.try_send(WriteCommand::Raw(hello));
                                let json_list: Vec<String> = packages.iter()
                                    .map(|p| format!("\"{}\"", p))
                                    .collect();
                                let supports = build_gmcp_message(
                                    "Core.Supports.Set",
                                    &format!("[{}]", json_list.join(",")),
                                );
                                let _ = tx.try_send(WriteCommand::Raw(supports));
                            }
                        }
                    }
                    AppEvent::MsdpNegotiated(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].msdp_enabled = true;
                        }
                    }
                    AppEvent::GmcpReceived(ref world_name, ref package, ref json_data) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Always store GMCP data
                            app.worlds[world_idx].gmcp_data.insert(package.clone(), json_data.clone());
                            // Always store Client.Media.Default URL (just URL storage, no playback)
                            if package == "Client.Media.Default" {
                                if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(json_data) {
                                    if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                                        app.worlds[world_idx].mcmp_default_url = url.to_string();
                                    }
                                }
                            }
                            // Always broadcast to remote clients (they decide locally)
                            app.ws_broadcast(WsMessage::GmcpData {
                                world_index: world_idx,
                                package: package.clone(),
                                data: json_data.clone(),
                            });
                            if package.starts_with("Client.Media.") {
                                let action = package.rsplit('.').next().unwrap_or("Play").to_string();
                                let default_url = app.worlds[world_idx].mcmp_default_url.clone();
                                app.ws_broadcast(WsMessage::McmpMedia {
                                    world_index: world_idx,
                                    action,
                                    data: json_data.clone(),
                                    default_url,
                                });
                            }
                            // Always track media state; only play audio when enabled + current world
                            if package.starts_with("Client.Media.") {
                                let play_audio = app.worlds[world_idx].gmcp_user_enabled
                                    && world_idx == app.current_world_index;
                                app.handle_gmcp_media(world_idx, package, json_data, play_audio);
                            }
                            // Gate TF hooks on gmcp_user_enabled
                            if app.worlds[world_idx].gmcp_user_enabled {
                                app.tf_engine.set_global("gmcp_package", crate::tf::TfValue::String(package.clone()));
                                app.tf_engine.set_global("gmcp_data", crate::tf::TfValue::String(json_data.clone()));
                                let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Gmcp);
                                for r in results {
                                    if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                        if let Some(world) = app.worlds.get(world_idx) {
                                            if let Some(ref tx) = world.command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(text));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    AppEvent::MsdpReceived(ref world_name, ref variable, ref value_json) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].msdp_variables.insert(variable.clone(), value_json.clone());
                            app.tf_engine.set_global("msdp_var", crate::tf::TfValue::String(variable.clone()));
                            app.tf_engine.set_global("msdp_val", crate::tf::TfValue::String(value_json.clone()));
                            let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Msdp);
                            for r in results {
                                if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                    if let Some(world) = app.worlds.get(world_idx) {
                                        if let Some(ref tx) = world.command_tx {
                                            let _ = tx.try_send(WriteCommand::Text(text));
                                        }
                                    }
                                }
                            }
                            app.ws_broadcast(WsMessage::MsdpData {
                                world_index: world_idx,
                                variable: variable.clone(),
                                value: value_json.clone(),
                            });
                        }
                    }
                    AppEvent::MediaProcessReady(world_idx, key, child, is_music) => {
                        if is_music {
                            app.media_music_key = Some((world_idx, key.clone()));
                        }
                        app.media_processes.insert(key, (world_idx, child));
                    }
                    AppEvent::ApiLookupResult(client_id, world_index, result) => {
                        match result {
                            Ok(text) => app.ws_send_to_client(client_id, WsMessage::SetInputBuffer { text }),
                            Err(e) => app.ws_send_to_client(client_id, WsMessage::ServerData {
                                world_index,
                                data: e,
                                is_viewed: false,
                                ts: current_timestamp_secs(),
                                from_server: false,
                            }),
                        }
                    }
                    _ => {}
                }
            }

            // GUI messages (same format as WsMessage - reuse daemon handler)
            Some(msg) = gui_rx.recv() => {
                // Use client_id 0 for the embedded GUI (not a real WS client)
                daemon::handle_daemon_ws_message(&mut app, 0, msg, &event_tx).await;
            }

            // Keepalive timer
            _ = keepalive_interval.tick() => {
                for world in &mut app.worlds {
                    if world.connected {
                        let last_activity = match (world.last_send_time, world.last_receive_time) {
                            (Some(s), Some(r)) => Some(s.max(r)),
                            (Some(s), None) => Some(s),
                            (None, Some(r)) => Some(r),
                            (None, None) => None,
                        };
                        let should_send = match last_activity {
                            Some(t) => t.elapsed() >= KEEPALIVE_INTERVAL,
                            None => true,
                        };
                        if should_send {
                            if let Some(tx) = &world.command_tx {
                                let now = std::time::Instant::now();
                                match world.settings.keep_alive_type {
                                    KeepAliveType::None => {}
                                    KeepAliveType::Nop => {
                                        let nop = vec![TELNET_IAC, TELNET_NOP];
                                        let _ = tx.try_send(WriteCommand::Raw(nop));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Custom => {
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let idler_tag = format!("###_idler_message_{}_###", rand_num);
                                        let cmd = world.settings.keep_alive_cmd
                                            .replace("##rand##", &idler_tag);
                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Generic => {
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let cmd = format!("help commands ###_idler_message_{}_###", rand_num);
                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                }
                            }
                        }
                    }
                }

                // Check proxy health
                #[cfg(all(unix, not(target_os = "android")))]
                for world in &mut app.worlds {
                    if world.connected {
                        if let Some(proxy_pid) = world.proxy_pid {
                            if !is_process_alive(proxy_pid) {
                                world.clear_connection_state(false, false);
                                let seq = world.next_seq;
                                world.next_seq += 1;
                                world.output_lines.push(OutputLine::new("TLS proxy terminated. Connection lost.".to_string(), seq));
                            }
                        }
                    }
                }
            }

            // Prompt timeout check
            _ = prompt_check_interval.tick() => {
                let now = std::time::Instant::now();
                for world in &mut app.worlds {
                    if let Some(wont_echo_time) = world.wont_echo_time {
                        if now.duration_since(wont_echo_time) >= Duration::from_millis(150) {
                            if !world.trigger_partial_line.is_empty() && world.prompt.is_empty() {
                                let prompt_text = std::mem::take(&mut world.trigger_partial_line);
                                let prompt_clean = prompt_text.replace('\r', "").replace('\n', " ");
                                let normalized = format!("{} ", prompt_clean.trim());

                                if !world.connected {
                                    let seq = world.next_seq;
                                    world.next_seq += 1;
                                    world.output_lines.push(OutputLine::new(normalized.trim().to_string(), seq));
                                    world.wont_echo_time = None;
                                    continue;
                                }

                                world.prompt = normalized;
                                world.prompt_count += 1;

                                // Handle auto-login
                                if !world.skip_auto_login {
                                    let auto_type = world.settings.auto_connect_type;
                                    let user = world.settings.user.clone();
                                    let password = world.settings.password.clone();
                                    let prompt_num = world.prompt_count;

                                    if !user.is_empty() && !password.is_empty() {
                                        let cmd_to_send = match auto_type {
                                            AutoConnectType::Prompt => {
                                                match prompt_num {
                                                    1 => Some(user),
                                                    2 => Some(password),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::MooPrompt => {
                                                match prompt_num {
                                                    1 => Some(user.clone()),
                                                    2 => Some(password),
                                                    3 => Some(user),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::Connect | AutoConnectType::NoLogin => None,
                                        };

                                        if let Some(cmd) = cmd_to_send {
                                            world.prompt.clear();
                                            if let Some(tx) = &world.command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(cmd));
                                            }
                                        }
                                    }
                                }
                            }
                            world.wont_echo_time = None;
                        }
                    }
                }
            }

            // TF repeat process tick
            _ = process_tick_interval.tick() => {
                let now = std::time::Instant::now();
                let mut to_remove = vec![];
                let process_count = app.tf_engine.processes.len();
                for i in 0..process_count {
                    if app.tf_engine.processes[i].on_prompt { continue; }
                    if app.tf_engine.processes[i].next_run <= now {
                        let cmd = app.tf_engine.processes[i].command.clone();
                        let process_world = app.tf_engine.processes[i].world.clone();
                        // Sync world info before executing process command
                        app.sync_tf_world_info();
                        let result = app.tf_engine.execute(&cmd);
                        let target_idx = if let Some(ref wname) = process_world {
                            if wname.is_empty() {
                                Some(app.current_world_index)
                            } else {
                                app.find_world_index(wname)
                            }
                        } else {
                            Some(app.current_world_index)
                        };
                        let world_idx = target_idx.unwrap_or(app.current_world_index);
                        match result {
                            tf::TfCommandResult::SendToMud(text) => {
                                if let Some(idx) = target_idx {
                                    if let Some(tx) = &app.worlds[idx].command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(text));
                                    }
                                }
                            }
                            tf::TfCommandResult::Success(Some(msg)) => {
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new_client(msg.clone(), seq));
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: format!("{}\n", msg),
                                    is_viewed: true,
                                    ts: current_timestamp_secs(),
                                    from_server: false,
                                });
                            }
                            tf::TfCommandResult::Error(err) => {
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                let err_msg = format!("Error: {}", err);
                                app.worlds[world_idx].output_lines.push(OutputLine::new_client(err_msg.clone(), seq));
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: format!("{}\n", err_msg),
                                    is_viewed: true,
                                    ts: current_timestamp_secs(),
                                    from_server: false,
                                });
                            }
                            tf::TfCommandResult::RepeatProcess(process) => {
                                app.tf_engine.processes.push(process);
                            }
                            tf::TfCommandResult::NotTfCommand => {
                                // Plain text command - send to MUD
                                if let Some(idx) = target_idx {
                                    if let Some(tx) = &app.worlds[idx].command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                    }
                                }
                            }
                            _ => {}
                        }
                        let interval = app.tf_engine.processes[i].interval;
                        app.tf_engine.processes[i].next_run += interval;
                        if let Some(ref mut rem) = app.tf_engine.processes[i].remaining {
                            *rem = rem.saturating_sub(1);
                            if *rem == 0 {
                                to_remove.push(i);
                            }
                        }
                    }
                }
                for i in to_remove.into_iter().rev() {
                    app.tf_engine.processes.remove(i);
                }
            }

            // Pending count update timer (every 2 seconds) - broadcast to world viewers if changed
            _ = pending_update_interval.tick() => {
                let now = std::time::Instant::now();
                for world in app.worlds.iter_mut() {
                    // Only send updates if world has pending lines and count has changed
                    let current_count = world.pending_lines.len();
                    if current_count > 0 && current_count != world.last_pending_count_broadcast {
                        // Check if 2 seconds have passed since last broadcast for this world
                        let should_broadcast = world.last_pending_broadcast
                            .map(|t| now.duration_since(t) >= Duration::from_secs(2))
                            .unwrap_or(true);
                        if should_broadcast {
                            world.last_pending_broadcast = Some(now);
                            world.last_pending_count_broadcast = current_count;
                        }
                    } else if current_count == 0 && world.last_pending_count_broadcast > 0 {
                        // Pending was cleared - reset tracking
                        world.last_pending_count_broadcast = 0;
                        world.last_pending_broadcast = None;
                    }
                }
                // Broadcast pending updates for worlds that need it
                for idx in 0..app.worlds.len() {
                    let current_count = app.worlds[idx].pending_lines.len();
                    if current_count > 0 {
                        app.ws_broadcast_to_world(idx, WsMessage::PendingCountUpdate {
                            world_index: idx,
                            count: current_count,
                        });
                    }
                }
            }
        }
    }
}

async fn run_app(terminal: &mut Terminal<CrosstermBackend<io::Stdout>>) -> io::Result<()> {
    let mut app = App::new();

    // Check if we're in reload mode (via --reload command line argument)
    let is_reload = std::env::args().any(|a| a == "--reload");
    app.is_reload = is_reload; // Suppress server startup messages during reload
    // Check if we're recovering from a crash (via --crash command line argument)
    let is_crash = std::env::args().any(|a| a == "--crash");

    // Initialize crash count from environment variable
    let crash_count = get_crash_count();
    CRASH_COUNT.store(crash_count, Ordering::SeqCst);

    // Collect any startup messages to display after ensuring we have a world
    let mut startup_messages: Vec<String> = Vec::new();

    // Crash recovery also loads state like reload
    let should_load_state = is_reload || is_crash;

    if should_load_state {
        // Load the reload state
        debug_log(true, "STARTUP: Loading reload state...");
        match persistence::load_reload_state(&mut app) {
            Ok(true) => {
                debug_log(true, "STARTUP: Reload state loaded successfully");
                // Silent on success - only show errors
            }
            Ok(false) => {
                debug_log(true, "STARTUP: No reload state found");
                startup_messages.push("Warning: No reload state found, starting fresh.".to_string());
                if let Err(e) = persistence::load_settings(&mut app) {
                    startup_messages.push(format!("Warning: Could not load settings: {}", e));
                }
            }
            Err(e) => {
                debug_log(true, &format!("STARTUP: Failed to load reload state: {}", e));
                startup_messages.push(format!("Warning: Failed to load reload state: {}", e));
                if let Err(e) = persistence::load_settings(&mut app) {
                    startup_messages.push(format!("Warning: Could not load settings: {}", e));
                }
            }
        }
    } else {
        // Normal startup - load settings from file
        if let Err(e) = persistence::load_settings(&mut app) {
            startup_messages.push(format!("Warning: Could not load settings: {}", e));
        }
        // On fresh start, clear all runtime state that was persisted for reload
        // These values are meaningless without active connections
        for world in &mut app.worlds {
            world.connected = false;
            world.command_tx = None;
            world.socket_fd = None;
            world.pending_lines.clear();
            world.pending_since = None;
            world.paused = false;
            world.unseen_lines = 0;
            world.first_unseen_at = None;
            world.lines_since_pause = 0;
        }
    }

    // Load theme file (~/clay.theme.dat)
    load_theme_file(&mut app);

    // Ensure we have at least one world (creates initial world only if no worlds loaded)
    debug_log(true, "STARTUP: Ensuring has world...");
    app.ensure_has_world();
    debug_log(true, &format!("STARTUP: Have {} worlds", app.worlds.len()));

    // Re-create spell checker with custom dictionary path if configured
    if !app.settings.dictionary_path.is_empty() {
        app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
    }

    // Note: pending_lines and paused state are preserved across reload
    // so that more-mode continues seamlessly. Disconnected worlds have their
    // pending_lines cleared in the cleanup pass below (line ~17205).

    // Now display any startup messages
    debug_log(true, "STARTUP: Displaying startup messages...");
    for msg in startup_messages {
        app.add_output(&msg);
    }

    debug_log(true, "STARTUP: Creating event channel...");
    let (event_tx, mut event_rx) = mpsc::channel::<AppEvent>(100);
    app.event_tx = Some(event_tx.clone());

    // If in reload or crash recovery mode, reconstruct connections from saved fds
    // FD reconstruction is Unix-only (reload/crash recovery requires exec() which is Unix-only)
    #[cfg(unix)]
    if should_load_state {
        debug_log(true, "STARTUP: Reconstructing connections...");
        // First pass: identify TLS worlds WITHOUT proxy that need to be disconnected
        // TLS worlds WITH proxy will be reconnected via Unix socket
        let mut tls_disconnect_worlds: Vec<usize> = Vec::new();
        for (world_idx, world) in app.worlds.iter().enumerate() {
            if world.connected && world.is_tls && world.proxy_pid.is_none() {
                tls_disconnect_worlds.push(world_idx);
            }
        }

        // Disconnect TLS worlds without proxy
        let tls_msg = if is_crash {
            "TLS connection was closed during crash recovery. Use /worlds to reconnect."
        } else {
            "TLS connection was closed during reload. Use /worlds to reconnect."
        };
        for world_idx in tls_disconnect_worlds {
            app.worlds[world_idx].connected = false;
            app.worlds[world_idx].command_tx = None;
            app.worlds[world_idx].socket_fd = None;
            let seq = app.worlds[world_idx].next_seq;
            app.worlds[world_idx].next_seq += 1;
            app.worlds[world_idx].output_lines.push(OutputLine::new_client(tls_msg.to_string(), seq));
            // If not the current world, set unseen_lines for activity indicator
            if world_idx != app.current_world_index {
                if app.worlds[world_idx].unseen_lines == 0 {
                    app.worlds[world_idx].first_unseen_at = Some(std::time::Instant::now());
                }
                app.worlds[world_idx].unseen_lines += 1;
            }
        }

        // Second pass: reconstruct plain TCP connections
        for world_idx in 0..app.worlds.len() {
            let world = &app.worlds[world_idx];
            if world.connected && world.socket_fd.is_some() && !world.is_tls {
                let fd = world.socket_fd.unwrap();

                // Reconstruct TcpStream from the raw fd
                let tcp_stream = unsafe { std::net::TcpStream::from_raw_fd(fd) };
                tcp_stream.set_nonblocking(true)?;
                let tcp_stream = TcpStream::from_std(tcp_stream)?;

                let (r, w) = tcp_stream.into_split();
                let mut read_half = StreamReader::Plain(r);
                let mut write_half = StreamWriter::Plain(w);

                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                // Skip auto-login for restored connections (only fresh connects should auto-login)
                app.worlds[world_idx].skip_auto_login = true;

                // Re-open log file if enabled
                app.worlds[world_idx].open_log_file();

                // Clone tx for use in reader (for telnet responses)
                let telnet_tx = cmd_tx;

                // Capture world name for the reader task (stable across world deletions)
                let world_name = app.worlds[world_idx].name.clone();
                app.worlds[world_idx].connection_id += 1;
                app.worlds[world_idx].reader_name = Some(world_name.clone());
                let reader_conn_id = app.worlds[world_idx].connection_id;

                // Spawn reader task
                let event_tx_read = event_tx.clone();
                tokio::spawn(async move {
                    let mut buffer = BytesMut::with_capacity(10240);
                    buffer.resize(10240, 0);
                    let mut line_buffer: Vec<u8> = Vec::new();

                    loop {
                        match read_half.read(&mut buffer).await {
                            Ok(0) => {
                                // Send any remaining buffered data
                                if !line_buffer.is_empty() {
                                    let result = process_telnet(&line_buffer);
                                    if !result.responses.is_empty() {
                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                    }
                                    if result.telnet_detected {
                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(world_name.clone())).await;
                                    }
                                    if result.gmcp_negotiated {
                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(world_name.clone())).await;
                                    }
                                    if result.msdp_negotiated {
                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(world_name.clone())).await;
                                    }
                                    for (pkg, json) in &result.gmcp_data {
                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(world_name.clone(), pkg.clone(), json.clone())).await;
                                    }
                                    for (var, val) in &result.msdp_data {
                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(world_name.clone(), var.clone(), val.clone())).await;
                                    }
                                    // Send prompt FIRST for immediate auto-login response
                                    if let Some(prompt_bytes) = result.prompt {
                                        let _ = event_tx_read.send(AppEvent::Prompt(world_name.clone(), prompt_bytes)).await;
                                    }
                                    // Send remaining data
                                    if !result.cleaned.is_empty() {
                                        let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), result.cleaned)).await;
                                    }
                                }
                                let _ = event_tx_read
                                    .send(AppEvent::ServerData(
                                        world_name.clone(),
                                        "Connection closed by server.\n".as_bytes().to_vec(),
                                    ))
                                    .await;
                                let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                                break;
                            }
                            Ok(n) => {
                                // Append new data to line buffer
                                line_buffer.extend_from_slice(&buffer[..n]);

                                // Find safe split point (complete lines with complete ANSI sequences)
                                let split_at = find_safe_split_point(&line_buffer);

                                // Send data immediately - either up to split point, or all if no incomplete sequences
                                let to_send = if split_at > 0 {
                                    line_buffer.drain(..split_at).collect()
                                } else if !line_buffer.is_empty() {
                                    // No safe split point but we have data - send it anyway
                                    std::mem::take(&mut line_buffer)
                                } else {
                                    Vec::new()
                                };

                                if !to_send.is_empty() {
                                    // Process telnet sequences
                                    let result = process_telnet(&to_send);

                                    // Send telnet responses if any
                                    if !result.responses.is_empty() {
                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                    }

                                    // Notify if telnet detected
                                    if result.telnet_detected {
                                        let _ = event_tx_read
                                            .send(AppEvent::TelnetDetected(world_name.clone()))
                                            .await;
                                    }

                                    // Notify if NAWS was requested (server sent DO NAWS)
                                    if result.naws_requested {
                                        let _ = event_tx_read
                                            .send(AppEvent::NawsRequested(world_name.clone()))
                                            .await;
                                    }

                                    // Notify if TTYPE was requested (server sent SB TTYPE SEND)
                                    if result.ttype_requested {
                                        let _ = event_tx_read
                                            .send(AppEvent::TtypeRequested(world_name.clone()))
                                            .await;
                                    }

                                    // Notify GMCP/MSDP negotiation and data
                                    if result.gmcp_negotiated {
                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(world_name.clone())).await;
                                    }
                                    if result.msdp_negotiated {
                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(world_name.clone())).await;
                                    }
                                    for (pkg, json) in &result.gmcp_data {
                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(world_name.clone(), pkg.clone(), json.clone())).await;
                                    }
                                    for (var, val) in &result.msdp_data {
                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(world_name.clone(), var.clone(), val.clone())).await;
                                    }

                                    // Send prompt FIRST if detected via telnet GA/EOR
                                    if let Some(prompt_bytes) = result.prompt {
                                        let _ = event_tx_read
                                            .send(AppEvent::Prompt(world_name.clone(), prompt_bytes))
                                            .await;
                                    }

                                    // Send cleaned data to main loop
                                    if !result.cleaned.is_empty()
                                        && event_tx_read
                                            .send(AppEvent::ServerData(world_name.clone(), result.cleaned))
                                            .await
                                            .is_err()
                                    {
                                        break;
                                    }
                                }
                            }
                            Err(e) => {
                                let msg = format!("Read error: {}", e);
                                let _ = event_tx_read
                                    .send(AppEvent::ServerData(world_name.clone(), msg.into_bytes()))
                                    .await;
                                let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                                break;
                            }
                        }
                    }
                });

                // Spawn writer task
                tokio::spawn(async move {
                    while let Some(cmd) = cmd_rx.recv().await {
                        match cmd {
                            WriteCommand::Text(text) => {
                                let bytes = format!("{}\r\n", text).into_bytes();
                                if write_half.write_all(&bytes).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Raw(raw) => {
                                if write_half.write_all(&raw).await.is_err() {
                                    break;
                                }
                            }
                            WriteCommand::Shutdown => {
                                let _ = write_half.shutdown().await;
                                break;
                            }
                        }
                    }
                });
            }
        }

        // Third pass: restore TLS proxy connections
        // The proxy is designed to accept reconnections - when exec() happens, the old
        // client connection closes and the proxy waits for a new connection on its listener.
        // We reconnect via the Unix socket path rather than trying to preserve FDs.
        for world_idx in 0..app.worlds.len() {
            let world = &app.worlds[world_idx];
            if world.connected && world.is_tls && world.proxy_pid.is_some() {
                let proxy_pid = world.proxy_pid.unwrap();
                let socket_path = world.proxy_socket_path.clone();

                // Check if proxy is still alive
                let proxy_alive = is_process_alive(proxy_pid);

                if !proxy_alive {
                    // Proxy died, mark disconnected
                    app.worlds[world_idx].clear_connection_state(false, false);
                    let seq = app.worlds[world_idx].next_seq;
                    app.worlds[world_idx].next_seq += 1;
                    app.worlds[world_idx].output_lines.push(OutputLine::new(
                        "TLS proxy terminated during reload. Use /worlds to reconnect.".to_string(), seq
                    ));
                    continue;
                }

                // Reconnect to proxy via Unix socket with retry logic
                // The proxy accepts reconnections after the old client disconnects
                let unix_stream: Option<tokio::net::UnixStream> = if let Some(ref path) = socket_path {
                    if path.exists() {
                        let mut result = None;
                        // More attempts with longer delays to give proxy time to accept
                        for attempt in 0..20 {
                            match tokio::net::UnixStream::connect(path).await {
                                Ok(stream) => {
                                    result = Some(stream);
                                    break;
                                }
                                Err(_) => {
                                    if attempt < 19 {
                                        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                                    }
                                }
                            }
                        }
                        result
                    } else {
                        None
                    }
                } else {
                    None
                };

                match unix_stream {
                    Some(unix_stream) => {
                        // Store the new FD for future reloads
                        #[cfg(unix)]
                        {
                            use std::os::unix::io::AsRawFd;
                            let new_fd = unix_stream.as_raw_fd();
                            app.worlds[world_idx].proxy_socket_fd = Some(new_fd);
                        }
                        let (r, w) = unix_stream.into_split();
                        let mut read_half = StreamReader::Proxy(r);
                        let mut write_half = StreamWriter::Proxy(w);

                        let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                        app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                        app.worlds[world_idx].skip_auto_login = true;

                        // Re-open log file if enabled
                        app.worlds[world_idx].open_log_file();

                        let world_name = app.worlds[world_idx].name.clone();
                        app.worlds[world_idx].connection_id += 1;
                        app.worlds[world_idx].reader_name = Some(world_name.clone());
                        let reader_conn_id = app.worlds[world_idx].connection_id;

                        // Spawn reader task with telnet processing
                        let event_tx_read = event_tx.clone();
                        let telnet_tx = cmd_tx.clone();
                        tokio::spawn(async move {
                            let mut buf = [0u8; 4096];
                            let mut line_buffer = Vec::new();
                            loop {
                                match tokio::io::AsyncReadExt::read(&mut read_half, &mut buf).await {
                                    Ok(0) => {
                                        if !line_buffer.is_empty() {
                                            let result = process_telnet(&line_buffer);
                                            if !result.responses.is_empty() {
                                                let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                            }
                                            if result.telnet_detected {
                                                let _ = event_tx_read.send(AppEvent::TelnetDetected(world_name.clone())).await;
                                            }
                                            if result.gmcp_negotiated {
                                                let _ = event_tx_read.send(AppEvent::GmcpNegotiated(world_name.clone())).await;
                                            }
                                            if result.msdp_negotiated {
                                                let _ = event_tx_read.send(AppEvent::MsdpNegotiated(world_name.clone())).await;
                                            }
                                            for (pkg, json) in &result.gmcp_data {
                                                let _ = event_tx_read.send(AppEvent::GmcpReceived(world_name.clone(), pkg.clone(), json.clone())).await;
                                            }
                                            for (var, val) in &result.msdp_data {
                                                let _ = event_tx_read.send(AppEvent::MsdpReceived(world_name.clone(), var.clone(), val.clone())).await;
                                            }
                                            if let Some(prompt_bytes) = result.prompt {
                                                let _ = event_tx_read.send(AppEvent::Prompt(world_name.clone(), prompt_bytes)).await;
                                            }
                                            if !result.cleaned.is_empty() {
                                                let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), result.cleaned)).await;
                                            }
                                        }
                                        let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                                        break;
                                    }
                                    Ok(n) => {
                                        line_buffer.extend_from_slice(&buf[..n]);
                                        let split_at = find_safe_split_point(&line_buffer);
                                        let to_send = if split_at > 0 {
                                            line_buffer.drain(..split_at).collect()
                                        } else if !line_buffer.is_empty() {
                                            std::mem::take(&mut line_buffer)
                                        } else {
                                            Vec::new()
                                        };
                                        if !to_send.is_empty() {
                                            let result = process_telnet(&to_send);
                                            if !result.responses.is_empty() {
                                                let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                            }
                                            if result.telnet_detected {
                                                let _ = event_tx_read.send(AppEvent::TelnetDetected(world_name.clone())).await;
                                            }
                                            if result.naws_requested {
                                                let _ = event_tx_read.send(AppEvent::NawsRequested(world_name.clone())).await;
                                            }
                                            if result.ttype_requested {
                                                let _ = event_tx_read.send(AppEvent::TtypeRequested(world_name.clone())).await;
                                            }
                                            if result.gmcp_negotiated {
                                                let _ = event_tx_read.send(AppEvent::GmcpNegotiated(world_name.clone())).await;
                                            }
                                            if result.msdp_negotiated {
                                                let _ = event_tx_read.send(AppEvent::MsdpNegotiated(world_name.clone())).await;
                                            }
                                            for (pkg, json) in &result.gmcp_data {
                                                let _ = event_tx_read.send(AppEvent::GmcpReceived(world_name.clone(), pkg.clone(), json.clone())).await;
                                            }
                                            for (var, val) in &result.msdp_data {
                                                let _ = event_tx_read.send(AppEvent::MsdpReceived(world_name.clone(), var.clone(), val.clone())).await;
                                            }
                                            if let Some(prompt_bytes) = result.prompt {
                                                let _ = event_tx_read.send(AppEvent::Prompt(world_name.clone(), prompt_bytes)).await;
                                            }
                                            if !result.cleaned.is_empty() {
                                                let _ = event_tx_read.send(AppEvent::ServerData(world_name.clone(), result.cleaned)).await;
                                            }
                                        }
                                    }
                                    Err(_) => {
                                        let _ = event_tx_read.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                                        break;
                                    }
                                }
                            }
                        });

                        // Spawn writer task
                        tokio::spawn(async move {
                            while let Some(cmd) = cmd_rx.recv().await {
                                let bytes = match &cmd {
                                    WriteCommand::Text(text) => {
                                        let mut b = text.as_bytes().to_vec();
                                        b.extend_from_slice(b"\r\n");
                                        b
                                    }
                                    WriteCommand::Raw(raw) => raw.clone(),
                                    WriteCommand::Shutdown => break,
                                };
                                if tokio::io::AsyncWriteExt::write_all(&mut write_half, &bytes).await.is_err() {
                                    break;
                                }
                            }
                        });
                    }
                    None => {
                        // Failed to reconnect
                        app.worlds[world_idx].clear_connection_state(false, false);
                        let seq = app.worlds[world_idx].next_seq;
                        app.worlds[world_idx].next_seq += 1;
                        app.worlds[world_idx].output_lines.push(OutputLine::new(
                            "Failed to reconnect to TLS proxy. Use /worlds to reconnect.".to_string(), seq
                        ));
                    }
                }
            }
        }

        // Final cleanup pass: mark any world as disconnected if it claims to be connected
        // but has no command channel (meaning the connection wasn't successfully reconstructed)
        for world in &mut app.worlds {
            if world.connected && world.command_tx.is_none() {
                world.connected = false;
                world.socket_fd = None;
                let seq = world.next_seq;
                world.next_seq += 1;
                world.output_lines
                    .push(OutputLine::new("Connection was not restored during reload. Use /worlds to reconnect.".to_string(), seq));
            }

            // For ALL worlds: flush pending_lines to output_lines so content isn't lost,
            // then clear more-mode state. This prevents stale activity indicators after reload.
            if !world.pending_lines.is_empty() {
                world.output_lines.append(&mut world.pending_lines);
                // Update scroll_offset to include the newly appended lines
                world.scroll_offset = world.output_lines.len().saturating_sub(1);
            } else if world.scroll_offset >= world.output_lines.len() {
                // Only adjust if scroll_offset is past the end (shouldn't happen, but be safe)
                world.scroll_offset = world.output_lines.len().saturating_sub(1);
            }
            world.pending_since = None;
            world.paused = false;

            // Clear unseen_lines for disconnected worlds only
            // (connected worlds may have received new output during reload)
            if !world.connected {
                world.unseen_lines = 0;
                world.first_unseen_at = None;
            }
        }

        debug_log(true, "STARTUP: Connection cleanup done, sending keepalives...");

        // Send immediate keepalive for all reconnected worlds since we don't know how long they were idle
        for world in &mut app.worlds {
            if world.connected {
                if let Some(tx) = &world.command_tx {
                    let now = std::time::Instant::now();

                    match world.settings.keep_alive_type {
                        KeepAliveType::None => {
                            // Keepalive disabled - still initialize timing fields for /connections display
                            world.last_send_time = Some(now);
                            world.last_receive_time = Some(now);
                        }
                        KeepAliveType::Nop => {
                            let nop = vec![TELNET_IAC, TELNET_NOP];
                            let _ = tx.try_send(WriteCommand::Raw(nop));
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                        KeepAliveType::Custom => {
                            let rand_num = (std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_nanos() % 1000 + 1) as u32;
                            let idler_tag = format!("###_idler_message_{}_###", rand_num);
                            let cmd = world.settings.keep_alive_cmd
                                .replace("##rand##", &idler_tag);
                            let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                        KeepAliveType::Generic => {
                            let rand_num = (std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_nanos() % 1000 + 1) as u32;
                            let cmd = format!("help commands ###_idler_message_{}_###", rand_num);
                            let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                            world.last_send_time = Some(now);
                            world.last_nop_time = Some(now);
                        }
                    }
                }
            }
        }
    }

    debug_log(true, "STARTUP: Keepalives sent, starting servers...");

    // Start WebSocket server if enabled (ws:// or wss:// based on web_secure setting)
    if app.settings.ws_enabled && !app.settings.websocket_password.is_empty() {
        let mut server = WebSocketServer::new(
            &app.settings.websocket_password,
            app.settings.ws_port,
            &app.settings.websocket_allow_list,
            app.settings.websocket_whitelisted_host.clone(),
            app.multiuser_mode,
            app.ban_list.clone(),
        );

        // Configure TLS if secure mode and cert/key files are specified
        #[cfg(feature = "native-tls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => {
                    app.add_output(&format!("Warning: Failed to configure WSS TLS: {}", e));
                    false
                }
            }
        } else {
            false
        };
        #[cfg(feature = "rustls-backend")]
        let tls_configured = if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            match server.configure_tls(&app.settings.websocket_cert_file, &app.settings.websocket_key_file) {
                Ok(()) => true,
                Err(e) => {
                    app.add_output(&format!("Warning: Failed to configure WSS TLS: {}", e));
                    false
                }
            }
        } else {
            false
        };

        if let Err(e) = start_websocket_server(&mut server, event_tx.clone()).await {
            // Don't show error if port is in use (likely another clay instance)
            let err_str = e.to_string();
            if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                app.add_output(&format!("Warning: Failed to start WebSocket server: {}", e));
            }
        } else {
            if !app.is_reload {
                let protocol = if tls_configured { "wss" } else { "ws" };
                app.add_output(&format!("WebSocket server started on port {} ({})", app.settings.ws_port, protocol));
            }
            app.ws_server = Some(server);
        }
    }

    // Start HTTP/HTTPS web interface server if enabled
    if app.settings.http_enabled {
        if app.settings.web_secure
            && !app.settings.websocket_cert_file.is_empty()
            && !app.settings.websocket_key_file.is_empty()
        {
            // Start HTTPS server (secure mode)
            #[cfg(feature = "native-tls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true, // HTTPS uses secure WebSocket (wss://)
                    app.gui_theme_colors().to_css_vars(),
                ).await {
                    Ok(()) => {
                        if !app.is_reload {
                            app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                        }
                        app.https_server = Some(https_server);
                    }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                        }
                    }
                }
            }
            #[cfg(feature = "rustls-backend")]
            {
                let mut https_server = HttpsServer::new(app.settings.http_port);
                match start_https_server(
                    &mut https_server,
                    &app.settings.websocket_cert_file,
                    &app.settings.websocket_key_file,
                    app.settings.ws_port,
                    true, // HTTPS uses secure WebSocket (wss://)
                    app.gui_theme_colors().to_css_vars(),
                ).await {
                    Ok(()) => {
                        if !app.is_reload {
                            app.add_output(&format!("HTTPS web interface started on port {} (wss://localhost:{})", app.settings.http_port, app.settings.ws_port));
                        }
                        app.https_server = Some(https_server);
                    }
                    Err(e) => {
                        let err_str = e.to_string();
                        if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                            app.add_output(&format!("Warning: Failed to start HTTPS server: {}", e));
                        }
                    }
                }
            }
        } else {
            // Start HTTP server (non-secure mode)
            let mut http_server = HttpServer::new(app.settings.http_port);
            match start_http_server(
                &mut http_server,
                app.settings.ws_port,
                false, // HTTP uses non-secure WebSocket (ws://)
                app.ban_list.clone(),
                app.gui_theme_colors().to_css_vars(),
            ).await {
                Ok(()) => {
                    if !app.is_reload {
                        app.add_output(&format!("HTTP web interface started on port {} (ws://localhost:{})", app.settings.http_port, app.settings.ws_port));
                    }
                    app.http_server = Some(http_server);
                }
                Err(e) => {
                    let err_str = e.to_string();
                    if !err_str.contains("Address in use") && !err_str.contains("address already in use") {
                        app.add_output(&format!("Warning: Failed to start HTTP server: {}", e));
                    }
                }
            }
        }
    }

    // Keepalive: send NOP every 5 minutes if telnet mode and idle
    const KEEPALIVE_INTERVAL: Duration = Duration::from_secs(5 * 60);

    // Use async event stream instead of polling to reduce CPU usage
    let mut event_stream = EventStream::new();

    // Spawn SIGUSR1 handler task for hot reload (not available on Android or Windows)
    #[cfg(all(unix, not(target_os = "android")))]
    {
        let sigusr1_tx = event_tx.clone();
        tokio::spawn(async move {
            let mut sigusr1 = match signal(SignalKind::user_defined1()) {
                Ok(s) => s,
                Err(e) => {
                    eprintln!("Failed to set up SIGUSR1 handler: {}", e);
                    return;
                }
            };
            loop {
                sigusr1.recv().await;
                let _ = sigusr1_tx.send(AppEvent::Sigusr1Received).await;
            }
        });
    }

    // Initial draw - after reload, we need to force a complete redraw
    // because the terminal state may be inconsistent
    terminal.clear()?;
    // Force ratatui to redraw everything by resizing (clears internal buffer cache)
    terminal.resize(terminal.size()?)?;
    terminal.draw(|f| ui(f, &mut app))?;
    // Render output with crossterm (needed after reload when ratatui early-returns)
    render_output_crossterm(&app);
    // Flush stdout to ensure everything is displayed
    std::io::Write::flush(&mut std::io::stdout())?;

    // Create a persistent interval for periodic tasks (clock updates, keepalive checks)
    let mut keepalive_interval = tokio::time::interval(Duration::from_secs(60));
    // Skip the first tick which fires immediately
    keepalive_interval.tick().await;

    // Create interval for prompt timeout detection (150ms)
    let mut prompt_check_interval = tokio::time::interval(Duration::from_millis(150));
    prompt_check_interval.tick().await;

    // Create interval for TF repeat process ticks (1 second)
    let mut process_tick_interval = tokio::time::interval(Duration::from_secs(1));
    process_tick_interval.tick().await;

    // Pending count update interval (2 seconds) for Phase 3 output routing
    let mut pending_update_interval = tokio::time::interval(Duration::from_secs(2));
    pending_update_interval.tick().await;

    // Set the app pointer for crash recovery
    // SAFETY: app lives for the duration of this function and the pointer is only used
    // in the panic hook which only runs while this function is on the stack
    set_app_ptr(&mut app as *mut App);

    // Track if we've cleared the crash count after successful user input
    let mut crash_count_cleared = false;

    // Run startup actions (including on reload/crash recovery)
    {
        let startup_actions: Vec<String> = app.settings.actions.iter()
            .filter(|a| a.startup && a.enabled)
            .map(|a| a.command.clone())
            .collect();
        for cmd_str in startup_actions {
            // Split by semicolons and execute each command
            for single_cmd in cmd_str.split(';') {
                let single_cmd = single_cmd.trim();
                if single_cmd.is_empty() { continue; }
                if single_cmd.starts_with('/') {
                    // Unified command system - route through TF parser
                    app.sync_tf_world_info();
                    match app.tf_engine.execute(single_cmd) {
                        tf::TfCommandResult::Success(Some(msg)) => {
                            app.add_output(&msg);
                        }
                        tf::TfCommandResult::Error(err) => {
                            app.add_output(&format!("Error: {}", err));
                        }
                        tf::TfCommandResult::ClayCommand(clay_cmd) => {
                            handle_command(&clay_cmd, &mut app, event_tx.clone()).await;
                        }
                        tf::TfCommandResult::RepeatProcess(process) => {
                            app.tf_engine.processes.push(process);
                        }
                        _ => {}
                    }
                } else {
                    // Text to send to server - but we're not connected yet
                    // Just add it to output as a note
                    app.add_output(&format!("[Startup] Would send: {}", single_cmd));
                }
            }
        }
    }

    debug_log(true, "STARTUP: Entering main event loop");

    // Counter for debugging first few loop iterations
    let mut loop_count: u64 = 0;

    loop {
        loop_count += 1;
        // Log first 5 iterations to debug early crashes
        if loop_count <= 5 {
            debug_log(true, &format!("LOOP: iteration {}", loop_count));
        }

        // Reap any zombie child processes (TLS proxies that have exited)
        // This is a fast non-blocking call that prevents defunct processes from accumulating
        #[cfg(all(unix, not(target_os = "android")))]
        reap_zombie_children();

        // Use tokio::select! to efficiently wait for events without busy-polling
        tokio::select! {
            // Terminal events (keyboard input)
            maybe_event = event_stream.next() => {
                if let Some(Ok(Event::Key(key))) = maybe_event {
                    if key.kind != KeyEventKind::Press { continue; }
                    match handle_key_event(key, &mut app) {
                        KeyAction::Quit => return Ok(()),
                        KeyAction::Redraw => {
                            // Filter output to only show server data (remove client-generated lines)
                            app.current_world_mut().filter_to_server_output();
                            terminal.clear()?;
                            app.needs_output_redraw = true;
                        }
                        KeyAction::Connect => {
                            if !app.current_world().connected
                                && handle_command("/connect", &mut app, event_tx.clone()).await
                            {
                                return Ok(());
                            }
                        }
                        KeyAction::Reload => {
                            if handle_command("/reload", &mut app, event_tx.clone()).await {
                                return Ok(());
                            }
                        }
                        KeyAction::Suspend => {
                            // Process suspension not available on Android or Windows
                            #[cfg(all(unix, not(target_os = "android")))]
                            {
                                // Restore terminal to normal mode before suspending
                                disable_raw_mode()?;
                                execute!(std::io::stdout(), LeaveAlternateScreen)?;

                                // Send SIGTSTP to self to suspend
                                unsafe {
                                    libc::kill(libc::getpid(), libc::SIGTSTP);
                                }

                                // When we resume (after fg), re-enter raw mode and redraw
                                enable_raw_mode()?;
                                execute!(std::io::stdout(), EnterAlternateScreen)?;
                                terminal.clear()?;
                                app.needs_output_redraw = true;
                            }
                            #[cfg(any(target_os = "android", not(unix)))]
                            {
                                app.add_output("Process suspension (Ctrl+Z) is not available on this platform.");
                            }
                        }
                        KeyAction::SendCommand(cmd) => {
                            // Clear splash on first user input (same as server data)
                            if app.current_world().showing_splash {
                                let world = app.current_world_mut();
                                world.showing_splash = false;
                                world.needs_redraw = true;
                                world.output_lines.clear();
                                world.scroll_offset = 0;
                                terminal.clear()?;
                                terminal.resize(terminal.size()?)?;
                            }
                            // Clear crash count after first successful user input
                            // This indicates the client is stable and running normally
                            if !crash_count_cleared {
                                clear_crash_count();
                                crash_count_cleared = true;
                            }

                            app.spell_state.reset();
                            app.suggestion_message = None;

                            // Check for TF-style /N pattern shorthand (e.g., /10 *combat*)
                            if cmd.starts_with('/') && cmd.len() > 1 {
                                let rest = &cmd[1..];
                                // Check if it starts with a number followed by space and pattern
                                if let Some(space_pos) = rest.find(char::is_whitespace) {
                                    let num_part = &rest[..space_pos];
                                    if num_part.chars().all(|c| c.is_ascii_digit()) && !num_part.is_empty() {
                                        let pattern = rest[space_pos..].trim();
                                        if !pattern.is_empty() {
                                            // Convert to #recall /N pattern - sync world info first
                                            app.sync_tf_world_info();
                                            let recall_cmd = format!("#recall /{} {}", num_part, pattern);
                                            match app.tf_engine.execute(&recall_cmd) {
                                                tf::TfCommandResult::Recall(opts) => {
                                                    let output_lines = app.current_world().output_lines.clone();
                                                    let (matches, header) = execute_recall(&opts, &output_lines);
                                                    let pattern_str = opts.pattern.as_deref().unwrap_or("*");

                                                    if !opts.quiet {
                                                        if let Some(h) = header {
                                                            app.add_tf_output(&h);
                                                        }
                                                    }
                                                    if matches.is_empty() {
                                                        app.add_tf_output(&format!("No matches for '{}'", pattern_str));
                                                    } else {
                                                        for m in &matches {
                                                            app.add_tf_output(m);
                                                        }
                                                    }
                                                    if !opts.quiet {
                                                        app.add_tf_output("================= Recall end =================");
                                                    }
                                                }
                                                tf::TfCommandResult::Error(err) => {
                                                    app.add_tf_output(&format!("Error: {}", err));
                                                }
                                                _ => {}
                                            }
                                            continue;
                                        }
                                    }
                                }
                            }

                            if cmd.starts_with('/') {
                                // Unified command system - route through TF parser first
                                // TF parser will return ClayCommand for Clay-specific commands
                                app.sync_tf_world_info();
                                match app.tf_engine.execute(&cmd) {
                                    tf::TfCommandResult::Success(Some(msg)) => {
                                        app.add_tf_output(&msg);
                                    }
                                    tf::TfCommandResult::Success(None) => {
                                        // Silent success
                                    }
                                    tf::TfCommandResult::Error(err) => {
                                        app.add_tf_output(&format!("Error: {}", err));
                                    }
                                    tf::TfCommandResult::SendToMud(text) => {
                                        if app.current_world().connected {
                                            if let Some(tx) = &app.current_world().command_tx {
                                                if tx.send(WriteCommand::Text(text)).await.is_err() {
                                                    app.add_tf_output("Failed to send command");
                                                } else {
                                                    let now = std::time::Instant::now();
                                                    app.current_world_mut().last_send_time = Some(now);
                                                    app.current_world_mut().last_user_command_time = Some(now);
                                                    app.current_world_mut().prompt.clear();
                                                    // Reset more-mode counter after successfully sending
                                                    app.current_world_mut().lines_since_pause = 0;
                                                }
                                            }
                                        } else {
                                            app.add_output("Not connected. Use /worlds to connect.");
                                        }
                                    }
                                    tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                        if handle_command(&clay_cmd, &mut app, event_tx.clone()).await {
                                            return Ok(());
                                        }
                                    }
                                    tf::TfCommandResult::Recall(opts) => {
                                        let output_lines = app.current_world().output_lines.clone();
                                        let (matches, header) = execute_recall(&opts, &output_lines);
                                        let pattern_str = opts.pattern.as_deref().unwrap_or("*");

                                        if !opts.quiet {
                                            if let Some(h) = header {
                                                app.add_output(&h);
                                            }
                                        }
                                        if matches.is_empty() {
                                            app.add_output(&format!("No matches for '{}'", pattern_str));
                                        } else {
                                            for m in &matches {
                                                app.add_output(m);
                                            }
                                        }
                                        if !opts.quiet {
                                            app.add_output("================= Recall end =================");
                                        }
                                    }
                                    tf::TfCommandResult::RepeatProcess(process) => {
                                        let id = process.id;
                                        let interval = format_duration_short(process.interval);
                                        let count_str = process.count.map_or("infinite".to_string(), |c| c.to_string());
                                        let cmd = process.command.clone();
                                        app.tf_engine.processes.push(process);
                                        app.add_tf_output(&format!("% Process {} started: {} every {} ({} times)", id, cmd, interval, count_str));
                                    }
                                    tf::TfCommandResult::Quote { mut lines, disposition, world, delay_secs, recall_opts } => {
                                        // If this is a /quote with backtick /recall, execute the recall now
                                        if let Some((opts, recall_prefix)) = recall_opts {
                                            let output_lines = app.current_world().output_lines.clone();
                                            let (matches, _header) = execute_recall(&opts, &output_lines);
                                            lines = matches.iter()
                                                .map(|line| format!("{}{}", recall_prefix, line))
                                                .collect();
                                            if lines.is_empty() {
                                                let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                                                app.add_tf_output(&format!("(no recall matches for '{}')", pattern_str));
                                            }
                                        }

                                        // Determine target world
                                        let target_world = if let Some(ref world_name) = world {
                                            Some(world_name.clone())
                                        } else {
                                            Some(app.current_world().name.clone())
                                        };
                                        let target_idx = if let Some(ref world_name) = world {
                                            app.worlds.iter().position(|w| w.name == *world_name)
                                        } else {
                                            Some(app.current_world_index)
                                        };

                                        if delay_secs > 0.0 && lines.len() > 1 {
                                            // Schedule as processes with delays
                                            let delay = std::time::Duration::from_secs_f64(delay_secs);
                                            let now = std::time::Instant::now();
                                            for (i, line) in lines.into_iter().enumerate() {
                                                let cmd = match disposition {
                                                    tf::QuoteDisposition::Send => line,
                                                    tf::QuoteDisposition::Echo => format!("#echo {}", line),
                                                    tf::QuoteDisposition::Exec => line,
                                                };
                                                let id = app.tf_engine.next_process_id;
                                                app.tf_engine.next_process_id += 1;
                                                let process = tf::TfProcess {
                                                    id,
                                                    command: cmd,
                                                    interval: delay,
                                                    count: Some(1),
                                                    remaining: Some(1),
                                                    next_run: now + delay * i as u32,
                                                    world: target_world.clone(),
                                                    synchronous: false,
                                                    on_prompt: false,
                                                    priority: 0,
                                                };
                                                app.tf_engine.processes.push(process);
                                            }
                                        } else {
                                            // Send immediately (no delay or single line)
                                            for line in lines {
                                                match disposition {
                                                    tf::QuoteDisposition::Send => {
                                                        if let Some(idx) = target_idx {
                                                            if app.worlds[idx].connected {
                                                                if let Some(tx) = &app.worlds[idx].command_tx {
                                                                    let _ = tx.send(WriteCommand::Text(line)).await;
                                                                }
                                                            } else {
                                                                app.add_output("Not connected");
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    tf::QuoteDisposition::Echo => {
                                                        app.add_output(&line);
                                                    }
                                                    tf::QuoteDisposition::Exec => {
                                                        // Execute each line as a TF command
                                                        let result = app.tf_engine.execute(&line);
                                                        match result {
                                                            tf::TfCommandResult::SendToMud(text) => {
                                                                if let Some(idx) = target_idx {
                                                                    if let Some(tx) = &app.worlds[idx].command_tx {
                                                                        let _ = tx.send(WriteCommand::Text(text)).await;
                                                                    }
                                                                }
                                                            }
                                                            tf::TfCommandResult::Success(Some(msg)) => {
                                                                app.add_output(&msg);
                                                            }
                                                            tf::TfCommandResult::Error(err) => {
                                                                app.add_output(&format!("Error: {}", err));
                                                            }
                                                            _ => {}
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    tf::TfCommandResult::NotTfCommand => {
                                        // Shouldn't happen since we checked for / or #
                                        app.add_output("Internal error: not a command");
                                    }
                                    tf::TfCommandResult::UnknownCommand(cmd_name) => {
                                        // Show the command with its original prefix
                                        let prefix = if cmd_name.starts_with("//") { "" } else if cmd.starts_with('/') { "/" } else { "#" };
                                        app.add_output(&format!("Unknown command: {}{}", prefix, cmd_name));
                                    }
                                    tf::TfCommandResult::ExitLoad => {
                                        // ExitLoad from command line means nothing (not in a file load)
                                        // This shouldn't normally happen since cmd_exit checks loading_files
                                    }
                                }
                                // Process any pending world operations from TF functions like addworld()
                                process_pending_world_ops(&mut app);
                                // Process any pending commands from TF macro execution
                                process_pending_tf_commands(&mut app);
                                // Process any pending keyboard operations from TF functions like kbgoto()
                                app.process_pending_keyboard_ops();
                            } else if app.current_world().connected {
                                if let Some(tx) = &app.current_world().command_tx {
                                    if tx.send(WriteCommand::Text(cmd)).await.is_err() {
                                        app.add_output("Failed to send command");
                                    } else {
                                        let now = std::time::Instant::now();
                                        app.current_world_mut().last_send_time = Some(now);
                                        app.current_world_mut().last_user_command_time = Some(now);
                                        app.current_world_mut().prompt.clear();
                                        // Reset more-mode counter after successfully sending command
                                        // This ensures the counter is 0 when the server response arrives
                                        app.current_world_mut().lines_since_pause = 0;
                                    }
                                }
                            } else {
                                app.add_output("Not connected. Use /worlds to connect.");
                            }
                        }
                        KeyAction::SwitchedWorld(_world_index) => {
                            // UnseenCleared is now broadcast by switch_world() itself
                        }
                        KeyAction::None => {}
                    }
                    app.check_word_ended();
                    app.check_temp_conversion();
                }
            }

            // Server events (data from MUD connections)
            Some(event) = event_rx.recv() => {
                match event {
                    AppEvent::ServerData(ref world_name, bytes) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Use shared server data processing
                            let console_height = app.output_height;
                            let console_width = app.output_width;
                            let commands = app.process_server_data(
                                world_idx,
                                &bytes,
                                console_height,
                                console_width,
                                false, // not daemon mode
                            );

                            // Check if terminal needs full redraw (after splash clear)
                            if app.worlds[world_idx].needs_redraw {
                                app.worlds[world_idx].needs_redraw = false;
                                terminal.clear()?;
                            }

                            // Execute any triggered commands
                            // Temporarily set current_world to the triggering world so /send
                            // without -w sends to the world that triggered the action
                            let saved_current_world = app.current_world_index;
                            app.current_world_index = world_idx;
                            for cmd in commands {
                                if cmd.starts_with('/') {
                                    // Unified command system - route through TF parser
                                    app.sync_tf_world_info();
                                    match app.tf_engine.execute(&cmd) {
                                        tf::TfCommandResult::SendToMud(text) => {
                                            if let Some(tx) = &app.worlds[world_idx].command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(text));
                                            }
                                        }
                                        tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                            handle_command(&clay_cmd, &mut app, event_tx.clone()).await;
                                        }
                                        tf::TfCommandResult::RepeatProcess(process) => {
                                            app.tf_engine.processes.push(process);
                                        }
                                        _ => {}
                                    }
                                } else if let Some(tx) = &app.worlds[world_idx].command_tx {
                                    // Plain text - send to MUD
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                }
                            }
                            app.current_world_index = saved_current_world;
                        }
                    }
                    AppEvent::Disconnected(ref world_name, conn_id) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Ignore stale disconnect from a previous connection
                            if conn_id != app.worlds[world_idx].connection_id {
                                continue;
                            }
                            // Fire TF DISCONNECT hook before cleaning up
                            let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Disconnect);
                            for cmd in hook_result.clay_commands {
                                let _ = app.tf_engine.execute(&cmd);
                            }

                            // Push prompt to output before clearing
                            if !app.worlds[world_idx].prompt.is_empty() {
                                let prompt_text = app.worlds[world_idx].prompt.trim().to_string();
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_text, seq));
                            }
                            app.worlds[world_idx].clear_connection_state(true, true);
                            // Show disconnection message
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            let disconnect_msg = OutputLine::new_client("Disconnected.".to_string(), seq);
                            app.worlds[world_idx].output_lines.push(disconnect_msg.clone());

                            // If this is not the current world, increment unseen_lines for activity indicator
                            if world_idx != app.current_world_index {
                                if app.worlds[world_idx].unseen_lines == 0 {
                                    app.worlds[world_idx].first_unseen_at = Some(std::time::Instant::now());
                                }
                                app.worlds[world_idx].unseen_lines += 1;
                            }

                            // Broadcast disconnect message to WebSocket clients
                            app.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                                world_index: world_idx,
                                data: "Disconnected.\n".to_string(),
                                is_viewed: true,
                                ts: disconnect_msg.timestamp.duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
                                from_server: false,
                            });
                            app.ws_broadcast(WsMessage::WorldDisconnected { world_index: world_idx });
                        }
                    }
                    AppEvent::TelnetDetected(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            if !app.worlds[world_idx].telnet_mode {
                                app.worlds[world_idx].telnet_mode = true;
                            }
                        }
                    }
                    AppEvent::WontEchoSeen(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            if !app.worlds[world_idx].uses_wont_echo_prompt {
                                app.worlds[world_idx].uses_wont_echo_prompt = true;
                            }
                        }
                    }
                    AppEvent::NawsRequested(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Mark NAWS as enabled for this world
                            app.worlds[world_idx].naws_enabled = true;
                            // Send initial window size
                            app.send_naws_if_changed(world_idx);
                        }
                    }
                    AppEvent::TtypeRequested(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Send terminal type response
                            // Use TERM environment variable if set, otherwise default to "ANSI"
                            let term_type = std::env::var("TERM").unwrap_or_else(|_| "ANSI".to_string());
                            if let Some(ref tx) = app.worlds[world_idx].command_tx {
                                let ttype_response = build_ttype_response(&term_type);
                                let _ = tx.try_send(WriteCommand::Raw(ttype_response));
                            }
                        }
                    }
                    AppEvent::GmcpNegotiated(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].gmcp_enabled = true;
                            // Build supports list from world settings
                            let packages_str = app.worlds[world_idx].settings.gmcp_packages.clone();
                            let packages: Vec<String> = packages_str
                                .split(',')
                                .map(|s| s.trim().to_string())
                                .filter(|s| !s.is_empty())
                                .collect();
                            app.worlds[world_idx].gmcp_supported_packages = packages.clone();
                            // Send Core.Hello and Core.Supports.Set
                            if let Some(ref tx) = app.worlds[world_idx].command_tx {
                                let hello = build_gmcp_message("Core.Hello", &format!(
                                    "{{\"client\":\"Clay\",\"version\":\"{}\"}}",
                                    VERSION
                                ));
                                let _ = tx.try_send(WriteCommand::Raw(hello));
                                let json_list: Vec<String> = packages.iter()
                                    .map(|p| format!("\"{}\"", p))
                                    .collect();
                                let supports = build_gmcp_message(
                                    "Core.Supports.Set",
                                    &format!("[{}]", json_list.join(",")),
                                );
                                let _ = tx.try_send(WriteCommand::Raw(supports));
                            }
                        }
                    }
                    AppEvent::MsdpNegotiated(ref world_name) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].msdp_enabled = true;
                        }
                    }
                    AppEvent::GmcpReceived(ref world_name, ref package, ref json_data) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Always store GMCP data
                            app.worlds[world_idx].gmcp_data.insert(package.clone(), json_data.clone());
                            // Always store Client.Media.Default URL
                            if package == "Client.Media.Default" {
                                if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(json_data) {
                                    if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                                        app.worlds[world_idx].mcmp_default_url = url.to_string();
                                    }
                                }
                            }
                            // Always broadcast to remote clients
                            app.ws_broadcast(WsMessage::GmcpData {
                                world_index: world_idx,
                                package: package.clone(),
                                data: json_data.clone(),
                            });
                            if package.starts_with("Client.Media.") {
                                let action = package.rsplit('.').next().unwrap_or("Play").to_string();
                                let default_url = app.worlds[world_idx].mcmp_default_url.clone();
                                app.ws_broadcast(WsMessage::McmpMedia {
                                    world_index: world_idx,
                                    action,
                                    data: json_data.clone(),
                                    default_url,
                                });
                            }
                            // Always track media state; only play audio when enabled + current world
                            if package.starts_with("Client.Media.") {
                                let play_audio = app.worlds[world_idx].gmcp_user_enabled
                                    && world_idx == app.current_world_index;
                                app.handle_gmcp_media(world_idx, package, json_data, play_audio);
                            }
                            // Gate TF hooks on gmcp_user_enabled
                            if app.worlds[world_idx].gmcp_user_enabled {
                                app.tf_engine.set_global("gmcp_package", crate::tf::TfValue::String(package.clone()));
                                app.tf_engine.set_global("gmcp_data", crate::tf::TfValue::String(json_data.clone()));
                                let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Gmcp);
                                for r in results {
                                    if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                        if let Some(world) = app.worlds.get(world_idx) {
                                            if let Some(ref tx) = world.command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(text));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    AppEvent::MsdpReceived(ref world_name, ref variable, ref value_json) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            // Store MSDP variable
                            app.worlds[world_idx].msdp_variables.insert(variable.clone(), value_json.clone());
                            // Fire TF MSDP hook
                            app.tf_engine.set_global("msdp_var", crate::tf::TfValue::String(variable.clone()));
                            app.tf_engine.set_global("msdp_val", crate::tf::TfValue::String(value_json.clone()));
                            let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Msdp);
                            for r in results {
                                if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                    if let Some(world) = app.worlds.get(world_idx) {
                                        if let Some(ref tx) = world.command_tx {
                                            let _ = tx.try_send(WriteCommand::Text(text));
                                        }
                                    }
                                }
                            }
                            // Broadcast to WebSocket clients
                            app.ws_broadcast(WsMessage::MsdpData {
                                world_index: world_idx,
                                variable: variable.clone(),
                                value: value_json.clone(),
                            });
                        }
                    }
                    AppEvent::Prompt(ref world_name, prompt_bytes) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                            let encoding = app.worlds[world_idx].settings.encoding;
                            let prompt_text = encoding.decode(&prompt_bytes);
                            let prompt_normalized = crate::util::normalize_prompt(&prompt_text);

                            // If world is not connected, display prompt as output instead of input area
                            if !app.worlds[world_idx].connected {
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_normalized.trim().to_string(), seq));
                                app.worlds[world_idx].prompt.clear();
                                continue;
                            }

                            app.worlds[world_idx].prompt = prompt_normalized.clone();

                            // Broadcast prompt to WebSocket clients
                            app.ws_broadcast(WsMessage::PromptUpdate {
                                world_index: world_idx,
                                prompt: prompt_normalized,
                            });

                            let world = &mut app.worlds[world_idx];
                            world.prompt_count += 1;

                            // Skip auto-login if flag is set (from /worlds -l)
                            if world.skip_auto_login {
                                continue;
                            }

                            let auto_type = world.settings.auto_connect_type;
                            let user = world.settings.user.clone();
                            let password = world.settings.password.clone();
                            let prompt_num = world.prompt_count;

                            if !user.is_empty() && !password.is_empty() {
                                let cmd_to_send = match auto_type {
                                    AutoConnectType::Prompt => {
                                        match prompt_num {
                                            1 if !user.is_empty() => Some(user),
                                            2 if !password.is_empty() => Some(password),
                                            _ => None,
                                        }
                                    }
                                    AutoConnectType::MooPrompt => {
                                        match prompt_num {
                                            1 if !user.is_empty() => Some(user.clone()),
                                            2 if !password.is_empty() => Some(password),
                                            3 if !user.is_empty() => Some(user),
                                            _ => None,
                                        }
                                    }
                                    AutoConnectType::Connect | AutoConnectType::NoLogin => None,
                                };

                                if let Some(cmd) = cmd_to_send {
                                    if let Some(tx) = &world.command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                        world.last_send_time = Some(std::time::Instant::now());
                                        // Clear prompt since we auto-answered it
                                        world.prompt.clear();
                                    }
                                }
                            }
                        }
                    }
                    AppEvent::SystemMessage(message) => {
                        // Display system message in current world's output
                        app.add_output(&message);
                    }
                    AppEvent::Sigusr1Received => {
                        // SIGUSR1 received - trigger hot reload (only on non-Android)
                        debug_log(true, "LOOP: Received SIGUSR1 via event channel");
                        app.add_output("Received SIGUSR1, performing hot reload...");
                        if handle_command("/reload", &mut app, event_tx.clone()).await {
                            return Ok(());
                        }
                    }
                    // Multiuser events are only used in multiuser mode, ignore in normal mode
                    AppEvent::ConnectWorldRequest(_, _) => {}
                    AppEvent::MultiuserServerData(_, _, _) => {}
                    AppEvent::MultiuserDisconnected(_, _) => {}
                    AppEvent::MultiuserTelnetDetected(_, _) => {}
                    AppEvent::MultiuserPrompt(_, _, _) => {}
                    // Slack/Discord events
                    AppEvent::SlackMessage(ref world_name, message) | AppEvent::DiscordMessage(ref world_name, message) => {
                        if let Some(world_idx) = app.find_world_index(world_name) {
                            app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                            let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                            let world_name_for_triggers = world_name.clone();
                            let actions = app.settings.actions.clone();

                            // Check action triggers on the message
                            let mut is_gagged = false;
                            let mut commands_to_execute: Vec<String> = Vec::new();
                            let mut tf_commands_to_execute: Vec<String> = Vec::new();
                            if let Some(result) = check_action_triggers(&message, &world_name_for_triggers, &actions) {
                                commands_to_execute = result.commands;
                                is_gagged = result.should_gag;
                            }
                            // Check TF triggers
                            let tf_result = tf::bridge::process_line(&mut app.tf_engine, &message, Some(&world_name_for_triggers));
                            commands_to_execute.extend(tf_result.send_commands);
                            tf_commands_to_execute.extend(tf_result.clay_commands);
                            for msg in &tf_result.messages {
                                app.add_tf_output(msg);
                            }
                            is_gagged = is_gagged || tf_result.should_gag;
                            // Handle substitution
                            if let Some((sub_text, sub_attrs)) = tf_result.substitution {
                                is_gagged = true;
                                let sub_with_attrs = if sub_attrs.contains('C') || sub_attrs.contains('B') {
                                    apply_tf_attrs(&sub_text, &sub_attrs)
                                } else {
                                    sub_text
                                };
                                app.add_tf_output(&sub_with_attrs);
                            }

                            let data = format!("{}\n", message);

                            if is_gagged {
                                // Add as gagged line (only visible with F2)
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(message.clone(), seq));
                                if !app.worlds[world_idx].paused {
                                    app.worlds[world_idx].scroll_to_bottom();
                                }
                            } else {
                                // Add non-gagged output normally
                                let settings = app.settings.clone();
                                let console_height = app.output_height;
                                let output_width = app.output_width;

                                // Calculate minimum visible lines among all viewers for synchronized more-mode
                                let console_viewing = world_idx == app.current_world_index;
                                let ws_min = app.min_viewer_lines(world_idx);
                                let output_height = match (console_viewing, ws_min) {
                                    (true, Some(ws)) => console_height.min(ws as u16),
                                    (true, None) => console_height,
                                    (false, Some(ws)) => ws as u16,
                                    (false, None) => console_height,
                                };

                                // Track pending count before add_output for synchronized more-mode
                                let pending_before = app.worlds[world_idx].pending_lines.len();
                                let output_before = app.worlds[world_idx].output_lines.len();

                                app.worlds[world_idx].add_output(&data, is_current, &settings, output_height, output_width, true, true);

                                // Calculate what went where
                                let pending_after = app.worlds[world_idx].pending_lines.len();
                                let output_after = app.worlds[world_idx].output_lines.len();
                                let lines_to_output = output_after.saturating_sub(output_before);
                                let lines_to_pending = pending_after.saturating_sub(pending_before);

                                // For synchronized more-mode: only broadcast lines that went to output_lines
                                if lines_to_output > 0 {
                                    let output_lines_to_broadcast: Vec<String> = app.worlds[world_idx]
                                        .output_lines
                                        .iter()
                                        .skip(output_before)
                                        .take(lines_to_output)
                                        .map(|line| line.text.replace('\r', ""))
                                        .collect();
                                    let ws_data = output_lines_to_broadcast.join("\n") + "\n";
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index: world_idx,
                                        data: ws_data,
                                        is_viewed: is_current,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }

                                // Broadcast pending count update if it changed
                                // Use filtered broadcast to skip clients that received pending in InitialState
                                if lines_to_pending > 0 || pending_after != pending_before {
                                    app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: pending_after });
                                }

                                // Broadcast updated unseen count so all clients stay in sync
                                let unseen_count = app.worlds[world_idx].unseen_lines;
                                if unseen_count > 0 {
                                    app.ws_broadcast(WsMessage::UnseenUpdate {
                                        world_index: world_idx,
                                        count: unseen_count,
                                    });
                                }

                                // Broadcast activity count to keep all clients in sync
                                app.broadcast_activity();
                            }

                            // Execute any triggered commands
                            // Temporarily set current_world to the triggering world so /send
                            // without -w sends to the world that triggered the action
                            let saved_current_world = app.current_world_index;
                            app.current_world_index = world_idx;
                            for cmd in commands_to_execute {
                                if cmd.starts_with('/') {
                                    // Unified command system - route through TF parser
                                    app.sync_tf_world_info();
                                    match app.tf_engine.execute(&cmd) {
                                        tf::TfCommandResult::SendToMud(text) => {
                                            if let Some(tx) = &app.worlds[world_idx].command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(text));
                                            }
                                        }
                                        tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                            handle_command(&clay_cmd, &mut app, event_tx.clone()).await;
                                        }
                                        tf::TfCommandResult::RepeatProcess(process) => {
                                            app.tf_engine.processes.push(process);
                                        }
                                        _ => {}
                                    }
                                } else if let Some(tx) = &app.worlds[world_idx].command_tx {
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                }
                            }
                            app.current_world_index = saved_current_world;
                            // Execute TF-generated Clay commands
                            for cmd in tf_commands_to_execute {
                                let _ = app.tf_engine.execute(&cmd);
                            }
                        }
                    }
                    // WebSocket events
                    AppEvent::WsClientConnected(_client_id) => {
                        // Client connected but not yet authenticated - nothing to do
                    }
                    AppEvent::WsClientDisconnected(client_id) => {
                        // Client disconnected - remove from ws_client_worlds cache
                        let had_dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions).is_some();
                        app.ws_client_worlds.remove(&client_id);
                        // If client had dimensions, recalculate minimum and send NAWS updates
                        if had_dimensions {
                            app.send_naws_to_all_worlds();
                        }
                    }
                    AppEvent::WsAuthKeyValidation(client_id, msg, client_ip) => {
                        // Validate auth key from AuthRequest
                        if let WsMessage::AuthRequest { auth_key: Some(key), current_world, .. } = *msg {
                            let is_valid = app.settings.websocket_auth_keys.contains(&key);
                            if is_valid {
                                // Key is valid - authenticate the client
                                app.ws_set_client_authenticated(client_id, true);
                                app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                    success: true,
                                    error: None,
                                    username: None,
                                    multiuser_mode: false,
                                });
                                // Send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                                app.ws_mark_initial_state_sent(client_id);
                                // Set client's world
                                let world_idx = current_world
                                    .filter(|&w| w < app.worlds.len())
                                    .unwrap_or(app.current_world_index);
                                app.ws_set_client_world(client_id, Some(world_idx));
                                app.ws_client_worlds.insert(client_id, ClientViewState {
                                    world_index: world_idx,
                                    visible_lines: 0,
                                    dimensions: None,
                                });
                                // Send activity count
                                app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                    count: app.activity_count(),
                                });
                            } else {
                                // Invalid key - record ban violation
                                app.ban_list.record_violation(&client_ip, "WebSocket: failed auth key");
                                app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                    success: false,
                                    error: Some("Invalid auth key".to_string()),
                                    username: None,
                                    multiuser_mode: false,
                                });
                            }
                        }
                    }
                    AppEvent::WsKeyRequest(client_id) => {
                        // Generate a new auth key for the client using SHA256 hash
                        use sha2::{Sha256, Digest};
                        let mut hasher = Sha256::new();
                        hasher.update(std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_nanos()
                            .to_le_bytes());
                        hasher.update(std::process::id().to_le_bytes());
                        hasher.update(client_id.to_le_bytes());
                        hasher.update(app.settings.websocket_auth_keys.len().to_le_bytes());
                        let key = hex::encode(hasher.finalize());
                        app.settings.websocket_auth_keys.push(key.clone());
                        let _ = persistence::save_settings(&app);
                        app.ws_send_to_client(client_id, WsMessage::KeyGenerated { auth_key: key });
                    }
                    AppEvent::WsKeyRevoke(_client_id, key) => {
                        app.settings.websocket_auth_keys.retain(|k| k != &key);
                        let _ = persistence::save_settings(&app);
                    }
                    AppEvent::WsClientMessage(client_id, msg) => {
                        // Extract current_world from AuthRequest before matching (avoids borrow issues)
                        let auth_current_world = if let WsMessage::AuthRequest { current_world, .. } = &*msg {
                            *current_world
                        } else {
                            None
                        };
                        match *msg {
                            WsMessage::AuthRequest { .. } => {
                                // Client just authenticated - send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                                // Mark client as having received initial state so it receives broadcasts
                                app.ws_mark_initial_state_sent(client_id);
                                // Use client's world if provided, otherwise default to console's world
                                let world_idx = auth_current_world
                                    .filter(|&w| w < app.worlds.len())
                                    .unwrap_or(app.current_world_index);
                                // Set client's initial world so broadcast_to_world_viewers works immediately
                                app.ws_set_client_world(client_id, Some(world_idx));
                                // Also update ws_client_worlds cache for ws_client_viewing()
                                app.ws_client_worlds.insert(client_id, ClientViewState {
                                    world_index: world_idx,
                                    visible_lines: 0,
                                    dimensions: None,
                                });
                                // Also send current activity count
                                app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                    count: app.activity_count(),
                                });
                            }
                            WsMessage::SendCommand { world_index, ref command } => {

                                // Reset more-mode counter when ANY client sends a command
                                if world_index < app.worlds.len() {
                                    app.worlds[world_index].lines_since_pause = 0;
                                    app.worlds[world_index].last_user_command_time = Some(std::time::Instant::now());
                                    // Update client's viewing world to ensure they receive output
                                    // (fixes race condition where client sends command before UpdateViewState)
                                    let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                    let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                    app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                    app.ws_set_client_world(client_id, Some(world_index));
                                }

                                // Use shared command parsing
                                let parsed = parse_command(command);

                                match parsed {
                                    // Commands handled locally on server
                                    Command::ActionCommand { name, args } => {
                                        // Execute action if it exists
                                        if let Some(action) = app.settings.actions.iter().find(|a| a.name.eq_ignore_ascii_case(&name)) {
                                            // Skip disabled actions
                                            if !action.enabled {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("âœ¨ Action '{}' is disabled.", name),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            } else {
                                            let commands = split_action_commands(&action.command);
                                            let mut sent_to_server = false;
                                            for cmd in commands {
                                                // Substitute $1-$9 and $* with arguments
                                                let cmd = substitute_action_args(&cmd, &args);

                                                if cmd.eq_ignore_ascii_case("/gag") || cmd.to_lowercase().starts_with("/gag ") {
                                                    continue;
                                                }
                                                // Unified command system - route through TF parser
                                                if cmd.starts_with('/') {
                                                    app.sync_tf_world_info();
                                                    match app.tf_engine.execute(&cmd) {
                                                        tf::TfCommandResult::Success(Some(msg)) => {
                                                            app.ws_broadcast(WsMessage::ServerData {
                                                                world_index,
                                                                data: msg,
                                                                is_viewed: false,
                                                                ts: current_timestamp_secs(),
                                                                from_server: false,
                                                            });
                                                        }
                                                        tf::TfCommandResult::Success(None) => {}
                                                        tf::TfCommandResult::Error(err) => {
                                                            app.ws_broadcast(WsMessage::ServerData {
                                                                world_index,
                                                                data: format!("Error: {}", err),
                                                                is_viewed: false,
                                                                ts: current_timestamp_secs(),
                                                                from_server: false,
                                                            });
                                                        }
                                                        tf::TfCommandResult::SendToMud(text) => {
                                                            if world_index < app.worlds.len() {
                                                                if let Some(tx) = &app.worlds[world_index].command_tx {
                                                                    let _ = tx.try_send(WriteCommand::Text(text));
                                                                    sent_to_server = true;
                                                                }
                                                            }
                                                        }
                                                        tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                                            app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: clay_cmd });
                                                        }
                                                        tf::TfCommandResult::Recall(opts) => {
                                                            if world_index < app.worlds.len() {
                                                                let output_lines = app.worlds[world_index].output_lines.clone();
                                                                let (matches, header) = execute_recall(&opts, &output_lines);
                                                                let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                                                                let ts = current_timestamp_secs();

                                                                if !opts.quiet {
                                                                    if let Some(h) = header {
                                                                        app.ws_broadcast(WsMessage::ServerData { world_index, data: h, is_viewed: false, ts , from_server: false });
                                                                    }
                                                                }
                                                                if matches.is_empty() {
                                                                    app.ws_broadcast(WsMessage::ServerData { world_index, data: format!("âœ¨ No matches for '{}'", pattern_str), is_viewed: false, ts, from_server: false });
                                                                } else {
                                                                    for m in matches {
                                                                        app.ws_broadcast(WsMessage::ServerData { world_index, data: m, is_viewed: false, ts , from_server: false });
                                                                    }
                                                                }
                                                                if !opts.quiet {
                                                                    app.ws_broadcast(WsMessage::ServerData { world_index, data: "================= Recall end =================".to_string(), is_viewed: false, ts , from_server: false });
                                                                }
                                                            }
                                                        }
                                                        tf::TfCommandResult::RepeatProcess(process) => {
                                                            app.tf_engine.processes.push(process);
                                                        }
                                                        _ => {}
                                                    }
                                                } else if world_index < app.worlds.len() {
                                                    // Plain text - send to MUD server
                                                    if let Some(tx) = &app.worlds[world_index].command_tx {
                                                        let _ = tx.try_send(WriteCommand::Text(cmd));
                                                        sent_to_server = true;
                                                    }
                                                }
                                            }
                                            if sent_to_server {
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                            }
                                            }
                                        } else {
                                            // No matching action - try TF engine (handles /recall, /set, /echo, etc.)
                                            app.sync_tf_world_info();
                                            match app.tf_engine.execute(command) {
                                                tf::TfCommandResult::Success(Some(msg)) => {
                                                    app.ws_broadcast(WsMessage::ServerData {
                                                        world_index, data: msg, is_viewed: false,
                                                        ts: current_timestamp_secs(), from_server: false,
                                                    });
                                                }
                                                tf::TfCommandResult::Success(None) => {}
                                                tf::TfCommandResult::Error(err) => {
                                                    app.ws_broadcast(WsMessage::ServerData {
                                                        world_index, data: format!("Error: {}", err), is_viewed: false,
                                                        ts: current_timestamp_secs(), from_server: false,
                                                    });
                                                }
                                                tf::TfCommandResult::SendToMud(text) => {
                                                    if world_index < app.worlds.len() {
                                                        if let Some(tx) = &app.worlds[world_index].command_tx {
                                                            let _ = tx.try_send(WriteCommand::Text(text));
                                                            app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                        }
                                                    }
                                                }
                                                tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                                    app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: clay_cmd });
                                                }
                                                tf::TfCommandResult::Recall(opts) => {
                                                    if world_index < app.worlds.len() {
                                                        let output_lines = app.worlds[world_index].output_lines.clone();
                                                        let (matches, header) = execute_recall(&opts, &output_lines);
                                                        let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                                                        let ts = current_timestamp_secs();
                                                        if !opts.quiet {
                                                            if let Some(h) = header {
                                                                app.ws_broadcast(WsMessage::ServerData { world_index, data: h, is_viewed: false, ts, from_server: false });
                                                            }
                                                        }
                                                        if matches.is_empty() {
                                                            app.ws_broadcast(WsMessage::ServerData { world_index, data: format!("âœ¨ No matches for '{}'", pattern_str), is_viewed: false, ts, from_server: false });
                                                        } else {
                                                            for m in matches {
                                                                app.ws_broadcast(WsMessage::ServerData { world_index, data: m, is_viewed: false, ts, from_server: false });
                                                            }
                                                        }
                                                        if !opts.quiet {
                                                            app.ws_broadcast(WsMessage::ServerData { world_index, data: "================= Recall end =================".to_string(), is_viewed: false, ts, from_server: false });
                                                        }
                                                    }
                                                }
                                                tf::TfCommandResult::RepeatProcess(process) => {
                                                    app.tf_engine.processes.push(process);
                                                }
                                                _ => {
                                                    app.ws_broadcast(WsMessage::ServerData {
                                                        world_index,
                                                        data: format!("Unknown command: /{}", name),
                                                        is_viewed: false,
                                                        ts: current_timestamp_secs(),
                                                        from_server: false,
                                                    });
                                                }
                                            }
                                        }
                                    }
                                    Command::NotACommand { text } => {
                                        // Regular text - send to MUD
                                        if world_index < app.worlds.len() {
                                            if let Some(tx) = &app.worlds[world_index].command_tx {
                                                if tx.try_send(WriteCommand::Text(text)).is_ok() {
                                                    app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                    app.worlds[world_index].prompt.clear();
                                                }
                                            }
                                        }
                                    }
                                    Command::Edit { .. } => {
                                        // Edit command is handled locally on the client, not on server
                                        // Send back to client for local execution
                                        app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                    }
                                    Command::Tag => {
                                        // Toggle show_tags setting (same as F2)
                                        app.show_tags = !app.show_tags;
                                        app.ws_broadcast(WsMessage::ShowTagsChanged { show_tags: app.show_tags });
                                    }
                                    Command::Unknown { cmd } => {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Unknown command: {}", cmd),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::Send { text, all_worlds, target_world, no_newline } => {
                                        // Handle /send command
                                        // Helper to create the write command
                                        let make_write_cmd = |t: &str| -> WriteCommand {
                                            if no_newline {
                                                WriteCommand::Raw(t.as_bytes().to_vec())
                                            } else {
                                                WriteCommand::Text(t.to_string())
                                            }
                                        };

                                        if all_worlds {
                                            // Send to all connected worlds
                                            for world in app.worlds.iter_mut() {
                                                if world.connected {
                                                    if let Some(tx) = &world.command_tx {
                                                        let _ = tx.try_send(make_write_cmd(&text));
                                                        world.last_send_time = Some(std::time::Instant::now());
                                                    }
                                                }
                                            }
                                        } else if let Some(ref target) = target_world {
                                            // Send to specific world by name
                                            if let Some(world) = app.worlds.iter_mut().find(|w| w.name.eq_ignore_ascii_case(target)) {
                                                if world.connected {
                                                    if let Some(tx) = &world.command_tx {
                                                        let _ = tx.try_send(make_write_cmd(&text));
                                                        world.last_send_time = Some(std::time::Instant::now());
                                                    }
                                                } else {
                                                    app.ws_broadcast(WsMessage::ServerData {
                                                        world_index,
                                                        data: format!("World '{}' is not connected.", target),
                                                        is_viewed: false,
                                                        ts: current_timestamp_secs(),
                                                        from_server: false,
                                                    });
                                                }
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("Unknown world: {}", target),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        } else {
                                            // Send to current world (the one this command came from)
                                            if world_index < app.worlds.len() {
                                                if let Some(tx) = &app.worlds[world_index].command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                }
                                            }
                                        }
                                    }
                                    Command::Disconnect => {
                                        // Disconnect the specified world
                                        if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                            // Kill proxy process if one exists
                                            #[cfg(unix)]
                                            if let Some(proxy_pid) = app.worlds[world_index].proxy_pid {
                                                unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                            }
                                            app.worlds[world_index].clear_connection_state(true, true);
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "Disconnected.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                            app.ws_broadcast(WsMessage::WorldDisconnected { world_index });
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "Not connected.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                    }
                                    Command::Flush => {
                                        // Clear output buffer for this world
                                        if world_index < app.worlds.len() {
                                            let line_count = app.worlds[world_index].output_lines.len();
                                            app.worlds[world_index].output_lines.clear();
                                            app.worlds[world_index].pending_lines.clear();
                                            app.worlds[world_index].scroll_offset = 0;
                                            app.worlds[world_index].lines_since_pause = 0;
                                            app.worlds[world_index].paused = false;
                                            app.ws_broadcast(WsMessage::WorldFlushed { world_index });
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Flushed {} lines from output buffer.", line_count),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                    }
                                    Command::Keepalive => {
                                        // Show keepalive settings for this world
                                        if world_index < app.worlds.len() {
                                            let world = &app.worlds[world_index];
                                            let info = format!(
                                                "Keepalive: {} ({})",
                                                world.settings.keep_alive_type.name(),
                                                if world.settings.keep_alive_type == KeepAliveType::Custom {
                                                    world.settings.keep_alive_cmd.clone()
                                                } else {
                                                    world.settings.keep_alive_type.name().to_string()
                                                }
                                            );
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: info,
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                    }
                                    Command::Gag { pattern } => {
                                        // TODO: Implement gag patterns storage
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Gag pattern set: {}", pattern),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::BanList => {
                                        // Send current ban list
                                        let bans = app.ban_list.get_ban_info();
                                        if bans.is_empty() {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: "No hosts are currently banned.".to_string(),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        } else {
                                            let mut output = String::new();
                                            output.push_str("\nBanned Hosts:\n");
                                            output.push_str(&"â”€".repeat(70));
                                            output.push_str(&format!("\n{:<20} {:<12} {}\n", "Host", "Type", "Last URL/Reason"));
                                            output.push_str(&"â”€".repeat(70));
                                            output.push('\n');
                                            for (ip, ban_type, reason) in &bans {
                                                let reason_display = if reason.is_empty() { "(unknown)" } else { reason };
                                                output.push_str(&format!("{:<20} {:<12} {}\n", ip, ban_type, reason_display));
                                            }
                                            output.push_str(&"â”€".repeat(70));
                                            output.push_str("\nUse /unban <host> to remove a ban.");
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: output,
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                        app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                                    }
                                    Command::Unban { host } => {
                                        if app.ban_list.remove_ban(&host) {
                                            // Save settings to persist the change
                                            let _ = persistence::save_settings(&app);
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Removed ban for: {}", host),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                            // Broadcast updated ban list
                                            app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                            app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("No ban found for: {}", host),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                            app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                        }
                                    }
                                    Command::TestMusic => {
                                        // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
                                        let test_notes = vec![
                                            ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                                            ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                                            ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                                            ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                                            ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
                                        ];
                                        // Play locally on console via mpv/ffplay
                                        if let Some(ref player_cmd) = app.media_player_cmd {
                                            let wav_data = generate_wav_from_notes(&test_notes);
                                            let _ = std::fs::create_dir_all(&app.media_cache_dir);
                                            let wav_path = app.media_cache_dir.join("ansi_music.wav");
                                            if std::fs::write(&wav_path, &wav_data).is_ok() {
                                                let wav_path_str = wav_path.to_string_lossy().to_string();
                                                let player = player_cmd.clone();
                                                std::thread::spawn(move || {
                                                    let mut cmd = std::process::Command::new(&player);
                                                    match player.as_str() {
                                                        "mpv" => { cmd.args(["--no-video", "--no-terminal", &wav_path_str]); }
                                                        "ffplay" => { cmd.args(["-nodisp", "-autoexit", &wav_path_str]); }
                                                        _ => { cmd.arg(&wav_path_str); }
                                                    }
                                                    cmd.stdout(std::process::Stdio::null());
                                                    cmd.stderr(std::process::Stdio::null());
                                                    let _ = cmd.status();
                                                });
                                            }
                                        }
                                        app.ws_broadcast(WsMessage::AnsiMusic {
                                            world_index,
                                            notes: test_notes,
                                        });
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Playing test music (C-D-E-F-G)...".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::Notify { message } => {
                                        // Send notification to mobile clients
                                        let title = if world_index < app.worlds.len() {
                                            app.worlds[world_index].name.clone()
                                        } else {
                                            "Clay".to_string()
                                        };
                                        app.ws_broadcast(WsMessage::Notification {
                                            title,
                                            message: message.clone(),
                                        });
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Notification sent: {}", message),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::Dump => {
                                        // Dump all scrollback buffers to ~/.clay.dmp.log
                                        use std::io::Write;
                                        let ts = current_timestamp_secs();

                                        let home = get_home_dir();
                                        let dump_path = format!("{}/{}", home, clay_filename("clay.dmp.log"));

                                        match std::fs::File::create(&dump_path) {
                                            Ok(mut file) => {
                                                let mut total_lines = 0;
                                                for world in app.worlds.iter() {
                                                    for line in &world.output_lines {
                                                        let line_ts = line.timestamp
                                                            .duration_since(std::time::UNIX_EPOCH)
                                                            .map(|d| d.as_secs())
                                                            .unwrap_or(0) as i64;
                                                        let lt = local_time_from_epoch(line_ts);
                                                        let datetime = format!(
                                                            "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                                            lt.year, lt.month, lt.day,
                                                            lt.hour, lt.minute, lt.second
                                                        );
                                                        let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                                                        total_lines += 1;
                                                    }
                                                    for line in &world.pending_lines {
                                                        let line_ts = line.timestamp
                                                            .duration_since(std::time::UNIX_EPOCH)
                                                            .map(|d| d.as_secs())
                                                            .unwrap_or(0) as i64;
                                                        let lt = local_time_from_epoch(line_ts);
                                                        let datetime = format!(
                                                            "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                                            lt.year, lt.month, lt.day,
                                                            lt.hour, lt.minute, lt.second
                                                        );
                                                        let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                                                        total_lines += 1;
                                                    }
                                                }
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("Dumped {} lines from {} worlds to {}", total_lines, app.worlds.len(), dump_path),
                                                    is_viewed: false,
                                                    ts,
                                                    from_server: false,
                                                });
                                            }
                                            Err(e) => {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("Failed to create dump file: {}", e),
                                                    is_viewed: false,
                                                    ts,
                                                    from_server: false,
                                                });
                                            }
                                        }
                                    }
                                    // Commands that should be blocked from remote
                                    Command::Quit | Command::Reload => {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "This command is not available from remote interfaces.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    // UI popup commands - send back to client for local handling
                                    Command::Help | Command::Menu | Command::Setup | Command::Web | Command::Actions { .. } |
                                    Command::WorldsList | Command::WorldSelector | Command::WorldEdit { .. } => {
                                        app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                    }
                                    Command::Version => {
                                        app.ws_send_to_client(client_id, WsMessage::ServerData {
                                            world_index,
                                            data: get_version_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    // AddWorld - add or update world definition
                                    Command::AddWorld { name, host, port, user, password, use_ssl } => {
                                        let existing_idx = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(&name));

                                        let world_idx = if let Some(idx) = existing_idx {
                                            idx
                                        } else {
                                            let new_world = World::new(&name);
                                            app.worlds.push(new_world);
                                            app.worlds.len() - 1
                                        };

                                        if let Some(h) = host {
                                            app.worlds[world_idx].settings.hostname = h;
                                        }
                                        if let Some(p) = port {
                                            app.worlds[world_idx].settings.port = p;
                                        }
                                        if let Some(u) = user {
                                            app.worlds[world_idx].settings.user = u;
                                        }
                                        if let Some(p) = password {
                                            app.worlds[world_idx].settings.password = p;
                                        }
                                        app.worlds[world_idx].settings.use_ssl = use_ssl;

                                        let _ = persistence::save_settings(&app);

                                        let action = if existing_idx.is_some() { "Updated" } else { "Added" };
                                        let host_info = if !app.worlds[world_idx].settings.hostname.is_empty() {
                                            format!(" ({}:{}{})",
                                                app.worlds[world_idx].settings.hostname,
                                                app.worlds[world_idx].settings.port,
                                                if use_ssl { " SSL" } else { "" })
                                        } else {
                                            " (connectionless)".to_string()
                                        };
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("{} world '{}'{}.", action, name, host_info),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    // Connect command is handled via ConnectWorld message
                                    Command::Connect { .. } => {
                                        // Remote clients should use ConnectWorld message instead
                                        // But we can try to handle it here too
                                        if world_index < app.worlds.len() && !app.worlds[world_index].connected {
                                            if app.worlds[world_index].settings.has_connection_settings() {
                                                // Save current index, connect target, restore
                                                let prev_index = app.current_world_index;
                                                app.current_world_index = world_index;
                                                let _ = handle_command("/connect", &mut app, event_tx.clone()).await;
                                                app.current_world_index = prev_index;
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: "No connection settings configured for this world.".to_string(),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        }
                                    }
                                    // WorldSwitch and WorldConnectNoLogin need proper handling
                                    Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                                        if let Some(idx) = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                            // Switch only the requesting client's world, not the console
                                            let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                            let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                            app.ws_client_worlds.insert(client_id, ClientViewState { world_index: idx, visible_lines, dimensions });
                                            app.ws_set_client_world(client_id, Some(idx));
                                            app.ws_send_to_client(client_id, WsMessage::WorldSwitched { new_index: idx });
                                            // Also send ExecuteLocalCommand so web clients can switch their local view
                                            app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                            // Connect if not connected and has settings
                                            if !app.worlds[idx].connected
                                                && app.worlds[idx].settings.has_connection_settings()
                                            {
                                                // For WorldConnectNoLogin, set skip flag
                                                if matches!(parsed, Command::WorldConnectNoLogin { .. }) {
                                                    app.worlds[idx].skip_auto_login = true;
                                                }
                                                let prev_index = app.current_world_index;
                                                app.current_world_index = idx;
                                                let _ = handle_command("/connect", &mut app, event_tx.clone()).await;
                                                app.current_world_index = prev_index;
                                            }
                                        } else {
                                            app.ws_send_to_client(client_id, WsMessage::ServerData {
                                                world_index,
                                                data: format!("World '{}' not found.", name),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                    }
                                    Command::Dict { .. } | Command::Urban { .. } | Command::Translate { .. } => {
                                        spawn_api_lookup(event_tx.clone(), client_id, world_index, parsed);
                                    }
                                    Command::DictUsage => {
                                        app.ws_send_to_client(client_id, WsMessage::ServerData {
                                            world_index,
                                            data: "Usage: /dict <prefix> <word>".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::UrbanUsage => {
                                        app.ws_send_to_client(client_id, WsMessage::ServerData {
                                            world_index,
                                            data: "Usage: /urban <prefix> <word>".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::TranslateUsage => {
                                        app.ws_send_to_client(client_id, WsMessage::ServerData {
                                            world_index,
                                            data: "Usage: /translate <lang> <prefix> <text>".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    Command::HelpTf => {
                                        // Execute TF help command and send the result
                                        match app.tf_engine.execute("#help") {
                                            tf::TfCommandResult::Success(Some(msg)) => {
                                                for line in msg.lines() {
                                                    app.ws_send_to_client(client_id, WsMessage::ServerData {
                                                        world_index,
                                                        data: line.to_string(),
                                                        is_viewed: false,
                                                        ts: current_timestamp_secs(),
                                                        from_server: false,
                                                    });
                                                }
                                            }
                                            _ => {
                                                app.ws_send_to_client(client_id, WsMessage::ServerData {
                                                    world_index,
                                                    data: "TF help not available.".to_string(),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                            WsMessage::SwitchWorld { world_index } => {
                                // Switch only the requesting client's world, not the console
                                if world_index < app.worlds.len() {
                                    let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                    let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                    app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                    app.ws_set_client_world(client_id, Some(world_index));
                                    app.ws_send_to_client(client_id, WsMessage::WorldSwitched { new_index: world_index });
                                    // Send active media for the new world
                                    app.ws_send_active_media_to_client(client_id, world_index);
                                }
                            }
                            WsMessage::ConnectWorld { world_index } => {
                                // Trigger connection for specified world
                                if world_index < app.worlds.len() && !app.worlds[world_index].connected {
                                    // Check if world has connection settings
                                    if !app.worlds[world_index].settings.has_connection_settings() {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "No connection settings configured for this world.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    } else {
                                        // Save current world index, switch to target, connect, then restore
                                        let prev_index = app.current_world_index;
                                        app.current_world_index = world_index;
                                        if handle_command("/connect", &mut app, event_tx.clone()).await {
                                            // Quit was triggered (shouldn't happen from /connect)
                                            return Ok(());
                                        }
                                        // Only broadcast WorldConnected if connection actually succeeded
                                        if app.worlds[world_index].connected {
                                            let name = app.worlds[world_index].name.clone();
                                            app.ws_broadcast(WsMessage::WorldConnected { world_index, name });
                                        }
                                        // Restore previous world if it wasn't the target
                                        if prev_index != world_index {
                                            app.current_world_index = prev_index;
                                        }
                                    }
                                }
                            }
                            WsMessage::DisconnectWorld { world_index } => {
                                // Disconnect specified world
                                if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                    let prev_index = app.current_world_index;
                                    app.current_world_index = world_index;
                                    if handle_command("/disconnect", &mut app, event_tx.clone()).await {
                                        return Ok(());
                                    }
                                    app.current_world_index = prev_index;
                                    // WorldDisconnected broadcast happens via AppEvent::Disconnected
                                }
                            }
                            WsMessage::DeleteWorld { world_index } => {
                                // Delete specified world (if not the last one)
                                if app.worlds.len() > 1 && world_index < app.worlds.len() {
                                    let deleted_name = app.worlds[world_index].name.clone();
                                    app.worlds.remove(world_index);
                                    // Adjust current_world_index if needed
                                    if app.current_world_index >= app.worlds.len() {
                                        app.current_world_index = app.worlds.len().saturating_sub(1);
                                    } else if app.current_world_index > world_index {
                                        app.current_world_index -= 1;
                                    }
                                    // Adjust previous_world_index if needed
                                    if let Some(prev) = app.previous_world_index {
                                        if prev >= app.worlds.len() {
                                            app.previous_world_index = Some(app.worlds.len().saturating_sub(1));
                                        } else if prev > world_index {
                                            app.previous_world_index = Some(prev - 1);
                                        }
                                    }
                                    app.add_output(&format!("World '{}' deleted.\n", deleted_name));
                                    // Broadcast WorldRemoved to all clients
                                    app.ws_broadcast(WsMessage::WorldRemoved { world_index });
                                    let _ = persistence::save_settings(&app);
                                }
                            }
                            WsMessage::MarkWorldSeen { world_index } => {
                                // A remote client has viewed this world - update their current_world
                                if world_index < app.worlds.len() {
                                    // Check if client is switching to a different world
                                    let old_world_idx = app.ws_client_worlds.get(&client_id).map(|s| s.world_index);
                                    let switched = old_world_idx.map(|old| old != world_index).unwrap_or(true);
                                    // Reset lines_since_pause for the old world if switching away and more-mode hasn't triggered
                                    if let Some(old_idx) = old_world_idx {
                                        if old_idx != world_index && old_idx < app.worlds.len()
                                            && app.worlds[old_idx].pending_lines.is_empty()
                                        {
                                            app.worlds[old_idx].lines_since_pause = 0;
                                        }
                                    }
                                    // Track which world this client is viewing (sync cache)
                                    let visible_lines = app.ws_client_worlds
                                        .get(&client_id)
                                        .map(|v| v.visible_lines)
                                        .unwrap_or(0);
                                    let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                    app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                    // Update client's world in WebSocket server (async state)
                                    app.ws_set_client_world(client_id, Some(world_index));

                                    app.worlds[world_index].mark_seen();
                                    // Broadcast to all clients so they update their UI
                                    app.ws_broadcast(WsMessage::UnseenCleared { world_index });
                                    // Broadcast activity count since a world was just marked as seen
                                    app.broadcast_activity();
                                    // Trigger console redraw to update activity indicator
                                    app.needs_output_redraw = true;
                                    if switched {
                                        app.ws_send_active_media_to_client(client_id, world_index);
                                    }
                                }
                            }
                            WsMessage::UpdateViewState { world_index, visible_lines } => {
                                // A remote client is reporting its view state (for more-mode threshold calculation)
                                if world_index < app.worlds.len() {
                                    // Preserve existing dimensions when updating view state
                                    let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                    app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                    // Update client's world in WebSocket server so broadcast_to_world_viewers works
                                    app.ws_set_client_world(client_id, Some(world_index));
                                }
                            }
                            WsMessage::UpdateDimensions { width, height } => {
                                // A remote client is reporting its output dimensions (for NAWS)
                                if let Some(state) = app.ws_client_worlds.get_mut(&client_id) {
                                    let old_dims = state.dimensions;
                                    state.dimensions = Some((width, height));
                                    // If dimensions changed, send NAWS updates to all worlds
                                    if old_dims != Some((width, height)) {
                                        app.send_naws_to_all_worlds();
                                    }
                                }
                            }
                            WsMessage::ReleasePending { world_index, count } => {
                                // A remote client is releasing pending lines - sync across all interfaces
                                if world_index < app.worlds.len() {
                                    let pending_count = app.worlds[world_index].pending_lines.len();
                                    if pending_count > 0 {
                                        // Get client's output width for visual line calculation
                                        let client_width = app.ws_client_worlds.get(&client_id)
                                            .and_then(|s| s.dimensions)
                                            .map(|(w, _)| w as usize)
                                            .unwrap_or(app.output_width as usize);

                                        // count == 0 means release all; otherwise treat count as visual budget
                                        let visual_budget = if count == 0 { usize::MAX } else { count };

                                        // Pre-calculate logical lines to release (same logic as release_pending)
                                        let width = client_width.max(1);
                                        let mut visual_total = 0;
                                        let mut logical_count = 0;
                                        for line in &app.worlds[world_index].pending_lines {
                                            let vl = visual_line_count(&line.text, width);
                                            if visual_total > 0 && visual_total + vl > visual_budget {
                                                break;
                                            }
                                            visual_total += vl;
                                            logical_count += 1;
                                            if visual_total >= visual_budget {
                                                break;
                                            }
                                        }
                                        if logical_count == 0 && pending_count > 0 {
                                            logical_count = 1;
                                        }
                                        // For release-all, cap at pending_count
                                        let to_release = logical_count.min(pending_count);

                                        // Get the lines that will be released (for broadcasting as ServerData)
                                        let lines_to_broadcast: Vec<String> = app.worlds[world_index]
                                            .pending_lines
                                            .iter()
                                            .take(to_release)
                                            .map(|line| line.text.replace('\r', ""))
                                            .collect();

                                        // Release the lines on the server
                                        app.worlds[world_index].release_pending(visual_budget, client_width);

                                        // Broadcast the released lines to clients viewing this world
                                        if !lines_to_broadcast.is_empty() {
                                            let ws_data = lines_to_broadcast.join("\n") + "\n";
                                            app.ws_broadcast_to_world(world_index, WsMessage::ServerData {
                                                world_index,
                                                data: ws_data,
                                                is_viewed: true,
                                                ts: current_timestamp_secs(),
                                                from_server: true,
                                            });
                                        }

                                        // Broadcast to all clients so they know how many were released
                                        app.ws_broadcast(WsMessage::PendingReleased { world_index, count: to_release });
                                        let new_count = app.worlds[world_index].pending_lines.len();
                                        app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index, count: new_count });

                                        // Broadcast activity count since pending lines changed
                                        app.broadcast_activity();

                                        // Update console display
                                        if world_index == app.current_world_index {
                                            app.needs_output_redraw = true;
                                        }
                                    } else {
                                        // Client has stale pending_count - sync them with the actual state
                                        app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index, count: 0 });
                                        app.broadcast_activity();
                                    }
                                }
                            }
                            WsMessage::UpdateWorldSettings { world_index, name, hostname, port, user, password, use_ssl, log_enabled, encoding, auto_login, keep_alive_type, keep_alive_cmd, gmcp_packages } => {
                                // Update world settings from remote client
                                if world_index < app.worlds.len() {
                                    app.worlds[world_index].name = name.clone();
                                    app.worlds[world_index].settings.hostname = hostname.clone();
                                    app.worlds[world_index].settings.port = port.clone();
                                    app.worlds[world_index].settings.user = user.clone();
                                    app.worlds[world_index].settings.password = password.clone();
                                    app.worlds[world_index].settings.use_ssl = use_ssl;
                                    app.worlds[world_index].settings.log_enabled = log_enabled;
                                    app.worlds[world_index].settings.encoding = match encoding.as_str() {
                                        "latin1" => Encoding::Latin1,
                                        "fansi" => Encoding::Fansi,
                                        _ => Encoding::Utf8,
                                    };
                                    app.worlds[world_index].settings.auto_connect_type = AutoConnectType::from_name(&auto_login);
                                    app.worlds[world_index].settings.keep_alive_type = KeepAliveType::from_name(&keep_alive_type);
                                    app.worlds[world_index].settings.keep_alive_cmd = keep_alive_cmd.clone();
                                    app.worlds[world_index].settings.gmcp_packages = gmcp_packages.clone();
                                    // Save settings to persist changes
                                    let _ = persistence::save_settings(&app);
                                    // Build settings message for broadcast (encrypt password)
                                    let settings_msg = WorldSettingsMsg {
                                        hostname,
                                        port,
                                        user,
                                        password: encrypt_password(&password),
                                        use_ssl,
                                        log_enabled,
                                        encoding,
                                        auto_connect_type: auto_login,
                                        keep_alive_type,
                                        keep_alive_cmd,
                                        gmcp_packages,
                                    };
                                    // Broadcast update to all clients
                                    app.ws_broadcast(WsMessage::WorldSettingsUpdated {
                                        world_index,
                                        settings: settings_msg,
                                        name,
                                    });
                                }
                            }
                            WsMessage::UpdateGlobalSettings { more_mode_enabled, spell_check_enabled, temp_convert_enabled, world_switch_mode, show_tags, debug_enabled, ansi_music_enabled, console_theme, gui_theme, gui_transparency, color_offset_percent, input_height, font_name, font_size, web_font_size_phone, web_font_size_tablet, web_font_size_desktop, ws_allow_list, web_secure, http_enabled, http_port, ws_enabled, ws_port, ws_cert_file, ws_key_file, tls_proxy_enabled, dictionary_path } => {
                                // Update global settings from remote client
                                app.settings.more_mode_enabled = more_mode_enabled;
                                app.settings.spell_check_enabled = spell_check_enabled;
                                app.settings.temp_convert_enabled = temp_convert_enabled;
                                app.settings.world_switch_mode = WorldSwitchMode::from_name(&world_switch_mode);
                                app.show_tags = show_tags;
                                app.settings.debug_enabled = debug_enabled;
                                app.settings.ansi_music_enabled = ansi_music_enabled;
                                // Console theme affects the TUI on the server
                                app.settings.theme = Theme::from_name(&console_theme);
                                // GUI theme is stored for sending back to GUI clients
                                app.settings.gui_theme = Theme::from_name(&gui_theme);
                                app.settings.gui_transparency = gui_transparency.clamp(0.3, 1.0);
                                app.settings.color_offset_percent = color_offset_percent.min(100);
                                app.input_height = input_height.clamp(1, 15);
                                app.input.visible_height = app.input_height;
                                app.settings.font_name = font_name;
                                app.settings.font_size = font_size.clamp(8.0, 48.0);
                                app.settings.web_font_size_phone = web_font_size_phone.clamp(8.0, 48.0);
                                app.settings.web_font_size_tablet = web_font_size_tablet.clamp(8.0, 48.0);
                                app.settings.web_font_size_desktop = web_font_size_desktop.clamp(8.0, 48.0);
                                app.settings.websocket_allow_list = ws_allow_list.clone();
                                // Update the running WebSocket server's allow list
                                if let Some(ref server) = app.ws_server {
                                    server.update_allow_list(&ws_allow_list);
                                }
                                // Update web settings
                                app.settings.web_secure = web_secure;
                                app.settings.http_enabled = http_enabled;
                                app.settings.http_port = http_port;
                                app.settings.ws_enabled = ws_enabled;
                                app.settings.ws_port = ws_port;
                                app.settings.websocket_cert_file = ws_cert_file;
                                app.settings.websocket_key_file = ws_key_file;
                                app.settings.tls_proxy_enabled = tls_proxy_enabled;
                                if app.settings.dictionary_path != dictionary_path {
                                    app.settings.dictionary_path = dictionary_path;
                                    app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
                                }
                                // Save settings to persist changes
                                let _ = persistence::save_settings(&app);
                                // Build settings message for broadcast
                                let settings_msg = GlobalSettingsMsg {
                                    more_mode_enabled: app.settings.more_mode_enabled,
                                    spell_check_enabled: app.settings.spell_check_enabled,
                                    temp_convert_enabled: app.settings.temp_convert_enabled,
                                    world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                                    debug_enabled: app.settings.debug_enabled,
                                    show_tags: app.show_tags,
                                    ansi_music_enabled: app.settings.ansi_music_enabled,
                                    console_theme: app.settings.theme.name().to_string(),
                                    gui_theme: app.settings.gui_theme.name().to_string(),
                                    gui_transparency: app.settings.gui_transparency,
                                    color_offset_percent: app.settings.color_offset_percent,
                                    input_height: app.input_height,
                                    font_name: app.settings.font_name.clone(),
                                    font_size: app.settings.font_size,
                                    web_font_size_phone: app.settings.web_font_size_phone,
                                    web_font_size_tablet: app.settings.web_font_size_tablet,
                                    web_font_size_desktop: app.settings.web_font_size_desktop,
                                    ws_allow_list: app.settings.websocket_allow_list.clone(),
                                    web_secure: app.settings.web_secure,
                                    http_enabled: app.settings.http_enabled,
                                    http_port: app.settings.http_port,
                                    ws_enabled: app.settings.ws_enabled,
                                    ws_port: app.settings.ws_port,
                                    ws_cert_file: app.settings.websocket_cert_file.clone(),
                                    ws_key_file: app.settings.websocket_key_file.clone(),
                                    tls_proxy_enabled: app.settings.tls_proxy_enabled,
                                    dictionary_path: app.settings.dictionary_path.clone(),
                                    theme_colors_json: app.gui_theme_colors().to_json(),
                                };
                                // Broadcast update to all clients
                                app.ws_broadcast(WsMessage::GlobalSettingsUpdated {
                                    settings: settings_msg,
                                    input_height: app.input_height,
                                });
                            }
                            WsMessage::UpdateActions { actions } => {
                                // Update actions from remote client
                                app.settings.actions = actions.clone();
                                // Save settings to persist changes
                                let _ = persistence::save_settings(&app);
                                // Broadcast update to all clients
                                app.ws_broadcast(WsMessage::ActionsUpdated {
                                    actions,
                                });
                            }
                            WsMessage::CalculateNextWorld { current_index } => {
                                // Calculate next world using shared logic
                                let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                    .map(|w| crate::util::WorldSwitchInfo {
                                        name: w.name.clone(),
                                        connected: w.connected,
                                        unseen_lines: w.unseen_lines,
                                        pending_lines: w.pending_lines.len(),
                                        first_unseen_at: w.first_unseen_at,
                                    })
                                    .collect();
                                let next_idx = crate::util::calculate_next_world(
                                    &world_info,
                                    current_index,
                                    app.settings.world_switch_mode,
                                );
                                app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: next_idx });
                            }
                            WsMessage::CalculatePrevWorld { current_index } => {
                                // Calculate prev world using shared logic
                                let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                    .map(|w| crate::util::WorldSwitchInfo {
                                        name: w.name.clone(),
                                        connected: w.connected,
                                        unseen_lines: w.unseen_lines,
                                        pending_lines: w.pending_lines.len(),
                                        first_unseen_at: w.first_unseen_at,
                                    })
                                    .collect();
                                let prev_idx = crate::util::calculate_prev_world(
                                    &world_info,
                                    current_index,
                                    app.settings.world_switch_mode,
                                );
                                app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: prev_idx });
                            }
                            WsMessage::CalculateOldestPending { current_index } => {
                                // Find world with oldest pending output (for Escape+w)
                                // Priority: 1) oldest pending, 2) any unseen, 3) previous world
                                let mut oldest_idx: Option<usize> = None;
                                let mut oldest_time: Option<std::time::Instant> = None;

                                // Check for worlds with pending output
                                for (idx, world) in app.worlds.iter().enumerate() {
                                    if idx == current_index || world.pending_lines.is_empty() {
                                        continue;
                                    }
                                    if let Some(pending_time) = world.pending_since {
                                        if oldest_time.is_none() || pending_time < oldest_time.unwrap() {
                                            oldest_time = Some(pending_time);
                                            oldest_idx = Some(idx);
                                        }
                                    }
                                }

                                // If no pending, check for unseen output
                                if oldest_idx.is_none() {
                                    for (idx, world) in app.worlds.iter().enumerate() {
                                        if idx != current_index && world.unseen_lines > 0 {
                                            oldest_idx = Some(idx);
                                            break;
                                        }
                                    }
                                }

                                // If still none, use previous world
                                if oldest_idx.is_none() {
                                    if let Some(prev_idx) = app.previous_world_index {
                                        if prev_idx != current_index && prev_idx < app.worlds.len() {
                                            oldest_idx = Some(prev_idx);
                                        }
                                    }
                                }

                                app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: oldest_idx });
                            }
                            WsMessage::RequestState => {
                                // Client requested full state resync - send initial state
                                let initial_state = app.build_initial_state();
                                app.ws_send_to_client(client_id, initial_state);
                                // Mark client as having received initial state so it receives broadcasts
                                app.ws_mark_initial_state_sent(client_id);
                                // Set client's initial world so broadcast_to_world_viewers works immediately
                                app.ws_set_client_world(client_id, Some(app.current_world_index));
                                // Also send current activity count
                                app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                    count: app.activity_count(),
                                });
                            }
                            WsMessage::RequestWorldState { world_index } => {
                                // Client switched to a world and needs current state
                                if world_index < app.worlds.len() {
                                    let world = &app.worlds[world_index];
                                    // Build recent lines from output_lines (last 100 lines for context)
                                    let recent_lines: Vec<TimestampedLine> = world.output_lines
                                        .iter()
                                        .rev()
                                        .take(100)
                                        .map(|line| TimestampedLine {
                                            text: line.text.clone(),
                                            ts: line.timestamp.duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
                                            gagged: line.gagged,
                                            from_server: line.from_server,
                                            seq: line.seq,
                                            highlight_color: line.highlight_color.clone(),
                                        })
                                        .collect::<Vec<_>>()
                                        .into_iter()
                                        .rev()
                                        .collect();

                                    let pending_count = world.pending_lines.len();

                                    app.ws_send_to_client(client_id, WsMessage::WorldStateResponse {
                                        world_index,
                                        pending_count,
                                        prompt: world.prompt.clone(),
                                        scroll_offset: world.scroll_offset,
                                        recent_lines,
                                    });
                                }
                            }
                            WsMessage::BanListRequest => {
                                // Send current ban list to client
                                let bans = app.ban_list.get_ban_info();
                                app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                            }
                            WsMessage::UnbanRequest { host } => {
                                if app.ban_list.remove_ban(&host) {
                                    // Save settings to persist the change
                                    let _ = persistence::save_settings(&app);
                                    // Broadcast updated ban list to all clients
                                    app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                    app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                } else {
                                    app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                }
                            }
                            // Theme editor messages
                            WsMessage::RequestThemeEditorState => {
                                let themes_json = app.theme_file.to_json_all();
                                let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                                let active_theme = app.settings.gui_theme.name().to_string();
                                app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                    themes_json,
                                    theme_names,
                                    active_theme,
                                });
                            }
                            WsMessage::UpdateThemeColors { theme_name, colors_json } => {
                                let base = if theme_name == "light" {
                                    theme::ThemeColors::light_default()
                                } else {
                                    theme::ThemeColors::dark_default()
                                };
                                let colors = theme::ThemeColors::from_json(&colors_json, &base);
                                app.theme_file.set_theme(&theme_name, colors);
                                // If updated theme is the active GUI theme, broadcast CSS vars update
                                if theme_name == app.settings.gui_theme.name() {
                                    let css_vars = app.gui_theme_colors().to_css_vars();
                                    let colors_json = app.gui_theme_colors().to_json();
                                    app.ws_broadcast(WsMessage::ThemeCssVarsUpdated {
                                        css_vars,
                                        colors_json: colors_json.clone(),
                                    });
                                    // Also broadcast GlobalSettingsUpdated for GUI clients
                                    let settings_msg = app.build_global_settings_msg();
                                    app.ws_broadcast(WsMessage::GlobalSettingsUpdated {
                                        settings: settings_msg,
                                        input_height: app.input_height,
                                    });
                                }
                            }
                            WsMessage::AddTheme { name, copy_from } => {
                                let base_colors = app.theme_file.get(&copy_from).clone();
                                app.theme_file.set_theme(&name, base_colors);
                                // Send updated state back to editor
                                let themes_json = app.theme_file.to_json_all();
                                let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                                let active_theme = app.settings.gui_theme.name().to_string();
                                app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                    themes_json,
                                    theme_names,
                                    active_theme,
                                });
                            }
                            WsMessage::DeleteTheme { name } => {
                                app.theme_file.remove_theme(&name);
                                // Send updated state back to editor
                                let themes_json = app.theme_file.to_json_all();
                                let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                                let active_theme = app.settings.gui_theme.name().to_string();
                                app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                    themes_json,
                                    theme_names,
                                    active_theme,
                                });
                            }
                            WsMessage::SaveThemeFile => {
                                let content = app.theme_file.generate_file_content();
                                let path = std::path::Path::new(&get_home_dir()).join("clay.theme.dat");
                                match std::fs::write(&path, &content) {
                                    Ok(_) => {
                                        app.ws_send_to_client(client_id, WsMessage::ThemeFileSaved { success: true, error: None });
                                    }
                                    Err(e) => {
                                        app.ws_send_to_client(client_id, WsMessage::ThemeFileSaved { success: false, error: Some(e.to_string()) });
                                    }
                                }
                            }
                            WsMessage::RequestConnectionsList => {
                                // Generate connections list using same format as master console
                                let current_idx = app.current_world_index;
                                let worlds_info: Vec<util::WorldListInfo> = app.worlds.iter().enumerate().map(|(idx, world)| {
                                    let now = std::time::Instant::now();
                                    util::WorldListInfo {
                                        name: world.name.clone(),
                                        connected: world.connected,
                                        is_current: idx == current_idx,
                                        is_ssl: world.is_tls,
                                        is_proxy: world.proxy_pid.is_some(),
                                        unseen_lines: world.unseen_lines,
                                        last_send_secs: world.last_user_command_time.map(|t| now.duration_since(t).as_secs()),
                                        last_recv_secs: world.last_receive_time.map(|t| now.duration_since(t).as_secs()),
                                        last_nop_secs: world.last_nop_time.map(|t| now.duration_since(t).as_secs()),
                                        next_nop_secs: None,
                                        buffer_size: world.output_lines.len() + world.pending_lines.len(),
                                    }
                                }).collect();
                                let output = util::format_worlds_list(&worlds_info);
                                let lines: Vec<String> = output.lines().map(|s| s.to_string()).collect();
                                app.ws_send_to_client(client_id, WsMessage::ConnectionsListResponse { lines });
                            }
                            WsMessage::ReportSeqMismatch { world_index, expected_seq_gt, actual_seq, line_text, source } => {
                                let world_name = app.worlds.get(world_index).map(|w| w.name.as_str()).unwrap_or("?");
                                use std::io::Write;
                                if let Ok(mut f) = std::fs::OpenOptions::new()
                                    .create(true).append(true)
                                    .open("clay.output.debug")
                                {
                                    let _ = writeln!(f, "SEQ MISMATCH [{}] in '{}': expected seq>{}, got seq={}, text={:?}",
                                        source, world_name, expected_seq_gt, actual_seq,
                                        line_text.chars().take(80).collect::<String>());
                                }
                            }
                            WsMessage::ClientTypeDeclaration { client_type } => {
                                // Update client type in WebSocket server
                                app.ws_set_client_type(client_id, client_type);
                            }
                            WsMessage::CycleWorld { direction } => {
                                // Client requests to cycle to next/previous world
                                let current = app.ws_client_worlds.get(&client_id)
                                    .map(|s| s.world_index)
                                    .unwrap_or(app.current_world_index);

                                let new_index = if direction == "up" {
                                    app.calculate_prev_world_from(current)
                                } else {
                                    app.calculate_next_world_from(current)
                                };

                                if let Some(idx) = new_index {
                                    // Update client's view state (sync state)
                                    let visible_lines = app.ws_client_worlds.get(&client_id)
                                        .map(|s| s.visible_lines)
                                        .unwrap_or(24);
                                    let dimensions = app.ws_client_worlds.get(&client_id)
                                        .and_then(|s| s.dimensions);
                                    app.ws_client_worlds.insert(client_id, ClientViewState {
                                        world_index: idx,
                                        visible_lines,
                                        dimensions,
                                    });
                                    // Update client's world in WebSocket server (async state)
                                    app.ws_set_client_world(client_id, Some(idx));

                                    // Send world switch result with state
                                    if idx < app.worlds.len() {
                                        let pending_count = app.worlds[idx].pending_lines.len();
                                        let paused = app.worlds[idx].paused;
                                        let world_name = app.worlds[idx].name.clone();

                                        app.ws_send_to_client(client_id, WsMessage::WorldSwitchResult {
                                            world_index: idx,
                                            world_name,
                                            pending_count,
                                            paused,
                                        });

                                        // Send initial output lines based on client type
                                        let client_type = app.ws_get_client_type(client_id);
                                        let world = &app.worlds[idx];
                                        let total_lines = world.output_lines.len();

                                        let lines_to_send = match client_type {
                                            Some(websocket::RemoteClientType::RemoteConsole) => {
                                                // Console: last screenful (viewport - 2)
                                                visible_lines.saturating_sub(2).min(total_lines)
                                            }
                                            _ => {
                                                // Web/GUI: full history
                                                total_lines
                                            }
                                        };

                                        if lines_to_send > 0 {
                                            let start = total_lines.saturating_sub(lines_to_send);
                                            let lines: Vec<TimestampedLine> = world.output_lines[start..].iter()
                                                .map(|line| {
                                                    let ts = line.timestamp
                                                        .duration_since(std::time::UNIX_EPOCH)
                                                        .map(|d| d.as_secs())
                                                        .unwrap_or(0);
                                                    TimestampedLine {
                                                        text: line.text.clone(),
                                                        ts,
                                                        gagged: line.gagged,
                                                        from_server: line.from_server,
                                                        seq: line.seq,
                                                        highlight_color: line.highlight_color.clone(),
                                                    }
                                                })
                                                .collect();

                                            app.ws_send_to_client(client_id, WsMessage::OutputLines {
                                                world_index: idx,
                                                lines,
                                                is_initial: true,
                                            });
                                        }

                                        // Also mark world as seen if it had unseen output
                                        if app.worlds[idx].unseen_lines > 0 {
                                            app.worlds[idx].unseen_lines = 0;
                                            app.worlds[idx].first_unseen_at = None;
                                            app.ws_broadcast(WsMessage::UnseenCleared { world_index: idx });
                                            app.broadcast_activity();
                                        }
                                    }
                                }
                            }
                            WsMessage::RequestScrollback { world_index, count, before_seq } => {
                                // Console client requests scrollback from master
                                if world_index < app.worlds.len() {
                                    let world = &app.worlds[world_index];

                                    // Find lines to send based on before_seq
                                    let lines: Vec<TimestampedLine> = if let Some(seq) = before_seq {
                                        // Send lines with seq < before_seq (older than what client has)
                                        let eligible: Vec<_> = world.output_lines.iter()
                                            .filter(|l| l.seq < seq)
                                            .collect();
                                        let start = eligible.len().saturating_sub(count);
                                        eligible[start..].iter()
                                            .map(|line| {
                                                let ts = line.timestamp
                                                    .duration_since(std::time::UNIX_EPOCH)
                                                    .map(|d| d.as_secs())
                                                    .unwrap_or(0);
                                                TimestampedLine {
                                                    text: line.text.clone(),
                                                    ts,
                                                    gagged: line.gagged,
                                                    from_server: line.from_server,
                                                    seq: line.seq,
                                                    highlight_color: line.highlight_color.clone(),
                                                }
                                            })
                                            .collect()
                                    } else {
                                        // No before_seq - send last N lines (backwards compatible)
                                        let total_lines = world.output_lines.len();
                                        let start = total_lines.saturating_sub(count);
                                        world.output_lines[start..].iter()
                                            .map(|line| {
                                                let ts = line.timestamp
                                                    .duration_since(std::time::UNIX_EPOCH)
                                                    .map(|d| d.as_secs())
                                                    .unwrap_or(0);
                                                TimestampedLine {
                                                    text: line.text.clone(),
                                                    ts,
                                                    gagged: line.gagged,
                                                    from_server: line.from_server,
                                                    seq: line.seq,
                                                    highlight_color: line.highlight_color.clone(),
                                                }
                                            })
                                            .collect()
                                    };

                                    app.ws_send_to_client(client_id, WsMessage::ScrollbackLines {
                                        world_index,
                                        lines,
                                    });
                                }
                            }
                            WsMessage::ToggleWorldGmcp { world_index } => {
                                if world_index < app.worlds.len() {
                                    app.worlds[world_index].gmcp_user_enabled = !app.worlds[world_index].gmcp_user_enabled;
                                    // Broadcast toggle state first so clients update before receiving media
                                    app.ws_broadcast(WsMessage::GmcpUserToggled {
                                        world_index,
                                        enabled: app.worlds[world_index].gmcp_user_enabled,
                                    });
                                    if app.worlds[world_index].gmcp_user_enabled {
                                        app.restart_world_media(world_index);
                                    } else {
                                        app.stop_world_media(world_index);
                                    }
                                    app.needs_output_redraw = true;
                                }
                            }
                            WsMessage::SendGmcp { world_index, ref package, ref data } => {
                                if world_index < app.worlds.len() {
                                    if let Some(ref tx) = app.worlds[world_index].command_tx {
                                        let msg = build_gmcp_message(package, data);
                                        let _ = tx.try_send(WriteCommand::Raw(msg));
                                    }
                                }
                            }
                            WsMessage::SendMsdp { world_index, ref variable, ref value } => {
                                if world_index < app.worlds.len() {
                                    if let Some(ref tx) = app.worlds[world_index].command_tx {
                                        let msg = build_msdp_set(variable, value);
                                        let _ = tx.try_send(WriteCommand::Raw(msg));
                                    }
                                }
                            }
                            _ => {
                                // Other message types handled elsewhere or ignored
                            }
                        }
                    }
                    // Background connection completed successfully
                    AppEvent::ConnectionSuccess(world_name, cmd_tx, socket_fd, is_tls) => {
                        if let Some(world_idx) = app.find_world_index(&world_name) {
                            app.worlds[world_idx].connected = true;
                            app.worlds[world_idx].was_connected = true;
                            app.worlds[world_idx].prompt_count = 0;
                            let now = std::time::Instant::now();
                            app.worlds[world_idx].last_send_time = Some(now);
                            app.worlds[world_idx].last_receive_time = Some(now);
                            app.worlds[world_idx].is_initial_world = false;
                            app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                            #[cfg(unix)]
                            { app.worlds[world_idx].socket_fd = socket_fd; }
                            app.worlds[world_idx].is_tls = is_tls;

                            // Discard any unused initial world
                            app.discard_initial_world();

                            // Open log file if enabled
                            if app.worlds[world_idx].settings.log_enabled {
                                if app.worlds[world_idx].open_log_file() {
                                    let log_path = app.worlds[world_idx].get_log_path();
                                    app.add_output_to_world(world_idx, &format!("Logging to: {}", log_path.display()));
                                } else {
                                    app.add_output_to_world(world_idx, "Warning: Could not open log file");
                                }
                            }

                            // Fire TF CONNECT hook
                            let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Connect);
                            for cmd in hook_result.send_commands {
                                let _ = cmd_tx.try_send(WriteCommand::Text(cmd));
                            }
                            for cmd in hook_result.clay_commands {
                                let _ = app.tf_engine.execute(&cmd);
                            }

                            // Send auto-login if configured
                            let skip_login = app.worlds[world_idx].skip_auto_login;
                            app.worlds[world_idx].skip_auto_login = false;
                            let user = app.worlds[world_idx].settings.user.clone();
                            let password = app.worlds[world_idx].settings.password.clone();
                            let auto_connect_type = app.worlds[world_idx].settings.auto_connect_type;
                            if !skip_login && !user.is_empty() && !password.is_empty() && auto_connect_type == AutoConnectType::Connect {
                                let connect_cmd = format!("connect {} {}", user, password);
                                let _ = cmd_tx.try_send(WriteCommand::Text(connect_cmd));
                            }

                            // Broadcast connection status
                            app.ws_broadcast(WsMessage::WorldConnected { world_index: world_idx, name: app.worlds[world_idx].name.clone() });
                        }
                    }
                    // Background connection failed
                    AppEvent::ConnectionFailed(world_name, error) => {
                        if let Some(world_idx) = app.find_world_index(&world_name) {
                            app.add_output_to_world(world_idx, &format!("Connection failed: {}", error));
                        }
                    }
                    AppEvent::MediaProcessReady(world_idx, key, child, is_music) => {
                        if is_music {
                            app.media_music_key = Some((world_idx, key.clone()));
                        }
                        app.media_processes.insert(key, (world_idx, child));
                    }
                    AppEvent::ApiLookupResult(client_id, world_index, result) => {
                        match result {
                            Ok(text) => app.ws_send_to_client(client_id, WsMessage::SetInputBuffer { text }),
                            Err(e) => app.ws_send_to_client(client_id, WsMessage::ServerData {
                                world_index,
                                data: e,
                                is_viewed: false,
                                ts: current_timestamp_secs(),
                                from_server: false,
                            }),
                        }
                    }
                }
            }

            // Periodic timer for clock updates and keepalive checks (once per minute)
            _ = keepalive_interval.tick() => {
                // Check keepalive for all connected worlds (send NOP if no activity in 5 min)
                for world in &mut app.worlds {
                    if world.connected {
                        // Check last activity time (either send or receive)
                        let last_activity = match (world.last_send_time, world.last_receive_time) {
                            (Some(s), Some(r)) => Some(s.max(r)),
                            (Some(s), None) => Some(s),
                            (None, Some(r)) => Some(r),
                            (None, None) => None,
                        };
                        let should_send = match last_activity {
                            Some(t) => t.elapsed() >= KEEPALIVE_INTERVAL,
                            None => true,
                        };
                        if should_send {
                            if let Some(tx) = &world.command_tx {
                                let now = std::time::Instant::now();

                                // Send keepalive based on type
                                match world.settings.keep_alive_type {
                                    KeepAliveType::None => {
                                        // Don't update times - nothing was sent
                                    }
                                    KeepAliveType::Nop => {
                                        let nop = vec![TELNET_IAC, TELNET_NOP];
                                        let _ = tx.try_send(WriteCommand::Raw(nop));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Custom => {
                                        // Generate random number 1-1000
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let idler_tag = format!("###_idler_message_{}_###", rand_num);
                                        let cmd = world.settings.keep_alive_cmd
                                            .replace("##rand##", &idler_tag);
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                    KeepAliveType::Generic => {
                                        // Generate random number 1-1000
                                        let rand_num = (std::time::SystemTime::now()
                                            .duration_since(std::time::UNIX_EPOCH)
                                            .unwrap_or_default()
                                            .as_nanos() % 1000 + 1) as u32;
                                        let cmd = format!("help commands ###_idler_message_{}_###", rand_num);
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                        world.last_send_time = Some(now);
                                        world.last_nop_time = Some(now);
                                    }
                                }
                            }
                        }
                    }
                }

                // Check proxy health for TLS proxy connections
                for world in &mut app.worlds {
                    if world.connected {
                        if let Some(proxy_pid) = world.proxy_pid {
                            if !is_process_alive(proxy_pid) {
                                // Proxy died - mark world as disconnected
                                world.clear_connection_state(false, false);
                                let seq = world.next_seq;
                                world.next_seq += 1;
                                world.output_lines.push(OutputLine::new("TLS proxy terminated. Connection lost.".to_string(), seq));
                            }
                        }
                    }
                }

                // Redraw to update the clock display in separator bar
            }

            // Prompt timeout check (every 150ms)
            _ = prompt_check_interval.tick() => {
                let now = std::time::Instant::now();
                for world in &mut app.worlds {
                    // Check if there's a partial line waiting to become a prompt
                    if let Some(wont_echo_time) = world.wont_echo_time {
                        // If 150ms+ has passed since partial line was seen
                        if now.duration_since(wont_echo_time) >= Duration::from_millis(150) {
                            // Check if there's a partial line to extract as prompt
                            if !world.trigger_partial_line.is_empty() && world.prompt.is_empty() {
                                // Extract partial line as prompt
                                let prompt_text = std::mem::take(&mut world.trigger_partial_line);
                                let normalized = crate::util::normalize_prompt(&prompt_text);

                                // If world is not connected, display prompt as output instead
                                if !world.connected {
                                    let seq = world.next_seq;
                                    world.next_seq += 1;
                                    world.output_lines.push(OutputLine::new(normalized.trim().to_string(), seq));
                                    world.wont_echo_time = None;
                                    continue;
                                }

                                world.prompt = normalized;
                                world.prompt_count += 1;

                                // Handle auto-login (same logic as AppEvent::Prompt handler)
                                if !world.skip_auto_login {
                                    let auto_type = world.settings.auto_connect_type;
                                    let user = world.settings.user.clone();
                                    let password = world.settings.password.clone();
                                    let prompt_num = world.prompt_count;

                                    if !user.is_empty() && !password.is_empty() {
                                        let cmd_to_send = match auto_type {
                                            AutoConnectType::Prompt => {
                                                match prompt_num {
                                                    1 if !user.is_empty() => Some(user),
                                                    2 if !password.is_empty() => Some(password),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::MooPrompt => {
                                                match prompt_num {
                                                    1 if !user.is_empty() => Some(user.clone()),
                                                    2 if !password.is_empty() => Some(password),
                                                    3 if !user.is_empty() => Some(user),
                                                    _ => None,
                                                }
                                            }
                                            AutoConnectType::Connect | AutoConnectType::NoLogin => None,
                                        };

                                        if let Some(cmd) = cmd_to_send {
                                            world.prompt.clear(); // Clear prompt since we're auto-responding
                                            if let Some(tx) = &world.command_tx {
                                                let _ = tx.try_send(WriteCommand::Text(cmd));
                                            }
                                        }
                                    }
                                }
                            }
                            world.wont_echo_time = None;
                        }
                    }
                }
            }

            // TF repeat process tick
            _ = process_tick_interval.tick() => {
                let now = std::time::Instant::now();
                let mut to_remove = vec![];
                let process_count = app.tf_engine.processes.len();
                for i in 0..process_count {
                    if app.tf_engine.processes[i].on_prompt { continue; }
                    if app.tf_engine.processes[i].next_run <= now {
                        let cmd = app.tf_engine.processes[i].command.clone();
                        let process_world = app.tf_engine.processes[i].world.clone();
                        // Sync world info before executing process command
                        app.sync_tf_world_info();
                        let result = app.tf_engine.execute(&cmd);
                        // Determine target world for this process
                        let target_idx = if let Some(ref wname) = process_world {
                            if wname.is_empty() {
                                Some(app.current_world_index)
                            } else {
                                app.find_world_index(wname)
                            }
                        } else {
                            Some(app.current_world_index)
                        };
                        let world_idx = target_idx.unwrap_or(app.current_world_index);
                        match result {
                            tf::TfCommandResult::SendToMud(text) => {
                                if let Some(idx) = target_idx {
                                    if let Some(tx) = &app.worlds[idx].command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(text));
                                    }
                                }
                            }
                            tf::TfCommandResult::Success(Some(msg)) => {
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new_client(msg.clone(), seq));
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: msg,
                                    is_viewed: true,
                                    ts: current_timestamp_secs(),
                                    from_server: false,
                                });
                            }
                            tf::TfCommandResult::Error(err) => {
                                let err_msg = format!("Error: {}", err);
                                let seq = app.worlds[world_idx].next_seq;
                                app.worlds[world_idx].next_seq += 1;
                                app.worlds[world_idx].output_lines.push(OutputLine::new_client(err_msg.clone(), seq));
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: err_msg,
                                    is_viewed: true,
                                    ts: current_timestamp_secs(),
                                    from_server: false,
                                });
                            }
                            tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                if handle_command(&clay_cmd, &mut app, event_tx.clone()).await {
                                    return Ok(());
                                }
                            }
                            tf::TfCommandResult::RepeatProcess(process) => {
                                app.tf_engine.processes.push(process);
                            }
                            tf::TfCommandResult::NotTfCommand => {
                                // Plain text command - send to MUD
                                if let Some(idx) = target_idx {
                                    if let Some(tx) = &app.worlds[idx].command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(cmd.clone()));
                                    }
                                }
                            }
                            _ => {}
                        }
                        let interval = app.tf_engine.processes[i].interval;
                        app.tf_engine.processes[i].next_run += interval;
                        if let Some(ref mut rem) = app.tf_engine.processes[i].remaining {
                            *rem = rem.saturating_sub(1);
                            if *rem == 0 {
                                to_remove.push(i);
                            }
                        }
                    }
                }
                for i in to_remove.into_iter().rev() {
                    app.tf_engine.processes.remove(i);
                }
            }

            // Pending count update timer (every 2 seconds) - broadcast to world viewers if changed
            _ = pending_update_interval.tick() => {
                let now = std::time::Instant::now();
                for world in app.worlds.iter_mut() {
                    // Only send updates if world has pending lines and count has changed
                    let current_count = world.pending_lines.len();
                    if current_count > 0 && current_count != world.last_pending_count_broadcast {
                        // Check if 2 seconds have passed since last broadcast for this world
                        let should_broadcast = world.last_pending_broadcast
                            .map(|t| now.duration_since(t) >= Duration::from_secs(2))
                            .unwrap_or(true);
                        if should_broadcast {
                            world.last_pending_broadcast = Some(now);
                            world.last_pending_count_broadcast = current_count;
                        }
                    } else if current_count == 0 && world.last_pending_count_broadcast > 0 {
                        // Pending was cleared - reset tracking
                        world.last_pending_count_broadcast = 0;
                        world.last_pending_broadcast = None;
                    }
                }
                // Broadcast pending updates for worlds that need it
                for idx in 0..app.worlds.len() {
                    let current_count = app.worlds[idx].pending_lines.len();
                    if current_count > 0 {
                        app.ws_broadcast_to_world(idx, WsMessage::PendingCountUpdate {
                            world_index: idx,
                            count: current_count,
                        });
                    }
                }
            }
        }

        // Process any additional queued server events BEFORE drawing
        // This ensures the render always shows the most current state
        // (the select! above processes only one event; drain remaining here)
        while let Ok(event) = event_rx.try_recv() {
            match event {
                AppEvent::ServerData(ref world_name, bytes) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        // Consider "current" if console OR any web/GUI client is viewing this world
                        let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                        let decoded_data = app.worlds[world_idx].settings.encoding.decode(&bytes);

                        // Extract ANSI music sequences FIRST, before any other processing
                        let (data, music_sequences) = if app.settings.ansi_music_enabled {
                            ansi_music::extract_music(&decoded_data)
                        } else {
                            (decoded_data.clone(), Vec::new())
                        };

                        // Broadcast music to WebSocket clients (web/GUI play audio)
                        for notes in music_sequences {
                            app.ws_broadcast(WsMessage::AnsiMusic {
                                world_index: world_idx,
                                notes,
                            });
                        }

                        let world_name_for_triggers = world_name.clone();
                        let actions = app.settings.actions.clone();

                        // Combine with any partial line from previous data chunk
                        let had_trigger_partial = !app.worlds[world_idx].trigger_partial_line.is_empty();
                        let combined_data = if had_trigger_partial {
                            let mut s = std::mem::take(&mut app.worlds[world_idx].trigger_partial_line);
                            s.push_str(&data);
                            s
                        } else {
                            data.clone()
                        };

                        // Process action triggers on complete lines
                        // Track lines with gagged flag and highlight color: (line, is_gagged, highlight_color)
                        let mut processed_lines: Vec<(&str, bool, Option<String>)> = Vec::new();
                        let mut commands_to_execute: Vec<String> = Vec::new();
                        let mut tf_commands_to_execute: Vec<String> = Vec::new();
                        let ends_with_newline = combined_data.ends_with('\n');
                        let lines: Vec<&str> = combined_data.lines().collect();
                        let line_count = lines.len();
                        let mut has_partial = false;
                        // Use persistent flag to track idler filtering across TCP packets
                        let mut just_filtered_idler = app.worlds[world_idx].just_filtered_idler;

                        for (i, line) in lines.iter().enumerate() {
                            let is_last = i == line_count - 1;
                            let is_partial = is_last && !ends_with_newline;

                            // Filter out keep-alive idler message lines (only for Custom/Generic keep-alive types)
                            let uses_idler_keepalive = matches!(
                                app.worlds[world_idx].settings.keep_alive_type,
                                KeepAliveType::Custom | KeepAliveType::Generic
                            );
                            if uses_idler_keepalive && line.contains("###_idler_message_") && line.contains("_###") {
                                just_filtered_idler = true;
                                continue;
                            }

                            // Filter blank lines that immediately follow an idler message
                            if just_filtered_idler && is_visually_empty(line) {
                                just_filtered_idler = false; // Reset after filtering the blank
                                continue;
                            }
                            just_filtered_idler = false;

                            // Check triggers on complete lines only
                            if is_partial {
                                // Store partial line for next chunk - don't process yet
                                app.worlds[world_idx].trigger_partial_line = line.to_string();
                                has_partial = true;
                            } else {
                                let mut is_gagged = false;
                                let mut highlight_color: Option<String> = None;
                                // Check Clay action triggers
                                if let Some(result) = check_action_triggers(line, &world_name_for_triggers, &actions) {
                                    commands_to_execute.extend(result.commands);
                                    is_gagged = result.should_gag;
                                    highlight_color = result.highlight_color;
                                }
                                // Check TF triggers
                                let tf_result = tf::bridge::process_line(&mut app.tf_engine, line, Some(&world_name_for_triggers));
                                commands_to_execute.extend(tf_result.send_commands);
                                tf_commands_to_execute.extend(tf_result.clay_commands);
                                is_gagged = is_gagged || tf_result.should_gag;
                                // Output TF messages (from #echo etc)
                                for msg in &tf_result.messages {
                                    app.add_tf_output(msg);
                                }
                                // Handle substitution
                                if let Some((sub_text, sub_attrs)) = tf_result.substitution {
                                    is_gagged = true;
                                    let sub_with_attrs = if sub_attrs.contains('C') || sub_attrs.contains('B') {
                                        apply_tf_attrs(&sub_text, &sub_attrs)
                                    } else {
                                        sub_text
                                    };
                                    app.add_tf_output(&sub_with_attrs);
                                }
                                // Only add complete lines with gagged flag and highlight color
                                processed_lines.push((line, is_gagged, highlight_color));
                            }
                        }

                        // Save the idler filter state for next packet
                        app.worlds[world_idx].just_filtered_idler = just_filtered_idler;

                        // If we have a partial line and world uses WONT ECHO prompts, start timeout
                        if has_partial && app.worlds[world_idx].prompt.is_empty()
                            && app.worlds[world_idx].uses_wont_echo_prompt {
                            app.worlds[world_idx].wont_echo_time = Some(std::time::Instant::now());
                        }

                        // Separate gagged and non-gagged lines, tracking highlight colors
                        let non_gagged_lines: Vec<(&str, Option<String>)> = processed_lines.iter()
                            .filter(|(_, gagged, _)| !gagged)
                            .map(|(line, _, highlight)| (*line, highlight.clone()))
                            .collect();
                        let gagged_lines: Vec<(&str, Option<String>)> = processed_lines.iter()
                            .filter(|(_, gagged, _)| *gagged)
                            .map(|(line, _, highlight)| (*line, highlight.clone()))
                            .collect();
                        // Create a map of line content to highlight color for non-gagged lines
                        let highlight_map: std::collections::HashMap<String, Option<String>> = non_gagged_lines.iter()
                            .filter(|(_, hl)| hl.is_some())
                            .map(|(line, hl)| (line.to_string(), hl.clone()))
                            .collect();

                        // Add trailing newline if original ended with newline OR if we have a partial
                        // (because a partial means there was a newline before it that we need to preserve)
                        let filtered_data = if non_gagged_lines.is_empty() {
                            String::new()
                        } else {
                            let lines_only: Vec<&str> = non_gagged_lines.iter().map(|(line, _)| *line).collect();
                            let mut result = lines_only.join("\n");
                            if ends_with_newline || has_partial {
                                result.push('\n');
                            }
                            result
                        };

                        if !filtered_data.is_empty() {
                            let settings = app.settings.clone();
                            let console_height = app.output_height;
                            let output_width = app.output_width;

                            // Calculate minimum visible lines among all viewers for synchronized more-mode
                            let console_viewing = world_idx == app.current_world_index;
                            let ws_min = app.min_viewer_lines(world_idx);
                            let output_height = match (console_viewing, ws_min) {
                                (true, Some(ws)) => console_height.min(ws as u16),
                                (true, None) => console_height,
                                (false, Some(ws)) => ws as u16,
                                (false, None) => console_height,
                            };

                            // Track pending count before add_output for synchronized more-mode
                            let pending_before = app.worlds[world_idx].pending_lines.len();
                            let output_before = app.worlds[world_idx].output_lines.len();

                            app.worlds[world_idx].add_output(&filtered_data, is_current, &settings, output_height, output_width, true, true);

                            // Calculate what went where
                            let pending_after = app.worlds[world_idx].pending_lines.len();
                            let output_after = app.worlds[world_idx].output_lines.len();
                            let lines_to_output = output_after.saturating_sub(output_before);
                            let lines_to_pending = pending_after.saturating_sub(pending_before);

                            // Apply highlight colors to newly added lines
                            if !highlight_map.is_empty() {
                                // Apply to output_lines
                                for line in app.worlds[world_idx].output_lines.iter_mut().skip(output_before) {
                                    let plain_text = strip_ansi_codes(&line.text);
                                    if let Some(hl) = highlight_map.get(&plain_text) {
                                        line.highlight_color = hl.clone();
                                    }
                                }
                                // Apply to pending_lines
                                for line in app.worlds[world_idx].pending_lines.iter_mut().skip(pending_before) {
                                    let plain_text = strip_ansi_codes(&line.text);
                                    if let Some(hl) = highlight_map.get(&plain_text) {
                                        line.highlight_color = hl.clone();
                                    }
                                }
                            }

                            // Mark output for redraw if this is the current world
                            if world_idx == app.current_world_index {
                                app.needs_output_redraw = true;
                            }
                            if app.worlds[world_idx].needs_redraw {
                                app.worlds[world_idx].needs_redraw = false;
                                let _ = terminal.clear();
                            }

                            // For synchronized more-mode: only broadcast lines that went to output_lines
                            if lines_to_output > 0 {
                                let output_lines_to_broadcast: Vec<String> = app.worlds[world_idx]
                                    .output_lines
                                    .iter()
                                    .skip(output_before)
                                    .take(lines_to_output)
                                    .map(|line| line.text.replace('\r', ""))
                                    .collect();
                                let ws_data = output_lines_to_broadcast.join("\n") + "\n";
                                app.ws_broadcast(WsMessage::ServerData {
                                    world_index: world_idx,
                                    data: ws_data,
                                    is_viewed: is_current,
                                    ts: current_timestamp_secs(),
                                    from_server: true,  // This is MUD server data
                                });
                            }

                            // Broadcast pending count update if it changed
                            // Use filtered broadcast to skip clients that received pending in InitialState
                            if lines_to_pending > 0 || pending_after != pending_before {
                                app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: pending_after });
                            }

                            // Broadcast updated unseen count so all clients stay in sync
                            let unseen_count = app.worlds[world_idx].unseen_lines;
                            if unseen_count > 0 {
                                app.ws_broadcast(WsMessage::UnseenUpdate {
                                    world_index: world_idx,
                                    count: unseen_count,
                                });
                            }

                            // Broadcast activity count to keep all clients in sync
                            app.broadcast_activity();
                        }

                        // Add gagged lines to output (they'll only show with F2)
                        for (line, highlight) in gagged_lines {
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            let mut output_line = OutputLine::new_gagged(line.to_string(), seq);
                            output_line.highlight_color = highlight;
                            app.worlds[world_idx].output_lines.push(output_line);
                        }
                        if !app.worlds[world_idx].paused {
                            app.worlds[world_idx].scroll_to_bottom();
                        }

                        // Temporarily set current_world to the triggering world so /send
                        // without -w sends to the world that triggered the action
                        let saved_current_world = app.current_world_index;
                        app.current_world_index = world_idx;
                        for cmd in commands_to_execute {
                            if cmd.starts_with('/') {
                                // Unified command system - route through TF parser
                                app.sync_tf_world_info();
                                match app.tf_engine.execute(&cmd) {
                                    tf::TfCommandResult::SendToMud(text) => {
                                        if let Some(tx) = &app.worlds[world_idx].command_tx {
                                            let _ = tx.try_send(WriteCommand::Text(text));
                                        }
                                    }
                                    tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                        handle_command(&clay_cmd, &mut app, event_tx.clone()).await;
                                    }
                                    tf::TfCommandResult::RepeatProcess(process) => {
                                        app.tf_engine.processes.push(process);
                                    }
                                    _ => {}
                                }
                            } else if let Some(tx) = &app.worlds[world_idx].command_tx {
                                let _ = tx.try_send(WriteCommand::Text(cmd));
                            }
                        }
                        app.current_world_index = saved_current_world;
                        // Execute TF-generated Clay commands
                        for cmd in tf_commands_to_execute {
                            let _ = app.tf_engine.execute(&cmd);
                        }
                    }
                }
                AppEvent::Disconnected(ref world_name, conn_id) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        // Ignore stale disconnect from a previous connection
                        if conn_id != app.worlds[world_idx].connection_id {
                            continue;
                        }
                        // Fire TF DISCONNECT hook before cleaning up
                        let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Disconnect);
                        for cmd in hook_result.clay_commands {
                            let _ = app.tf_engine.execute(&cmd);
                        }

                        // Push prompt to output before clearing
                        if !app.worlds[world_idx].prompt.is_empty() {
                            let prompt_text = app.worlds[world_idx].prompt.trim().to_string();
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_text, seq));
                        }
                        app.worlds[world_idx].clear_connection_state(true, true);
                        // Show disconnection message
                        let seq = app.worlds[world_idx].next_seq;
                        app.worlds[world_idx].next_seq += 1;
                        let disconnect_msg = OutputLine::new_client("Disconnected.".to_string(), seq);
                        app.worlds[world_idx].output_lines.push(disconnect_msg.clone());

                        // If this is not the current world, increment unseen_lines for activity indicator
                        if world_idx != app.current_world_index {
                            if app.worlds[world_idx].unseen_lines == 0 {
                                app.worlds[world_idx].first_unseen_at = Some(std::time::Instant::now());
                            }
                            app.worlds[world_idx].unseen_lines += 1;
                        }

                        // Broadcast disconnect message to WebSocket clients viewing this world
                        app.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                            world_index: world_idx,
                            data: "Disconnected.\n".to_string(),
                            is_viewed: true,
                            ts: disconnect_msg.timestamp.duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
                            from_server: false,
                        });
                        app.ws_broadcast(WsMessage::WorldDisconnected { world_index: world_idx });
                    }
                }
                AppEvent::TelnetDetected(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        if !app.worlds[world_idx].telnet_mode {
                            app.worlds[world_idx].telnet_mode = true;
                        }
                    }
                }
                AppEvent::WontEchoSeen(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        if !app.worlds[world_idx].uses_wont_echo_prompt {
                            app.worlds[world_idx].uses_wont_echo_prompt = true;
                        }
                    }
                }
                AppEvent::NawsRequested(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        // Mark NAWS as enabled for this world
                        app.worlds[world_idx].naws_enabled = true;
                        // Send initial window size
                        app.send_naws_if_changed(world_idx);
                    }
                }
                AppEvent::TtypeRequested(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        // Send terminal type response
                        // Use TERM environment variable if set, otherwise default to "ANSI"
                        let term_type = std::env::var("TERM").unwrap_or_else(|_| "ANSI".to_string());
                        if let Some(ref tx) = app.worlds[world_idx].command_tx {
                            let ttype_response = build_ttype_response(&term_type);
                            let _ = tx.try_send(WriteCommand::Raw(ttype_response));
                        }
                    }
                }
                AppEvent::Prompt(ref world_name, prompt_bytes) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        let encoding = app.worlds[world_idx].settings.encoding;
                        let prompt_text = encoding.decode(&prompt_bytes);
                        let prompt_normalized = crate::util::normalize_prompt(&prompt_text);

                        // If world is not connected, display prompt as output instead of input area
                        if !app.worlds[world_idx].connected {
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            app.worlds[world_idx].output_lines.push(OutputLine::new(prompt_normalized.trim().to_string(), seq));
                            app.worlds[world_idx].prompt.clear();
                            continue;
                        }

                        app.worlds[world_idx].prompt = prompt_normalized.clone();
                        app.ws_broadcast(WsMessage::PromptUpdate {
                            world_index: world_idx,
                            prompt: prompt_normalized,
                        });

                        let world = &mut app.worlds[world_idx];
                        world.prompt_count += 1;

                        // Skip auto-login if flag is set (from /worlds -l)
                        if world.skip_auto_login {
                            continue;
                        }

                        let auto_type = world.settings.auto_connect_type;
                        let user = world.settings.user.clone();
                        let password = world.settings.password.clone();
                        let prompt_num = world.prompt_count;

                        if !user.is_empty() && !password.is_empty() {
                            let cmd_to_send = match auto_type {
                                AutoConnectType::Prompt => {
                                    match prompt_num {
                                        1 if !user.is_empty() => Some(user),
                                        2 if !password.is_empty() => Some(password),
                                        _ => None,
                                    }
                                }
                                AutoConnectType::MooPrompt => {
                                    match prompt_num {
                                        1 if !user.is_empty() => Some(user.clone()),
                                        2 if !password.is_empty() => Some(password),
                                        3 if !user.is_empty() => Some(user),
                                        _ => None,
                                    }
                                }
                                AutoConnectType::Connect | AutoConnectType::NoLogin => None,
                            };

                            if let Some(cmd) = cmd_to_send {
                                if let Some(tx) = &world.command_tx {
                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                    world.last_send_time = Some(std::time::Instant::now());
                                    // Clear prompt since we auto-answered it
                                    world.prompt.clear();
                                }
                            }
                        }
                    }
                }
                AppEvent::SystemMessage(message) => {
                    // Display system message in current world's output
                    app.add_output(&message);
                }
                // Multiuser events are only used in multiuser mode, ignore in normal mode
                AppEvent::ConnectWorldRequest(_, _) => {}
                AppEvent::MultiuserServerData(_, _, _) => {}
                AppEvent::MultiuserDisconnected(_, _) => {}
                AppEvent::MultiuserTelnetDetected(_, _) => {}
                AppEvent::MultiuserPrompt(_, _, _) => {}
                // SIGUSR1 - only relevant in main console mode, ignore in daemon mode
                AppEvent::Sigusr1Received => {}
                AppEvent::GmcpNegotiated(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].gmcp_enabled = true;
                        let packages_str = app.worlds[world_idx].settings.gmcp_packages.clone();
                        let packages: Vec<String> = packages_str
                            .split(',')
                            .map(|s| s.trim().to_string())
                            .filter(|s| !s.is_empty())
                            .collect();
                        app.worlds[world_idx].gmcp_supported_packages = packages.clone();
                        if let Some(ref tx) = app.worlds[world_idx].command_tx {
                            let hello = build_gmcp_message("Core.Hello", &format!(
                                "{{\"client\":\"Clay\",\"version\":\"{}\"}}",
                                VERSION
                            ));
                            let _ = tx.try_send(WriteCommand::Raw(hello));
                            let json_list: Vec<String> = packages.iter()
                                .map(|p| format!("\"{}\"", p))
                                .collect();
                            let supports = build_gmcp_message(
                                "Core.Supports.Set",
                                &format!("[{}]", json_list.join(",")),
                            );
                            let _ = tx.try_send(WriteCommand::Raw(supports));
                        }
                    }
                }
                AppEvent::MsdpNegotiated(ref world_name) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].msdp_enabled = true;
                    }
                }
                AppEvent::GmcpReceived(ref world_name, ref package, ref json_data) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        // Always store GMCP data
                        app.worlds[world_idx].gmcp_data.insert(package.clone(), json_data.clone());
                        // Always store Client.Media.Default URL
                        if package == "Client.Media.Default" {
                            if let Ok(parsed) = serde_json::from_str::<serde_json::Value>(json_data) {
                                if let Some(url) = parsed.get("url").and_then(|v| v.as_str()) {
                                    app.worlds[world_idx].mcmp_default_url = url.to_string();
                                }
                            }
                        }
                        // Always broadcast to remote clients
                        app.ws_broadcast(WsMessage::GmcpData {
                            world_index: world_idx,
                            package: package.clone(),
                            data: json_data.clone(),
                        });
                        if package.starts_with("Client.Media.") {
                            let action = package.rsplit('.').next().unwrap_or("Play").to_string();
                            let default_url = app.worlds[world_idx].mcmp_default_url.clone();
                            app.ws_broadcast(WsMessage::McmpMedia {
                                world_index: world_idx,
                                action,
                                data: json_data.clone(),
                                default_url,
                            });
                        }
                        // Always track media state; only play audio when enabled + current world
                        if package.starts_with("Client.Media.") {
                            let play_audio = app.worlds[world_idx].gmcp_user_enabled
                                && world_idx == app.current_world_index;
                            app.handle_gmcp_media(world_idx, package, json_data, play_audio);
                        }
                        // Gate TF hooks on gmcp_user_enabled
                        if app.worlds[world_idx].gmcp_user_enabled {
                            app.tf_engine.set_global("gmcp_package", crate::tf::TfValue::String(package.clone()));
                            app.tf_engine.set_global("gmcp_data", crate::tf::TfValue::String(json_data.clone()));
                            let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Gmcp);
                            for r in results {
                                if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                    if let Some(world) = app.worlds.get(world_idx) {
                                        if let Some(ref tx) = world.command_tx {
                                            let _ = tx.try_send(WriteCommand::Text(text));
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                AppEvent::MsdpReceived(ref world_name, ref variable, ref value_json) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].msdp_variables.insert(variable.clone(), value_json.clone());
                        app.tf_engine.set_global("msdp_var", crate::tf::TfValue::String(variable.clone()));
                        app.tf_engine.set_global("msdp_val", crate::tf::TfValue::String(value_json.clone()));
                        let results = crate::tf::hooks::fire_hook(&mut app.tf_engine, crate::tf::TfHookEvent::Msdp);
                        for r in results {
                            if let crate::tf::TfCommandResult::SendToMud(text) = r {
                                if let Some(world) = app.worlds.get(world_idx) {
                                    if let Some(ref tx) = world.command_tx {
                                        let _ = tx.try_send(WriteCommand::Text(text));
                                    }
                                }
                            }
                        }
                        app.ws_broadcast(WsMessage::MsdpData {
                            world_index: world_idx,
                            variable: variable.clone(),
                            value: value_json.clone(),
                        });
                    }
                }
                // Slack/Discord events
                AppEvent::SlackMessage(ref world_name, message) | AppEvent::DiscordMessage(ref world_name, message) => {
                    if let Some(world_idx) = app.find_world_index(world_name) {
                        app.worlds[world_idx].last_receive_time = Some(std::time::Instant::now());
                        let is_current = world_idx == app.current_world_index || app.ws_client_viewing(world_idx);
                        let world_name_for_triggers = world_name.clone();
                        let actions = app.settings.actions.clone();

                        // Check action triggers on the message
                        let mut is_gagged = false;
                        let mut commands_to_execute: Vec<String> = Vec::new();
                        let mut tf_commands_to_execute: Vec<String> = Vec::new();
                        if let Some(result) = check_action_triggers(&message, &world_name_for_triggers, &actions) {
                            commands_to_execute = result.commands;
                            is_gagged = result.should_gag;
                        }
                        // Check TF triggers
                        let tf_result = tf::bridge::process_line(&mut app.tf_engine, &message, Some(&world_name_for_triggers));
                        commands_to_execute.extend(tf_result.send_commands);
                        tf_commands_to_execute.extend(tf_result.clay_commands);
                        is_gagged = is_gagged || tf_result.should_gag;
                        // Output TF messages (from #echo etc)
                        for msg in &tf_result.messages {
                            app.add_tf_output(msg);
                        }
                        // Handle substitution
                        if let Some((sub_text, sub_attrs)) = tf_result.substitution {
                            is_gagged = true;
                            let sub_with_attrs = if sub_attrs.contains('C') || sub_attrs.contains('B') {
                                apply_tf_attrs(&sub_text, &sub_attrs)
                            } else {
                                sub_text
                            };
                            app.add_tf_output(&sub_with_attrs);
                        }

                        let data = format!("{}\n", message);

                        if is_gagged {
                            // Add as gagged line (only visible with F2)
                            let seq = app.worlds[world_idx].next_seq;
                            app.worlds[world_idx].next_seq += 1;
                            app.worlds[world_idx].output_lines.push(OutputLine::new_gagged(message.clone(), seq));
                            if !app.worlds[world_idx].paused {
                                app.worlds[world_idx].scroll_to_bottom();
                            }
                        } else {
                            // Add non-gagged output normally
                            let settings = app.settings.clone();
                            let output_height = app.output_height;
                            let output_width = app.output_width;
                            app.worlds[world_idx].add_output(&data, is_current, &settings, output_height, output_width, true, true);
                            // Broadcast to WebSocket clients (only non-gagged)
                            app.ws_broadcast(WsMessage::ServerData {
                                world_index: world_idx,
                                data,
                                is_viewed: is_current,
                                ts: current_timestamp_secs(),
                                from_server: false,
                            });
                        }

                        // Execute any triggered commands
                        // Temporarily set current_world to the triggering world so /send
                        // without -w sends to the world that triggered the action
                        let saved_current_world = app.current_world_index;
                        app.current_world_index = world_idx;
                        for cmd in commands_to_execute {
                            if cmd.starts_with('/') {
                                // Unified command system - route through TF parser
                                app.sync_tf_world_info();
                                match app.tf_engine.execute(&cmd) {
                                    tf::TfCommandResult::SendToMud(text) => {
                                        if let Some(tx) = &app.worlds[world_idx].command_tx {
                                            let _ = tx.try_send(WriteCommand::Text(text));
                                        }
                                    }
                                    tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                        handle_command(&clay_cmd, &mut app, event_tx.clone()).await;
                                    }
                                    tf::TfCommandResult::RepeatProcess(process) => {
                                        app.tf_engine.processes.push(process);
                                    }
                                    _ => {}
                                }
                            } else if let Some(tx) = &app.worlds[world_idx].command_tx {
                                let _ = tx.try_send(WriteCommand::Text(cmd));
                            }
                        }
                        app.current_world_index = saved_current_world;
                        // Execute TF-generated Clay commands
                        for cmd in tf_commands_to_execute {
                            let _ = app.tf_engine.execute(&cmd);
                        }
                    }
                }
                // WebSocket events (drain loop - complex handlers use primary loop)
                AppEvent::WsClientConnected(_) => {}
                AppEvent::WsClientDisconnected(client_id) => {
                    // Client disconnected - remove from ws_client_worlds cache
                    let had_dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions).is_some();
                    app.ws_client_worlds.remove(&client_id);
                    // If client had dimensions, recalculate minimum and send NAWS updates
                    if had_dimensions {
                        app.send_naws_to_all_worlds();
                    }
                }
                AppEvent::WsAuthKeyValidation(client_id, msg, client_ip) => {
                    // Validate auth key from AuthRequest
                    if let WsMessage::AuthRequest { auth_key: Some(key), current_world, .. } = *msg {
                        let is_valid = app.settings.websocket_auth_keys.contains(&key);
                        if is_valid {
                            app.ws_set_client_authenticated(client_id, true);
                            app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                success: true,
                                error: None,
                                username: None,
                                multiuser_mode: false,
                            });
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                            app.ws_mark_initial_state_sent(client_id);
                            let world_idx = current_world
                                .filter(|&w| w < app.worlds.len())
                                .unwrap_or(app.current_world_index);
                            app.ws_set_client_world(client_id, Some(world_idx));
                            app.ws_client_worlds.insert(client_id, ClientViewState {
                                world_index: world_idx,
                                visible_lines: 0,
                                dimensions: None,
                            });
                            app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                count: app.activity_count(),
                            });
                        } else {
                            // Invalid key - record ban violation
                            app.ban_list.record_violation(&client_ip, "WebSocket: failed auth key");
                            app.ws_send_to_client(client_id, WsMessage::AuthResponse {
                                success: false,
                                error: Some("Invalid auth key".to_string()),
                                username: None,
                                multiuser_mode: false,
                            });
                        }
                    }
                }
                AppEvent::WsKeyRequest(client_id) => {
                    use sha2::{Sha256, Digest};
                    let mut hasher = Sha256::new();
                    hasher.update(std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap_or_default()
                        .as_nanos()
                        .to_le_bytes());
                    hasher.update(std::process::id().to_le_bytes());
                    hasher.update(client_id.to_le_bytes());
                    hasher.update(app.settings.websocket_auth_keys.len().to_le_bytes());
                    let key = hex::encode(hasher.finalize());
                    app.settings.websocket_auth_keys.push(key.clone());
                    let _ = persistence::save_settings(&app);
                    app.ws_send_to_client(client_id, WsMessage::KeyGenerated { auth_key: key });
                }
                AppEvent::WsKeyRevoke(_client_id, key) => {
                    app.settings.websocket_auth_keys.retain(|k| k != &key);
                    let _ = persistence::save_settings(&app);
                }
                AppEvent::WsClientMessage(client_id, msg) => {
                    // Handle simple messages in drain loop
                    // Extract current_world from AuthRequest before matching (avoids borrow issues)
                    let auth_current_world = if let WsMessage::AuthRequest { current_world, .. } = &*msg {
                        *current_world
                    } else {
                        None
                    };
                    match *msg {
                        WsMessage::AuthRequest { .. } => {
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                            // Mark client as having received initial state so it receives broadcasts
                            app.ws_mark_initial_state_sent(client_id);
                            // Use client's world if provided, otherwise default to console's world
                            let world_idx = auth_current_world
                                .filter(|&w| w < app.worlds.len())
                                .unwrap_or(app.current_world_index);
                            // Set client's initial world so broadcast_to_world_viewers works immediately
                            app.ws_set_client_world(client_id, Some(world_idx));
                            // Also update ws_client_worlds cache for ws_client_viewing()
                            app.ws_client_worlds.insert(client_id, ClientViewState {
                                world_index: world_idx,
                                visible_lines: 0,
                                dimensions: None,
                            });
                            // Also send current activity count
                            app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                count: app.activity_count(),
                            });
                        }
                        WsMessage::SendCommand { world_index, ref command } => {
                            // Reset more-mode counter when ANY client sends a command
                            if world_index < app.worlds.len() {
                                app.worlds[world_index].lines_since_pause = 0;
                                app.worlds[world_index].last_user_command_time = Some(std::time::Instant::now());
                                // Update client's viewing world to ensure they receive output
                                // (fixes race condition where client sends command before UpdateViewState)
                                let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                app.ws_set_client_world(client_id, Some(world_index));
                            }

                            // Use shared command parsing
                            let parsed = parse_command(command);

                            match parsed {
                                // Commands handled locally on server
                                Command::ActionCommand { name, args } => {
                                    // Execute action if it exists
                                    if let Some(action) = app.settings.actions.iter().find(|a| a.name.eq_ignore_ascii_case(&name)) {
                                        // Skip disabled actions
                                        if !action.enabled {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("âœ¨ Action '{}' is disabled.", name),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        } else {
                                        let commands = split_action_commands(&action.command);
                                        let mut sent_to_server = false;
                                        for cmd in commands {
                                            // Substitute $1-$9 and $* with arguments
                                            let cmd = substitute_action_args(&cmd, &args);

                                            if cmd.eq_ignore_ascii_case("/gag") || cmd.to_lowercase().starts_with("/gag ") {
                                                continue;
                                            }
                                            // Unified command system - route through TF parser
                                            if cmd.starts_with('/') {
                                                app.sync_tf_world_info();
                                                match app.tf_engine.execute(&cmd) {
                                                    tf::TfCommandResult::Success(Some(msg)) => {
                                                        app.ws_broadcast(WsMessage::ServerData {
                                                            world_index,
                                                            data: msg,
                                                            is_viewed: false,
                                                            ts: current_timestamp_secs(),
                                                            from_server: false,
                                                        });
                                                    }
                                                    tf::TfCommandResult::Success(None) => {}
                                                    tf::TfCommandResult::Error(err) => {
                                                        app.ws_broadcast(WsMessage::ServerData {
                                                            world_index,
                                                            data: format!("Error: {}", err),
                                                            is_viewed: false,
                                                            ts: current_timestamp_secs(),
                                                            from_server: false,
                                                        });
                                                    }
                                                    tf::TfCommandResult::SendToMud(text) => {
                                                        if world_index < app.worlds.len() {
                                                            if let Some(tx) = &app.worlds[world_index].command_tx {
                                                                let _ = tx.try_send(WriteCommand::Text(text));
                                                                sent_to_server = true;
                                                            }
                                                        }
                                                    }
                                                    tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                                        app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: clay_cmd });
                                                    }
                                                    tf::TfCommandResult::Recall(opts) => {
                                                        if world_index < app.worlds.len() {
                                                            let output_lines = app.worlds[world_index].output_lines.clone();
                                                            let (matches, header) = execute_recall(&opts, &output_lines);
                                                            let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                                                            let ts = current_timestamp_secs();

                                                            if !opts.quiet {
                                                                if let Some(h) = header {
                                                                    app.ws_broadcast(WsMessage::ServerData { world_index, data: h, is_viewed: false, ts , from_server: false });
                                                                }
                                                            }
                                                            if matches.is_empty() {
                                                                app.ws_broadcast(WsMessage::ServerData { world_index, data: format!("âœ¨ No matches for '{}'", pattern_str), is_viewed: false, ts, from_server: false });
                                                            } else {
                                                                for m in matches {
                                                                    app.ws_broadcast(WsMessage::ServerData { world_index, data: m, is_viewed: false, ts , from_server: false });
                                                                }
                                                            }
                                                            if !opts.quiet {
                                                                app.ws_broadcast(WsMessage::ServerData { world_index, data: "================= Recall end =================".to_string(), is_viewed: false, ts , from_server: false });
                                                            }
                                                        }
                                                    }
                                                    tf::TfCommandResult::RepeatProcess(process) => {
                                                        let id = process.id;
                                                        let interval = format_duration_short(process.interval);
                                                        let count_str = process.count.map_or("infinite".to_string(), |c| c.to_string());
                                                        let cmd_str = process.command.clone();
                                                        app.tf_engine.processes.push(process);
                                                        app.ws_broadcast(WsMessage::ServerData {
                                                            world_index,
                                                            data: format!("% Process {} started: {} every {} ({} times)", id, cmd_str, interval, count_str),
                                                            is_viewed: false,
                                                            ts: current_timestamp_secs(),
                                                            from_server: false,
                                                        });
                                                    }
                                                    _ => {}
                                                }
                                            } else if world_index < app.worlds.len() {
                                                // Plain text - send to MUD server
                                                if let Some(tx) = &app.worlds[world_index].command_tx {
                                                    let _ = tx.try_send(WriteCommand::Text(cmd));
                                                    sent_to_server = true;
                                                }
                                            }
                                        }
                                        if sent_to_server {
                                            app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                        }
                                        }
                                    } else {
                                        // No matching action - try TF engine (handles /recall, /set, /echo, etc.)
                                        app.sync_tf_world_info();
                                        match app.tf_engine.execute(command) {
                                            tf::TfCommandResult::Success(Some(msg)) => {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index, data: msg, is_viewed: false,
                                                    ts: current_timestamp_secs(), from_server: false,
                                                });
                                            }
                                            tf::TfCommandResult::Success(None) => {}
                                            tf::TfCommandResult::Error(err) => {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index, data: format!("Error: {}", err), is_viewed: false,
                                                    ts: current_timestamp_secs(), from_server: false,
                                                });
                                            }
                                            tf::TfCommandResult::SendToMud(text) => {
                                                if world_index < app.worlds.len() {
                                                    if let Some(tx) = &app.worlds[world_index].command_tx {
                                                        let _ = tx.try_send(WriteCommand::Text(text));
                                                        app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                    }
                                                }
                                            }
                                            tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                                app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: clay_cmd });
                                            }
                                            tf::TfCommandResult::Recall(opts) => {
                                                if world_index < app.worlds.len() {
                                                    let output_lines = app.worlds[world_index].output_lines.clone();
                                                    let (matches, header) = execute_recall(&opts, &output_lines);
                                                    let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                                                    let ts = current_timestamp_secs();
                                                    if !opts.quiet {
                                                        if let Some(h) = header {
                                                            app.ws_broadcast(WsMessage::ServerData { world_index, data: h, is_viewed: false, ts, from_server: false });
                                                        }
                                                    }
                                                    if matches.is_empty() {
                                                        app.ws_broadcast(WsMessage::ServerData { world_index, data: format!("âœ¨ No matches for '{}'", pattern_str), is_viewed: false, ts, from_server: false });
                                                    } else {
                                                        for m in matches {
                                                            app.ws_broadcast(WsMessage::ServerData { world_index, data: m, is_viewed: false, ts, from_server: false });
                                                        }
                                                    }
                                                    if !opts.quiet {
                                                        app.ws_broadcast(WsMessage::ServerData { world_index, data: "================= Recall end =================".to_string(), is_viewed: false, ts, from_server: false });
                                                    }
                                                }
                                            }
                                            tf::TfCommandResult::RepeatProcess(process) => {
                                                app.tf_engine.processes.push(process);
                                            }
                                            _ => {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("Unknown command: /{}", name),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        }
                                    }
                                }
                                Command::NotACommand { text } => {
                                    // Regular text - send to MUD
                                    if world_index < app.worlds.len() {
                                        if let Some(tx) = &app.worlds[world_index].command_tx {
                                            if tx.try_send(WriteCommand::Text(text)).is_ok() {
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                                app.worlds[world_index].prompt.clear();
                                            }
                                        }
                                    }
                                }
                                Command::Edit { .. } => {
                                    // Edit command is handled locally on the client, not on server
                                    // Send back to client for local execution
                                    app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                }
                                Command::Tag => {
                                    // Toggle show_tags setting (same as F2)
                                    app.show_tags = !app.show_tags;
                                    app.ws_broadcast(WsMessage::ShowTagsChanged { show_tags: app.show_tags });
                                }
                                Command::Unknown { cmd } => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: format!("Unknown command: {}", cmd),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                Command::Send { text, all_worlds, target_world, no_newline } => {
                                    // Handle /send command
                                    // Helper to create the write command
                                    let make_write_cmd = |t: &str| -> WriteCommand {
                                        if no_newline {
                                            WriteCommand::Raw(t.as_bytes().to_vec())
                                        } else {
                                            WriteCommand::Text(t.to_string())
                                        }
                                    };

                                    if all_worlds {
                                        // Send to all connected worlds
                                        for world in app.worlds.iter_mut() {
                                            if world.connected {
                                                if let Some(tx) = &world.command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    world.last_send_time = Some(std::time::Instant::now());
                                                }
                                            }
                                        }
                                    } else if let Some(ref target) = target_world {
                                        // Send to specific world by name
                                        if let Some(world) = app.worlds.iter_mut().find(|w| w.name.eq_ignore_ascii_case(target)) {
                                            if world.connected {
                                                if let Some(tx) = &world.command_tx {
                                                    let _ = tx.try_send(make_write_cmd(&text));
                                                    world.last_send_time = Some(std::time::Instant::now());
                                                }
                                            } else {
                                                app.ws_broadcast(WsMessage::ServerData {
                                                    world_index,
                                                    data: format!("World '{}' is not connected.", target),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        } else {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Unknown world: {}", target),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                    } else {
                                        // Send to current world (the one this command came from)
                                        if world_index < app.worlds.len() {
                                            if let Some(tx) = &app.worlds[world_index].command_tx {
                                                let _ = tx.try_send(make_write_cmd(&text));
                                                app.worlds[world_index].last_send_time = Some(std::time::Instant::now());
                                            }
                                        }
                                    }
                                }
                                Command::Disconnect => {
                                    // Disconnect the specified world
                                    if world_index < app.worlds.len() && app.worlds[world_index].connected {
                                        // Kill proxy process if one exists
                                        #[cfg(unix)]
                                        if let Some(proxy_pid) = app.worlds[world_index].proxy_pid {
                                            unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                        }
                                        app.worlds[world_index].clear_connection_state(true, true);
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Disconnected.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                        app.ws_broadcast(WsMessage::WorldDisconnected { world_index });
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "Not connected.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                }
                                Command::Flush => {
                                    // Clear output buffer for this world
                                    if world_index < app.worlds.len() {
                                        let line_count = app.worlds[world_index].output_lines.len();
                                        app.worlds[world_index].output_lines.clear();
                                        app.worlds[world_index].pending_lines.clear();
                                        app.worlds[world_index].scroll_offset = 0;
                                        app.worlds[world_index].lines_since_pause = 0;
                                        app.worlds[world_index].paused = false;
                                        app.ws_broadcast(WsMessage::WorldFlushed { world_index });
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Flushed {} lines from output buffer.", line_count),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                }
                                Command::Keepalive => {
                                    // Show keepalive settings for this world
                                    if world_index < app.worlds.len() {
                                        let world = &app.worlds[world_index];
                                        let info = format!(
                                            "Keepalive: {} ({})",
                                            world.settings.keep_alive_type.name(),
                                            if world.settings.keep_alive_type == KeepAliveType::Custom {
                                                world.settings.keep_alive_cmd.clone()
                                            } else {
                                                world.settings.keep_alive_type.name().to_string()
                                            }
                                        );
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: info,
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                }
                                Command::Gag { pattern } => {
                                    // TODO: Implement gag patterns storage
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: format!("Gag pattern set: {}", pattern),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                Command::BanList => {
                                    // Send current ban list
                                    let bans = app.ban_list.get_ban_info();
                                    if bans.is_empty() {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: "No hosts are currently banned.".to_string(),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    } else {
                                        let mut output = String::new();
                                        output.push_str("\nBanned Hosts:\n");
                                        output.push_str(&"â”€".repeat(70));
                                        output.push_str(&format!("\n{:<20} {:<12} {}\n", "Host", "Type", "Last URL/Reason"));
                                        output.push_str(&"â”€".repeat(70));
                                        output.push('\n');
                                        for (ip, ban_type, reason) in &bans {
                                            let reason_display = if reason.is_empty() { "(unknown)" } else { reason };
                                            output.push_str(&format!("{:<20} {:<12} {}\n", ip, ban_type, reason_display));
                                        }
                                        output.push_str(&"â”€".repeat(70));
                                        output.push_str("\nUse /unban <host> to remove a ban.");
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: output,
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                    app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                                }
                                Command::Unban { host } => {
                                    if app.ban_list.remove_ban(&host) {
                                        // Save settings to persist the change
                                        let _ = persistence::save_settings(&app);
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("Removed ban for: {}", host),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                        // Broadcast updated ban list
                                        app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                        app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                                    } else {
                                        app.ws_broadcast(WsMessage::ServerData {
                                            world_index,
                                            data: format!("No ban found for: {}", host),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                        app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                                    }
                                }
                                Command::TestMusic => {
                                    // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
                                    let test_notes = vec![
                                        ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                                        ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                                        ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                                        ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                                        ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
                                    ];
                                    // Play locally on console via mpv/ffplay
                                    if let Some(ref player_cmd) = app.media_player_cmd {
                                        let wav_data = generate_wav_from_notes(&test_notes);
                                        let _ = std::fs::create_dir_all(&app.media_cache_dir);
                                        let wav_path = app.media_cache_dir.join("ansi_music.wav");
                                        if std::fs::write(&wav_path, &wav_data).is_ok() {
                                            let wav_path_str = wav_path.to_string_lossy().to_string();
                                            let player = player_cmd.clone();
                                            std::thread::spawn(move || {
                                                let mut cmd = std::process::Command::new(&player);
                                                match player.as_str() {
                                                    "mpv" => { cmd.args(["--no-video", "--no-terminal", &wav_path_str]); }
                                                    "ffplay" => { cmd.args(["-nodisp", "-autoexit", &wav_path_str]); }
                                                    _ => { cmd.arg(&wav_path_str); }
                                                }
                                                cmd.stdout(std::process::Stdio::null());
                                                cmd.stderr(std::process::Stdio::null());
                                                let _ = cmd.status();
                                            });
                                        }
                                    }
                                    app.ws_broadcast(WsMessage::AnsiMusic {
                                        world_index,
                                        notes: test_notes,
                                    });
                                    if app.media_player_cmd.is_some() {
                                        app.add_output("Playing test music (C-D-E-F-G)...");
                                    } else {
                                        app.add_output("No audio player found (install mpv or ffplay for console audio)");
                                    }
                                }
                                Command::Notify { message } => {
                                    // Send notification to mobile clients
                                    let title = if world_index < app.worlds.len() {
                                        app.worlds[world_index].name.clone()
                                    } else {
                                        "Clay".to_string()
                                    };
                                    app.ws_broadcast(WsMessage::Notification {
                                        title,
                                        message: message.clone(),
                                    });
                                    app.add_output(&format!("Notification sent: {}", message));
                                }
                                Command::Dump => {
                                    // Dump all scrollback buffers to ~/.clay.dmp.log
                                    use std::io::Write;
                                    let ts = current_timestamp_secs();

                                    let home = get_home_dir();
                                    let dump_path = format!("{}/{}", home, clay_filename("clay.dmp.log"));

                                    match std::fs::File::create(&dump_path) {
                                        Ok(mut file) => {
                                            let mut total_lines = 0;
                                            for world in app.worlds.iter() {
                                                for line in &world.output_lines {
                                                    let line_ts = line.timestamp
                                                        .duration_since(std::time::UNIX_EPOCH)
                                                        .map(|d| d.as_secs())
                                                        .unwrap_or(0) as i64;
                                                    let lt = local_time_from_epoch(line_ts);
                                                    let datetime = format!(
                                                        "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                                        lt.year, lt.month, lt.day,
                                                        lt.hour, lt.minute, lt.second
                                                    );
                                                    let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                                                    total_lines += 1;
                                                }
                                                for line in &world.pending_lines {
                                                    let line_ts = line.timestamp
                                                        .duration_since(std::time::UNIX_EPOCH)
                                                        .map(|d| d.as_secs())
                                                        .unwrap_or(0) as i64;
                                                    let lt = local_time_from_epoch(line_ts);
                                                    let datetime = format!(
                                                        "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                                        lt.year, lt.month, lt.day,
                                                        lt.hour, lt.minute, lt.second
                                                    );
                                                    let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                                                    total_lines += 1;
                                                }
                                            }
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Dumped {} lines from {} worlds to {}", total_lines, app.worlds.len(), dump_path),
                                                is_viewed: false,
                                                ts,
                                                from_server: false,
                                            });
                                        }
                                        Err(e) => {
                                            app.ws_broadcast(WsMessage::ServerData {
                                                world_index,
                                                data: format!("Failed to create dump file: {}", e),
                                                is_viewed: false,
                                                ts,
                                                from_server: false,
                                            });
                                        }
                                    }
                                }
                                // Commands that should be blocked from remote
                                Command::Quit | Command::Reload => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: "This command is not available from remote interfaces.".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                // UI popup commands - send back to client for local handling
                                Command::Help | Command::Menu | Command::Setup | Command::Web | Command::Actions { .. } |
                                Command::WorldsList | Command::WorldSelector | Command::WorldEdit { .. } => {
                                    app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                }
                                Command::Version => {
                                    app.ws_send_to_client(client_id, WsMessage::ServerData {
                                        world_index,
                                        data: get_version_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                // AddWorld - add or update world definition
                                Command::AddWorld { name, host, port, user, password, use_ssl } => {
                                    let existing_idx = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(&name));

                                    let world_idx = if let Some(idx) = existing_idx {
                                        idx
                                    } else {
                                        let new_world = World::new(&name);
                                        app.worlds.push(new_world);
                                        app.worlds.len() - 1
                                    };

                                    if let Some(h) = host {
                                        app.worlds[world_idx].settings.hostname = h;
                                    }
                                    if let Some(p) = port {
                                        app.worlds[world_idx].settings.port = p;
                                    }
                                    if let Some(u) = user {
                                        app.worlds[world_idx].settings.user = u;
                                    }
                                    if let Some(p) = password {
                                        app.worlds[world_idx].settings.password = p;
                                    }
                                    app.worlds[world_idx].settings.use_ssl = use_ssl;

                                    let _ = persistence::save_settings(&app);

                                    let action = if existing_idx.is_some() { "Updated" } else { "Added" };
                                    let host_info = if !app.worlds[world_idx].settings.hostname.is_empty() {
                                        format!(" ({}:{}{})",
                                            app.worlds[world_idx].settings.hostname,
                                            app.worlds[world_idx].settings.port,
                                            if use_ssl { " SSL" } else { "" })
                                    } else {
                                        " (connectionless)".to_string()
                                    };
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: format!("{} world '{}'{}.", action, name, host_info),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                // Connect command - can't do async in drain loop, use ConnectWorld message
                                Command::Connect { .. } => {
                                    app.ws_broadcast(WsMessage::ServerData {
                                        world_index,
                                        data: "Use ConnectWorld message for connection.".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                // WorldSwitch - do the switch part, skip async connect
                                Command::WorldSwitch { ref name } | Command::WorldConnectNoLogin { ref name } => {
                                    if let Some(idx) = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(name)) {
                                        // Switch only the requesting client's world, not the console
                                        let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                        let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                        app.ws_client_worlds.insert(client_id, ClientViewState { world_index: idx, visible_lines, dimensions });
                                        app.ws_set_client_world(client_id, Some(idx));
                                        app.ws_send_to_client(client_id, WsMessage::WorldSwitched { new_index: idx });
                                        // Also send ExecuteLocalCommand so web clients can switch their local view
                                        app.ws_send_to_client(client_id, WsMessage::ExecuteLocalCommand { command: command.clone() });
                                        // Note: Connection requires async, use ConnectWorld message
                                    } else {
                                        app.ws_send_to_client(client_id, WsMessage::ServerData {
                                            world_index,
                                            data: format!("World '{}' not found.", name),
                                            is_viewed: false,
                                            ts: current_timestamp_secs(),
                                            from_server: false,
                                        });
                                    }
                                }
                                Command::Dict { .. } | Command::Urban { .. } | Command::Translate { .. } => {
                                    spawn_api_lookup(event_tx.clone(), client_id, world_index, parsed);
                                }
                                Command::DictUsage => {
                                    app.ws_send_to_client(client_id, WsMessage::ServerData {
                                        world_index,
                                        data: "Usage: /dict <prefix> <word>".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                Command::UrbanUsage => {
                                    app.ws_send_to_client(client_id, WsMessage::ServerData {
                                        world_index,
                                        data: "Usage: /urban <prefix> <word>".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                Command::TranslateUsage => {
                                    app.ws_send_to_client(client_id, WsMessage::ServerData {
                                        world_index,
                                        data: "Usage: /translate <lang> <prefix> <text>".to_string(),
                                        is_viewed: false,
                                        ts: current_timestamp_secs(),
                                        from_server: false,
                                    });
                                }
                                Command::HelpTf => {
                                    // Execute TF help command and send the result
                                    match app.tf_engine.execute("#help") {
                                        tf::TfCommandResult::Success(Some(msg)) => {
                                            for line in msg.lines() {
                                                app.ws_send_to_client(client_id, WsMessage::ServerData {
                                                    world_index,
                                                    data: line.to_string(),
                                                    is_viewed: false,
                                                    ts: current_timestamp_secs(),
                                                    from_server: false,
                                                });
                                            }
                                        }
                                        tf::TfCommandResult::Success(None) => {}
                                        tf::TfCommandResult::Error(err) => {
                                            app.ws_send_to_client(client_id, WsMessage::ServerData {
                                                world_index,
                                                data: format!("Error: {}", err),
                                                is_viewed: false,
                                                ts: current_timestamp_secs(),
                                                from_server: false,
                                            });
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                        WsMessage::SwitchWorld { world_index } => {
                            // Switch only the requesting client's world, not the console
                            if world_index < app.worlds.len() {
                                let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                let visible_lines = app.ws_client_worlds.get(&client_id).map(|v| v.visible_lines).unwrap_or(0);
                                app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                app.ws_set_client_world(client_id, Some(world_index));
                                app.ws_send_to_client(client_id, WsMessage::WorldSwitched { new_index: world_index });
                                // Send active media for the new world
                                app.ws_send_active_media_to_client(client_id, world_index);
                            }
                        }
                        WsMessage::UpdateWorldSettings { world_index, name, hostname, port, user, password, use_ssl, log_enabled, encoding, auto_login, keep_alive_type, keep_alive_cmd, gmcp_packages } => {
                            if world_index < app.worlds.len() {
                                app.worlds[world_index].name = name.clone();
                                app.worlds[world_index].settings.hostname = hostname.clone();
                                app.worlds[world_index].settings.port = port.clone();
                                app.worlds[world_index].settings.user = user.clone();
                                app.worlds[world_index].settings.password = password.clone();
                                app.worlds[world_index].settings.use_ssl = use_ssl;
                                app.worlds[world_index].settings.log_enabled = log_enabled;
                                app.worlds[world_index].settings.encoding = match encoding.as_str() {
                                    "latin1" => Encoding::Latin1,
                                    "fansi" => Encoding::Fansi,
                                    _ => Encoding::Utf8,
                                };
                                app.worlds[world_index].settings.auto_connect_type = AutoConnectType::from_name(&auto_login);
                                app.worlds[world_index].settings.keep_alive_type = KeepAliveType::from_name(&keep_alive_type);
                                app.worlds[world_index].settings.keep_alive_cmd = keep_alive_cmd.clone();
                                app.worlds[world_index].settings.gmcp_packages = gmcp_packages.clone();
                                let _ = persistence::save_settings(&app);
                                let settings_msg = WorldSettingsMsg {
                                    hostname, port, user,
                                    password: encrypt_password(&password),
                                    use_ssl,
                                    log_enabled,
                                    encoding,
                                    auto_connect_type: auto_login,
                                    keep_alive_type,
                                    keep_alive_cmd,
                                    gmcp_packages,
                                };
                                app.ws_broadcast(WsMessage::WorldSettingsUpdated { world_index, settings: settings_msg, name });
                            }
                        }
                        WsMessage::UpdateGlobalSettings { more_mode_enabled, spell_check_enabled, temp_convert_enabled, world_switch_mode, show_tags, debug_enabled, ansi_music_enabled, console_theme, gui_theme, gui_transparency, color_offset_percent, input_height, font_name, font_size, web_font_size_phone, web_font_size_tablet, web_font_size_desktop, ws_allow_list, web_secure, http_enabled, http_port, ws_enabled, ws_port, ws_cert_file, ws_key_file, tls_proxy_enabled, dictionary_path } => {
                            app.settings.more_mode_enabled = more_mode_enabled;
                            app.settings.spell_check_enabled = spell_check_enabled;
                            app.settings.temp_convert_enabled = temp_convert_enabled;
                            app.settings.world_switch_mode = WorldSwitchMode::from_name(&world_switch_mode);
                            app.show_tags = show_tags;
                            app.settings.debug_enabled = debug_enabled;
                            app.settings.ansi_music_enabled = ansi_music_enabled;
                            app.settings.theme = Theme::from_name(&console_theme);
                            app.settings.gui_theme = Theme::from_name(&gui_theme);
                            app.settings.gui_transparency = gui_transparency.clamp(0.3, 1.0);
                            app.settings.color_offset_percent = color_offset_percent.min(100);
                            app.input_height = input_height.clamp(1, 15);
                            app.input.visible_height = app.input_height;
                            app.settings.font_name = font_name;
                            app.settings.font_size = font_size.clamp(8.0, 48.0);
                            app.settings.web_font_size_phone = web_font_size_phone.clamp(8.0, 48.0);
                            app.settings.web_font_size_tablet = web_font_size_tablet.clamp(8.0, 48.0);
                            app.settings.web_font_size_desktop = web_font_size_desktop.clamp(8.0, 48.0);
                            app.settings.websocket_allow_list = ws_allow_list.clone();
                            if let Some(ref server) = app.ws_server {
                                server.update_allow_list(&ws_allow_list);
                            }
                            app.settings.web_secure = web_secure;
                            app.settings.http_enabled = http_enabled;
                            app.settings.http_port = http_port;
                            app.settings.ws_enabled = ws_enabled;
                            app.settings.ws_port = ws_port;
                            app.settings.websocket_cert_file = ws_cert_file;
                            app.settings.websocket_key_file = ws_key_file;
                            app.settings.tls_proxy_enabled = tls_proxy_enabled;
                            if app.settings.dictionary_path != dictionary_path {
                                app.settings.dictionary_path = dictionary_path;
                                app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
                            }
                            let _ = persistence::save_settings(&app);
                            let settings_msg = GlobalSettingsMsg {
                                more_mode_enabled: app.settings.more_mode_enabled,
                                spell_check_enabled: app.settings.spell_check_enabled,
                                temp_convert_enabled: app.settings.temp_convert_enabled,
                                world_switch_mode: app.settings.world_switch_mode.name().to_string(),
                                debug_enabled: app.settings.debug_enabled,
                                show_tags: app.show_tags,
                                ansi_music_enabled: app.settings.ansi_music_enabled,
                                console_theme: app.settings.theme.name().to_string(),
                                gui_theme: app.settings.gui_theme.name().to_string(),
                                gui_transparency: app.settings.gui_transparency,
                                color_offset_percent: app.settings.color_offset_percent,
                                input_height: app.input_height,
                                font_name: app.settings.font_name.clone(),
                                font_size: app.settings.font_size,
                                web_font_size_phone: app.settings.web_font_size_phone,
                                web_font_size_tablet: app.settings.web_font_size_tablet,
                                web_font_size_desktop: app.settings.web_font_size_desktop,
                                ws_allow_list: app.settings.websocket_allow_list.clone(),
                                web_secure: app.settings.web_secure,
                                http_enabled: app.settings.http_enabled,
                                http_port: app.settings.http_port,
                                ws_enabled: app.settings.ws_enabled,
                                ws_port: app.settings.ws_port,
                                ws_cert_file: app.settings.websocket_cert_file.clone(),
                                ws_key_file: app.settings.websocket_key_file.clone(),
                                tls_proxy_enabled: app.settings.tls_proxy_enabled,
                                dictionary_path: app.settings.dictionary_path.clone(),
                                theme_colors_json: app.gui_theme_colors().to_json(),
                            };
                            app.ws_broadcast(WsMessage::GlobalSettingsUpdated { settings: settings_msg, input_height: app.input_height });
                        }
                        WsMessage::UpdateActions { actions } => {
                            app.settings.actions = actions.clone();
                            let _ = persistence::save_settings(&app);
                            app.ws_broadcast(WsMessage::ActionsUpdated { actions });
                        }
                        WsMessage::CalculateNextWorld { current_index } => {
                            let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                .map(|w| crate::util::WorldSwitchInfo {
                                    name: w.name.clone(),
                                    connected: w.connected,
                                    unseen_lines: w.unseen_lines,
                                    pending_lines: w.pending_lines.len(),
                                    first_unseen_at: w.first_unseen_at,
                                })
                                .collect();
                            let next_idx = crate::util::calculate_next_world(
                                &world_info,
                                current_index,
                                app.settings.world_switch_mode,
                            );
                            app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: next_idx });
                        }
                        WsMessage::CalculatePrevWorld { current_index } => {
                            let world_info: Vec<crate::util::WorldSwitchInfo> = app.worlds.iter()
                                .map(|w| crate::util::WorldSwitchInfo {
                                    name: w.name.clone(),
                                    connected: w.connected,
                                    unseen_lines: w.unseen_lines,
                                    pending_lines: w.pending_lines.len(),
                                    first_unseen_at: w.first_unseen_at,
                                })
                                .collect();
                            let prev_idx = crate::util::calculate_prev_world(
                                &world_info,
                                current_index,
                                app.settings.world_switch_mode,
                            );
                            app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: prev_idx });
                        }
                        WsMessage::CalculateOldestPending { current_index } => {
                            // Find world with oldest pending output (for Escape+w)
                            let mut oldest_idx: Option<usize> = None;
                            let mut oldest_time: Option<std::time::Instant> = None;

                            for (idx, world) in app.worlds.iter().enumerate() {
                                if idx == current_index || world.pending_lines.is_empty() {
                                    continue;
                                }
                                if let Some(pending_time) = world.pending_since {
                                    if oldest_time.is_none() || pending_time < oldest_time.unwrap() {
                                        oldest_time = Some(pending_time);
                                        oldest_idx = Some(idx);
                                    }
                                }
                            }

                            if oldest_idx.is_none() {
                                for (idx, world) in app.worlds.iter().enumerate() {
                                    if idx != current_index && world.unseen_lines > 0 {
                                        oldest_idx = Some(idx);
                                        break;
                                    }
                                }
                            }

                            if oldest_idx.is_none() {
                                if let Some(prev_idx) = app.previous_world_index {
                                    if prev_idx != current_index && prev_idx < app.worlds.len() {
                                        oldest_idx = Some(prev_idx);
                                    }
                                }
                            }

                            app.ws_send_to_client(client_id, WsMessage::CalculatedWorld { index: oldest_idx });
                        }
                        WsMessage::RequestState => {
                            // Client requested full state resync - send initial state
                            let initial_state = app.build_initial_state();
                            app.ws_send_to_client(client_id, initial_state);
                            // Mark client as having received initial state so it receives broadcasts
                            app.ws_mark_initial_state_sent(client_id);
                            // Set client's initial world so broadcast_to_world_viewers works immediately
                            app.ws_set_client_world(client_id, Some(app.current_world_index));
                            // Also send current activity count
                            app.ws_send_to_client(client_id, WsMessage::ActivityUpdate {
                                count: app.activity_count(),
                            });
                        }
                        WsMessage::RequestWorldState { world_index } => {
                            // Client switched to a world and needs current state
                            if world_index < app.worlds.len() {
                                let world = &app.worlds[world_index];
                                // Build recent lines from output_lines (last 100 lines for context)
                                let recent_lines: Vec<TimestampedLine> = world.output_lines
                                    .iter()
                                    .rev()
                                    .take(100)
                                    .map(|line| TimestampedLine {
                                        text: line.text.clone(),
                                        ts: line.timestamp.duration_since(std::time::UNIX_EPOCH).unwrap_or_default().as_secs(),
                                        gagged: line.gagged,
                                        from_server: line.from_server,
                                        seq: line.seq,
                                        highlight_color: line.highlight_color.clone(),
                                    })
                                    .collect::<Vec<_>>()
                                    .into_iter()
                                    .rev()
                                    .collect();

                                let pending_count = world.pending_lines.len();

                                app.ws_send_to_client(client_id, WsMessage::WorldStateResponse {
                                    world_index,
                                    pending_count,
                                    prompt: world.prompt.clone(),
                                    scroll_offset: world.scroll_offset,
                                    recent_lines,
                                });
                            }
                        }
                        WsMessage::BanListRequest => {
                            // Send current ban list to client
                            let bans = app.ban_list.get_ban_info();
                            app.ws_send_to_client(client_id, WsMessage::BanListResponse { bans });
                        }
                        WsMessage::UnbanRequest { host } => {
                            if app.ban_list.remove_ban(&host) {
                                // Save settings to persist the change
                                let _ = persistence::save_settings(&app);
                                // Broadcast updated ban list to all clients
                                app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                                app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: true, host, error: None });
                            } else {
                                app.ws_send_to_client(client_id, WsMessage::UnbanResult { success: false, host, error: Some("No ban found".to_string()) });
                            }
                        }
                        // Theme editor messages
                        WsMessage::RequestThemeEditorState => {
                            let themes_json = app.theme_file.to_json_all();
                            let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                            let active_theme = app.settings.gui_theme.name().to_string();
                            app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                themes_json,
                                theme_names,
                                active_theme,
                            });
                        }
                        WsMessage::UpdateThemeColors { theme_name, colors_json } => {
                            let base = if theme_name == "light" {
                                theme::ThemeColors::light_default()
                            } else {
                                theme::ThemeColors::dark_default()
                            };
                            let colors = theme::ThemeColors::from_json(&colors_json, &base);
                            app.theme_file.set_theme(&theme_name, colors);
                            // If updated theme is the active GUI theme, broadcast CSS vars update
                            if theme_name == app.settings.gui_theme.name() {
                                let css_vars = app.gui_theme_colors().to_css_vars();
                                let colors_json = app.gui_theme_colors().to_json();
                                app.ws_broadcast(WsMessage::ThemeCssVarsUpdated {
                                    css_vars,
                                    colors_json: colors_json.clone(),
                                });
                                let settings_msg = app.build_global_settings_msg();
                                app.ws_broadcast(WsMessage::GlobalSettingsUpdated {
                                    settings: settings_msg,
                                    input_height: app.input_height,
                                });
                            }
                        }
                        WsMessage::AddTheme { name, copy_from } => {
                            let base_colors = app.theme_file.get(&copy_from).clone();
                            app.theme_file.set_theme(&name, base_colors);
                            let themes_json = app.theme_file.to_json_all();
                            let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                            let active_theme = app.settings.gui_theme.name().to_string();
                            app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                themes_json,
                                theme_names,
                                active_theme,
                            });
                        }
                        WsMessage::DeleteTheme { name } => {
                            app.theme_file.remove_theme(&name);
                            let themes_json = app.theme_file.to_json_all();
                            let theme_names: Vec<String> = app.theme_file.themes.keys().cloned().collect();
                            let active_theme = app.settings.gui_theme.name().to_string();
                            app.ws_send_to_client(client_id, WsMessage::ThemeEditorState {
                                themes_json,
                                theme_names,
                                active_theme,
                            });
                        }
                        WsMessage::SaveThemeFile => {
                            let content = app.theme_file.generate_file_content();
                            let path = std::path::Path::new(&get_home_dir()).join("clay.theme.dat");
                            match std::fs::write(&path, &content) {
                                Ok(_) => {
                                    app.ws_send_to_client(client_id, WsMessage::ThemeFileSaved { success: true, error: None });
                                }
                                Err(e) => {
                                    app.ws_send_to_client(client_id, WsMessage::ThemeFileSaved { success: false, error: Some(e.to_string()) });
                                }
                            }
                        }
                        WsMessage::RequestConnectionsList => {
                            // Generate connections list for remote console client
                            let current_idx = app.current_world_index;
                            let now = std::time::Instant::now();
                            let worlds_info: Vec<util::WorldListInfo> = app.worlds.iter().enumerate().map(|(idx, world)| {
                                util::WorldListInfo {
                                    name: world.name.clone(),
                                    connected: world.connected,
                                    is_current: idx == current_idx,
                                    is_ssl: world.is_tls,
                                    is_proxy: world.proxy_pid.is_some(),
                                    unseen_lines: world.unseen_lines,
                                    last_send_secs: world.last_user_command_time.map(|t| now.duration_since(t).as_secs()),
                                    last_recv_secs: world.last_receive_time.map(|t| now.duration_since(t).as_secs()),
                                    last_nop_secs: world.last_nop_time.map(|t| now.duration_since(t).as_secs()),
                                    next_nop_secs: None,
                                    buffer_size: world.output_lines.len() + world.pending_lines.len(),
                                }
                            }).collect();
                            let output = util::format_worlds_list(&worlds_info);
                            let lines: Vec<String> = output.lines().map(|s| s.to_string()).collect();
                            app.ws_send_to_client(client_id, WsMessage::ConnectionsListResponse { lines });
                        }
                        WsMessage::ReportSeqMismatch { world_index, expected_seq_gt, actual_seq, line_text, source } => {
                            let world_name = app.worlds.get(world_index).map(|w| w.name.as_str()).unwrap_or("?");
                            use std::io::Write;
                            if let Ok(mut f) = std::fs::OpenOptions::new()
                                .create(true).append(true)
                                .open("clay.output.debug")
                            {
                                let _ = writeln!(f, "SEQ MISMATCH [{}] in '{}': expected seq>{}, got seq={}, text={:?}",
                                    source, world_name, expected_seq_gt, actual_seq,
                                    line_text.chars().take(80).collect::<String>());
                            }
                        }
                        WsMessage::ClientTypeDeclaration { client_type } => {
                            // Update client type in WebSocket server
                            app.ws_set_client_type(client_id, client_type);
                        }
                        WsMessage::CycleWorld { direction } => {
                            // Client requests to cycle to next/previous world
                            let current = app.ws_client_worlds.get(&client_id)
                                .map(|s| s.world_index)
                                .unwrap_or(app.current_world_index);

                            let new_index = if direction == "up" {
                                app.calculate_prev_world_from(current)
                            } else {
                                app.calculate_next_world_from(current)
                            };

                            if let Some(idx) = new_index {
                                // Update client's view state (sync state)
                                let visible_lines = app.ws_client_worlds.get(&client_id)
                                    .map(|s| s.visible_lines)
                                    .unwrap_or(24);
                                let dimensions = app.ws_client_worlds.get(&client_id)
                                    .and_then(|s| s.dimensions);
                                app.ws_client_worlds.insert(client_id, ClientViewState {
                                    world_index: idx,
                                    visible_lines,
                                    dimensions,
                                });
                                // Update client's world in WebSocket server (async state)
                                app.ws_set_client_world(client_id, Some(idx));

                                // Send world switch result with state
                                if idx < app.worlds.len() {
                                    let pending_count = app.worlds[idx].pending_lines.len();
                                    let paused = app.worlds[idx].paused;
                                    let world_name = app.worlds[idx].name.clone();

                                    app.ws_send_to_client(client_id, WsMessage::WorldSwitchResult {
                                        world_index: idx,
                                        world_name,
                                        pending_count,
                                        paused,
                                    });

                                    // Send initial output lines based on client type
                                    let client_type = app.ws_get_client_type(client_id);
                                    let world = &app.worlds[idx];
                                    let total_lines = world.output_lines.len();

                                    let lines_to_send = match client_type {
                                        Some(websocket::RemoteClientType::RemoteConsole) => {
                                            // Console: last screenful (viewport - 2)
                                            visible_lines.saturating_sub(2).min(total_lines)
                                        }
                                        _ => {
                                            // Web/GUI: full history
                                            total_lines
                                        }
                                    };

                                    if lines_to_send > 0 {
                                        let start = total_lines.saturating_sub(lines_to_send);
                                        let lines: Vec<TimestampedLine> = world.output_lines[start..].iter()
                                            .map(|line| {
                                                let ts = line.timestamp
                                                    .duration_since(std::time::UNIX_EPOCH)
                                                    .map(|d| d.as_secs())
                                                    .unwrap_or(0);
                                                TimestampedLine {
                                                    text: line.text.clone(),
                                                    ts,
                                                    gagged: line.gagged,
                                                    from_server: line.from_server,
                                                    seq: line.seq,
                                                    highlight_color: line.highlight_color.clone(),
                                                }
                                            })
                                            .collect();

                                        app.ws_send_to_client(client_id, WsMessage::OutputLines {
                                            world_index: idx,
                                            lines,
                                            is_initial: true,
                                        });
                                    }

                                    // Also mark world as seen if it had unseen output
                                    if app.worlds[idx].unseen_lines > 0 {
                                        app.worlds[idx].unseen_lines = 0;
                                        app.worlds[idx].first_unseen_at = None;
                                        app.ws_broadcast(WsMessage::UnseenCleared { world_index: idx });
                                        app.broadcast_activity();
                                    }
                                }
                            }
                        }
                        WsMessage::MarkWorldSeen { world_index } => {
                            // A remote client has viewed this world - update their current_world
                            if world_index < app.worlds.len() {
                                // Check if client is switching to a different world
                                let old_world_idx = app.ws_client_worlds.get(&client_id).map(|s| s.world_index);
                                let switched = old_world_idx.map(|old| old != world_index).unwrap_or(true);
                                // Reset lines_since_pause for the old world if switching away and more-mode hasn't triggered
                                if let Some(old_idx) = old_world_idx {
                                    if old_idx != world_index && old_idx < app.worlds.len()
                                        && app.worlds[old_idx].pending_lines.is_empty()
                                    {
                                        app.worlds[old_idx].lines_since_pause = 0;
                                    }
                                }
                                // Track which world this client is viewing (sync cache)
                                let visible_lines = app.ws_client_worlds
                                    .get(&client_id)
                                    .map(|v| v.visible_lines)
                                    .unwrap_or(0);
                                let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                // Update client's world in WebSocket server (async state)
                                app.ws_set_client_world(client_id, Some(world_index));

                                app.worlds[world_index].mark_seen();
                                // Broadcast to all clients so they update their UI
                                app.ws_broadcast(WsMessage::UnseenCleared { world_index });
                                // Broadcast activity count since a world was just marked as seen
                                app.broadcast_activity();
                                // Trigger console redraw to update activity indicator
                                app.needs_output_redraw = true;
                                if switched {
                                    app.ws_send_active_media_to_client(client_id, world_index);
                                }
                            }
                        }
                        WsMessage::UpdateViewState { world_index, visible_lines } => {
                            // A remote client is reporting its view state (for more-mode threshold calculation)
                            if world_index < app.worlds.len() {
                                // Preserve existing dimensions when updating view state
                                let dimensions = app.ws_client_worlds.get(&client_id).and_then(|s| s.dimensions);
                                app.ws_client_worlds.insert(client_id, ClientViewState { world_index, visible_lines, dimensions });
                                // Update client's world in WebSocket server so broadcast_to_world_viewers works
                                app.ws_set_client_world(client_id, Some(world_index));
                            }
                        }
                        WsMessage::RequestScrollback { world_index, count, before_seq } => {
                            // Console client requests scrollback from master
                            if world_index < app.worlds.len() {
                                let world = &app.worlds[world_index];

                                // Find lines to send based on before_seq
                                let lines: Vec<TimestampedLine> = if let Some(seq) = before_seq {
                                    // Send lines with seq < before_seq (older than what client has)
                                    let eligible: Vec<_> = world.output_lines.iter()
                                        .filter(|l| l.seq < seq)
                                        .collect();
                                    let start = eligible.len().saturating_sub(count);
                                    eligible[start..].iter()
                                        .map(|line| {
                                            let ts = line.timestamp
                                                .duration_since(std::time::UNIX_EPOCH)
                                                .map(|d| d.as_secs())
                                                .unwrap_or(0);
                                            TimestampedLine {
                                                text: line.text.clone(),
                                                ts,
                                                gagged: line.gagged,
                                                from_server: line.from_server,
                                                seq: line.seq,
                                                highlight_color: line.highlight_color.clone(),
                                            }
                                        })
                                        .collect()
                                } else {
                                    // No before_seq - send last N lines (backwards compatible)
                                    let total_lines = world.output_lines.len();
                                    let start = total_lines.saturating_sub(count);
                                    world.output_lines[start..].iter()
                                        .map(|line| {
                                            let ts = line.timestamp
                                                .duration_since(std::time::UNIX_EPOCH)
                                                .map(|d| d.as_secs())
                                                .unwrap_or(0);
                                            TimestampedLine {
                                                text: line.text.clone(),
                                                ts,
                                                gagged: line.gagged,
                                                from_server: line.from_server,
                                                seq: line.seq,
                                                highlight_color: line.highlight_color.clone(),
                                            }
                                        })
                                        .collect()
                                };

                                app.ws_send_to_client(client_id, WsMessage::ScrollbackLines {
                                    world_index,
                                    lines,
                                });
                            }
                        }
                        _ => {}
                    }
                }
                // Background connection completed successfully
                AppEvent::ConnectionSuccess(world_name, cmd_tx, socket_fd, is_tls) => {
                    if let Some(world_idx) = app.find_world_index(&world_name) {
                        app.worlds[world_idx].connected = true;
                        app.worlds[world_idx].was_connected = true;
                        app.worlds[world_idx].prompt_count = 0;
                        let now = std::time::Instant::now();
                        app.worlds[world_idx].last_send_time = Some(now);
                        app.worlds[world_idx].last_receive_time = Some(now);
                        app.worlds[world_idx].is_initial_world = false;
                        app.worlds[world_idx].command_tx = Some(cmd_tx.clone());
                        #[cfg(unix)]
                        { app.worlds[world_idx].socket_fd = socket_fd; }
                        app.worlds[world_idx].is_tls = is_tls;

                        // Discard any unused initial world
                        app.discard_initial_world();

                        // Open log file if enabled
                        if app.worlds[world_idx].settings.log_enabled {
                            if app.worlds[world_idx].open_log_file() {
                                let log_path = app.worlds[world_idx].get_log_path();
                                app.add_output_to_world(world_idx, &format!("Logging to: {}", log_path.display()));
                            } else {
                                app.add_output_to_world(world_idx, "Warning: Could not open log file");
                            }
                        }

                        // Fire TF CONNECT hook
                        let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Connect);
                        for cmd in hook_result.send_commands {
                            let _ = cmd_tx.try_send(WriteCommand::Text(cmd));
                        }
                        for cmd in hook_result.clay_commands {
                            let _ = app.tf_engine.execute(&cmd);
                        }

                        // Send auto-login if configured
                        let skip_login = app.worlds[world_idx].skip_auto_login;
                        app.worlds[world_idx].skip_auto_login = false;
                        let user = app.worlds[world_idx].settings.user.clone();
                        let password = app.worlds[world_idx].settings.password.clone();
                        let auto_connect_type = app.worlds[world_idx].settings.auto_connect_type;
                        if !skip_login && !user.is_empty() && !password.is_empty() && auto_connect_type == AutoConnectType::Connect {
                            let connect_cmd = format!("connect {} {}", user, password);
                            let _ = cmd_tx.try_send(WriteCommand::Text(connect_cmd));
                        }

                        // Broadcast connection status
                        app.ws_broadcast(WsMessage::WorldConnected { world_index: world_idx, name: app.worlds[world_idx].name.clone() });
                        app.add_output_to_world(world_idx, "Connected!");
                    }
                }
                // Background connection failed
                AppEvent::ConnectionFailed(world_name, error) => {
                    if let Some(world_idx) = app.find_world_index(&world_name) {
                        app.add_output_to_world(world_idx, &format!("Connection failed: {}", error));
                    }
                }
                AppEvent::MediaProcessReady(world_idx, key, child, is_music) => {
                    if is_music {
                        app.media_music_key = Some((world_idx, key.clone()));
                    }
                    app.media_processes.insert(key, (world_idx, child));
                }
                AppEvent::ApiLookupResult(client_id, world_index, result) => {
                    match result {
                        Ok(text) => app.ws_send_to_client(client_id, WsMessage::SetInputBuffer { text }),
                        Err(e) => app.ws_send_to_client(client_id, WsMessage::ServerData {
                            world_index,
                            data: e,
                            is_viewed: false,
                            ts: current_timestamp_secs(),
                            from_server: false,
                        }),
                    }
                }
            }
        }

        // Now draw with the most up-to-date state (after all events processed)
        // Check if any popup is now visible
        let any_popup_visible = app.confirm_dialog.visible
            || app.filter_popup.visible
            || app.has_new_popup();

        // If transitioning from no popup to popup, clear terminal to sync ratatui with terminal state
        if any_popup_visible && !app.popup_was_visible {
            terminal.clear()?;
        }
        // Detect popup visibility change before updating
        let popup_visibility_changed = any_popup_visible != app.popup_was_visible;
        app.popup_was_visible = any_popup_visible;

        // Handle terminal clear request (e.g., after closing editor)
        if app.needs_terminal_clear {
            execute!(
                std::io::stdout(),
                crossterm::terminal::Clear(crossterm::terminal::ClearType::All)
            )?;
            terminal.clear()?;
            app.needs_terminal_clear = false;
        }

        // Use ratatui for everything, but render output area with raw crossterm
        // after the ratatui draw (ratatui's Paragraph has rendering bugs)
        terminal.draw(|f| ui(f, &mut app))?;

        // Render output area with crossterm only when needed (optimization)
        // Also redraw when popup visibility changes
        if app.needs_output_redraw || popup_visibility_changed {
            render_output_crossterm(&app);
            app.needs_output_redraw = false;
            // Mark current world as seen since its output was just displayed
            let has_unseen = app.current_world().unseen_lines > 0;
            let has_pending = !app.current_world().pending_lines.is_empty();
            if has_unseen {
                app.current_world_mut().mark_seen();
                // Broadcast to WebSocket clients
                app.ws_broadcast(WsMessage::UnseenCleared { world_index: app.current_world_index });
                // Broadcast activity count since a world was just marked as seen
                app.broadcast_activity();
            }
            // If more mode is disabled but world has orphaned pending_lines, release them
            if has_pending && !app.settings.more_mode_enabled {
                let world = app.current_world_mut();
                world.output_lines.append(&mut world.pending_lines);
                world.pending_since = None;
                world.paused = false;
                world.scroll_to_bottom();
            }
        }
    }
}

/// Save editor content (to file or world notes) and close editor
fn save_editor_content(app: &mut App) -> KeyAction {
    if let Some(ref path) = app.editor.file_path {
        // Save to file
        match std::fs::write(path, &app.editor.buffer) {
            Ok(()) => {
                app.add_output(&format!("Saved: {}", path.display()));
            }
            Err(e) => {
                app.add_output(&format!("Failed to save file: {}", e));
                return KeyAction::None; // Don't close on error
            }
        }
    } else if let Some(world_idx) = app.editor.world_index {
        // Save to world notes
        if world_idx < app.worlds.len() {
            app.worlds[world_idx].settings.notes = app.editor.buffer.clone();
            // Save settings to persist notes
            let _ = persistence::save_settings(app);
            app.add_output("Notes saved.");
        }
    }
    app.editor.close();
    app.needs_output_redraw = true;
    app.needs_terminal_clear = true;
    KeyAction::None
}

enum KeyAction {
    Quit,
    SendCommand(String),
    Connect, // Trigger connection from settings popup
    Redraw,  // Force screen redraw
    Reload,  // Trigger /reload
    Suspend, // Ctrl+Z to suspend process
    SwitchedWorld(usize), // Console switched to this world, broadcast unseen clear
    None,
}

fn handle_key_event(key: KeyEvent, app: &mut App) -> KeyAction {

    // Handle confirm dialog first (highest priority)
    if app.confirm_dialog.visible {
        match key.code {
            KeyCode::Left | KeyCode::Right | KeyCode::Up | KeyCode::Down | KeyCode::Tab => {
                // Toggle between Yes and No
                app.confirm_dialog.yes_selected = !app.confirm_dialog.yes_selected;
            }
            KeyCode::Char('y') | KeyCode::Char('Y') => {
                app.confirm_dialog.yes_selected = true;
            }
            KeyCode::Char('n') | KeyCode::Char('N') => {
                app.confirm_dialog.yes_selected = false;
            }
            KeyCode::Enter => {
                // ConfirmAction::None is the only variant now
                app.confirm_dialog.close();
            }
            KeyCode::Esc => {
                // Cancel - just close the dialog
                app.confirm_dialog.close();
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle split-screen editor (before popups, after confirm dialog)
    if app.editor.visible {
        // Ctrl+Space toggles focus between editor and input
        if key.modifiers.contains(KeyModifiers::CONTROL) && key.code == KeyCode::Char(' ') {
            app.editor.toggle_focus();
            return KeyAction::None;
        }

        // When editor is focused, handle editor keys
        if app.editor.focus == EditorFocus::Editor {
            match key.code {
                KeyCode::Esc => {
                    // Close editor without saving
                    app.editor.close();
                    app.needs_output_redraw = true;
                    app.needs_terminal_clear = true;
                    return KeyAction::None;
                }
                KeyCode::Char('s') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                    // Save and close
                    return save_editor_content(app);
                }
                KeyCode::Char('s') | KeyCode::Char('S') if !key.modifiers.contains(KeyModifiers::CONTROL) && !key.modifiers.contains(KeyModifiers::ALT) => {
                    // Just 'S' key - check if at start of buffer (for shortcut)
                    // Actually, we want S anywhere to be a shortcut when not typing
                    // Let's make S work as a shortcut only without any modifiers
                    // But we should insert 's' when typing... let's just use Ctrl+S
                    // Insert the character
                    app.editor.insert_char('s');
                    return KeyAction::None;
                }
                KeyCode::Char('c') | KeyCode::Char('C') if !key.modifiers.contains(KeyModifiers::CONTROL) && !key.modifiers.contains(KeyModifiers::ALT) => {
                    // Insert the character
                    app.editor.insert_char(if key.code == KeyCode::Char('C') { 'C' } else { 'c' });
                    return KeyAction::None;
                }
                KeyCode::Up => {
                    app.editor.cursor_up();
                    let visible_lines = app.output_height.saturating_sub(2) as usize; // Account for border and buttons
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize; // Half width minus borders
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Down => {
                    app.editor.cursor_down();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Left => {
                    app.editor.cursor_left();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Right => {
                    app.editor.cursor_right();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Home => {
                    app.editor.cursor_home();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::End => {
                    app.editor.cursor_end();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::PageUp => {
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.page_up(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::PageDown => {
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.page_down(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Enter => {
                    app.editor.insert_char('\n');
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Backspace => {
                    app.editor.delete_backward();
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Delete => {
                    app.editor.delete_forward();
                    return KeyAction::None;
                }
                KeyCode::Tab => {
                    // Insert 4 spaces for tab
                    for _ in 0..4 {
                        app.editor.insert_char(' ');
                    }
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                KeyCode::Char(c) => {
                    // Insert character
                    let ch = if key.modifiers.contains(KeyModifiers::SHIFT) {
                        c.to_ascii_uppercase()
                    } else {
                        c
                    };
                    app.editor.insert_char(ch);
                    let visible_lines = app.output_height.saturating_sub(2) as usize;
                    let editor_width = (app.output_width / 2).saturating_sub(2) as usize;
                    app.editor.ensure_cursor_visible(visible_lines, editor_width);
                    return KeyAction::None;
                }
                _ => {}
            }
            return KeyAction::None;
        }
        // When input is focused, fall through to normal input handling below
    }

    // Handle new unified popup system (help popup and others)
    if app.has_new_popup() {
        match handle_new_popup_key(app, key) {
            NewPopupAction::Command(cmd) => {
                // Menu command selected - execute it
                return KeyAction::SendCommand(cmd);
            }
            NewPopupAction::Confirm(data) => {
                // Handle confirmed action
                if let Some(world_index_str) = data.get("world_index") {
                    if let Ok(world_index) = world_index_str.parse::<usize>() {
                        // Delete the world
                        if app.worlds.len() > 1 && world_index < app.worlds.len() {
                            let world_name = app.worlds[world_index].name.clone();
                            app.worlds.remove(world_index);
                            // Adjust current_world_index if needed
                            if app.current_world_index >= app.worlds.len() {
                                app.current_world_index = app.worlds.len().saturating_sub(1);
                            } else if app.current_world_index > world_index {
                                app.current_world_index -= 1;
                            }
                            // Adjust previous_world_index if needed
                            if let Some(prev) = app.previous_world_index {
                                if prev >= app.worlds.len() {
                                    app.previous_world_index = Some(app.worlds.len().saturating_sub(1));
                                } else if prev > world_index {
                                    app.previous_world_index = Some(prev - 1);
                                }
                            }
                            app.add_output(&format!("World '{}' deleted.", world_name));
                            // Reopen world selector to show updated list
                            app.open_world_selector_new();
                        }
                    }
                } else if let Some(action_index_str) = data.get("action_index") {
                    if let Ok(action_index) = action_index_str.parse::<usize>() {
                        // Delete the action
                        if action_index < app.settings.actions.len() {
                            let action_name = app.settings.actions[action_index].name.clone();
                            app.settings.actions.remove(action_index);
                            app.add_output(&format!("Action '{}' deleted.", action_name));
                            // Save settings to disk
                            let _ = persistence::save_settings(app);
                            // Reopen actions list to show updated list
                            app.open_actions_list_popup();
                        }
                    }
                }
            }
            NewPopupAction::ConfirmCancelled(data) => {
                // Reopen the parent list popup when confirm dialog is cancelled
                if data.contains_key("world_index") {
                    app.open_world_selector_new();
                } else if data.contains_key("action_index") {
                    app.open_actions_list_popup();
                }
            }
            NewPopupAction::WorldSelector(action) => {
                match action {
                    WorldSelectorAction::Connect(name) => {
                        // Find world and connect to it
                        if let Some(idx) = app.find_world(&name) {
                            app.switch_world(idx);
                            if !app.current_world().connected {
                                if app.current_world().settings.has_connection_settings() {
                                    return KeyAction::SendCommand("/connect".to_string());
                                } else {
                                    app.add_output(&format!("World '{}' has no connection settings.", name));
                                }
                            }
                        }
                    }
                    WorldSelectorAction::Edit(name) => {
                        // Open world editor using new popup
                        if let Some(idx) = app.find_world(&name) {
                            app.open_world_editor_popup_new(idx);
                        }
                    }
                    WorldSelectorAction::Delete(name) => {
                        // Open confirmation dialog for delete
                        if let Some(idx) = app.find_world(&name) {
                            if app.worlds.len() > 1 {
                                app.open_delete_world_confirm(&name, idx);
                            } else {
                                app.add_output("Cannot delete the last world.");
                            }
                        }
                    }
                    WorldSelectorAction::Add => {
                        // Create new world and open editor using new popup
                        let new_name = format!("World {}", app.worlds.len() + 1);
                        let new_world = World::new(&new_name);
                        app.worlds.push(new_world);
                        let idx = app.worlds.len() - 1;
                        app.open_world_editor_popup_new(idx);
                    }
                }
            }
            NewPopupAction::WorldSelectorFilter => {
                // Filter changed - update the world list
                use popup::definitions::world_selector::SELECTOR_FIELD_FILTER;
                if let Some(state) = app.popup_manager.current_mut() {
                    // Use edit_buffer if currently editing, otherwise use field value
                    let filter_text = if state.editing && state.is_field_selected(SELECTOR_FIELD_FILTER) {
                        state.edit_buffer.clone()
                    } else {
                        state.get_text(SELECTOR_FIELD_FILTER).unwrap_or("").to_string()
                    };
                    // Build world info list
                    let all_worlds: Vec<popup::definitions::world_selector::WorldInfo> = app.worlds
                        .iter()
                        .enumerate()
                        .map(|(idx, w)| popup::definitions::world_selector::WorldInfo {
                            name: w.name.clone(),
                            hostname: w.settings.hostname.clone(),
                            port: w.settings.port.to_string(),
                            user: w.settings.user.clone(),
                            is_connected: w.connected,
                            is_current: idx == app.current_world_index,
                        })
                        .collect();
                    // Apply filter
                    let filtered = popup::definitions::world_selector::filter_worlds(&all_worlds, &filter_text);
                    // Update the list in the popup state
                    popup::definitions::world_selector::update_world_list(state, &filtered);
                }
            }
            NewPopupAction::SetupSaved(settings) => {
                // Apply saved settings
                app.settings.more_mode_enabled = settings.more_mode;
                app.settings.spell_check_enabled = settings.spell_check;
                app.settings.temp_convert_enabled = settings.temp_convert;
                app.settings.world_switch_mode = if settings.world_switching == "unseen_first" {
                    WorldSwitchMode::UnseenFirst
                } else {
                    WorldSwitchMode::Alphabetical
                };
                app.settings.debug_enabled = settings.debug;
                // Note: show_tags is not in setup anymore - controlled by F2 or /tag
                app.input_height = settings.input_height as u16;
                app.settings.gui_theme = Theme::from_name(&settings.gui_theme);
                app.settings.tls_proxy_enabled = settings.tls_proxy;
                if app.settings.dictionary_path != settings.dictionary_path {
                    app.settings.dictionary_path = settings.dictionary_path.clone();
                    app.spell_checker = SpellChecker::new(&app.settings.dictionary_path);
                }
                app.settings.editor_side = EditorSide::from_name(&settings.editor_side);
                // Save settings to disk
                let _ = persistence::save_settings(app);
            }
            NewPopupAction::WebSaved(settings) => {
                // Apply saved web settings
                app.settings.web_secure = settings.web_secure;
                app.settings.http_enabled = settings.http_enabled;
                app.settings.http_port = settings.http_port.parse().unwrap_or(9000);
                app.settings.ws_enabled = settings.ws_enabled;
                app.settings.ws_port = settings.ws_port.parse().unwrap_or(9002);
                app.settings.websocket_password = settings.ws_password;
                app.settings.websocket_allow_list = settings.ws_allow_list;
                app.settings.websocket_cert_file = settings.ws_cert_file;
                app.settings.websocket_key_file = settings.ws_key_file;
                // Save settings to disk
                let _ = persistence::save_settings(app);
                // Note: Server start/stop requires reload to take effect
                app.add_output("Web settings saved. Use /reload to apply server changes.");
            }
            NewPopupAction::ConnectionsClose => {
                // Nothing to do, popup is already closed
            }
            NewPopupAction::ActionsList(action) => {
                match action {
                    ActionsListAction::Add => {
                        // Open action editor for new action
                        app.open_action_editor_popup(None);
                    }
                    ActionsListAction::Edit(idx) => {
                        // Open action editor for existing action
                        if idx < app.settings.actions.len() {
                            app.open_action_editor_popup(Some(idx));
                        }
                    }
                    ActionsListAction::Delete(idx) => {
                        // Open confirmation dialog for delete
                        if idx < app.settings.actions.len() {
                            let name = app.settings.actions[idx].name.clone();
                            app.open_delete_action_confirm(&name, idx);
                        }
                    }
                    ActionsListAction::Toggle(idx) => {
                        // Toggle enable/disable for the action
                        if idx < app.settings.actions.len() {
                            app.settings.actions[idx].enabled = !app.settings.actions[idx].enabled;
                            let _ = persistence::save_settings(app);

                            // Update the list display in the popup
                            use popup::definitions::actions::{ActionInfo, filter_actions, ACTIONS_FIELD_FILTER, ACTIONS_FIELD_LIST};
                            if let Some(state) = app.popup_manager.current_mut() {
                                // Get current filter text
                                let filter_text = if state.editing && state.is_field_selected(ACTIONS_FIELD_FILTER) {
                                    state.edit_buffer.clone()
                                } else {
                                    state.get_text(ACTIONS_FIELD_FILTER).unwrap_or("").to_string()
                                };
                                // Build action info list
                                let all_actions: Vec<ActionInfo> = app.settings.actions
                                    .iter()
                                    .enumerate()
                                    .map(|(i, a)| ActionInfo {
                                        name: a.name.clone(),
                                        world: a.world.clone(),
                                        pattern: a.pattern.clone(),
                                        enabled: a.enabled,
                                        index: i,
                                    })
                                    .collect();
                                // Apply filter and sort alphabetically
                                let mut filtered = filter_actions(&all_actions, &filter_text);
                                filtered.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                                // Update the list in the popup state
                                if let Some(field) = state.field_mut(ACTIONS_FIELD_LIST) {
                                    if let popup::FieldKind::List { items, .. } = &mut field.kind {
                                        // Rebuild items with indices
                                        *items = filtered.iter().map(|info| {
                                                #[cfg(not(windows))]
                                                let status = if info.enabled { "[âœ“]" } else { "[ ]" };
                                                #[cfg(windows)]
                                                let status = if info.enabled { "[x]" } else { "[ ]" };
                                                let world_part = if info.world.is_empty() {
                                                    String::new()
                                                } else {
                                                    format!("({})", info.world)
                                                };
                                                let pattern_preview = if info.pattern.len() > 30 {
                                                    format!("{}...", &info.pattern[..27])
                                                } else {
                                                    info.pattern.clone()
                                                };
                                                popup::ListItem {
                                                    id: info.index.to_string(),
                                                    columns: vec![
                                                        format!("{} {}", status, info.name),
                                                        world_part,
                                                        pattern_preview,
                                                    ],
                                                    style: popup::ListItemStyle {
                                                        is_disabled: !info.enabled,
                                                        ..Default::default()
                                                    },
                                                }
                                        }).collect();
                                    }
                                }
                            }
                        }
                    }
                }
            }
            NewPopupAction::ActionsListFilter => {
                // Filter changed - update the actions list
                use popup::definitions::actions::{ActionInfo, filter_actions, ACTIONS_FIELD_FILTER};
                if let Some(state) = app.popup_manager.current_mut() {
                    // Use edit_buffer if currently editing, otherwise use field value
                    let filter_text = if state.editing && state.is_field_selected(ACTIONS_FIELD_FILTER) {
                        state.edit_buffer.clone()
                    } else {
                        state.get_text(ACTIONS_FIELD_FILTER).unwrap_or("").to_string()
                    };
                    // Build action info list
                    let all_actions: Vec<ActionInfo> = app.settings.actions
                        .iter()
                        .enumerate()
                        .map(|(i, a)| ActionInfo {
                            name: a.name.clone(),
                            world: a.world.clone(),
                            pattern: a.pattern.clone(),
                            enabled: a.enabled,
                            index: i,
                        })
                        .collect();
                    // Apply filter and sort alphabetically
                    let mut filtered = filter_actions(&all_actions, &filter_text);
                    filtered.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));
                    // Update the list in the popup state
                    if let Some(field) = state.field_mut(popup::definitions::actions::ACTIONS_FIELD_LIST) {
                        if let popup::FieldKind::List { items, selected_index, scroll_offset, .. } = &mut field.kind {
                            let old_len = items.len();
                            // Rebuild items with indices
                            *items = filtered.iter().map(|info| {
                                    #[cfg(not(windows))]
                                    let status = if info.enabled { "[âœ“]" } else { "[ ]" };
                                    #[cfg(windows)]
                                    let status = if info.enabled { "[x]" } else { "[ ]" };
                                    let world_part = if info.world.is_empty() {
                                        String::new()
                                    } else {
                                        format!("({})", info.world)
                                    };
                                    let pattern_preview = if info.pattern.len() > 30 {
                                        format!("{}...", &info.pattern[..27])
                                    } else {
                                        info.pattern.clone()
                                    };
                                    popup::ListItem {
                                        id: info.index.to_string(),  // Store original index as ID
                                        columns: vec![
                                            format!("{} {}", status, info.name),
                                            world_part,
                                            pattern_preview,
                                        ],
                                        style: popup::ListItemStyle {
                                            is_disabled: !info.enabled,
                                            ..Default::default()
                                        },
                                    }
                            }).collect();
                            // Reset selection if list changed significantly
                            if items.is_empty() {
                                *selected_index = 0;
                                *scroll_offset = 0;
                            } else if *selected_index >= items.len() {
                                *selected_index = items.len().saturating_sub(1);
                            }
                            if old_len != items.len() {
                                *scroll_offset = 0;
                            }
                        }
                    }
                }
            }
            NewPopupAction::ActionEditorSave { action, editing_index } => {
                // Validate action
                if action.name.trim().is_empty() {
                    app.add_output("Action name cannot be empty.");
                } else {
                    // Check for duplicate names (case-insensitive)
                    let name_lower = action.name.to_lowercase();
                    let is_duplicate = app.settings.actions.iter().enumerate().any(|(i, a)| {
                        a.name.to_lowercase() == name_lower && Some(i) != editing_index
                    });
                    if is_duplicate {
                        app.add_output(&format!("An action named '{}' already exists.", action.name));
                    } else {
                        // Save the action
                        if let Some(idx) = editing_index {
                            if idx < app.settings.actions.len() {
                                app.settings.actions[idx] = action.clone();
                                app.add_output(&format!("Action '{}' updated.", action.name));
                            }
                        } else {
                            app.settings.actions.push(action.clone());
                            app.add_output(&format!("Action '{}' created.", action.name));
                        }
                        // Save settings to disk
                        let _ = persistence::save_settings(app);
                        // Reopen actions list to show updated list
                        app.open_actions_list_popup();
                    }
                }
            }
            NewPopupAction::WorldEditorSaved(settings) => {
                let idx = settings.world_index;
                if idx < app.worlds.len() {
                    // Update world name
                    app.worlds[idx].name = settings.name;

                    // Update world type
                    app.worlds[idx].settings.world_type = WorldType::from_name(&settings.world_type);

                    // Update MUD settings
                    app.worlds[idx].settings.hostname = settings.hostname;
                    app.worlds[idx].settings.port = settings.port;
                    app.worlds[idx].settings.user = settings.user;
                    app.worlds[idx].settings.password = settings.password;
                    app.worlds[idx].settings.use_ssl = settings.use_ssl;
                    app.worlds[idx].settings.log_enabled = settings.log_enabled;

                    // Update encoding
                    app.worlds[idx].settings.encoding = Encoding::from_name(&settings.encoding);

                    // Update auto connect type
                    app.worlds[idx].settings.auto_connect_type = match settings.auto_connect.as_str() {
                        "prompt" => AutoConnectType::Prompt,
                        "moo_prompt" => AutoConnectType::MooPrompt,
                        "none" => AutoConnectType::NoLogin,
                        _ => AutoConnectType::Connect,
                    };

                    // Update keep alive type
                    app.worlds[idx].settings.keep_alive_type = match settings.keep_alive.as_str() {
                        "none" => KeepAliveType::None,
                        "custom" => KeepAliveType::Custom,
                        "generic" => KeepAliveType::Generic,
                        _ => KeepAliveType::Nop,
                    };
                    app.worlds[idx].settings.keep_alive_cmd = settings.keep_alive_cmd;
                    app.worlds[idx].settings.gmcp_packages = settings.gmcp_packages;

                    // Update Slack settings
                    app.worlds[idx].settings.slack_token = settings.slack_token;
                    app.worlds[idx].settings.slack_channel = settings.slack_channel;
                    app.worlds[idx].settings.slack_workspace = settings.slack_workspace;

                    // Update Discord settings
                    app.worlds[idx].settings.discord_token = settings.discord_token;
                    app.worlds[idx].settings.discord_guild = settings.discord_guild;
                    app.worlds[idx].settings.discord_channel = settings.discord_channel;
                    app.worlds[idx].settings.discord_dm_user = settings.discord_dm_user;

                    app.add_output(&format!("World '{}' saved.", app.worlds[idx].name));
                    let _ = persistence::save_settings(app);
                }
            }
            NewPopupAction::WorldEditorDelete(idx) => {
                if app.worlds.len() > 1 && idx < app.worlds.len() {
                    let name = app.worlds[idx].name.clone();
                    app.open_delete_world_confirm(&name, idx);
                } else {
                    app.add_output("Cannot delete the last world.");
                }
            }
            NewPopupAction::WorldEditorConnect(idx) => {
                if idx < app.worlds.len() {
                    // First save the settings that were extracted
                    // Note: The settings were already saved via WorldEditorSaved before this
                    app.switch_world(idx);
                    if !app.current_world().connected {
                        return KeyAction::Connect;
                    }
                }
            }
            NewPopupAction::None => {}
        }
        return KeyAction::None;
    }


    // Handle filter popup input
    if app.filter_popup.visible {
        match key.code {
            KeyCode::Esc => {
                app.filter_popup.close();
                app.needs_output_redraw = true;
            }
            KeyCode::F(4) => {
                // F4 again closes the filter
                app.filter_popup.close();
                app.needs_output_redraw = true;
            }
            KeyCode::F(2) => {
                // F2 toggles show_tags while filter is open
                app.show_tags = !app.show_tags;
                let output_lines = app.current_world().output_lines.clone();
                app.filter_popup.update_filter(&output_lines);
                app.needs_output_redraw = true;
            }
            KeyCode::Backspace => {
                if app.filter_popup.cursor > 0 {
                    app.filter_popup.cursor -= 1;
                    app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                    let output_lines = app.current_world().output_lines.clone();
                    app.filter_popup.update_filter(&output_lines);
                    app.needs_output_redraw = true;
                }
            }
            KeyCode::Delete => {
                if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                    app.filter_popup.filter_text.remove(app.filter_popup.cursor);
                    let output_lines = app.current_world().output_lines.clone();
                    app.filter_popup.update_filter(&output_lines);
                    app.needs_output_redraw = true;
                }
            }
            KeyCode::Left | KeyCode::Char('b') if key.code == KeyCode::Left || key.modifiers.contains(KeyModifiers::CONTROL) => {
                // Left or Ctrl+B = cursor left
                if app.filter_popup.cursor > 0 {
                    app.filter_popup.cursor -= 1;
                }
            }
            KeyCode::Right | KeyCode::Char('f') if key.code == KeyCode::Right || key.modifiers.contains(KeyModifiers::CONTROL) => {
                // Right or Ctrl+F = cursor right
                if app.filter_popup.cursor < app.filter_popup.filter_text.len() {
                    app.filter_popup.cursor += 1;
                }
            }
            KeyCode::Home => {
                app.filter_popup.cursor = 0;
            }
            KeyCode::End => {
                app.filter_popup.cursor = app.filter_popup.filter_text.len();
            }
            KeyCode::PageUp => {
                // Scroll up in filtered results
                let visible_height = app.output_height as usize;
                app.filter_popup.scroll_offset = app.filter_popup.scroll_offset
                    .saturating_sub(visible_height.saturating_sub(2));
                app.needs_output_redraw = true;
            }
            KeyCode::PageDown => {
                // Scroll down in filtered results
                let visible_height = app.output_height as usize;
                let max_offset = app.filter_popup.filtered_indices.len().saturating_sub(1);
                app.filter_popup.scroll_offset = (app.filter_popup.scroll_offset + visible_height.saturating_sub(2))
                    .min(max_offset);
                app.needs_output_redraw = true;
            }
            KeyCode::Char(c) => {
                app.filter_popup.filter_text.insert(app.filter_popup.cursor, c);
                app.filter_popup.cursor += 1;
                let output_lines = app.current_world().output_lines.clone();
                app.filter_popup.update_filter(&output_lines);
                app.needs_output_redraw = true;
            }
            _ => {}
        }
        return KeyAction::None;
    }

    // Handle Tab - more-mode takes priority over command completion
    // Check more-mode first: scroll down when viewing history, release pending when at bottom and paused
    if key.code == KeyCode::Tab && key.modifiers.is_empty() {
        if !app.current_world().is_at_bottom() {
            // Viewing history (Hist indicator showing) - scroll down like PgDn
            app.scroll_output_down();
            app.needs_output_redraw = true;
            return KeyAction::None;
        } else if app.current_world().paused {
            // At bottom and paused - release one screenful (or just unpause if pending is empty)
            app.release_pending_screenful();
            return KeyAction::None;
        }
    }

    // Handle Tab for command completion when input starts with / (only if not in more-mode)
    let is_command_prefix = app.input.buffer.starts_with('/');
    if key.code == KeyCode::Tab && key.modifiers.is_empty() && is_command_prefix {
        // Get the current partial command (everything up to first space, or whole buffer)
        let input = app.input.buffer.clone();
        let partial = if let Some(space_pos) = input.find(' ') {
            &input[..space_pos]
        } else {
            input.as_str()
        };

        // Check if this is a /worlds or /world command with arguments (for world name completion)
        let is_worlds_cmd = partial.eq_ignore_ascii_case("/worlds") || partial.eq_ignore_ascii_case("/world");
        if is_worlds_cmd && input.contains(' ') {
            // World name completion for /worlds and /world commands
            let args_part = &input[input.find(' ').unwrap() + 1..];

            // Parse out -e or -l flag if present
            let (has_flag, partial_name) = if args_part.starts_with("-e ") || args_part.starts_with("-E ")
                || args_part.starts_with("-l ") || args_part.starts_with("-L ")
            {
                (true, args_part[3..].trim_start())
            } else if args_part == "-e" || args_part == "-E" || args_part == "-l" || args_part == "-L" {
                // Just the flag with no world name yet
                return KeyAction::None;
            } else {
                (false, args_part)
            };

            // Get matching world names
            let partial_lower = partial_name.to_lowercase();
            let mut world_matches: Vec<String> = app.worlds.iter()
                .map(|w| w.name.clone())
                .filter(|name| name.to_lowercase().starts_with(&partial_lower))
                .collect();
            world_matches.sort_by_key(|a| a.to_lowercase());

            if !world_matches.is_empty() {
                // Find current match index
                let current_idx = world_matches.iter().position(|m| m.eq_ignore_ascii_case(partial_name));
                let next_idx = match current_idx {
                    Some(idx) => (idx + 1) % world_matches.len(),
                    None => 0,
                };

                // Build the completed input
                let completion = &world_matches[next_idx];
                let flag_part = if has_flag {
                    if args_part.starts_with("-e") || args_part.starts_with("-E") {
                        "-e "
                    } else {
                        "-l "
                    }
                } else {
                    ""
                };
                app.input.buffer = format!("{} {}{}", partial, flag_part, completion);
                app.input.cursor_position = app.input.buffer.len();
            }
            return KeyAction::None;
        }

        // Only complete if we're still in the command part (no space yet or cursor before space)
        if !input.contains(' ') || app.input.cursor_position <= input.find(' ').unwrap_or(input.len()) {
            let matches = {
                // Unified / commands: Clay commands + TF commands + manual actions + macros
                let internal_commands = vec![
                    // Clay-specific commands
                    "/help", "/disconnect", "/dc", "/worlds", "/world", "/connections",
                    "/setup", "/web", "/actions", "/keepalive", "/reload", "/quit", "/gag",
                    "/testmusic", "/dump", "/edit", "/tag", "/menu", "/notify",
                    // TF commands (now available with / prefix)
                    "/set", "/unset", "/let", "/echo", "/send", "/beep", "/quote",
                    "/expr", "/test", "/eval", "/if", "/elseif", "/else", "/endif",
                    "/while", "/done", "/for", "/break", "/def", "/undef", "/undefn",
                    "/undeft", "/list", "/purge", "/bind", "/unbind", "/load", "/save",
                    "/lcd", "/time", "/version", "/ps", "/kill", "/sh", "/recall",
                    "/setenv", "/listvar", "/repeat", "/fg", "/trigger", "/input",
                    "/grab", "/ungag", "/exit", "/connect", "/addworld",
                    // TF-specific versions (for conflicting commands)
                    "/tfhelp", "/tfgag",
                ];

                // Get manual actions (empty pattern)
                let manual_actions: Vec<String> = app.settings.actions.iter()
                    .filter(|a| a.pattern.is_empty())
                    .map(|a| format!("/{}", a.name))
                    .collect();

                // Get user-defined macro names
                let macro_names: Vec<String> = app.tf_engine.macros.iter()
                    .map(|m| format!("/{}", m.name))
                    .collect();

                // Find all matches
                let partial_lower = partial.to_lowercase();
                let mut m: Vec<String> = internal_commands.iter()
                    .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                    .map(|s| s.to_string())
                    .collect();
                m.extend(manual_actions.iter()
                    .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                    .cloned());
                m.extend(macro_names.iter()
                    .filter(|cmd| cmd.to_lowercase().starts_with(&partial_lower))
                    .cloned());
                m.sort();
                m.dedup();
                m
            };

            if !matches.is_empty() {
                // Find current match index if we're already on a completed command
                let current_idx = matches.iter().position(|m| m.eq_ignore_ascii_case(partial));

                // Get next match (cycle through)
                let next_idx = match current_idx {
                    Some(idx) => (idx + 1) % matches.len(),
                    None => 0,
                };

                // Replace the command part with the completion
                let completion = &matches[next_idx];
                if input.contains(' ') {
                    // Preserve arguments after the command
                    let args_start = input.find(' ').unwrap();
                    app.input.buffer = format!("{}{}", completion, &input[args_start..]);
                } else {
                    app.input.buffer = completion.clone();
                }
                app.input.cursor_position = completion.len();
                return KeyAction::None;
            }
        }
    }

    // Helper to check if escape was pressed recently (for Escape+key sequences)
    let recent_escape = app.last_escape
        .map(|t| t.elapsed() < Duration::from_millis(500))
        .unwrap_or(false);

    // Track bare Escape key presses for Escape+key sequences
    if key.code == KeyCode::Esc && key.modifiers.is_empty() {
        app.last_escape = Some(std::time::Instant::now());
        return KeyAction::None;
    }

    // Handle Escape+j (Alt+j) to jump to end - release all pending
    if key.code == KeyCode::Char('j') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None; // Clear escape state
        if app.current_world().paused {
            let world_idx = app.current_world_index;

            // Get the lines that will be released (for broadcasting as ServerData)
            let lines_to_broadcast: Vec<String> = app.worlds[world_idx]
                .pending_lines
                .iter()
                .map(|line| line.text.replace('\r', ""))
                .collect();
            let released = lines_to_broadcast.len();

            app.current_world_mut().release_all_pending();

            // Broadcast the released lines to clients viewing this world
            if !lines_to_broadcast.is_empty() {
                let ws_data = lines_to_broadcast.join("\n") + "\n";
                app.ws_broadcast_to_world(world_idx, WsMessage::ServerData {
                    world_index: world_idx,
                    data: ws_data,
                    is_viewed: true,
                    ts: current_timestamp_secs(),
                    from_server: true,
                });
            }

            // Broadcast release event so other clients sync
            app.ws_broadcast(WsMessage::PendingReleased { world_index: world_idx, count: released });
            app.ws_broadcast(WsMessage::PendingLinesUpdate { world_index: world_idx, count: 0 });
            // Broadcast activity count since pending lines changed
            app.broadcast_activity();
            app.needs_output_redraw = true;
        }
        return KeyAction::None;
    }

    // Handle Escape+w (Alt+w) to switch to world with oldest pending output
    if key.code == KeyCode::Char('w') && (key.modifiers.contains(KeyModifiers::ALT) || recent_escape) {
        app.last_escape = None; // Clear escape state
        app.switch_to_oldest_pending();
        return KeyAction::None;
    }

    // Ctrl+Up/Down - move cursor up/down in multi-line input
    if key.code == KeyCode::Up && key.modifiers.contains(KeyModifiers::CONTROL) && !key.modifiers.contains(KeyModifiers::ALT) {
        app.input.move_cursor_up();
        return KeyAction::None;
    }
    if key.code == KeyCode::Down && key.modifiers.contains(KeyModifiers::CONTROL) && !key.modifiers.contains(KeyModifiers::ALT) {
        app.input.move_cursor_down();
        return KeyAction::None;
    }

    // Alt+Up/Down - resize input area
    if key.code == KeyCode::Up && key.modifiers.contains(KeyModifiers::ALT) {
        app.increase_input_height();
        return KeyAction::None;
    }
    if key.code == KeyCode::Down && key.modifiers.contains(KeyModifiers::ALT) {
        app.decrease_input_height();
        return KeyAction::None;
    }

    match (key.modifiers, key.code) {
        (KeyModifiers::CONTROL, KeyCode::Char('c')) => {
            // Check if we pressed Ctrl+C within the last 15 seconds
            if let Some(last_time) = app.last_ctrl_c {
                if last_time.elapsed() < Duration::from_secs(15) {
                    return KeyAction::Quit;
                }
            }
            // First Ctrl+C or timeout - show message and record time
            app.last_ctrl_c = Some(std::time::Instant::now());
            app.add_output("Press Ctrl+C again within 15 seconds to exit, or use /quit");
            KeyAction::None
        }

        // Ctrl+L to redraw screen
        (KeyModifiers::CONTROL, KeyCode::Char('l')) => KeyAction::Redraw,

        // Ctrl+R to reload
        (KeyModifiers::CONTROL, KeyCode::Char('r')) => KeyAction::Reload,

        // Ctrl+Z to suspend
        (KeyModifiers::CONTROL, KeyCode::Char('z')) => KeyAction::Suspend,

        // F1 to open help popup (using new unified popup system)
        (_, KeyCode::F(1)) => {
            app.open_help_popup_new();
            KeyAction::None
        }

        // F2 to toggle tag display
        (_, KeyCode::F(2)) => {
            app.show_tags = !app.show_tags;
            KeyAction::Redraw // Force full screen redraw to apply change
        }

        // F8 to toggle action pattern highlighting
        (_, KeyCode::F(8)) => {
            app.highlight_actions = !app.highlight_actions;
            KeyAction::Redraw // Force full screen redraw to apply change
        }

        // F9 to toggle GMCP user processing for current world
        (_, KeyCode::F(9)) => {
            let idx = app.current_world_index;
            app.worlds[idx].gmcp_user_enabled = !app.worlds[idx].gmcp_user_enabled;
            app.ws_broadcast(WsMessage::GmcpUserToggled {
                world_index: idx,
                enabled: app.worlds[idx].gmcp_user_enabled,
            });
            if app.worlds[idx].gmcp_user_enabled {
                app.restart_world_media(idx);
            } else {
                app.stop_world_media(idx);
            }
            app.needs_output_redraw = true;
            KeyAction::Redraw
        }

        // F4 to open filter popup
        (_, KeyCode::F(4)) => {
            app.filter_popup.open();
            let output_lines = app.current_world().output_lines.clone();
            app.filter_popup.update_filter(&output_lines);
            app.needs_output_redraw = true;
            KeyAction::None
        }

        // Switch worlds (Up/Down without modifiers)
        (KeyModifiers::NONE, KeyCode::Up) => {
            app.prev_world();
            KeyAction::SwitchedWorld(app.current_world_index)
        }
        (KeyModifiers::NONE, KeyCode::Down) => {
            app.next_world();
            KeyAction::SwitchedWorld(app.current_world_index)
        }

        // Clear input
        (KeyModifiers::CONTROL, KeyCode::Char('u')) => {
            app.input.clear();
            app.spell_state.reset();
            app.suggestion_message = None;
            KeyAction::None
        }

        // Delete word before cursor
        (KeyModifiers::CONTROL, KeyCode::Char('w')) => {
            app.input.delete_word_before_cursor();
            app.spell_state.reset();
            app.suggestion_message = None;
            app.last_input_was_delete = true;
            KeyAction::None
        }

        // History navigation
        (KeyModifiers::CONTROL, KeyCode::Char('p')) => {
            app.input.history_prev();
            app.spell_state.reset();
            KeyAction::None
        }
        (KeyModifiers::CONTROL, KeyCode::Char('n')) => {
            app.input.history_next();
            app.spell_state.reset();
            KeyAction::None
        }

        // Spell check
        (KeyModifiers::CONTROL, KeyCode::Char('q')) => {
            app.handle_spell_check();
            KeyAction::None
        }

        // Submit - Reset lines_since_pause when sending a command
        (_, KeyCode::Enter) => {
            let input = app.input.take_input();
            // Allow empty input to be sent if connected (some MUDs use empty lines)
            if !input.is_empty() || app.current_world().connected {
                // Always reset counter when user sends a command
                // This matches daemon.rs behavior and prevents spurious pausing
                app.current_world_mut().lines_since_pause = 0;
                // Also clear paused flag if no pending lines
                // This prevents staying paused after the triggering line when user sends a command
                if app.current_world().pending_lines.is_empty() {
                    app.current_world_mut().paused = false;
                }
                KeyAction::SendCommand(input)
            } else {
                KeyAction::None
            }
        }

        // Editing
        (_, KeyCode::Backspace) => {
            app.input.delete_char();
            app.last_input_was_delete = true;
            KeyAction::None
        }
        (_, KeyCode::Delete) => {
            app.input.delete_char_forward();
            app.last_input_was_delete = true;
            KeyAction::None
        }

        // Cursor movement
        (_, KeyCode::Left) | (KeyModifiers::CONTROL, KeyCode::Char('b')) => {
            app.input.move_cursor_left();
            KeyAction::None
        }
        (_, KeyCode::Right) | (KeyModifiers::CONTROL, KeyCode::Char('f')) => {
            app.input.move_cursor_right();
            KeyAction::None
        }
        (_, KeyCode::Home) | (KeyModifiers::CONTROL, KeyCode::Char('a')) => {
            app.input.home();
            KeyAction::None
        }
        (_, KeyCode::End) => {
            app.input.end();
            KeyAction::None
        }

        // Output scrolling (history)
        (_, KeyCode::PageUp) => {
            app.scroll_output_up();
            KeyAction::None
        }
        (_, KeyCode::PageDown) => {
            if app.current_world().is_at_bottom() && app.current_world().paused {
                // At bottom and paused - release one screenful (same as Tab)
                app.release_pending_screenful();
            } else {
                app.scroll_output_down();
            }
            KeyAction::None
        }

        // Character input
        (_, KeyCode::Char(c)) => {
            if !c.is_alphabetic() && app.spell_state.showing_suggestions {
                app.spell_state.reset();
            }
            // Clear skip_temp_conversion when typing non-separator (starting new word)
            if !c.is_whitespace() && !matches!(c, '.' | ',' | '!' | '?' | ';' | ':' | ')' | ']' | '}') {
                app.skip_temp_conversion = None;
            }
            app.input.insert_char(c);
            app.last_input_was_delete = false;
            KeyAction::None
        }

        _ => KeyAction::None,
    }
}

// ============================================================================
// Slack Socket Mode Connection
// ============================================================================

async fn connect_slack(app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    // Capture world name for the reader task (stable across world deletions)
    let world_name = app.current_world().name.clone();

    // Clone settings values first to avoid borrow conflicts
    let token = app.current_world().settings.slack_token.clone();
    let channel = app.current_world().settings.slack_channel.clone();

    if token.is_empty() {
        app.add_output("Error: Slack token is required.");
        app.add_output("Configure the token in world settings (/worlds -e)");
        return false;
    }

    app.add_output("");
    app.add_output("Connecting to Slack...");
    app.add_output("");

    // Get WebSocket URL from Slack API
    let client = reqwest::Client::new();
    let response = match client
        .post("https://slack.com/api/apps.connections.open")
        .header("Authorization", format!("Bearer {}", token))
        .header("Content-Type", "application/x-www-form-urlencoded")
        .send()
        .await
    {
        Ok(r) => r,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Slack API: {}", e));
            return false;
        }
    };

    let body: serde_json::Value = match response.json().await {
        Ok(j) => j,
        Err(e) => {
            app.add_output(&format!("Failed to parse Slack response: {}", e));
            return false;
        }
    };

    if body.get("ok").and_then(|v| v.as_bool()) != Some(true) {
        let error = body.get("error").and_then(|v| v.as_str()).unwrap_or("unknown");
        app.add_output(&format!("Slack API error: {}", error));
        return false;
    }

    let ws_url = match body.get("url").and_then(|v| v.as_str()) {
        Some(u) => u.to_string(),
        None => {
            app.add_output("Slack response missing WebSocket URL");
            return false;
        }
    };

    app.add_output("Got WebSocket URL, connecting...");

    // Connect to Slack WebSocket
    use tokio_tungstenite::tungstenite::Message as WsMsg;

    let (ws_stream, _) = match tokio_tungstenite::connect_async(&ws_url).await {
        Ok(s) => s,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Slack WebSocket: {}", e));
            return false;
        }
    };

    app.add_output("Connected to Slack!");
    app.current_world_mut().connected = true;
    app.current_world_mut().was_connected = true;

    let (write, mut read) = ws_stream.split();
    let write = std::sync::Arc::new(tokio::sync::Mutex::new(write));

    // Create command channel for sending messages
    let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
    app.current_world_mut().command_tx = Some(cmd_tx);

    // Spawn reader task
    app.current_world_mut().connection_id += 1;
    let reader_conn_id = app.current_world().connection_id;
    let event_tx_clone = event_tx.clone();
    let _token_clone = token.clone(); // Reserved for future use (user lookup, etc.)
    let channel_clone = channel.clone();
    let write_clone = write.clone();

    tokio::spawn(async move {
        use futures::SinkExt;

        while let Some(msg) = read.next().await {
            match msg {
                Ok(WsMsg::Text(text)) => {
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
                        // Handle envelope acknowledgment
                        if let Some(envelope_id) = json.get("envelope_id").and_then(|v| v.as_str()) {
                            let ack = serde_json::json!({ "envelope_id": envelope_id });
                            let mut w = write_clone.lock().await;
                            let _ = w.send(WsMsg::Text(ack.to_string())).await;
                        }

                        // Handle events
                        if let Some(payload) = json.get("payload") {
                            if let Some(event) = payload.get("event") {
                                let event_type = event.get("type").and_then(|v| v.as_str()).unwrap_or("");

                                if event_type == "message" {
                                    // Check if it's the right channel
                                    let msg_channel = event.get("channel").and_then(|v| v.as_str()).unwrap_or("");
                                    if channel_clone.is_empty() || msg_channel == channel_clone || msg_channel.contains(&channel_clone) {
                                        let user = event.get("user").and_then(|v| v.as_str()).unwrap_or("unknown");
                                        let text = event.get("text").and_then(|v| v.as_str()).unwrap_or("");
                                        let formatted = format!("[{}] <{}> {}", msg_channel, user, text);
                                        let _ = event_tx_clone.send(AppEvent::SlackMessage(world_name.clone(), formatted)).await;
                                    }
                                }
                            }
                        }
                    }
                }
                Ok(WsMsg::Close(_)) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                    break;
                }
                Err(_) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                    break;
                }
                _ => {}
            }
        }
    });

    // Spawn writer task for sending messages
    let token_for_writer = token.clone();
    let channel_for_writer = channel.clone();
    tokio::spawn(async move {
        let client = reqwest::Client::new();
        while let Some(cmd) = cmd_rx.recv().await {
            let text = match cmd {
                WriteCommand::Text(t) => t,
                WriteCommand::Raw(r) => String::from_utf8_lossy(&r).to_string(),
                WriteCommand::Shutdown => break,
            };
            // Send message via chat.postMessage API
            let _ = client
                .post("https://slack.com/api/chat.postMessage")
                .header("Authorization", format!("Bearer {}", token_for_writer))
                .header("Content-Type", "application/json")
                .json(&serde_json::json!({
                    "channel": channel_for_writer,
                    "text": text
                }))
                .send()
                .await;
        }
    });

    false
}

// ============================================================================
// Discord Gateway Bot Connection
// ============================================================================

async fn connect_discord(app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    // Capture world name for the reader task (stable across world deletions)
    let world_name = app.current_world().name.clone();

    // Clone settings values first to avoid borrow conflicts
    let token = app.current_world().settings.discord_token.clone();
    let _guild_id = app.current_world().settings.discord_guild.clone();
    let mut channel_id = app.current_world().settings.discord_channel.clone();
    let dm_user = app.current_world().settings.discord_dm_user.clone();

    if token.is_empty() {
        app.add_output("Error: Discord token is required.");
        app.add_output("Configure the token in world settings (/worlds -e)");
        return false;
    }

    app.add_output("");
    app.add_output("Connecting to Discord...");

    // If DM user is set, create a DM channel first
    if !dm_user.is_empty() && channel_id.is_empty() {
        app.add_output(&format!("Creating DM channel with user {}...", dm_user));

        let client = reqwest::Client::new();
        let response = match client
            .post("https://discord.com/api/v10/users/@me/channels")
            .header("Authorization", format!("Bot {}", token))
            .header("Content-Type", "application/json")
            .json(&serde_json::json!({
                "recipient_id": dm_user
            }))
            .send()
            .await
        {
            Ok(r) => r,
            Err(e) => {
                app.add_output(&format!("Failed to create DM channel: {}", e));
                return false;
            }
        };

        let status = response.status();
        let body: serde_json::Value = match response.json().await {
            Ok(j) => j,
            Err(e) => {
                app.add_output(&format!("Failed to parse DM response: {} (HTTP {})", e, status));
                return false;
            }
        };

        if status.is_success() {
            if let Some(id) = body.get("id").and_then(|v| v.as_str()) {
                channel_id = id.to_string();
                app.add_output(&format!("DM channel created: {}", channel_id));
            } else {
                app.add_output("Failed to create DM channel: no channel ID in response");
                app.add_output(&format!("Response: {}", body));
                return false;
            }
        } else {
            let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
            let error_code = body.get("code").and_then(|v| v.as_i64());
            app.add_output(&format!("Failed to create DM channel (HTTP {}): {}", status.as_u16(), error_msg));
            if let Some(code) = error_code {
                app.add_output(&format!("Discord error code: {}", code));
            }
            // Show hint for common errors
            if status.as_u16() == 401 {
                app.add_output("Hint: Check that your bot token is correct and includes 'Bot ' prefix if needed");
            } else if status.as_u16() == 403 {
                app.add_output("Hint: Bot may lack permissions or the user has DMs disabled");
            }
            return false;
        }
    }

    // Resolve channel name to ID if needed
    let guild_id = app.current_world().settings.discord_guild.clone();
    if !channel_id.is_empty() && !channel_id.chars().all(|c| c.is_ascii_digit()) {
        // Channel is a name, not an ID - need to resolve it
        if guild_id.is_empty() {
            app.add_output("Error: Guild ID is required when using a channel name.");
            app.add_output("Either use a numeric channel ID or configure the Guild ID.");
            return false;
        }

        app.add_output(&format!("Resolving channel name '{}'...", channel_id));

        let client = reqwest::Client::new();
        let url = format!("https://discord.com/api/v10/guilds/{}/channels", guild_id);
        let response = match client
            .get(&url)
            .header("Authorization", format!("Bot {}", token))
            .send()
            .await
        {
            Ok(r) => r,
            Err(e) => {
                app.add_output(&format!("Failed to fetch guild channels: {}", e));
                return false;
            }
        };

        let status = response.status();
        if !status.is_success() {
            let body: serde_json::Value = response.json().await.unwrap_or_default();
            let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
            app.add_output(&format!("Failed to fetch guild channels (HTTP {}): {}", status.as_u16(), error_msg));
            return false;
        }

        let channels: Vec<serde_json::Value> = match response.json().await {
            Ok(c) => c,
            Err(e) => {
                app.add_output(&format!("Failed to parse channels response: {}", e));
                return false;
            }
        };

        // Find channel by name (case-insensitive)
        let channel_name_lower = channel_id.to_lowercase();
        let found_channel = channels.iter().find(|ch| {
            ch.get("name")
                .and_then(|n| n.as_str())
                .map(|n| n.to_lowercase() == channel_name_lower)
                .unwrap_or(false)
        });

        match found_channel {
            Some(ch) => {
                if let Some(id) = ch.get("id").and_then(|v| v.as_str()) {
                    app.add_output(&format!("Resolved '{}' to channel ID {}", channel_id, id));
                    channel_id = id.to_string();
                } else {
                    app.add_output(&format!("Channel '{}' found but has no ID", channel_id));
                    return false;
                }
            }
            None => {
                app.add_output(&format!("Channel '{}' not found in guild", channel_id));
                // List available channels as a hint
                let available: Vec<&str> = channels.iter()
                    .filter_map(|ch| ch.get("name").and_then(|n| n.as_str()))
                    .take(10)
                    .collect();
                if !available.is_empty() {
                    app.add_output(&format!("Available channels: {}", available.join(", ")));
                }
                return false;
            }
        }
    }

    app.add_output("");

    // Connect to Discord Gateway
    use tokio_tungstenite::tungstenite::Message as WsMsg;

    let (ws_stream, _) = match tokio_tungstenite::connect_async("wss://gateway.discord.gg/?v=10&encoding=json").await {
        Ok(s) => s,
        Err(e) => {
            app.add_output(&format!("Failed to connect to Discord Gateway: {}", e));
            return false;
        }
    };

    let (write, mut read) = ws_stream.split();
    let write = std::sync::Arc::new(tokio::sync::Mutex::new(write));

    // Create command channel for sending messages
    let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
    app.current_world_mut().command_tx = Some(cmd_tx);

    // Clone world_name for both spawns before moving into first one
    let world_name_for_writer = world_name.clone();

    // Spawn reader/heartbeat task
    app.current_world_mut().connection_id += 1;
    let reader_conn_id = app.current_world().connection_id;
    let event_tx_clone = event_tx.clone();
    let token_clone = token.clone();
    let channel_id_clone = channel_id.clone();
    let write_clone = write.clone();

    tokio::spawn(async move {
        use futures::SinkExt;

        let mut _heartbeat_interval: Option<u64> = None; // Reserved for dynamic heartbeat
        let mut last_sequence: Option<u64> = None;
        let mut _identified = false; // Track READY state

        while let Some(msg) = read.next().await {
            match msg {
                Ok(WsMsg::Text(text)) => {
                    if let Ok(json) = serde_json::from_str::<serde_json::Value>(&text) {
                        let op = json.get("op").and_then(|v| v.as_u64()).unwrap_or(0);

                        // Update sequence number
                        if let Some(s) = json.get("s").and_then(|v| v.as_u64()) {
                            last_sequence = Some(s);
                        }

                        match op {
                            10 => {
                                // Hello - start heartbeat
                                if let Some(d) = json.get("d") {
                                    if let Some(interval) = d.get("heartbeat_interval").and_then(|v| v.as_u64()) {
                                        _heartbeat_interval = Some(interval);

                                        // Send IDENTIFY
                                        let identify = serde_json::json!({
                                            "op": 2,
                                            "d": {
                                                "token": token_clone,
                                                "intents": 2099200, // GUILDS + GUILD_MESSAGES + MESSAGE_CONTENT
                                                "properties": {
                                                    "os": "linux",
                                                    "browser": "clay",
                                                    "device": "clay"
                                                }
                                            }
                                        });
                                        let mut w = write_clone.lock().await;
                                        let _ = w.send(WsMsg::Text(identify.to_string())).await;
                                    }
                                }
                            }
                            0 => {
                                // Dispatch event
                                let event_type = json.get("t").and_then(|v| v.as_str()).unwrap_or("");

                                if event_type == "READY" {
                                    _identified = true;
                                    let _ = event_tx_clone.send(AppEvent::DiscordMessage(world_name.clone(), "Connected to Discord!".to_string())).await;
                                } else if event_type == "MESSAGE_CREATE" {
                                    if let Some(d) = json.get("d") {
                                        let msg_channel = d.get("channel_id").and_then(|v| v.as_str()).unwrap_or("");
                                        if channel_id_clone.is_empty() || msg_channel == channel_id_clone {
                                            let author = d.get("author").and_then(|a| a.get("username")).and_then(|v| v.as_str()).unwrap_or("unknown");
                                            let content = d.get("content").and_then(|v| v.as_str()).unwrap_or("");
                                            let formatted = format!("[#{}] <{}> {}", msg_channel, author, content);
                                            let _ = event_tx_clone.send(AppEvent::DiscordMessage(world_name.clone(), formatted)).await;
                                        }
                                    }
                                }
                            }
                            11 => {
                                // Heartbeat ACK - good, keep going
                            }
                            1 => {
                                // Heartbeat request - send heartbeat
                                let hb = serde_json::json!({
                                    "op": 1,
                                    "d": last_sequence
                                });
                                let mut w = write_clone.lock().await;
                                let _ = w.send(WsMsg::Text(hb.to_string())).await;
                            }
                            _ => {}
                        }
                    }
                }
                Ok(WsMsg::Close(_)) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                    break;
                }
                Err(_) => {
                    let _ = event_tx_clone.send(AppEvent::Disconnected(world_name.clone(), reader_conn_id)).await;
                    break;
                }
                _ => {}
            }
        }
    });

    // Spawn heartbeat task
    let write_for_heartbeat = write.clone();
    tokio::spawn(async move {
        use futures::SinkExt;
        let mut interval = tokio::time::interval(std::time::Duration::from_secs(41)); // ~41s heartbeat
        loop {
            interval.tick().await;
            let hb = serde_json::json!({
                "op": 1,
                "d": null
            });
            let mut w = write_for_heartbeat.lock().await;
            if w.send(WsMsg::Text(hb.to_string())).await.is_err() {
                break;
            }
        }
    });

    // Spawn writer task for sending messages via REST API
    let token_for_writer = token.clone();
    let channel_for_writer = channel_id.clone();
    let event_tx_for_writer = event_tx.clone();
    tokio::spawn(async move {
        let client = reqwest::Client::new();
        while let Some(cmd) = cmd_rx.recv().await {
            let text = match cmd {
                WriteCommand::Text(t) => t,
                WriteCommand::Raw(r) => String::from_utf8_lossy(&r).to_string(),
                WriteCommand::Shutdown => break,
            };
            if channel_for_writer.is_empty() {
                let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), "Error: No channel configured".to_string())).await;
                continue;
            }
            let url = format!("https://discord.com/api/v10/channels/{}/messages", channel_for_writer);
            match client
                .post(&url)
                .header("Authorization", format!("Bot {}", token_for_writer))
                .header("Content-Type", "application/json")
                .json(&serde_json::json!({
                    "content": text
                }))
                .send()
                .await
            {
                Ok(response) => {
                    if !response.status().is_success() {
                        let status = response.status();
                        let body: serde_json::Value = response.json().await.unwrap_or_default();
                        let error_msg = body.get("message").and_then(|v| v.as_str()).unwrap_or("unknown error");
                        let msg = format!("Discord send failed (HTTP {}): {}", status.as_u16(), error_msg);
                        let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), msg)).await;
                    }
                }
                Err(e) => {
                    let msg = format!("Discord send error: {}", e);
                    let _ = event_tx_for_writer.send(AppEvent::DiscordMessage(world_name_for_writer.clone(), msg)).await;
                }
            }
        }
    });

    app.current_world_mut().connected = true;
    app.current_world_mut().was_connected = true;

    false
}

/// Convert UTF-8 characters with diacritics to ASCII equivalents
/// for better compatibility with non-UTF-8 MUD worlds
pub fn transliterate_to_ascii(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    for c in s.chars() {
        match c {
            // Accented vowels - lowercase
            'Ã ' | 'Ã¡' | 'Ã¢' | 'Ã£' | 'Ã¤' | 'Ã¥' | 'Ä' | 'Äƒ' | 'Ä…' => result.push('a'),
            'Ã¨' | 'Ã©' | 'Ãª' | 'Ã«' | 'Ä“' | 'Ä•' | 'Ä—' | 'Ä™' | 'Ä›' => result.push('e'),
            'Ã¬' | 'Ã­' | 'Ã®' | 'Ã¯' | 'Ä©' | 'Ä«' | 'Ä­' | 'Ä¯' | 'Ä±' => result.push('i'),
            'Ã²' | 'Ã³' | 'Ã´' | 'Ãµ' | 'Ã¶' | 'Å' | 'Å' | 'Å‘' | 'Ã¸' => result.push('o'),
            'Ã¹' | 'Ãº' | 'Ã»' | 'Ã¼' | 'Å©' | 'Å«' | 'Å­' | 'Å¯' | 'Å±' | 'Å³' => result.push('u'),
            'Ã½' | 'Ã¿' | 'Å·' => result.push('y'),
            // Accented vowels - uppercase
            'Ã€' | 'Ã' | 'Ã‚' | 'Ãƒ' | 'Ã„' | 'Ã…' | 'Ä€' | 'Ä‚' | 'Ä„' => result.push('A'),
            'Ãˆ' | 'Ã‰' | 'ÃŠ' | 'Ã‹' | 'Ä’' | 'Ä”' | 'Ä–' | 'Ä˜' | 'Äš' => result.push('E'),
            'ÃŒ' | 'Ã' | 'ÃŽ' | 'Ã' | 'Ä¨' | 'Äª' | 'Ä¬' | 'Ä®' | 'Ä°' => result.push('I'),
            'Ã’' | 'Ã“' | 'Ã”' | 'Ã•' | 'Ã–' | 'ÅŒ' | 'ÅŽ' | 'Å' | 'Ã˜' => result.push('O'),
            'Ã™' | 'Ãš' | 'Ã›' | 'Ãœ' | 'Å¨' | 'Åª' | 'Å¬' | 'Å®' | 'Å°' | 'Å²' => result.push('U'),
            'Ã' | 'Å¸' | 'Å¶' => result.push('Y'),
            // Accented consonants - lowercase
            'Ã§' | 'Ä‡' | 'Ä‰' | 'Ä‹' | 'Ä' => result.push('c'),
            'Ã±' | 'Å„' | 'Å†' | 'Åˆ' | 'Å‰' => result.push('n'),
            'Å›' | 'Å' | 'ÅŸ' | 'Å¡' => result.push('s'),
            'Åº' | 'Å¼' | 'Å¾' => result.push('z'),
            'Ã°' | 'Ä‘' => result.push('d'),
            'Ä' | 'ÄŸ' | 'Ä¡' | 'Ä£' => result.push('g'),
            'Ä¥' | 'Ä§' => result.push('h'),
            'Äµ' => result.push('j'),
            'Ä·' | 'Ä¸' => result.push('k'),
            'Äº' | 'Ä¼' | 'Ä¾' | 'Å€' | 'Å‚' => result.push('l'),
            'Å•' | 'Å—' | 'Å™' => result.push('r'),
            'Å£' | 'Å¥' | 'Å§' => result.push('t'),
            'Åµ' => result.push('w'),
            // Accented consonants - uppercase
            'Ã‡' | 'Ä†' | 'Äˆ' | 'ÄŠ' | 'ÄŒ' => result.push('C'),
            'Ã‘' | 'Åƒ' | 'Å…' | 'Å‡' => result.push('N'),
            'Åš' | 'Åœ' | 'Åž' | 'Å ' => result.push('S'),
            'Å¹' | 'Å»' | 'Å½' => result.push('Z'),
            'Ã' | 'Ä' => result.push('D'),
            'Äœ' | 'Äž' | 'Ä ' | 'Ä¢' => result.push('G'),
            'Ä¤' | 'Ä¦' => result.push('H'),
            'Ä´' => result.push('J'),
            'Ä¶' => result.push('K'),
            'Ä¹' | 'Ä»' | 'Ä½' | 'Ä¿' | 'Å' => result.push('L'),
            'Å”' | 'Å–' | 'Å˜' => result.push('R'),
            'Å¢' | 'Å¤' | 'Å¦' => result.push('T'),
            'Å´' => result.push('W'),
            // Ligatures (multi-char replacements)
            'Ã¦' => result.push_str("ae"),
            'Ã†' => result.push_str("AE"),
            'Å“' => result.push_str("oe"),
            'Å’' => result.push_str("OE"),
            'ÃŸ' => result.push_str("ss"),
            'Ã¾' => result.push_str("th"),
            'Ãž' => result.push_str("Th"),
            'Ä³' => result.push_str("ij"),
            'Ä²' => result.push_str("IJ"),
            // Quotes and punctuation (using unicode escapes for curly quotes)
            '\u{2018}' | '\u{2019}' | '\u{201A}' | '\u{201B}' => result.push('\''),
            '\u{201C}' | '\u{201D}' | '\u{201E}' | '\u{201F}' => result.push('"'),
            'â€“' | 'â€”' => result.push('-'),
            'â€¦' => result.push_str("..."),
            // Cyrillic - lowercase
            'Ð°' => result.push('a'),
            'Ð±' => result.push('b'),
            'Ð²' => result.push('v'),
            'Ð³' => result.push('g'),
            'Ð´' => result.push('d'),
            'Ðµ' | 'Ñ' => result.push('e'),
            'Ñ‘' => result.push_str("yo"),
            'Ð¶' => result.push_str("zh"),
            'Ð·' => result.push('z'),
            'Ð¸' | 'Ñ‹' => result.push('i'),
            'Ð¹' => result.push('y'),
            'Ðº' => result.push('k'),
            'Ð»' => result.push('l'),
            'Ð¼' => result.push('m'),
            'Ð½' => result.push('n'),
            'Ð¾' => result.push('o'),
            'Ð¿' => result.push('p'),
            'Ñ€' => result.push('r'),
            'Ñ' => result.push('s'),
            'Ñ‚' => result.push('t'),
            'Ñƒ' => result.push('u'),
            'Ñ„' => result.push('f'),
            'Ñ…' => result.push_str("kh"),
            'Ñ†' => result.push_str("ts"),
            'Ñ‡' => result.push_str("ch"),
            'Ñˆ' => result.push_str("sh"),
            'Ñ‰' => result.push_str("shch"),
            'ÑŠ' => {} // hard sign - omit
            'ÑŒ' => {} // soft sign - omit
            'ÑŽ' => result.push_str("yu"),
            'Ñ' => result.push_str("ya"),
            // Cyrillic - uppercase
            'Ð' => result.push('A'),
            'Ð‘' => result.push('B'),
            'Ð’' => result.push('V'),
            'Ð“' => result.push('G'),
            'Ð”' => result.push('D'),
            'Ð•' | 'Ð­' => result.push('E'),
            'Ð' => result.push_str("Yo"),
            'Ð–' => result.push_str("Zh"),
            'Ð—' => result.push('Z'),
            'Ð˜' | 'Ð«' => result.push('I'),
            'Ð™' => result.push('Y'),
            'Ðš' => result.push('K'),
            'Ð›' => result.push('L'),
            'Ðœ' => result.push('M'),
            'Ð' => result.push('N'),
            'Ðž' => result.push('O'),
            'ÐŸ' => result.push('P'),
            'Ð ' => result.push('R'),
            'Ð¡' => result.push('S'),
            'Ð¢' => result.push('T'),
            'Ð£' => result.push('U'),
            'Ð¤' => result.push('F'),
            'Ð¥' => result.push_str("Kh"),
            'Ð¦' => result.push_str("Ts"),
            'Ð§' => result.push_str("Ch"),
            'Ð¨' => result.push_str("Sh"),
            'Ð©' => result.push_str("Shch"),
            'Ðª' => {} // hard sign - omit
            'Ð¬' => {} // soft sign - omit
            'Ð®' => result.push_str("Yu"),
            'Ð¯' => result.push_str("Ya"),
            // Greek - lowercase
            'Î±' => result.push('a'),
            'Î²' => result.push('b'),
            'Î³' => result.push('g'),
            'Î´' => result.push('d'),
            'Îµ' => result.push('e'),
            'Î¶' => result.push('z'),
            'Î·' => result.push('i'),
            'Î¸' => result.push_str("th"),
            'Î¹' => result.push('i'),
            'Îº' => result.push('k'),
            'Î»' => result.push('l'),
            'Î¼' => result.push('m'),
            'Î½' => result.push('n'),
            'Î¾' => result.push('x'),
            'Î¿' => result.push('o'),
            'Ï€' => result.push('p'),
            'Ï' => result.push('r'),
            'Ïƒ' | 'Ï‚' => result.push('s'),
            'Ï„' => result.push('t'),
            'Ï…' => result.push('y'),
            'Ï†' => result.push_str("ph"),
            'Ï‡' => result.push_str("ch"),
            'Ïˆ' => result.push_str("ps"),
            'Ï‰' => result.push('o'),
            // Greek - uppercase
            'Î‘' => result.push('A'),
            'Î’' => result.push('B'),
            'Î“' => result.push('G'),
            'Î”' => result.push('D'),
            'Î•' => result.push('E'),
            'Î–' => result.push('Z'),
            'Î—' => result.push('I'),
            'Î˜' => result.push_str("Th"),
            'Î™' => result.push('I'),
            'Îš' => result.push('K'),
            'Î›' => result.push('L'),
            'Îœ' => result.push('M'),
            'Î' => result.push('N'),
            'Îž' => result.push('X'),
            'ÎŸ' => result.push('O'),
            'Î ' => result.push('P'),
            'Î¡' => result.push('R'),
            'Î£' => result.push('S'),
            'Î¤' => result.push('T'),
            'Î¥' => result.push('Y'),
            'Î¦' => result.push_str("Ph"),
            'Î§' => result.push_str("Ch"),
            'Î¨' => result.push_str("Ps"),
            'Î©' => result.push('O'),
            // Everything else passes through unchanged
            _ => result.push(c),
        }
    }
    result
}

/// Look up a word definition from the Free Dictionary API
/// Returns the first definition, with multiple definitions joined by spaces
/// Result is a single line with newlines replaced by spaces
pub async fn lookup_definition(word: &str) -> Result<String, String> {
    let url = format!("https://api.dictionaryapi.dev/api/v2/entries/en/{}", word);

    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .map_err(|e| format!("Failed to create HTTP client: {}", e))?;

    let response = client
        .get(&url)
        .send()
        .await
        .map_err(|e| format!("HTTP request failed: {}", e))?;

    if response.status() == 404 {
        return Err(format!("Word '{}' not found", word));
    }

    if !response.status().is_success() {
        return Err(format!("API error: {}", response.status()));
    }

    let json: serde_json::Value = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse JSON: {}", e))?;

    // Parse the response - it's an array of entries
    let entries = json.as_array()
        .ok_or_else(|| "Invalid response format".to_string())?;

    if entries.is_empty() {
        return Err(format!("No definitions found for '{}'", word));
    }

    // Collect definitions from the first entry
    let mut definitions = Vec::new();

    if let Some(meanings) = entries[0].get("meanings").and_then(|m| m.as_array()) {
        for meaning in meanings {
            if let Some(defs) = meaning.get("definitions").and_then(|d| d.as_array()) {
                for def in defs {
                    if let Some(definition) = def.get("definition").and_then(|d| d.as_str()) {
                        definitions.push(definition.to_string());
                    }
                }
            }
        }
    }

    if definitions.is_empty() {
        return Err(format!("No definitions found for '{}'", word));
    }

    // Join all definitions with spaces and ensure single line
    let result = definitions.join(" ")
        .replace('\n', " ")
        .replace('\r', "")
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ");

    Ok(result)
}

/// Look up a word definition from Urban Dictionary API
/// Returns the first definition only, as a single line
pub async fn lookup_urban_definition(word: &str) -> Result<String, String> {
    let encoded: String = url::form_urlencoded::Serializer::new(String::new())
        .append_pair("term", word)
        .finish();
    let url = format!("https://api.urbandictionary.com/v0/define?{}", encoded);

    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .map_err(|e| format!("Failed to create HTTP client: {}", e))?;

    let response = client
        .get(&url)
        .send()
        .await
        .map_err(|e| format!("HTTP request failed: {}", e))?;

    if !response.status().is_success() {
        return Err(format!("API error: {}", response.status()));
    }

    let json: serde_json::Value = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse JSON: {}", e))?;

    // Parse the response - it has a "list" array
    let list = json.get("list")
        .and_then(|l| l.as_array())
        .ok_or_else(|| "Invalid response format".to_string())?;

    if list.is_empty() {
        return Err(format!("No definitions found for '{}'", word));
    }

    // Get the first definition only
    let definition = list[0].get("definition")
        .and_then(|d| d.as_str())
        .ok_or_else(|| "No definition text found".to_string())?;

    // Clean up: remove brackets (Urban Dictionary uses [word] for links), ensure single line
    let result = definition
        .replace(['[', ']'], "")
        .replace('\n', " ")
        .replace('\r', "")
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ");

    Ok(result)
}

/// Convert language name or code to ISO 639-1 code (case-insensitive)
pub fn normalize_language_code(lang: &str) -> String {
    let lower = lang.to_lowercase();
    match lower.as_str() {
        // Already a 2-letter code - return as-is
        "en" | "es" | "fr" | "de" | "it" | "pt" | "ru" | "zh" | "ja" | "ko" |
        "ar" | "nl" | "pl" | "sv" | "da" | "no" | "fi" | "cs" | "el" | "he" |
        "hi" | "hu" | "id" | "ms" | "ro" | "sk" | "th" | "tr" | "uk" | "vi" |
        "bg" | "ca" | "hr" | "et" | "lv" | "lt" | "sl" | "sr" | "tl" | "fa" => lower,
        // Full language names
        "english" => "en".to_string(),
        "spanish" | "espanol" | "espaÃ±ol" => "es".to_string(),
        "french" | "francais" | "franÃ§ais" => "fr".to_string(),
        "german" | "deutsch" => "de".to_string(),
        "italian" | "italiano" => "it".to_string(),
        "portuguese" | "portugues" | "portuguÃªs" => "pt".to_string(),
        "russian" | "russkiy" | "Ñ€ÑƒÑÑÐºÐ¸Ð¹" => "ru".to_string(),
        "chinese" | "mandarin" | "zhongwen" => "zh".to_string(),
        "japanese" | "nihongo" => "ja".to_string(),
        "korean" | "hangugeo" => "ko".to_string(),
        "arabic" => "ar".to_string(),
        "dutch" | "nederlands" => "nl".to_string(),
        "polish" | "polski" => "pl".to_string(),
        "swedish" | "svenska" => "sv".to_string(),
        "danish" | "dansk" => "da".to_string(),
        "norwegian" | "norsk" => "no".to_string(),
        "finnish" | "suomi" => "fi".to_string(),
        "czech" | "cesky" | "ÄeÅ¡tina" => "cs".to_string(),
        "greek" | "ellinika" => "el".to_string(),
        "hebrew" | "ivrit" => "he".to_string(),
        "hindi" => "hi".to_string(),
        "hungarian" | "magyar" => "hu".to_string(),
        "indonesian" | "bahasa" => "id".to_string(),
        "malay" | "melayu" => "ms".to_string(),
        "romanian" | "romana" | "romÃ¢nÄƒ" => "ro".to_string(),
        "slovak" | "slovencina" => "sk".to_string(),
        "thai" => "th".to_string(),
        "turkish" | "turkce" | "tÃ¼rkÃ§e" => "tr".to_string(),
        "ukrainian" | "ukrainska" => "uk".to_string(),
        "vietnamese" | "tiengviet" => "vi".to_string(),
        "bulgarian" | "balgarski" => "bg".to_string(),
        "catalan" | "catala" | "catalÃ " => "ca".to_string(),
        "croatian" | "hrvatski" => "hr".to_string(),
        "estonian" | "eesti" => "et".to_string(),
        "latvian" | "latviesu" => "lv".to_string(),
        "lithuanian" | "lietuviu" => "lt".to_string(),
        "slovenian" | "slovenscina" => "sl".to_string(),
        "serbian" | "srpski" => "sr".to_string(),
        "tagalog" | "filipino" => "tl".to_string(),
        "persian" | "farsi" => "fa".to_string(),
        // Default: assume it's a code and pass through
        _ => lower,
    }
}

/// Translate text using MyMemory API (free, no API key required for up to 1000 words/day)
pub async fn lookup_translation(text: &str, target_lang: &str) -> Result<String, String> {
    // Normalize language input (accepts both codes and names)
    let lang_code = normalize_language_code(target_lang);

    // MyMemory API uses langpair format: source|target
    // Using "autodetect" as source to auto-detect the input language
    let encoded_text: String = url::form_urlencoded::Serializer::new(String::new())
        .append_pair("q", text)
        .append_pair("langpair", &format!("autodetect|{}", lang_code))
        .finish();
    let url = format!("https://api.mymemory.translated.net/get?{}", encoded_text);

    let client = reqwest::Client::builder()
        .timeout(std::time::Duration::from_secs(10))
        .build()
        .map_err(|e| format!("Failed to create HTTP client: {}", e))?;

    let response = client
        .get(&url)
        .send()
        .await
        .map_err(|e| format!("HTTP request failed: {}", e))?;

    if !response.status().is_success() {
        return Err(format!("API error: {}", response.status()));
    }

    let json: serde_json::Value = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse JSON: {}", e))?;

    // Check for error response
    if let Some(response_status) = json.get("responseStatus").and_then(|s| s.as_i64()) {
        if response_status != 200 {
            let error_msg = json.get("responseDetails")
                .and_then(|d| d.as_str())
                .unwrap_or("Unknown error");
            return Err(format!("Translation failed: {}", error_msg));
        }
    }

    // Get the translated text
    let translated = json.get("responseData")
        .and_then(|d| d.get("translatedText"))
        .and_then(|t| t.as_str())
        .ok_or_else(|| "No translation found in response".to_string())?;

    // Clean up: ensure single line
    let result = translated
        .replace('\n', " ")
        .replace('\r', "")
        .split_whitespace()
        .collect::<Vec<_>>()
        .join(" ");

    Ok(result)
}

/// Cap a string to max_len bytes at a valid char boundary.
fn cap_text(s: String, max_len: usize) -> String {
    if s.len() <= max_len {
        s
    } else {
        let mut end = max_len;
        while end > 0 && !s.is_char_boundary(end) {
            end -= 1;
        }
        s[..end].to_string()
    }
}

/// Spawn an async API lookup task for /dict, /urban, or /translate commands.
/// Results are sent back via event_tx as ApiLookupResult for the main loop to route to the client.
pub fn spawn_api_lookup(
    event_tx: mpsc::Sender<AppEvent>,
    client_id: u64,
    world_index: usize,
    command: Command,
) {
    match command {
        Command::Dict { prefix, word } => {
            tokio::spawn(async move {
                let result = match lookup_definition(&word).await {
                    Ok(def) => {
                        let ascii = transliterate_to_ascii(&def);
                        Ok(cap_text(format!("{} {}: {}", prefix, word, ascii), 1024))
                    }
                    Err(e) => Err(format!("Definition lookup failed: {}", e)),
                };
                let _ = event_tx.send(AppEvent::ApiLookupResult(client_id, world_index, result)).await;
            });
        }
        Command::Urban { prefix, word } => {
            tokio::spawn(async move {
                let result = match lookup_urban_definition(&word).await {
                    Ok(def) => {
                        let ascii = transliterate_to_ascii(&def);
                        Ok(cap_text(format!("{} Urban Dict: {}: {}", prefix, word, ascii), 1024))
                    }
                    Err(e) => Err(format!("Urban Dictionary lookup failed: {}", e)),
                };
                let _ = event_tx.send(AppEvent::ApiLookupResult(client_id, world_index, result)).await;
            });
        }
        Command::Translate { lang, prefix, text } => {
            tokio::spawn(async move {
                let result = match lookup_translation(&text, &lang).await {
                    Ok(trans) => {
                        let ascii = transliterate_to_ascii(&trans);
                        Ok(cap_text(format!("{} {}", prefix, ascii), 1024))
                    }
                    Err(e) => Err(format!("Translation failed: {}", e)),
                };
                let _ = event_tx.send(AppEvent::ApiLookupResult(client_id, world_index, result)).await;
            });
        }
        _ => {}
    }
}

#[async_recursion(?Send)]
async fn handle_command(cmd: &str, app: &mut App, event_tx: mpsc::Sender<AppEvent>) -> bool {
    let parsed = parse_command(cmd);

    match parsed {
        Command::Help => {
            app.open_help_popup_new();
        }
        Command::HelpTf => {
            // Execute TF help command and display the result
            match app.tf_engine.execute("#help") {
                tf::TfCommandResult::Success(Some(msg)) => {
                    for line in msg.lines() {
                        app.add_output(line);
                    }
                }
                _ => {
                    app.add_output("TF help not available.");
                }
            }
        }
        Command::Version => {
            app.add_output(&get_version_string());
        }
        Command::Menu => {
            app.open_menu_popup_new();
        }
        Command::Quit => {
            // Kill all TLS proxy processes before quitting
            for world in &app.worlds {
                #[cfg(unix)]
                if let Some(proxy_pid) = world.proxy_pid {
                    unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                }
                if let Some(ref socket_path) = world.proxy_socket_path {
                    let _ = std::fs::remove_file(socket_path);
                }
            }
            return true; // Signal to quit
        }
        Command::Setup => {
            // Open settings popup for global settings only
            app.open_setup_popup_new();
        }
        Command::Web => {
            // Open web settings popup
            app.open_web_popup_new();
        }
        Command::WorldSelector => {
            // /worlds (no args) - show world selector popup
            app.open_world_selector_new();
        }
        Command::WorldEdit { name } => {
            // /worlds -e or /worlds -e <name>
            let idx = if let Some(ref world_name) = name {
                // /worlds -e <name> - find or create the world, then edit
                app.find_or_create_world(world_name)
            } else {
                // /worlds -e - edit current world
                app.current_world_index
            };
            app.open_world_editor_popup_new(idx);
        }
        Command::WorldConnectNoLogin { name } => {
            // /worlds -l <name> - connect without auto-login
            if let Some(idx) = app.find_world(&name) {
                app.switch_world(idx);
                if !app.current_world().connected {
                    if app.current_world().settings.has_connection_settings() {
                        // Set flag to skip auto-login
                        app.current_world_mut().skip_auto_login = true;
                        return Box::pin(handle_command("/connect", app, event_tx)).await;
                    } else {
                        app.add_output(&format!("World '{}' has no connection settings.", name));
                    }
                }
            } else {
                app.add_output(&format!("World '{}' not found.", name));
            }
        }
        Command::WorldSwitch { name } => {
            // /worlds <name> - switch to world and connect if not already connected
            if let Some(idx) = app.find_world(&name) {
                // World exists - switch to it
                app.switch_world(idx);
                // Connect if not already connected and has settings
                if !app.current_world().connected
                    && app.current_world().settings.has_connection_settings()
                {
                    return Box::pin(handle_command("/connect", app, event_tx)).await;
                }
            } else {
                // World doesn't exist - show error message (goes through more-mode flow)
                app.add_output(&format!("World '{}' not found.", name));
            }
        }
        Command::WorldsList => {
            // Output connected worlds list as text
            let current_idx = app.current_world_index;
            let worlds_info: Vec<util::WorldListInfo> = app.worlds.iter().enumerate().map(|(idx, world)| {
                let now = std::time::Instant::now();
                util::WorldListInfo {
                    name: world.name.clone(),
                    connected: world.connected,
                    is_current: idx == current_idx,
                    is_ssl: world.is_tls,
                    is_proxy: world.proxy_pid.is_some(),
                    unseen_lines: world.unseen_lines,
                    last_send_secs: world.last_user_command_time.map(|t| now.duration_since(t).as_secs()),
                    last_recv_secs: world.last_receive_time.map(|t| now.duration_since(t).as_secs()),
                    last_nop_secs: world.last_nop_time.map(|t| now.duration_since(t).as_secs()),
                    next_nop_secs: None,
                    buffer_size: world.output_lines.len() + world.pending_lines.len(),
                }
            }).collect();
            let output = util::format_worlds_list(&worlds_info);
            app.add_output(&output);
        }
        Command::Keepalive => {
            // Show keepalive settings for all worlds
            let current_idx = app.current_world_index;
            let lines: Vec<String> = app.worlds.iter().enumerate().map(|(idx, world)| {
                let current = if idx == current_idx { "*" } else { " " };
                let connected = if world.connected { "x" } else { " " };
                let type_str = world.settings.keep_alive_type.name();
                let cmd_str = if world.settings.keep_alive_cmd.is_empty() {
                    "(none)".to_string()
                } else {
                    world.settings.keep_alive_cmd.clone()
                };
                let last_nop = match world.last_nop_time {
                    Some(t) => format!("{:.0}s ago", t.elapsed().as_secs_f64()),
                    None => "never".to_string(),
                };
                format!(
                    "{}{} {:15} type={:8} cmd={:30} last={}",
                    current, connected, world.name, type_str, cmd_str, last_nop
                )
            }).collect();

            app.add_output("");
            app.add_output("Keepalive Settings for All Worlds:");
            app.add_output("â”€".repeat(70).as_str());
            for line in lines {
                app.add_output(&line);
            }
            app.add_output("â”€".repeat(70).as_str());
            app.add_output("(*=current, x=connected)");
        }
        Command::Actions { world } => {
            if let Some(world_name) = world {
                app.open_actions_list_popup_with_filter(&world_name);
            } else {
                app.open_actions_list_popup();
            }
        }
        Command::Connect { host: arg_host, port: arg_port, ssl: arg_ssl } => {
            // Only master client can initiate connections
            if !app.is_master {
                app.add_output("Only the master client can initiate connections.");
                return false;
            }
            if app.current_world().connected {
                app.add_output("Already connected. Use /disconnect first.");
                return false;
            }

            // Route connection based on world type
            let world_type = app.current_world().settings.world_type.clone();
            match world_type {
                WorldType::Slack => {
                    return connect_slack(app, event_tx).await;
                }
                WorldType::Discord => {
                    return connect_discord(app, event_tx).await;
                }
                WorldType::Mud => {
                    // Continue with MUD connection below
                }
            }

            // MUD connection: Determine host/port/ssl: use args if provided, else use stored settings
            let world_settings = &app.current_world().settings;
            let (host, port, use_ssl) = if let (Some(h), Some(p)) = (arg_host, arg_port) {
                (h, p, arg_ssl)
            } else if !world_settings.hostname.is_empty() && !world_settings.port.is_empty() {
                (
                    world_settings.hostname.clone(),
                    world_settings.port.clone(),
                    world_settings.use_ssl,
                )
            } else {
                app.add_output("Configure host/port in world settings (/worlds)");
                return false;
            };

            // Check if using TLS proxy for connection preservation
            // TLS proxy not available on Android
            #[cfg(all(unix, not(target_os = "android")))]
            let use_tls_proxy = use_ssl && app.settings.tls_proxy_enabled;
            #[cfg(any(target_os = "android", not(unix)))]
            let use_tls_proxy = false;

            let ssl_msg = if use_ssl {
                if use_tls_proxy { " with SSL (via proxy)" } else { " with SSL" }
            } else { "" };
            app.add_output("");
            app.add_output(&format!("Connecting to {}:{}{}...", host, port, ssl_msg));
            app.add_output("");

            // Handle TLS proxy case separately (proxy does its own TCP connect)
            // TLS proxy only available on Unix (not Android or Windows)
            #[cfg(all(unix, not(target_os = "android")))]
            if use_tls_proxy {
                let world_name = app.current_world().name.clone();
                match spawn_tls_proxy(&world_name, &host, &port) {
                    Ok((proxy_pid, socket_path)) => {
                        // Connect to the proxy via Unix socket
                        match tokio::net::UnixStream::connect(&socket_path).await {
                            Ok(unix_stream) => {
                                // Store the Unix socket FD for hot reload preservation
                                #[cfg(unix)]
                                {
                                    use std::os::unix::io::AsRawFd;
                                    app.current_world_mut().proxy_socket_fd = Some(unix_stream.as_raw_fd());
                                }
                                app.current_world_mut().socket_fd = None;  // Can't preserve TLS fd directly
                                app.current_world_mut().is_tls = true;
                                app.current_world_mut().proxy_pid = Some(proxy_pid);
                                app.current_world_mut().proxy_socket_path = Some(socket_path);

                                let (r, w) = unix_stream.into_split();
                                let mut read_half = StreamReader::Proxy(r);
                                let mut write_half = StreamWriter::Proxy(w);

                                app.current_world_mut().connected = true;
                                app.current_world_mut().was_connected = true;
                                app.current_world_mut().prompt_count = 0;
                                let now = std::time::Instant::now();
                                app.current_world_mut().last_send_time = Some(now);
                                app.current_world_mut().last_receive_time = Some(now);
                                app.current_world_mut().is_initial_world = false;
                                app.discard_initial_world();

                                let world_name = app.current_world().name.clone();

                                // Open log file if enabled
                                if app.current_world().settings.log_enabled {
                                    if app.current_world_mut().open_log_file() {
                                        let log_path = app.current_world().get_log_path();
                                        app.add_output(&format!("Logging to: {}", log_path.display()));
                                    } else {
                                        app.add_output("Warning: Could not open log file");
                                    }
                                }

                                // Setup writer channel (before reader task so telnet_tx is available)
                                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);
                                app.current_world_mut().command_tx = Some(cmd_tx.clone());

                                // Fire TF CONNECT hook
                                let hook_result = tf::bridge::fire_event(&mut app.tf_engine, tf::TfHookEvent::Connect);
                                for cmd in hook_result.send_commands {
                                    let _ = cmd_tx.try_send(WriteCommand::Text(cmd));
                                }
                                for cmd in hook_result.clay_commands {
                                    let _ = app.tf_engine.execute(&cmd);
                                }

                                // Send auto-login if configured (for Connect type)
                                // Requires BOTH username AND password to be set
                                let skip_login = app.current_world().skip_auto_login;
                                app.current_world_mut().skip_auto_login = false;
                                let user = app.current_world().settings.user.clone();
                                let password = app.current_world().settings.password.clone();
                                let auto_connect_type = app.current_world().settings.auto_connect_type;
                                // DEBUG: trace auto-login conditions (proxy path)
                                debug_log(true, &format!("[proxy] Auto-login check: skip={}, user='{}', pass_len={}, type={}",
                                    skip_login, user, password.len(), auto_connect_type.name()));
                                if !skip_login && !user.is_empty() && !password.is_empty() && auto_connect_type == AutoConnectType::Connect {
                                    debug_log(true, "[proxy] Auto-login sending immediately");
                                    let connect_cmd = format!("connect {} {}", user, password);
                                    let _ = cmd_tx.send(WriteCommand::Text(connect_cmd)).await;
                                }

                                // Start reader task with telnet processing
                                app.current_world_mut().connection_id += 1;
                                let reader_conn_id = app.current_world().connection_id;
                                let event_tx_read = event_tx.clone();
                                let read_world_name = world_name.clone();
                                let telnet_tx = cmd_tx;
                                tokio::spawn(async move {
                                    let mut buf = [0u8; 4096];
                                    let mut line_buffer = Vec::new();
                                    loop {
                                        match tokio::io::AsyncReadExt::read(&mut read_half, &mut buf).await {
                                            Ok(0) => {
                                                // Send any remaining buffered data
                                                if !line_buffer.is_empty() {
                                                    let result = process_telnet(&line_buffer);
                                                    if !result.responses.is_empty() {
                                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                                    }
                                                    if result.telnet_detected {
                                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(read_world_name.clone())).await;
                                                    }
                                                    if result.gmcp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    if result.msdp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    for (pkg, json) in &result.gmcp_data {
                                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(read_world_name.clone(), pkg.clone(), json.clone())).await;
                                                    }
                                                    for (var, val) in &result.msdp_data {
                                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(read_world_name.clone(), var.clone(), val.clone())).await;
                                                    }
                                                    if let Some(prompt_bytes) = result.prompt {
                                                        let _ = event_tx_read.send(AppEvent::Prompt(read_world_name.clone(), prompt_bytes)).await;
                                                    }
                                                    if !result.cleaned.is_empty() {
                                                        let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), result.cleaned)).await;
                                                    }
                                                }
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone(), reader_conn_id)).await;
                                                break;
                                            }
                                            Ok(n) => {
                                                line_buffer.extend_from_slice(&buf[..n]);
                                                let split_at = find_safe_split_point(&line_buffer);
                                                let to_send = if split_at > 0 {
                                                    line_buffer.drain(..split_at).collect()
                                                } else if !line_buffer.is_empty() {
                                                    std::mem::take(&mut line_buffer)
                                                } else {
                                                    Vec::new()
                                                };
                                                if !to_send.is_empty() {
                                                    let result = process_telnet(&to_send);
                                                    if !result.responses.is_empty() {
                                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                                    }
                                                    if result.telnet_detected {
                                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(read_world_name.clone())).await;
                                                    }
                                                    if result.naws_requested {
                                                        let _ = event_tx_read.send(AppEvent::NawsRequested(read_world_name.clone())).await;
                                                    }
                                                    if result.ttype_requested {
                                                        let _ = event_tx_read.send(AppEvent::TtypeRequested(read_world_name.clone())).await;
                                                    }
                                                    if result.gmcp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    if result.msdp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    for (pkg, json) in &result.gmcp_data {
                                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(read_world_name.clone(), pkg.clone(), json.clone())).await;
                                                    }
                                                    for (var, val) in &result.msdp_data {
                                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(read_world_name.clone(), var.clone(), val.clone())).await;
                                                    }
                                                    if let Some(prompt_bytes) = result.prompt {
                                                        let _ = event_tx_read.send(AppEvent::Prompt(read_world_name.clone(), prompt_bytes)).await;
                                                    }
                                                    if !result.cleaned.is_empty() {
                                                        let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), result.cleaned)).await;
                                                    }
                                                }
                                            }
                                            Err(_) => {
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone(), reader_conn_id)).await;
                                                break;
                                            }
                                        }
                                    }
                                });

                                // Spawn writer task
                                tokio::spawn(async move {
                                    while let Some(cmd) = cmd_rx.recv().await {
                                        let bytes = match &cmd {
                                            WriteCommand::Text(text) => {
                                                let mut b = text.as_bytes().to_vec();
                                                b.extend_from_slice(b"\r\n");
                                                b
                                            }
                                            WriteCommand::Raw(raw) => raw.clone(),
                                            WriteCommand::Shutdown => break,
                                        };
                                        if tokio::io::AsyncWriteExt::write_all(&mut write_half, &bytes).await.is_err() {
                                            break;
                                        }
                                    }
                                });

                                // Connection established successfully via proxy, skip regular connection code
                                return false;
                            }
                            Err(e) => {
                                app.add_output(&format!("Failed to connect to TLS proxy: {}", e));
                                // Kill the proxy process
                                #[cfg(unix)]
                                unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                                return false;
                            }
                        }
                    }
                    Err(e) => {
                        app.add_output(&format!("Failed to spawn TLS proxy: {}", e));
                        app.add_output("Falling back to direct TLS connection...");
                        // Fall through to direct TLS connection below
                    }
                }
            }

            // Spawn connection in background to avoid blocking the UI
            app.current_world_mut().connection_id += 1;
            let reader_conn_id = app.current_world().connection_id;
            let world_name = app.current_world().name.clone();
            let connect_host = host.clone();
            let connect_port = port.clone();
            let connect_use_ssl = use_ssl;
            let event_tx_connect = event_tx.clone();

            tokio::spawn(async move {
                match TcpStream::connect(format!("{}:{}", connect_host, connect_port)).await {
                    Ok(tcp_stream) => {
                        // Store the socket fd for hot reload (before splitting, Unix only)
                        #[cfg(unix)]
                        let socket_fd = {
                            use std::os::unix::io::AsRawFd;
                            Some(tcp_stream.as_raw_fd())
                        };
                        #[cfg(not(unix))]
                        let socket_fd: Option<i32> = None;

                        // Enable TCP keepalive to detect dead connections faster
                        enable_tcp_keepalive(&tcp_stream);

                        // Handle SSL if needed
                        let connection_result: Result<(StreamReader, StreamWriter, bool), String> = if connect_use_ssl {
                            #[cfg(feature = "native-tls-backend")]
                            {
                                let connector = match native_tls::TlsConnector::builder()
                                    .danger_accept_invalid_certs(true)
                                    .build()
                                {
                                    Ok(c) => c,
                                    Err(e) => {
                                        let _ = event_tx_connect.send(AppEvent::ConnectionFailed(
                                            world_name.clone(),
                                            format!("TLS error: {}", e)
                                        )).await;
                                        return;
                                    }
                                };
                                let connector = tokio_native_tls::TlsConnector::from(connector);

                                match connector.connect(&connect_host, tcp_stream).await {
                                    Ok(tls_stream) => {
                                        let (r, w) = tokio::io::split(tls_stream);
                                        Ok((StreamReader::Tls(r), StreamWriter::Tls(w), true))
                                    }
                                    Err(e) => {
                                        Err(format!("SSL handshake failed: {}", e))
                                    }
                                }
                            }

                            #[cfg(feature = "rustls-backend")]
                            {
                                use rustls::RootCertStore;
                                use tokio_rustls::TlsConnector;
                                use rustls::pki_types::ServerName;

                                let mut root_store = RootCertStore::empty();
                                root_store.roots = webpki_roots::TLS_SERVER_ROOTS.iter().map(|ta| { rustls::pki_types::TrustAnchor { subject: ta.subject.into(), subject_public_key_info: ta.spki.into(), name_constraints: ta.name_constraints.map(|nc| nc.into()), } }).collect();

                                let config = rustls::ClientConfig::builder()
                                    .dangerous()
                                    .with_custom_certificate_verifier(Arc::new(danger::NoCertificateVerification::new()))
                                    .with_no_client_auth();

                                let connector = TlsConnector::from(Arc::new(config));
                                let server_name = match ServerName::try_from(connect_host.clone()) {
                                    Ok(sn) => sn,
                                    Err(e) => {
                                        let _ = event_tx_connect.send(AppEvent::ConnectionFailed(
                                            world_name.clone(),
                                            format!("Invalid server name: {}", e)
                                        )).await;
                                        return;
                                    }
                                };

                                match connector.connect(server_name, tcp_stream).await {
                                    Ok(tls_stream) => {
                                        let (r, w) = tokio::io::split(tls_stream);
                                        Ok((StreamReader::Tls(r), StreamWriter::Tls(w), true))
                                    }
                                    Err(e) => {
                                        Err(format!("SSL handshake failed: {}", e))
                                    }
                                }
                            }

                            #[cfg(not(any(feature = "native-tls-backend", feature = "rustls-backend")))]
                            {
                                Err("No TLS backend available".to_string())
                            }
                        } else {
                            let (r, w) = tcp_stream.into_split();
                            Ok((StreamReader::Plain(r), StreamWriter::Plain(w), false))
                        };

                        match connection_result {
                            Ok((mut read_half, mut write_half, is_tls)) => {
                                // Create command channel
                                let (cmd_tx, mut cmd_rx) = mpsc::channel::<WriteCommand>(100);

                                // Clone for reader task
                                let telnet_tx = cmd_tx.clone();
                                let event_tx_read = event_tx_connect.clone();
                                let read_world_name = world_name.clone();

                                // Spawn reader task
                                tokio::spawn(async move {
                                    let mut buffer = BytesMut::with_capacity(4096);
                                    buffer.resize(4096, 0);
                                    let mut line_buffer: Vec<u8> = Vec::new();

                                    loop {
                                        match read_half.read(&mut buffer).await {
                                            Ok(0) => {
                                                if !line_buffer.is_empty() {
                                                    let result = process_telnet(&line_buffer);
                                                    if !result.responses.is_empty() {
                                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                                    }
                                                    if result.telnet_detected {
                                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(read_world_name.clone())).await;
                                                    }
                                                    if result.gmcp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    if result.msdp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    for (pkg, json) in &result.gmcp_data {
                                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(read_world_name.clone(), pkg.clone(), json.clone())).await;
                                                    }
                                                    for (var, val) in &result.msdp_data {
                                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(read_world_name.clone(), var.clone(), val.clone())).await;
                                                    }
                                                    if let Some(prompt_bytes) = result.prompt {
                                                        let _ = event_tx_read.send(AppEvent::Prompt(read_world_name.clone(), prompt_bytes)).await;
                                                    }
                                                    if !result.cleaned.is_empty() {
                                                        let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), result.cleaned)).await;
                                                    }
                                                }
                                                let _ = event_tx_read
                                                    .send(AppEvent::ServerData(
                                                        read_world_name.clone(),
                                                        "Connection closed by server.\n".as_bytes().to_vec(),
                                                    ))
                                                    .await;
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone(), reader_conn_id)).await;
                                                break;
                                            }
                                            Ok(n) => {
                                                line_buffer.extend_from_slice(&buffer[..n]);
                                                let split_at = find_safe_split_point(&line_buffer);
                                                let to_send = if split_at > 0 {
                                                    line_buffer.drain(..split_at).collect()
                                                } else if !line_buffer.is_empty() {
                                                    std::mem::take(&mut line_buffer)
                                                } else {
                                                    Vec::new()
                                                };

                                                if !to_send.is_empty() {
                                                    let result = process_telnet(&to_send);
                                                    if !result.responses.is_empty() {
                                                        let _ = telnet_tx.send(WriteCommand::Raw(result.responses)).await;
                                                    }
                                                    if result.telnet_detected {
                                                        let _ = event_tx_read.send(AppEvent::TelnetDetected(read_world_name.clone())).await;
                                                    }
                                                    if result.naws_requested {
                                                        let _ = event_tx_read.send(AppEvent::NawsRequested(read_world_name.clone())).await;
                                                    }
                                                    if result.ttype_requested {
                                                        let _ = event_tx_read.send(AppEvent::TtypeRequested(read_world_name.clone())).await;
                                                    }
                                                    if result.wont_echo_seen {
                                                        let _ = event_tx_read.send(AppEvent::WontEchoSeen(read_world_name.clone())).await;
                                                    }
                                                    if result.gmcp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::GmcpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    if result.msdp_negotiated {
                                                        let _ = event_tx_read.send(AppEvent::MsdpNegotiated(read_world_name.clone())).await;
                                                    }
                                                    for (pkg, json) in &result.gmcp_data {
                                                        let _ = event_tx_read.send(AppEvent::GmcpReceived(read_world_name.clone(), pkg.clone(), json.clone())).await;
                                                    }
                                                    for (var, val) in &result.msdp_data {
                                                        let _ = event_tx_read.send(AppEvent::MsdpReceived(read_world_name.clone(), var.clone(), val.clone())).await;
                                                    }
                                                    if let Some(prompt_bytes) = result.prompt {
                                                        let _ = event_tx_read.send(AppEvent::Prompt(read_world_name.clone(), prompt_bytes)).await;
                                                    }
                                                    if !result.cleaned.is_empty() {
                                                        let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), result.cleaned)).await;
                                                    }
                                                }
                                            }
                                            Err(e) => {
                                                let msg = format!("Read error: {}", e);
                                                let _ = event_tx_read.send(AppEvent::ServerData(read_world_name.clone(), msg.into_bytes())).await;
                                                let _ = event_tx_read.send(AppEvent::Disconnected(read_world_name.clone(), reader_conn_id)).await;
                                                break;
                                            }
                                        }
                                    }
                                });

                                // Spawn writer task
                                tokio::spawn(async move {
                                    while let Some(cmd) = cmd_rx.recv().await {
                                        match cmd {
                                            WriteCommand::Text(text) => {
                                                let bytes = format!("{}\r\n", text).into_bytes();
                                                if write_half.write_all(&bytes).await.is_err() {
                                                    break;
                                                }
                                            }
                                            WriteCommand::Raw(raw) => {
                                                if write_half.write_all(&raw).await.is_err() {
                                                    break;
                                                }
                                            }
                                            WriteCommand::Shutdown => {
                                                let _ = write_half.shutdown().await;
                                                break;
                                            }
                                        }
                                    }
                                });

                                // Notify main loop of successful connection
                                // For TLS, socket_fd should be None (can't preserve across reload)
                                let final_socket_fd = if is_tls { None } else { socket_fd };
                                let _ = event_tx_connect.send(AppEvent::ConnectionSuccess(
                                    world_name,
                                    cmd_tx,
                                    final_socket_fd,
                                    is_tls
                                )).await;
                            }
                            Err(e) => {
                                let _ = event_tx_connect.send(AppEvent::ConnectionFailed(world_name, e)).await;
                            }
                        }
                    }
                    Err(e) => {
                        let _ = event_tx_connect.send(AppEvent::ConnectionFailed(
                            world_name,
                            format!("Connection failed: {}", e)
                        )).await;
                    }
                }
            });
        }
        Command::Disconnect => {
            if app.current_world().connected {
                // Kill proxy process if one exists
                #[cfg(unix)]
                if let Some(proxy_pid) = app.current_world().proxy_pid {
                    unsafe { libc::kill(proxy_pid as libc::pid_t, libc::SIGTERM); }
                }
                app.current_world_mut().clear_connection_state(true, true);
                app.add_output("Disconnected.");
            } else {
                app.add_output("Not connected.");
            }
        }
        Command::Flush => {
            let line_count = app.current_world().output_lines.len();
            app.current_world_mut().output_lines.clear();
            app.current_world_mut().pending_lines.clear();
            app.current_world_mut().scroll_offset = 0;
            app.current_world_mut().lines_since_pause = 0;
            app.current_world_mut().paused = false;
            // Broadcast flush to WebSocket clients
            let world_index = app.current_world_index;
            app.ws_broadcast(WsMessage::WorldFlushed { world_index });
            app.add_output(&format!("Flushed {} lines from output buffer.", line_count));
        }
        Command::Send { text, all_worlds, target_world, no_newline } => {
            // Send the text
            let send_to_world = |world: &mut World, text: &str, no_newline: bool| -> bool {
                if !world.connected {
                    return false;
                }
                if let Some(tx) = &world.command_tx {
                    let result = if no_newline {
                        tx.try_send(WriteCommand::Raw(text.as_bytes().to_vec()))
                    } else {
                        tx.try_send(WriteCommand::Text(text.to_string()))
                    };
                    if result.is_ok() {
                        world.last_send_time = Some(std::time::Instant::now());
                        return true;
                    }
                }
                false
            };

            if all_worlds {
                // Send to all connected worlds
                let mut sent_count = 0;
                for world in &mut app.worlds {
                    if send_to_world(world, &text, no_newline) {
                        sent_count += 1;
                    }
                }
                if sent_count == 0 {
                    app.add_output("No connected worlds to send to.");
                }
            } else if let Some(world_name) = target_world {
                // Send to specific world
                if let Some(idx) = app.find_world(&world_name) {
                    if !send_to_world(&mut app.worlds[idx], &text, no_newline) {
                        app.add_output(&format!("World '{}' is not connected.", world_name));
                    }
                } else {
                    app.add_output(&format!("World '{}' not found.", world_name));
                }
            } else {
                // Send to current world
                let world = app.current_world_mut();
                if !world.connected {
                    app.add_output("Not connected. Use /worlds to connect.");
                } else if let Some(tx) = &world.command_tx {
                    let result = if no_newline {
                        tx.try_send(WriteCommand::Raw(text.as_bytes().to_vec()))
                    } else {
                        tx.try_send(WriteCommand::Text(text.to_string()))
                    };
                    if result.is_ok() {
                        world.last_send_time = Some(std::time::Instant::now());
                    } else {
                        app.add_output("Failed to send command.");
                    }
                }
            }
        }
        Command::Reload => {
            // Hot reload is not available on Android/Termux or Windows
            #[cfg(any(target_os = "android", not(unix)))]
            {
                app.add_output("Hot reload is not available on this platform.");
                app.add_output("Restart the app manually to apply changes.");
            }

            #[cfg(all(unix, not(target_os = "android")))]
            {
                // First check if we can find the executable (handling " (deleted)" suffix)
                let exe_path = match get_executable_path() {
                    Ok((p, _)) => p,
                    Err(e) => {
                        app.add_output(&format!("Cannot find executable: {}", e));
                        return false;
                    }
                };

                if !exe_path.exists() {
                    app.add_output(&format!("Executable not found: {}", exe_path.display()));
                    app.add_output("Hot reload requires the binary to exist on disk.");
                    app.add_output("If running via 'cargo run', try running the compiled binary directly.");
                    return false;
                }

                // Check if there are any TLS connections that will be lost (only those without proxy)
                let tls_worlds: Vec<_> = app
                    .worlds
                    .iter()
                    .filter(|w| w.connected && w.is_tls && w.proxy_pid.is_none())
                    .map(|w| w.name.clone())
                    .collect();

                if !tls_worlds.is_empty() {
                    app.add_output(&format!(
                        "Warning: TLS connections will be closed: {}",
                        tls_worlds.join(", ")
                    ));
                    app.add_output("These connections will need to be re-established after reload.");
                }

                // Binary path is only shown on failure (see error handler below)

                // Notify connected web/GUI clients to reconnect after reload
                app.ws_broadcast(WsMessage::ServerReloading);

                // Disable raw mode before exec (the new process will re-enable it)
                let _ = crossterm::terminal::disable_raw_mode();
                let _ = crossterm::execute!(
                    std::io::stdout(),
                    crossterm::terminal::LeaveAlternateScreen
                );

                match exec_reload(app) {
                    Ok(()) => {
                        // This should never be reached - exec replaces the process
                        unreachable!();
                    }
                    Err(e) => {
                        // Restore terminal state if exec failed
                        let _ = crossterm::terminal::enable_raw_mode();
                        let _ = crossterm::execute!(
                            std::io::stdout(),
                            crossterm::terminal::EnterAlternateScreen,
                            crossterm::terminal::Clear(crossterm::terminal::ClearType::All),
                            crossterm::cursor::MoveTo(0, 0)
                        );
                        app.add_output(&format!("Hot reload failed: {}", e));
                        app.add_output(&format!("Executable path: {}", exe_path.display()));
                    }
                }
            }
        }
        Command::Gag { pattern } => {
            // TODO: Implement gag patterns
            app.add_output(&format!("Gag pattern set: {}", pattern));
        }
        Command::BanList => {
            // Show current banned hosts
            let bans = app.ban_list.get_ban_info();
            if bans.is_empty() {
                app.add_output("No hosts are currently banned.");
            } else {
                app.add_output("");
                app.add_output("Banned Hosts:");
                app.add_output("â”€".repeat(70).as_str());
                app.add_output(&format!("{:<20} {:<12} {}", "Host", "Type", "Last URL/Reason"));
                app.add_output("â”€".repeat(70).as_str());
                for (ip, ban_type, reason) in bans {
                    let reason_display = if reason.is_empty() { "(unknown)" } else { &reason };
                    app.add_output(&format!("{:<20} {:<12} {}", ip, ban_type, reason_display));
                }
                app.add_output("â”€".repeat(70).as_str());
                app.add_output("Use /unban <host> to remove a ban.");
            }
            // Broadcast to remote clients
            app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
        }
        Command::Unban { host } => {
            if app.ban_list.remove_ban(&host) {
                app.add_output(&format!("Removed ban for: {}", host));
                // Save settings to persist the change
                if app.multiuser_mode {
                    if let Err(e) = persistence::save_multiuser_settings(app) {
                        app.add_output(&format!("Warning: Failed to save settings: {}", e));
                    }
                } else if let Err(e) = persistence::save_settings(app) {
                    app.add_output(&format!("Warning: Failed to save settings: {}", e));
                }
                // Broadcast updated ban list to remote clients
                app.ws_broadcast(WsMessage::BanListResponse { bans: app.ban_list.get_ban_info() });
                app.ws_broadcast(WsMessage::UnbanResult { success: true, host: host.clone(), error: None });
            } else {
                app.add_output(&format!("No ban found for: {}", host));
                app.ws_broadcast(WsMessage::UnbanResult { success: false, host: host.clone(), error: Some("No ban found".to_string()) });
            }
        }
        Command::TestMusic => {
            // Broadcast a test ANSI music sequence (C-D-E-F-G melody)
            let test_notes = vec![
                ansi_music::MusicNote { frequency: 261.63, duration_ms: 250 }, // C4
                ansi_music::MusicNote { frequency: 293.66, duration_ms: 250 }, // D4
                ansi_music::MusicNote { frequency: 329.63, duration_ms: 250 }, // E4
                ansi_music::MusicNote { frequency: 349.23, duration_ms: 250 }, // F4
                ansi_music::MusicNote { frequency: 392.00, duration_ms: 250 }, // G4
            ];
            app.ws_broadcast(WsMessage::AnsiMusic {
                world_index: app.current_world_index,
                notes: test_notes,
            });
            app.add_output("Playing test music (C-D-E-F-G)...");
        }
        Command::Notify { message } => {
            // Send notification to mobile clients
            let title = app.current_world().name.clone();
            app.ws_broadcast(WsMessage::Notification {
                title,
                message: message.clone(),
            });
            app.add_output(&format!("Notification sent: {}", message));
        }
        Command::Dict { prefix, word } => {
            // Look up word definition from Free Dictionary API
            match lookup_definition(&word).await {
                Ok(definition) => {
                    // Transliterate to ASCII for non-UTF-8 MUD compatibility
                    let ascii_def = transliterate_to_ascii(&definition);
                    // Format: prefix word: definition, capped at 1024 bytes, single line
                    let full_text = format!("{} {}: {}", prefix, word, ascii_def);
                    let capped = if full_text.len() > 1024 {
                        let mut end = 1024;
                        // Don't cut in the middle of a UTF-8 character
                        while end > 0 && !full_text.is_char_boundary(end) {
                            end -= 1;
                        }
                        full_text[..end].to_string()
                    } else {
                        full_text
                    };
                    // Put result in input buffer for user to review/send
                    app.input.buffer = capped;
                    app.input.cursor_position = app.input.buffer.len();
                }
                Err(e) => {
                    app.add_output(&format!("Definition lookup failed: {}", e));
                }
            }
        }
        Command::Urban { prefix, word } => {
            // Look up word definition from Urban Dictionary API
            match lookup_urban_definition(&word).await {
                Ok(definition) => {
                    // Transliterate to ASCII for non-UTF-8 MUD compatibility
                    let ascii_def = transliterate_to_ascii(&definition);
                    // Format: prefix Urban Dict: word: definition, capped at 1024 bytes, single line
                    let full_text = format!("{} Urban Dict: {}: {}", prefix, word, ascii_def);
                    let capped = if full_text.len() > 1024 {
                        let mut end = 1024;
                        // Don't cut in the middle of a UTF-8 character
                        while end > 0 && !full_text.is_char_boundary(end) {
                            end -= 1;
                        }
                        full_text[..end].to_string()
                    } else {
                        full_text
                    };
                    // Put result in input buffer for user to review/send
                    app.input.buffer = capped;
                    app.input.cursor_position = app.input.buffer.len();
                }
                Err(e) => {
                    app.add_output(&format!("Urban Dictionary lookup failed: {}", e));
                }
            }
        }
        Command::DictUsage => {
            app.add_output("Usage: /dict <prefix> <word>");
            app.add_output("  Looks up <word> in the dictionary and sends '<prefix> <word>: <definition>' to the MUD.");
            app.add_output("  Example: /dict say hello");
        }
        Command::UrbanUsage => {
            app.add_output("Usage: /urban <prefix> <word>");
            app.add_output("  Looks up <word> in Urban Dictionary and sends '<prefix> Urban Dict: <word>: <definition>' to the MUD.");
            app.add_output("  Example: /urban say yeet");
        }
        Command::Translate { lang, prefix, text } => {
            // Translate text using MyMemory API
            match lookup_translation(&text, &lang).await {
                Ok(translation) => {
                    // Transliterate to ASCII for non-UTF-8 MUD compatibility
                    let ascii_trans = transliterate_to_ascii(&translation);
                    // Format: prefix translated_text, capped at 1024 bytes, single line
                    let full_text = format!("{} {}", prefix, ascii_trans);
                    let capped = if full_text.len() > 1024 {
                        let mut end = 1024;
                        // Don't cut in the middle of a UTF-8 character
                        while end > 0 && !full_text.is_char_boundary(end) {
                            end -= 1;
                        }
                        full_text[..end].to_string()
                    } else {
                        full_text
                    };
                    // Put result in input buffer for user to review/send
                    app.input.buffer = capped;
                    app.input.cursor_position = app.input.buffer.len();
                }
                Err(e) => {
                    app.add_output(&format!("Translation failed: {}", e));
                }
            }
        }
        Command::TranslateUsage => {
            app.add_output("Usage: /translate <lang> <prefix> <text>");
            app.add_output("  Translates <text> to <lang> and puts '<prefix> <translated text>' in input.");
            app.add_output("  <lang> can be a code (es, fr, de) or name (spanish, french, german).");
            app.add_output("  Example: /translate spanish say Hello, how are you?");
            app.add_output("  Example: /tr es say Hello");
        }
        Command::Dump => {
            // Dump all scrollback buffers to ~/.clay.dmp.log
            use std::io::Write;

            let home = get_home_dir();
            let dump_path = format!("{}/{}", home, clay_filename("clay.dmp.log"));

            match std::fs::File::create(&dump_path) {
                Ok(mut file) => {
                    let mut total_lines = 0;

                    // Cycle through all worlds
                    for world in app.worlds.iter() {
                        // Write output_lines
                        for line in &world.output_lines {
                            // Format timestamp as YYYY-MM-DD HH:MM:SS
                            let ts = line.timestamp
                                .duration_since(std::time::UNIX_EPOCH)
                                .map(|d| d.as_secs())
                                .unwrap_or(0) as i64;
                            let lt = local_time_from_epoch(ts);
                            let datetime = format!(
                                "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                lt.year, lt.month, lt.day,
                                lt.hour, lt.minute, lt.second
                            );

                            // Write: world_name,datetime,line_text
                            let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                            total_lines += 1;
                        }

                        // Also write pending_lines if any
                        for line in &world.pending_lines {
                            let ts = line.timestamp
                                .duration_since(std::time::UNIX_EPOCH)
                                .map(|d| d.as_secs())
                                .unwrap_or(0) as i64;
                            let lt = local_time_from_epoch(ts);
                            let datetime = format!(
                                "{:04}-{:02}-{:02} {:02}:{:02}:{:02}",
                                lt.year, lt.month, lt.day,
                                lt.hour, lt.minute, lt.second
                            );

                            let _ = writeln!(file, "{},{},{}", world.name, datetime, line.text);
                            total_lines += 1;
                        }
                    }

                    app.add_output(&format!("Dumped {} lines from {} worlds to {}", total_lines, app.worlds.len(), dump_path));
                }
                Err(e) => {
                    app.add_output(&format!("Failed to create dump file: {}", e));
                }
            }
        }
        Command::AddWorld { name, host, port, user, password, use_ssl } => {
            // Check if world already exists (case-insensitive)
            let existing_idx = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(&name));

            let world_idx = if let Some(idx) = existing_idx {
                // Update existing world
                idx
            } else {
                // Create new world - validate name
                if name.is_empty() {
                    app.add_output("Error: World name cannot be empty");
                    return false;
                }
                if name.contains(' ') {
                    app.add_output("Error: World name cannot contain spaces");
                    return false;
                }
                if name.starts_with('(') {
                    app.add_output("Error: World name cannot start with '('");
                    return false;
                }

                // Create new world
                let new_world = World::new(&name);
                app.worlds.push(new_world);
                app.worlds.len() - 1
            };

            // Update world settings
            if let Some(h) = host {
                app.worlds[world_idx].settings.hostname = h;
            }
            if let Some(p) = port {
                app.worlds[world_idx].settings.port = p;
            }
            if let Some(u) = user {
                app.worlds[world_idx].settings.user = u;
            }
            if let Some(p) = password {
                app.worlds[world_idx].settings.password = p;
            }
            app.worlds[world_idx].settings.use_ssl = use_ssl;

            // Save settings to persist the new/updated world
            if let Err(e) = persistence::save_settings(app) {
                app.add_output(&format!("Warning: Failed to save settings: {}", e));
            }

            // Confirm the operation
            let action = if existing_idx.is_some() { "Updated" } else { "Added" };
            let host_info = if !app.worlds[world_idx].settings.hostname.is_empty() {
                format!(" ({}:{}{})",
                    app.worlds[world_idx].settings.hostname,
                    app.worlds[world_idx].settings.port,
                    if use_ssl { " SSL" } else { "" })
            } else {
                " (connectionless)".to_string()
            };
            app.add_output(&format!("{} world '{}'{}.", action, name, host_info));
        }
        Command::Edit { filename } => {
            // Open split-screen editor
            if app.editor.visible {
                app.add_output("Editor is already open. Close it first.");
            } else if let Some(ref path_str) = filename {
                // Edit a file
                let path = PathBuf::from(path_str);
                let content = if path.exists() {
                    match std::fs::read_to_string(&path) {
                        Ok(c) => c,
                        Err(e) => {
                            app.add_output(&format!("Failed to read file: {}", e));
                            return false;
                        }
                    }
                } else {
                    // New file - start with empty content
                    String::new()
                };
                app.editor.open_file(path, &content);
                app.needs_terminal_clear = true;
            } else {
                // Edit current world's notes
                let world_idx = app.current_world_index;
                let notes = app.worlds[world_idx].settings.notes.clone();
                app.editor.open_notes(world_idx, &notes);
                app.needs_terminal_clear = true;
            }
        }
        Command::Tag => {
            // Toggle MUD tag display (same as F2) - silent, no output
            app.show_tags = !app.show_tags;
            app.needs_output_redraw = true;
            // Broadcast to WebSocket clients
            app.ws_broadcast(WsMessage::ShowTagsChanged { show_tags: app.show_tags });
        }
        Command::ActionCommand { name, args } => {
            // Check if this is an action command (/name)
            let action_found = app.settings.actions.iter()
                .find(|a| a.name.eq_ignore_ascii_case(&name))
                .cloned();

            if let Some(action) = action_found {
                // Skip disabled actions
                if !action.enabled {
                    app.add_output(&format!("Action '{}' is disabled.", name));
                } else {
                // Execute the action's commands - process each individually
                let commands = split_action_commands(&action.command);
                let mut sent_to_server = false;
                for cmd_str in commands {
                    // Substitute $1-$9 and $* with arguments
                    let cmd_str = substitute_action_args(&cmd_str, &args);

                    // Skip /gag commands when invoked manually
                    if cmd_str.eq_ignore_ascii_case("/gag") || cmd_str.to_lowercase().starts_with("/gag ") {
                        continue;
                    }

                    // Unified command system - route through TF parser
                    if cmd_str.starts_with('/') {
                        app.sync_tf_world_info();
                        match app.tf_engine.execute(&cmd_str) {
                            tf::TfCommandResult::Success(Some(msg)) => {
                                app.add_tf_output(&msg);
                            }
                            tf::TfCommandResult::Success(None) => {}
                            tf::TfCommandResult::Error(err) => {
                                app.add_tf_output(&format!("âœ¨ {}", err));
                            }
                            tf::TfCommandResult::SendToMud(text) => {
                                if let Some(tx) = &app.current_world().command_tx {
                                    let _ = tx.try_send(WriteCommand::Text(text));
                                    sent_to_server = true;
                                } else {
                                    app.add_output("Not connected. Use /worlds to connect.");
                                }
                            }
                            tf::TfCommandResult::ClayCommand(clay_cmd) => {
                                Box::pin(handle_command(&clay_cmd, app, event_tx.clone())).await;
                            }
                            tf::TfCommandResult::Recall(opts) => {
                                let output_lines = app.current_world().output_lines.clone();
                                let (matches, header) = execute_recall(&opts, &output_lines);
                                let pattern_str = opts.pattern.as_deref().unwrap_or("*");

                                if !opts.quiet {
                                    if let Some(h) = header {
                                        app.add_output(&h);
                                    }
                                }
                                if matches.is_empty() {
                                    app.add_output(&format!("No matches for '{}'", pattern_str));
                                } else {
                                    for m in matches {
                                        app.add_output(&m);
                                    }
                                }
                                if !opts.quiet {
                                    app.add_output("================= Recall end =================");
                                }
                            }
                            _ => {}
                        }
                    } else {
                        // Plain text - send to server if connected
                        if let Some(tx) = &app.current_world().command_tx {
                            let _ = tx.try_send(WriteCommand::Text(cmd_str.clone()));
                            sent_to_server = true;
                        } else {
                            app.add_output(&format!("Not connected. Cannot send: {}", cmd_str));
                        }
                    }
                }
                if sent_to_server {
                    app.current_world_mut().last_send_time = Some(std::time::Instant::now());
                }
                }
            } else {
                // No matching action - try TF engine (handles /recall, /set, /echo, etc.)
                app.sync_tf_world_info();
                match app.tf_engine.execute(cmd) {
                    tf::TfCommandResult::Success(Some(msg)) => {
                        app.add_tf_output(&msg);
                    }
                    tf::TfCommandResult::Success(None) => {}
                    tf::TfCommandResult::Error(err) => {
                        app.add_tf_output(&format!("Error: {}", err));
                    }
                    tf::TfCommandResult::SendToMud(text) => {
                        if let Some(tx) = &app.current_world().command_tx {
                            let _ = tx.try_send(WriteCommand::Text(text));
                            app.current_world_mut().last_send_time = Some(std::time::Instant::now());
                        }
                    }
                    tf::TfCommandResult::ClayCommand(_) => {
                        // Avoid recursion - just show unknown
                        app.add_output(&format!("Unknown command: /{}", name));
                    }
                    tf::TfCommandResult::Recall(opts) => {
                        let output_lines = app.current_world().output_lines.clone();
                        let (matches, header) = execute_recall(&opts, &output_lines);
                        let pattern_str = opts.pattern.as_deref().unwrap_or("*");
                        if !opts.quiet {
                            if let Some(h) = header {
                                app.add_output(&h);
                            }
                        }
                        if matches.is_empty() {
                            app.add_output(&format!("No matches for '{}'", pattern_str));
                        } else {
                            for m in &matches {
                                app.add_output(m);
                            }
                        }
                        if !opts.quiet {
                            app.add_output("================= Recall end =================");
                        }
                    }
                    tf::TfCommandResult::RepeatProcess(process) => {
                        app.tf_engine.processes.push(process);
                    }
                    _ => {
                        app.add_output(&format!("Unknown command: /{}", name));
                    }
                }
            }
        }
        Command::NotACommand { text } => {
            // Not a command - send to MUD as regular input
            if let Some(tx) = &app.current_world().command_tx {
                let _ = tx.try_send(WriteCommand::Text(text));
                app.current_world_mut().last_send_time = Some(std::time::Instant::now());
            }
        }
        Command::Unknown { cmd } => {
            app.add_output(&format!("Unknown command: {}", cmd));
        }
    }
    false
}

/// Process any pending world operations queued by TF functions like addworld()
fn process_pending_world_ops(app: &mut App) {
    // Drain pending operations
    let ops: Vec<tf::PendingWorldOp> = app.tf_engine.pending_world_ops.drain(..).collect();

    for op in ops {
        // Check if world already exists (case-insensitive)
        let existing_idx = app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(&op.name));

        let world_idx = if let Some(idx) = existing_idx {
            idx
        } else {
            // Create new world
            let new_world = World::new(&op.name);
            app.worlds.push(new_world);
            app.worlds.len() - 1
        };

        // Update world settings
        if let Some(h) = op.host {
            app.worlds[world_idx].settings.hostname = h;
        }
        if let Some(p) = op.port {
            app.worlds[world_idx].settings.port = p;
        }
        if let Some(u) = op.user {
            app.worlds[world_idx].settings.user = u;
        }
        if let Some(p) = op.password {
            app.worlds[world_idx].settings.password = p;
        }
        app.worlds[world_idx].settings.use_ssl = op.use_ssl;

        // Save settings to persist the new/updated world
        let _ = persistence::save_settings(app);

        // addworld() function should be silent on success (only errors are reported)
    }
}

/// Process any pending commands queued by TF macro execution
fn process_pending_tf_commands(app: &mut App) {
    // Drain pending commands
    let cmds: Vec<tf::TfCommand> = app.tf_engine.pending_commands.drain(..).collect();

    for cmd in cmds {
        // Determine target world
        let world_idx = if let Some(ref world_name) = cmd.world {
            // Find world by name
            app.worlds.iter().position(|w| w.name.eq_ignore_ascii_case(world_name))
                .unwrap_or(app.current_world_index)
        } else {
            app.current_world_index
        };

        // Send command to the world
        if world_idx < app.worlds.len() && app.worlds[world_idx].connected {
            if let Some(tx) = &app.worlds[world_idx].command_tx {
                let _ = tx.try_send(WriteCommand::Text(cmd.command.clone()));
                app.worlds[world_idx].last_send_time = Some(std::time::Instant::now());
            }
        }
    }
}

// Break characters for word wrapping within long words
const BREAK_CHARS: &[char] = &['[', ']', '(', ')', ',', '\\', '/', '-', '&', '=', '?', '.', ';'];

// Wrap a line with ANSI codes by visible width, preferring to break at word boundaries
// Similar to CSS white-space: pre-wrap; word-wrap: break-word
// Optimized to track byte positions instead of cloning the full string at every break point
// (still clones the small active_codes vector, but that's typically 0-5 elements)
fn wrap_ansi_line(line: &str, max_width: usize) -> Vec<String> {
    if max_width == 0 {
        return vec![line.to_string()];
    }

    let mut result = Vec::new();
    let mut current_line = String::new();
    let mut current_width = 0;
    let mut in_csi = false;      // CSI sequence: \x1b[...
    let mut in_osc = false;      // OSC sequence: \x1b]...
    let mut escape_seq = String::new();
    let mut active_codes: Vec<String> = Vec::new();
    let mut active_hyperlink: Option<String> = None;  // Track active OSC 8 hyperlink URL

    // Track last word boundary (space) for wrapping - byte position instead of string clone
    let mut last_space_byte_pos: usize = 0;
    let mut last_space_width = 0;
    let mut last_space_codes: Vec<String> = Vec::new();  // small vec, ok to clone
    let mut last_space_hyperlink: Option<String> = None;
    let mut has_space_on_line = false;

    // Track break opportunities within long words (for BREAK_CHARS)
    let mut last_break_byte_pos: usize = 0;
    let mut last_break_width = 0;
    let mut last_break_codes: Vec<String> = Vec::new();
    let mut last_break_hyperlink: Option<String> = None;

    // Helper to build line prefix (color codes + hyperlink)
    // Using BEL (0x07) as OSC terminator for better terminal compatibility
    let build_prefix = |codes: &[String], hyperlink: &Option<String>| -> String {
        let mut prefix = codes.join("");
        if let Some(url) = hyperlink {
            prefix.push_str("\x1b]8;;");
            prefix.push_str(url);
            prefix.push('\x07');
        }
        prefix
    };

    // Helper to build line suffix (close hyperlink + reset colors)
    let build_suffix = |hyperlink: &Option<String>| -> String {
        let mut suffix = String::new();
        if hyperlink.is_some() {
            suffix.push_str("\x1b]8;;\x07");
        }
        suffix.push_str("\x1b[0m");
        suffix
    };

    let chars: Vec<char> = line.chars().collect();
    let mut i = 0;

    while i < chars.len() {
        let c = chars[i];

        // Handle CSI/OSC continuations first, before checking for new ESC
        if in_csi {
            escape_seq.push(c);
            // CSI ends with alphabetic char or ~
            if c.is_alphabetic() || c == '~' {
                in_csi = false;
                current_line.push_str(&escape_seq);
                if c == 'm' {
                    if escape_seq == "\x1b[0m" || escape_seq == "\x1b[m" {
                        active_codes.clear();
                    } else {
                        active_codes.push(escape_seq.clone());
                    }
                }
                escape_seq.clear();
            }
            i += 1;
            continue;
        } else if in_osc {
            // OSC ends with BEL (\x07) or ST (\x1b\\)
            if c == '\x07' {
                escape_seq.push(c);
                in_osc = false;
                // Check if this is an OSC 8 hyperlink
                if escape_seq.starts_with("\x1b]8;;") {
                    let url = &escape_seq[5..escape_seq.len()-1];
                    if url.is_empty() {
                        active_hyperlink = None;
                    } else {
                        active_hyperlink = Some(url.to_string());
                    }
                }
                current_line.push_str(&escape_seq);
                escape_seq.clear();
                i += 1;
                continue;
            } else if c == '\x1b' && i + 1 < chars.len() && chars[i + 1] == '\\' {
                // ST terminator
                escape_seq.push(c);
                escape_seq.push('\\');
                in_osc = false;
                // Check if this is an OSC 8 hyperlink
                if escape_seq.starts_with("\x1b]8;;") {
                    let url = &escape_seq[5..escape_seq.len()-2];
                    if url.is_empty() {
                        active_hyperlink = None;
                    } else {
                        active_hyperlink = Some(url.to_string());
                    }
                }
                current_line.push_str(&escape_seq);
                escape_seq.clear();
                i += 2;
                continue;
            } else {
                escape_seq.push(c);
                i += 1;
                continue;
            }
        } else if c == '\x1b' {
            escape_seq.push(c);
            // Check next char to determine sequence type
            if i + 1 < chars.len() {
                let next = chars[i + 1];
                if next == '[' {
                    in_csi = true;
                    escape_seq.push(next);
                    i += 2;
                    continue;
                } else if next == ']' {
                    in_osc = true;
                    escape_seq.push(next);
                    i += 2;
                    continue;
                } else if next == '\\' {
                    // ST (String Terminator) - standalone, pass through
                    escape_seq.push(next);
                    current_line.push_str(&escape_seq);
                    escape_seq.clear();
                    i += 2;
                    continue;
                }
            }
            // Lone ESC or unknown sequence
            current_line.push(c);
            escape_seq.clear();
            i += 1;
            continue;
        } else {
            let char_width = unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);

            // Check if we need to wrap before adding this character
            if current_width + char_width > max_width && current_width > 0 {
                // Prefer break char over space when it's further along (packs more on line)
                if last_break_width > last_space_width {
                    // Break at period/hyphen/etc within the current word
                    let mut break_line = current_line[..last_break_byte_pos].to_string();
                    break_line.push_str(&build_suffix(&last_break_hyperlink));
                    result.push(break_line);

                    let prefix = build_prefix(&last_break_codes, &last_break_hyperlink);
                    let remainder = &current_line[last_break_byte_pos..];
                    current_line = prefix + remainder;
                    current_width -= last_break_width;
                } else if has_space_on_line && last_space_width > 0 {
                    // Break at word boundary - emit up to and including the space
                    let mut break_line = current_line[..last_space_byte_pos].to_string();
                    break_line.push_str(&build_suffix(&last_space_hyperlink));
                    result.push(break_line);

                    // Start new line with content after the space
                    let prefix = build_prefix(&last_space_codes, &last_space_hyperlink);
                    let remainder = &current_line[last_space_byte_pos..];
                    current_line = prefix + remainder;
                    current_width -= last_space_width;
                } else {
                    // No break point at all - hard wrap at current position
                    current_line.push_str(&build_suffix(&active_hyperlink));
                    result.push(current_line);
                    current_line = build_prefix(&active_codes, &active_hyperlink);
                    current_width = 0;
                }

                // Reset tracking for new line
                has_space_on_line = false;
                last_space_byte_pos = 0;
                last_space_width = 0;
                last_space_codes.clear();
                last_space_hyperlink = None;
                last_break_byte_pos = 0;
                last_break_width = 0;
                last_break_codes.clear();
                last_break_hyperlink = None;
            }

            // Add the character
            current_line.push(c);
            current_width += char_width;

            // Track break opportunities - save byte position (not string clone)
            if c.is_whitespace() {
                // Save position AFTER the space as a word boundary
                last_space_byte_pos = current_line.len();
                last_space_width = current_width;
                last_space_codes = active_codes.clone();  // small vec
                last_space_hyperlink = active_hyperlink.clone();
                has_space_on_line = true;
                // Reset break char tracking since we have a new word
                last_break_byte_pos = 0;
                last_break_width = 0;
            } else if BREAK_CHARS.contains(&c) {
                // Save as potential break point within a word (after this char)
                last_break_byte_pos = current_line.len();
                last_break_width = current_width;
                last_break_codes = active_codes.clone();
                last_break_hyperlink = active_hyperlink.clone();
            }

            i += 1;
        }
    }

    if !current_line.is_empty() || result.is_empty() {
        // Add suffix to close any active hyperlink and reset colors
        current_line.push_str(&build_suffix(&active_hyperlink));
        result.push(current_line);
    }

    result
}

fn ui(f: &mut Frame, app: &mut App) {
    let total_height = f.size().height.max(3);  // Minimum 3 lines for output + separator + input

    // Layout: output area, separator bar (1 line), input area
    let separator_height = 1;
    let input_total_height = app.input_height;
    let output_height = total_height.saturating_sub(separator_height + input_total_height);

    // Store output dimensions for scrolling and more-mode calculations
    // Use max(1) to prevent any division by zero elsewhere
    let new_output_height = output_height.max(1);
    let new_output_width = f.size().width.max(1);
    // Mark output for redraw if dimensions changed (terminal resize)
    let dimensions_changed = new_output_height != app.output_height || new_output_width != app.output_width;
    if dimensions_changed {
        app.needs_output_redraw = true;
    }
    app.output_height = new_output_height;
    app.output_width = new_output_width;
    // Send NAWS updates if terminal was resized
    if dimensions_changed {
        app.send_naws_to_all_worlds();
    }

    let chunks = Layout::default()
        .direction(Direction::Vertical)
        .constraints([
            Constraint::Length(output_height),
            Constraint::Length(separator_height),
            Constraint::Length(input_total_height),
        ])
        .split(f.size());

    let output_area = chunks[0];
    let separator_area = chunks[1];
    let input_area = chunks[2];

    // Update input dimensions and prompt length for viewport calculation
    app.input.set_dimensions(input_area.width, app.input_height);
    app.input.prompt_len = strip_ansi_codes(&app.current_world().prompt).chars().count();

    // Check if editor is visible - split the output area if so
    if app.editor.visible {
        // Split output area horizontally into editor and world output
        let half_width = output_area.width / 2;
        let (editor_area, world_area) = match app.settings.editor_side {
            EditorSide::Left => {
                let editor = Rect {
                    x: output_area.x,
                    y: output_area.y,
                    width: half_width,
                    height: output_area.height,
                };
                let world = Rect {
                    x: output_area.x + half_width,
                    y: output_area.y,
                    width: output_area.width - half_width,
                    height: output_area.height,
                };
                (editor, world)
            }
            EditorSide::Right => {
                let world = Rect {
                    x: output_area.x,
                    y: output_area.y,
                    width: half_width,
                    height: output_area.height,
                };
                let editor = Rect {
                    x: output_area.x + half_width,
                    y: output_area.y,
                    width: output_area.width - half_width,
                    height: output_area.height,
                };
                (editor, world)
            }
        };

        // Render editor panel
        render_editor_panel(f, app, editor_area);

        // Render world output on the other half
        render_output_area(f, app, world_area);
    } else {
        // Normal full-width output area
        render_output_area(f, app, output_area);
    }

    // Render separator bar
    render_separator_bar(f, app, separator_area);

    // Render input area
    render_input_area(f, app, input_area);

    // Render popups if visible (confirm dialog last so it's on top)
    render_confirm_dialog(f, app);
    render_filter_popup(f, app);
    // New unified popup system - renders on top of old popups
    render_new_popup(f, app);
}

/// Render output area using raw crossterm (bypasses ratatui's buggy rendering)
/// Returns early if splash screen or popup is visible (let ratatui handle those)
fn render_output_crossterm(app: &App) {
    use std::io::Write;
    use crossterm::{style::Print, QueueableCommand};

    // Skip if showing splash screen, any popup is visible, or editor is visible
    // When editor is visible, ratatui handles all rendering for the split-screen layout
    let any_popup_visible = app.confirm_dialog.visible
        || app.has_new_popup();
    if app.current_world().showing_splash || any_popup_visible || app.editor.visible {
        return;
    }

    let mut stdout = std::io::stdout();

    let world = app.current_world();
    let visible_height = (app.output_height as usize).max(1);
    let term_width = (app.output_width as usize).max(1);

    // Calculate visible width of a string (excluding ANSI escape sequences including OSC 8)
    fn visible_width(s: &str) -> usize {
        let mut width = 0;
        let mut in_csi = false;   // CSI sequence: \x1b[...
        let mut in_osc = false;   // OSC sequence: \x1b]...
        let chars: Vec<char> = s.chars().collect();
        let mut i = 0;
        while i < chars.len() {
            let c = chars[i];
            // Handle CSI/OSC continuations first, before checking for new ESC
            if in_csi {
                if c.is_alphabetic() || c == '~' {
                    in_csi = false;
                }
                i += 1;
                continue;
            } else if in_osc {
                // OSC ends with BEL or ST (\x1b\\)
                if c == '\x07' {
                    in_osc = false;
                    i += 1;
                    continue;
                } else if c == '\x1b' && i + 1 < chars.len() && chars[i + 1] == '\\' {
                    in_osc = false;
                    i += 2;
                    continue;
                }
                i += 1;
                continue;
            } else if c == '\x1b' {
                // Start of new escape sequence
                if i + 1 < chars.len() {
                    let next = chars[i + 1];
                    if next == '[' {
                        in_csi = true;
                        i += 2;
                        continue;
                    } else if next == ']' {
                        in_osc = true;
                        i += 2;
                        continue;
                    } else if next == '\\' {
                        // ST terminator (standalone)
                        i += 2;
                        continue;
                    }
                }
                i += 1;
                continue;
            } else {
                width += unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);
                i += 1;
            }
        }
        width
    }

    // Collect wrapped lines centered around scroll_offset to fill the screen
    // Each entry is (line_text, should_highlight_f8, highlight_color_from_action)
    let mut visual_lines: Vec<(String, bool, Option<String>)> = Vec::new();
    let mut first_line_idx: usize = 0;

    let show_tags = app.show_tags;
    let temp_convert_enabled = app.settings.temp_convert_enabled;
    let highlight_actions = app.highlight_actions;
    let world_name = &world.name;
    // Pre-compile action patterns once (not per-line)
    let compiled_patterns = if highlight_actions {
        compile_action_patterns(world_name, &app.settings.actions)
    } else {
        Vec::new()
    };

    // Cache "now" for timestamp formatting - compute once per frame, not per line
    let cached_now = CachedNow::new();

    let expand_and_wrap = |line: &OutputLine, term_width: usize, show_tags: bool, highlight_f8: bool, cached_now: &CachedNow| -> Vec<(String, bool, Option<String>)> {
        // Skip gagged lines unless show_tags (F2) is enabled
        if line.gagged && !show_tags {
            return Vec::new();
        }
        // Skip lines that are only ANSI codes (cursor control garbage)
        if is_ansi_only_line(&line.text) {
            return Vec::new();
        }
        // For legitimate blank lines (empty or whitespace-only without background colors), render as blank line
        // Lines with background colors (like ANSI art) should preserve their ANSI codes
        if is_visually_empty(&line.text) && !has_background_color(&line.text) {
            return vec![("".to_string(), false, None)];
        }
        // Colorize square emoji (ðŸŸ©ðŸŸ¨ etc.) with ANSI codes
        // Note: Discord emoji conversion happens later, after URL wrapping
        let text = colorize_square_emojis(&line.text);
        // Add âœ¨ prefix for client-generated messages
        let text = if !line.from_server {
            format!("âœ¨ {}", text)
        } else {
            text
        };
        let processed = if show_tags {
            // Show timestamp + original text when tags are shown
            // Convert temperatures only if both show_tags AND temp_convert are enabled
            let text_with_temps = if temp_convert_enabled {
                convert_temperatures(&text)
            } else {
                text.clone()
            };
            format!("\x1b[36m{}\x1b[0m {}", line.format_timestamp_with_now(cached_now), text_with_temps)
        } else {
            strip_mud_tag(&text)
        };
        let expanded = processed.replace('\t', "        ");
        // Wrap URLs with OSC 8 hyperlink sequences for terminal clickability
        let with_links = wrap_urls_with_osc8(&expanded);
        // Convert Discord custom emojis to clickable :name: links (after URL wrapping to avoid conflicts)
        // Skip conversion when show_tags is enabled so users can see original text
        let with_emoji_links = if show_tags {
            with_links
        } else {
            convert_discord_emojis_with_links(&with_links)
        };
        let hl_color = line.highlight_color.clone();
        wrap_ansi_line(&with_emoji_links, term_width)
            .into_iter()
            .map(|s| (s, highlight_f8, hl_color.clone()))
            .collect()
    };

    // Helper to check if a line should be highlighted
    let should_highlight = |line: &OutputLine| -> bool {
        highlight_actions && line_matches_compiled_patterns(&line.text, &compiled_patterns)
    };

    // Check if filter popup is active with a non-empty filter
    // If filter is active but no matches, show nothing (don't fall through to normal rendering)
    if app.filter_popup.visible && !app.filter_popup.filter_text.is_empty() {
        // If no matches, visual_lines stays empty - that's correct behavior
        if !app.filter_popup.filtered_indices.is_empty() {
            // Use filtered indices
            let filtered = &app.filter_popup.filtered_indices;
            let end_pos = app.filter_popup.scroll_offset.min(filtered.len().saturating_sub(1));

            // Work backwards from scroll_offset to fill the screen
            for pos in (0..=end_pos).rev() {
                let line_idx = filtered[pos];
                if line_idx < world.output_lines.len() {
                    let line = &world.output_lines[line_idx];
                    let highlight = should_highlight(line);
                    let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                    for w in wrapped.into_iter().rev() {
                        visual_lines.insert(0, w);
                    }

                    if visual_lines.len() >= visible_height {
                        break;
                    }
                }
            }

            // If we still have room, show lines after scroll_offset
            if visual_lines.len() < visible_height {
                for &line_idx in filtered.iter().skip(end_pos + 1) {
                    if line_idx < world.output_lines.len() {
                        let line = &world.output_lines[line_idx];
                        let highlight = should_highlight(line);
                        let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                        for w in wrapped {
                            visual_lines.push(w);
                        }

                        if visual_lines.len() >= visible_height {
                            break;
                        }
                    }
                }
            }
        }
    } else if !world.output_lines.is_empty() {
        // Normal unfiltered rendering
        let end_line = world.scroll_offset.min(world.output_lines.len().saturating_sub(1));

        first_line_idx = end_line;
        for line_idx in (0..=end_line).rev() {
            first_line_idx = line_idx;
            let line = &world.output_lines[line_idx];
            let highlight = should_highlight(line);
            let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

            for w in wrapped.into_iter().rev() {
                visual_lines.insert(0, w);
            }

            if visual_lines.len() >= visible_height {
                break;
            }
        }

        if visual_lines.len() < visible_height && first_line_idx == 0 {
            for line_idx in (end_line + 1)..world.output_lines.len() {
                let line = &world.output_lines[line_idx];
                let highlight = should_highlight(line);
                let wrapped = expand_and_wrap(line, term_width, show_tags, highlight, &cached_now);

                for w in wrapped {
                    visual_lines.push(w);
                }

                if visual_lines.len() >= visible_height {
                    break;
                }
            }
        }
    }

    // Debug: verify output line sequence order (only check visible range, log mismatches)
    if !world.output_lines.is_empty() {
        let check_start = first_line_idx;
        let check_end = world.scroll_offset.min(world.output_lines.len().saturating_sub(1));
        let mut last_seq: Option<u64> = None;
        for idx in check_start..=check_end {
            let line = &world.output_lines[idx];
            if line.gagged && !show_tags {
                continue; // Skip gagged lines when not showing tags
            }
            if let Some(prev_seq) = last_seq {
                if line.seq <= prev_seq {
                    if let Some(ref tx) = app.ws_client_tx {
                        // Remote console: report to master via WebSocket
                        let _ = tx.send(WsMessage::ReportSeqMismatch {
                            world_index: app.current_world_index,
                            expected_seq_gt: prev_seq,
                            actual_seq: line.seq,
                            line_text: line.text.chars().take(80).collect::<String>(),
                            source: "console".to_string(),
                        });
                    } else {
                        // Local console: write to debug file
                        if let Ok(mut f) = std::fs::OpenOptions::new()
                            .create(true).append(true)
                            .open("clay.output.debug")
                        {
                            let _ = writeln!(f, "SEQ MISMATCH in '{}': idx={}, expected seq>{}, got seq={}, text={:?}",
                                world.name, idx, prev_seq, line.seq,
                                line.text.chars().take(80).collect::<String>());
                        }
                    }
                }
            }
            last_seq = Some(line.seq);
        }
    }

    let lines_to_show: &[(String, bool, Option<String>)] = if first_line_idx == 0 && visual_lines.len() <= visible_height {
        &visual_lines[..visual_lines.len().min(visible_height)]
    } else {
        let display_start = visual_lines.len().saturating_sub(visible_height);
        &visual_lines[display_start..]
    };

    for (row_idx, (wrapped, highlight_f8, hl_color)) in lines_to_show.iter().enumerate() {
        let _ = stdout.queue(cursor::MoveTo(0, row_idx as u16));

        // Determine background color: /highlight color takes priority, then F8 highlight
        let bg_code = if let Some(color) = hl_color {
            Some(color_name_to_ansi_bg(color))
        } else if *highlight_f8 {
            // Dark yellow/brown background for F8 action-matched lines
            Some("\x1b[48;5;58m".to_string())
        } else {
            None
        };

        if let Some(ref bg) = bg_code {
            let _ = stdout.queue(Print(bg));
            // Replace \x1b[0m with \x1b[0m<bg_code> to preserve background
            let highlighted = wrapped.replace("\x1b[0m", &format!("\x1b[0m{}", bg));
            let _ = stdout.queue(Print(&highlighted));
        } else {
            let _ = stdout.queue(Print(wrapped));
        }

        let line_visible_width = visible_width(wrapped);
        if line_visible_width < term_width {
            let padding = " ".repeat(term_width - line_visible_width);
            let _ = stdout.queue(Print(padding));
        }

        let _ = stdout.queue(Print("\x1b[0m"));
    }

    for row_idx in lines_to_show.len()..visible_height {
        let _ = stdout.queue(cursor::MoveTo(0, row_idx as u16));
        let spaces = " ".repeat(term_width);
        let _ = stdout.queue(Print(spaces));
    }

    // Render filter popup if visible (must be after output so it's on top)
    if app.filter_popup.visible {
        let popup_width = 40usize.min(term_width);
        let x = term_width.saturating_sub(popup_width) as u16;
        let title = " Find [Esc to close] ";
        let dashes_needed = popup_width.saturating_sub(title.len() + 2); // +2 for corners

        // Draw border top
        let _ = stdout.queue(cursor::MoveTo(x, 0));
        let border_top = format!("\x1b[36mâ”Œ{}{}{}\x1b[0m", title, "â”€".repeat(dashes_needed), "â”");
        let _ = stdout.queue(Print(border_top));

        // Draw content line
        let _ = stdout.queue(cursor::MoveTo(x, 1));
        let mut display_text = app.filter_popup.filter_text.clone();
        display_text.insert(app.filter_popup.cursor, 'â–');
        let label = "Filter: ";
        let content_width = label.len() + display_text.chars().count();
        let inner_width = popup_width.saturating_sub(2); // -2 for side borders
        let padding = inner_width.saturating_sub(content_width);
        let _ = stdout.queue(Print(format!("\x1b[36mâ”‚\x1b[0m{}{}{}\x1b[36mâ”‚\x1b[0m", label, display_text, " ".repeat(padding))));

        // Draw border bottom
        let _ = stdout.queue(cursor::MoveTo(x, 2));
        let border_bottom = format!("\x1b[36mâ””{}â”˜\x1b[0m", "â”€".repeat(popup_width.saturating_sub(2)));
        let _ = stdout.queue(Print(border_bottom));
    }

    // Calculate and set cursor position in input area
    // This replicates the logic from render_input_area to avoid Save/Restore timing issues
    let prompt = &app.current_world().prompt;
    let prompt_len = strip_ansi_codes(prompt).chars().count();
    let cursor_line = app.input.cursor_line();
    let viewport_line = cursor_line.saturating_sub(app.input.viewport_start_line);

    // Input area starts after output + separator bar (1 line)
    let input_area_y = app.output_height + 1;
    let input_area_width = term_width.max(1);

    if viewport_line < app.input_height as usize {
        // Use display width for cursor positioning (handles zero-width chars)
        let width_before_cursor = display_width(&app.input.buffer[..app.input.cursor_position]);

        // Calculate cursor column - must match cursor_line() logic exactly
        let first_line_capacity = input_area_width.saturating_sub(prompt_len);
        let cursor_col = if first_line_capacity == 0 {
            // Prompt fills entire line
            width_before_cursor % input_area_width
        } else if width_before_cursor < first_line_capacity {
            // On first line - add prompt offset if viewport shows it
            if app.input.viewport_start_line == 0 {
                width_before_cursor + prompt_len
            } else {
                width_before_cursor
            }
        } else {
            // Past first line - get remainder within the line
            (width_before_cursor - first_line_capacity) % input_area_width
        };

        let cursor_x = cursor_col as u16;
        // Calculate visual line within viewport
        let cursor_y = input_area_y + viewport_line as u16;
        let max_y = input_area_y + app.input_height - 1;
        let _ = stdout.queue(cursor::MoveTo(cursor_x, cursor_y.min(max_y)));
    }

    let _ = stdout.flush();
}

fn render_output_area(f: &mut Frame, app: &App, area: Rect) {
    let world = app.current_world();
    let visible_height = area.height as usize;
    let area_width = area.width as usize;

    // Clear the output area first
    f.render_widget(ratatui::widgets::Clear, area);

    // Check if showing splash screen - ratatui handles splash rendering
    if world.showing_splash {
        let output_text = render_splash_centered(world, visible_height, area_width);
        let output_paragraph = Paragraph::new(output_text);
        f.render_widget(output_paragraph, area);
        return;
    }

    // Check if any popup is visible or editor is visible - ratatui handles output in these cases
    let any_popup_visible = app.confirm_dialog.visible
        || app.filter_popup.visible
        || app.has_new_popup();

    // If no popup is visible and editor is not visible, raw crossterm will handle output rendering
    // (it provides better ANSI color handling)
    // Just clear the area and return - crossterm will fill it in
    if !any_popup_visible && !app.editor.visible {
        return;
    }

    // Popup or editor is visible - render output with ratatui (crossterm is skipped in these cases)
    // First, fill the entire output area with background to cover any crossterm remnants
    let theme = app.settings.theme;
    let background = ratatui::widgets::Block::default().style(Style::default().bg(theme.bg()));
    f.render_widget(background, area);

    // Get lines to display
    let end = world.scroll_offset.saturating_add(1).min(world.output_lines.len());
    let start = end.saturating_sub(visible_height);

    // Build Text with proper ANSI color parsing
    let mut lines: Vec<Line<'_>> = Vec::with_capacity(end - start);

    for line in world.output_lines.iter().skip(start).take(end - start) {
        // Skip lines that are only ANSI codes (cursor control garbage)
        if is_ansi_only_line(&line.text) {
            continue;
        }
        // For legitimate blank lines (empty or whitespace without background colors), render as blank line
        // Lines with background colors (like ANSI art) should preserve their ANSI codes
        if is_visually_empty(&line.text) && !has_background_color(&line.text) {
            lines.push(Line::from(""));
            continue;
        }

        // Strip MUD tags if show_tags is disabled, add timestamp if enabled
        // Also colorize square emoji (ðŸŸ©ðŸŸ¨ etc.) with ANSI codes
        let display_line = if app.show_tags {
            // Show timestamp + original text when tags are shown
            colorize_square_emojis(&format!("\x1b[36m{}\x1b[0m {}", line.format_timestamp(), line.text))
        } else {
            colorize_square_emojis(&strip_mud_tag(&line.text))
        };

        // Parse ANSI codes and convert to ratatui spans
        match ansi_to_tui::IntoText::into_text(&display_line) {
            Ok(text) => {
                for l in text.lines {
                    lines.push(l);
                }
            }
            Err(_) => {
                lines.push(Line::raw(display_line));
            }
        }
    }

    let output_text = Text::from(lines);
    let output_paragraph = Paragraph::new(output_text).style(Style::default().bg(theme.bg()));
    f.render_widget(output_paragraph, area);
}

/// Render the split-screen editor panel
fn render_editor_panel(f: &mut Frame, app: &App, area: Rect) {
    let theme = app.settings.theme;

    // Get editor title with world name if editing notes
    let world_name = app.editor.world_index.map(|idx| app.worlds[idx].name.as_str());
    let title = app.editor.title(world_name);

    // Add focus indicator to title
    let title_with_focus = if app.editor.focus == EditorFocus::Editor {
        format!("[Ctrl+Space] {}", title)
    } else {
        format!(" {} ", title)
    };

    // Create bordered block - highlight border when focused
    let border_style = if app.editor.focus == EditorFocus::Editor {
        Style::default().fg(theme.fg_highlight())
    } else {
        Style::default().fg(theme.fg_dim())
    };

    let block = Block::default()
        .borders(Borders::ALL)
        .border_style(border_style)
        .title(title_with_focus)
        .style(Style::default().bg(theme.bg()));

    // Calculate inner area (accounting for border and button row)
    let inner = block.inner(area);
    let button_height = 1;
    let content_height = inner.height.saturating_sub(button_height);
    let content_width = inner.width as usize;

    // Split inner area into content and button row
    let content_area = Rect {
        x: inner.x,
        y: inner.y,
        width: inner.width,
        height: content_height,
    };
    let button_area = Rect {
        x: inner.x,
        y: inner.y + content_height,
        width: inner.width,
        height: button_height,
    };

    // Clear the entire area first to prevent any bleed-through
    f.render_widget(ratatui::widgets::Clear, area);

    // Fill the entire area with background color
    let background = Block::default().style(Style::default().bg(theme.bg()));
    f.render_widget(background, area);

    // Render the border on top
    f.render_widget(block, area);

    // Get logical lines from buffer
    let logical_lines: Vec<&str> = app.editor.lines();
    let visible_lines = content_height as usize;
    let scroll_offset = app.editor.scroll_offset;

    // Wrap lines by character (letter wrapping) and track cursor position
    // Each visual line is (text, Option<cursor_col>) where cursor_col is Some if cursor is on this visual line
    let mut visual_lines: Vec<(String, Option<usize>)> = Vec::new();

    let cursor_line = app.editor.cursor_line;
    let cursor_col = app.editor.cursor_col;
    let show_cursor = app.editor.focus == EditorFocus::Editor;

    for (line_idx, line) in logical_lines.iter().enumerate() {
        let is_cursor_line = line_idx == cursor_line;
        let chars: Vec<char> = line.chars().collect();

        if chars.is_empty() {
            // Empty line - just add it, with cursor if applicable
            if is_cursor_line && show_cursor {
                visual_lines.push((String::new(), Some(0)));
            } else {
                visual_lines.push((String::new(), None));
            }
        } else if content_width == 0 {
            // Edge case: no width
            visual_lines.push((String::new(), None));
        } else {
            // Wrap the line by characters
            let mut pos = 0;
            while pos < chars.len() {
                let end = (pos + content_width).min(chars.len());
                let segment: String = chars[pos..end].iter().collect();

                // Check if cursor is in this segment
                let cursor_in_segment = if is_cursor_line && show_cursor {
                    if cursor_col >= pos && cursor_col <= end {
                        Some(cursor_col - pos)
                    } else {
                        None
                    }
                } else {
                    None
                };

                visual_lines.push((segment, cursor_in_segment));
                pos = end;
            }

            // If cursor is at end of line and line length is exact multiple of width,
            // we need an extra visual line for the cursor
            if is_cursor_line && show_cursor && cursor_col == chars.len() && chars.len() % content_width == 0 && !chars.is_empty() {
                visual_lines.push((String::new(), Some(0)));
            }
        }
    }

    // Build display lines from scroll_offset
    let mut display_lines: Vec<Line<'_>> = Vec::with_capacity(visible_lines);

    for (text, cursor_pos) in visual_lines.iter().skip(scroll_offset).take(visible_lines) {
        if let Some(col) = cursor_pos {
            // This visual line has the cursor
            let chars: Vec<char> = text.chars().collect();
            let col = (*col).min(chars.len());
            let before: String = chars[..col].iter().collect();
            let after: String = chars[col..].iter().collect();

            let spans = vec![
                Span::raw(before),
                Span::styled("â”‚", Style::default().fg(theme.fg_highlight())),
                Span::raw(after),
            ];
            display_lines.push(Line::from(spans));
        } else {
            display_lines.push(Line::raw(text.clone()));
        }
    }

    // Fill remaining lines if content is shorter than visible area
    while display_lines.len() < visible_lines {
        display_lines.push(Line::raw("~"));
    }

    let content = Text::from(display_lines);
    let content_paragraph = Paragraph::new(content)
        .style(Style::default().bg(theme.bg()).fg(theme.fg()));
    f.render_widget(content_paragraph, content_area);

    // Render button row with proper background
    let save_style = Style::default().fg(theme.fg_success());
    let cancel_style = Style::default().fg(theme.fg_error());
    let button_text = Line::from(vec![
        Span::raw(" "),
        Span::styled("[S]", save_style),
        Span::raw("ave "),
        Span::styled("[C]", cancel_style),
        Span::raw("ancel"),
    ]);
    let button_paragraph = Paragraph::new(button_text)
        .style(Style::default().bg(theme.bg()).fg(theme.fg()));
    f.render_widget(button_paragraph, button_area);
}

fn render_splash_centered<'a>(world: &World, visible_height: usize, area_width: usize) -> Text<'a> {
    let mut lines: Vec<Line<'static>> = Vec::new();

    // Calculate visible width of a string (excluding ANSI escape sequences)
    fn visible_width(s: &str) -> usize {
        let mut width = 0;
        let mut in_escape = false;
        for c in s.chars() {
            if c == '\x1b' {
                in_escape = true;
            } else if in_escape {
                if c == 'm' {
                    in_escape = false;
                }
            } else {
                width += unicode_width::UnicodeWidthChar::width(c).unwrap_or(0);
            }
        }
        width
    }

    // Calculate vertical centering - how many blank lines to add at top
    let content_height = world.output_lines.len();
    let vertical_padding = if visible_height > content_height {
        (visible_height - content_height) / 2
    } else {
        0
    };

    // Add vertical padding
    for _ in 0..vertical_padding {
        lines.push(Line::from(""));
    }

    // Center all lines while splash is showing
    for line in &world.output_lines {
        let line_width = visible_width(&line.text);
        let padding = if area_width > line_width {
            (area_width - line_width) / 2
        } else {
            0
        };

        // Create padded line
        let padded = if padding > 0 {
            format!("{:width$}{}", "", line.text, width = padding)
        } else {
            line.text.clone()
        };

        // Parse ANSI codes and convert to ratatui spans
        match ansi_to_tui::IntoText::into_text(&padded) {
            Ok(text) => {
                for l in text.lines {
                    lines.push(l);
                }
            }
            Err(_) => {
                lines.push(Line::raw(padded));
            }
        }
    }

    Text::from(lines)
}

fn format_more_count(count: usize) -> String {
    // Returns exactly 4 characters to make "More XXXX" or "Hist XXXX" = 9 chars total (right-justified)
    if count <= 9999 {
        format!("{:>4}", count)
    } else if count < 1_000_000 {
        // 10K, 99K, 100K, 999K etc.
        format!("{:>3}K", (count / 1000).min(999))
    } else {
        "Alot".to_string()
    }
}

fn render_separator_bar(f: &mut Frame, app: &App, area: Rect) {
    let width = area.width as usize;
    let world = app.current_world();
    let theme = app.settings.theme;

    // Build bar components
    let time_str = get_current_time_12hr();

    // Status indicator - always reserve space for "More XXXX" or "Hist XXXX" (9 chars)
    // Priority: Hist (when scrolled back) > More (when paused) > underscores
    const STATUS_INDICATOR_LEN: usize = 9;
    let (status_str, status_active) = if !world.is_at_bottom() {
        // Show History indicator when scrolled back (takes precedence over More)
        let lines_back = world.lines_from_bottom();
        (format!("Hist {}", format_more_count(lines_back)), true)
    } else if world.paused && (!world.pending_lines.is_empty() || world.pending_count > 0) {
        // Show More indicator when paused with pending lines
        // Use pending_count for console mode (synced from daemon), pending_lines.len() for daemon mode
        let count = if !world.pending_lines.is_empty() { world.pending_lines.len() } else { world.pending_count };
        (format!("More {}", format_more_count(count)), true)
    } else {
        // Fill with underscores when nothing to show
        ("_".repeat(STATUS_INDICATOR_LEN), false)
    };

    // World name
    let world_display = world.name.clone();

    // Tag indicator (only shown when F2 toggled to show tags)
    let tag_indicator = if app.show_tags { " [tag]" } else { "" };

    // GMCP indicator (only shown when F9 toggled to enable GMCP processing)
    let gmcp_indicator = if world.gmcp_user_enabled { " [g]" } else { "" };

    // Activity indicator - positioned at column 24
    const ACTIVITY_POSITION: usize = 24;
    // In remote client mode, use the server's activity count
    let activity_count = if app.is_master {
        app.activity_count()
    } else {
        app.server_activity_count
    };

    // Determine activity string based on available space
    // Full format: "(Activity: X)", Short format: "(Act X)"
    let activity_str = if activity_count > 0 {
        let full_format = format!("(Activity: {})", activity_count);
        let short_format = format!("(Act {})", activity_count);
        // Use short format if screen is narrow (less than 60 chars)
        if width < 60 {
            short_format
        } else {
            full_format
        }
    } else {
        String::new()
    };

    // Time on the right (no space before it, underscores fill to it)
    let time_display = time_str.clone();

    // Create styled spans
    let mut spans = Vec::new();

    // Status indicator on the left (black on red if active, dim underscores if not)
    spans.push(Span::styled(
        status_str.clone(),
        if status_active {
            Style::default().fg(theme.button_selected_fg()).bg(theme.fg_error())
        } else {
            Style::default().fg(theme.fg_dim())
        },
    ));

    // Only show connection ball, world name, and tag indicator if world has ever connected
    // Use world.was_connected flag (set to true on first connection)
    let is_connected = world.connected;
    let was_connected = world.was_connected;

    let current_pos = if was_connected {
        // Connection status ball (green when connected, red when disconnected)
        spans.push(Span::styled(
            "â— ",
            Style::default().fg(if is_connected { theme.fg_success() } else { theme.fg_error() }),
        ));

        // World name
        spans.push(Span::styled(
            world_display.clone(),
            Style::default().fg(theme.fg()),
        ));

        // Tag indicator (cyan, like prompt)
        if !tag_indicator.is_empty() {
            spans.push(Span::styled(
                tag_indicator.to_string(),
                Style::default().fg(theme.fg_accent()),
            ));
        }

        // GMCP indicator (cyan, like prompt)
        if !gmcp_indicator.is_empty() {
            spans.push(Span::styled(
                gmcp_indicator.to_string(),
                Style::default().fg(theme.fg_accent()),
            ));
        }

        // Calculate position: status + ball (2 chars) + world name + tag indicator + gmcp indicator
        status_str.len() + 2 + world_display.len() + tag_indicator.len() + gmcp_indicator.len()
    } else {
        // World never connected - don't show ball or name
        status_str.len()
    };

    // Add underscores to reach position 24 (or as close as possible)
    if !activity_str.is_empty() && current_pos < ACTIVITY_POSITION {
        let padding = ACTIVITY_POSITION - current_pos;
        spans.push(Span::styled(
            "_".repeat(padding),
            Style::default().fg(theme.fg_dim()),
        ));
    }

    // Activity indicator (highlight color)
    if !activity_str.is_empty() {
        spans.push(Span::styled(
            activity_str.clone(),
            Style::default()
                .fg(theme.fg_highlight())
                .add_modifier(Modifier::BOLD),
        ));
    }

    // Calculate underscore padding - fill between content and time
    let used_len = if activity_str.is_empty() {
        current_pos
    } else {
        ACTIVITY_POSITION.max(current_pos) + activity_str.len()
    };
    // Subtract 2 for the fixed underscores before time
    let underscore_count = width.saturating_sub(used_len + time_display.len() + 2);

    spans.push(Span::styled(
        "_".repeat(underscore_count),
        Style::default().fg(theme.fg_dim()),
    ));

    // Underscore separator before time (2 chars for extra spacing)
    spans.push(Span::styled("__", Style::default().fg(theme.fg_dim())));

    // Time on the right (no spaces around it)
    spans.push(Span::styled(time_display, Style::default().fg(theme.fg())));

    let line = Line::from(spans);
    let paragraph = Paragraph::new(line).style(Style::default().bg(theme.bg()));

    f.render_widget(paragraph, area);
}

fn render_input_area(f: &mut Frame, app: &mut App, area: Rect) {
    // Get prompt for current world only (clone to avoid borrow conflict)
    let prompt = app.current_world().prompt.clone();
    // Use visible length (without ANSI codes) for cursor positioning
    let prompt_len = strip_ansi_codes(&prompt).chars().count();

    let input_text = render_input(app, area.width as usize, &prompt);

    let input_paragraph = Paragraph::new(input_text);
    f.render_widget(input_paragraph, area);

    // Set cursor position (offset by prompt length on first line)
    let cursor_line = app.input.cursor_line();
    let viewport_line = cursor_line.saturating_sub(app.input.viewport_start_line);

    if viewport_line < app.input_height as usize {
        let inner_width = area.width.max(1) as usize;
        // Use display width for cursor positioning (handles zero-width chars)
        let width_before_cursor = display_width(&app.input.buffer[..app.input.cursor_position]);

        // Calculate cursor column - must match cursor_line() logic exactly
        let first_line_capacity = inner_width.saturating_sub(prompt_len);
        let cursor_col = if first_line_capacity == 0 {
            // Prompt fills entire line
            width_before_cursor % inner_width
        } else if width_before_cursor < first_line_capacity {
            // On first line - add prompt offset if viewport shows it
            if app.input.viewport_start_line == 0 {
                width_before_cursor + prompt_len
            } else {
                width_before_cursor
            }
        } else {
            // Past first line - get remainder within the line
            (width_before_cursor - first_line_capacity) % inner_width
        };

        let cursor_x = area.x + cursor_col as u16;
        // Calculate visual line within viewport
        let cursor_y = area.y + viewport_line as u16;
        f.set_cursor(cursor_x, cursor_y.min(area.y + area.height - 1));
    }
}

fn render_input(app: &mut App, width: usize, prompt: &str) -> Text<'static> {
    let tc = app.settings.theme;
    let misspelled = app.find_misspelled_words();
    let chars: Vec<char> = app.input.buffer.chars().collect();

    // Calculate visible prompt length (without ANSI codes)
    let prompt_visible_len = strip_ansi_codes(prompt).chars().count();

    if width == 0 {
        return Text::default();
    }

    let mut lines: Vec<Line<'static>> = Vec::new();

    // If we're at the start, render the prompt first
    if app.input.viewport_start_line == 0 && !prompt.is_empty() {
        // Check if prompt has ANSI codes
        let has_ansi = prompt.contains("\x1b[");

        if has_ansi {
            // Parse ANSI codes and render with proper styling
            match ansi_to_tui::IntoText::into_text(&prompt) {
                Ok(text) => {
                    // Collect all spans from all lines into a single line
                    let mut all_spans: Vec<Span<'static>> = Vec::new();
                    for line in text.lines {
                        for span in line.spans {
                            all_spans.push(span);
                        }
                    }
                    if !all_spans.is_empty() {
                        lines.push(Line::from(all_spans));
                    }
                }
                Err(_) => {
                    // Fallback to accent color if parsing fails
                    lines.push(Line::from(Span::styled(
                        prompt.to_string(),
                        Style::default().fg(tc.fg_accent()),
                    )));
                }
            }
        } else {
            // No ANSI codes, use accent color
            lines.push(Line::from(Span::styled(
                prompt.to_string(),
                Style::default().fg(tc.fg_accent()),
            )));
        }
    }

    // Build a combined first line if prompt doesn't fill the width
    if app.input.viewport_start_line == 0 && !prompt.is_empty() && !lines.is_empty() {
        let prompt_line_chars = prompt_visible_len % width;
        let remaining_width = if prompt_line_chars == 0 && prompt_visible_len > 0 {
            0
        } else {
            width - prompt_line_chars
        };

        if remaining_width > 0 && !chars.is_empty() {
            // Add user input to the same line as prompt
            // Use display width to determine how many chars fit
            let (input_chars_on_first_line, _) = chars_for_display_width(&chars, remaining_width);
            let first_input: String = chars[..input_chars_on_first_line].iter().collect();

            // Get the last line (which has the prompt) and append user input
            if let Some(last_line) = lines.last_mut() {
                let mut new_spans = last_line.spans.clone();
                // Check for misspellings in this portion
                let misspelled_in_range: Vec<_> = misspelled
                    .iter()
                    .filter(|(s, e)| *s < input_chars_on_first_line || *e <= input_chars_on_first_line)
                    .cloned()
                    .collect();

                if misspelled_in_range.is_empty() {
                    new_spans.push(Span::raw(first_input));
                } else {
                    // Handle misspellings
                    let mut pos = 0;
                    for (start, end) in &misspelled_in_range {
                        let s = (*start).min(input_chars_on_first_line);
                        let e = (*end).min(input_chars_on_first_line);
                        if pos < s {
                            let text: String = chars[pos..s].iter().collect();
                            new_spans.push(Span::raw(text));
                        }
                        if s < e {
                            let text: String = chars[s..e].iter().collect();
                            new_spans.push(Span::styled(text, Style::default().fg(tc.fg_error()).add_modifier(Modifier::BOLD)));
                        }
                        pos = e;
                    }
                    if pos < input_chars_on_first_line {
                        let text: String = chars[pos..input_chars_on_first_line].iter().collect();
                        new_spans.push(Span::raw(text));
                    }
                }
                *last_line = Line::from(new_spans);
            }

            // Now handle remaining input on subsequent lines
            let mut char_pos = input_chars_on_first_line;
            while char_pos < chars.len() && lines.len() < app.input_height as usize {
                // Use display width to determine how many chars fit on this line
                let (chars_on_line, _) = chars_for_display_width(&chars[char_pos..], width);
                let line_end = char_pos + chars_on_line;
                let mut spans: Vec<Span<'static>> = Vec::new();
                let mut current_pos = char_pos;

                while current_pos < line_end {
                    let in_misspelled = misspelled
                        .iter()
                        .find(|(s, e)| current_pos >= *s && current_pos < *e);

                    if let Some(&(word_start, word_end)) = in_misspelled {
                        if current_pos > char_pos && spans.is_empty() {
                            let before_end = word_start.min(line_end);
                            if before_end > char_pos {
                                let text: String = chars[char_pos..before_end].iter().collect();
                                spans.push(Span::raw(text));
                            }
                        }
                        let mis_start = word_start.max(char_pos);
                        let mis_end = word_end.min(line_end);
                        let text: String = chars[mis_start..mis_end].iter().collect();
                        spans.push(Span::styled(text, Style::default().fg(tc.fg_error()).add_modifier(Modifier::BOLD)));
                        current_pos = mis_end;
                    } else {
                        let next_mis = misspelled
                            .iter()
                            .filter(|(s, _)| *s > current_pos && *s < line_end)
                            .map(|(s, _)| *s)
                            .min();
                        let chunk_end = next_mis.unwrap_or(line_end);
                        let text: String = chars[current_pos..chunk_end].iter().collect();
                        spans.push(Span::raw(text));
                        current_pos = chunk_end;
                    }
                }

                if spans.is_empty() {
                    let text: String = chars[char_pos..line_end].iter().collect();
                    lines.push(Line::from(text));
                } else {
                    lines.push(Line::from(spans));
                }
                char_pos = line_end;
            }
        } else if remaining_width == 0 {
            // Prompt fills the line exactly, user input starts on next line
            let mut char_pos = 0;
            while char_pos < chars.len() && lines.len() < app.input_height as usize {
                // Use display width to determine how many chars fit on this line
                let (chars_on_line, _) = chars_for_display_width(&chars[char_pos..], width);
                let line_end = char_pos + chars_on_line;
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
                char_pos = line_end;
            }
        }
    } else if app.input.viewport_start_line == 0 && prompt.is_empty() {
        // No prompt, just render user input
        let mut char_pos = 0;
        while char_pos < chars.len() && lines.len() < app.input_height as usize {
            // Use display width to determine how many chars fit on this line
            let (chars_on_line, _) = chars_for_display_width(&chars[char_pos..], width);
            let line_end = char_pos + chars_on_line;
            let mut spans: Vec<Span<'static>> = Vec::new();
            let mut current_pos = char_pos;

            while current_pos < line_end {
                let in_misspelled = misspelled
                    .iter()
                    .find(|(s, e)| current_pos >= *s && current_pos < *e);

                if let Some(&(word_start, word_end)) = in_misspelled {
                    if current_pos > char_pos && spans.is_empty() {
                        let before_end = word_start.min(line_end);
                        if before_end > char_pos {
                            let text: String = chars[char_pos..before_end].iter().collect();
                            spans.push(Span::raw(text));
                        }
                    }
                    let mis_start = word_start.max(char_pos);
                    let mis_end = word_end.min(line_end);
                    let text: String = chars[mis_start..mis_end].iter().collect();
                    spans.push(Span::styled(text, Style::default().fg(tc.fg_error()).add_modifier(Modifier::BOLD)));
                    current_pos = mis_end;
                } else {
                    let next_mis = misspelled
                        .iter()
                        .filter(|(s, _)| *s > current_pos && *s < line_end)
                        .map(|(s, _)| *s)
                        .min();
                    let chunk_end = next_mis.unwrap_or(line_end);
                    let text: String = chars[current_pos..chunk_end].iter().collect();
                    spans.push(Span::raw(text));
                    current_pos = chunk_end;
                }
            }

            if spans.is_empty() {
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
            } else {
                lines.push(Line::from(spans));
            }
            char_pos = line_end;
        }
    } else {
        // Scrolled down, don't show prompt
        // Calculate start_char by iterating through lines to find correct starting position
        // This accounts for variable chars-per-line due to display width differences
        // IMPORTANT: First line has less capacity due to prompt
        let first_line_width = width.saturating_sub(prompt_visible_len);
        let mut start_char = 0;
        for line_idx in 0..app.input.viewport_start_line {
            if start_char >= chars.len() {
                break;
            }
            // First line has reduced width due to prompt, subsequent lines have full width
            let line_width = if line_idx == 0 { first_line_width } else { width };
            let (chars_on_line, _) = chars_for_display_width(&chars[start_char..], line_width);
            start_char += chars_on_line.max(1); // Ensure progress even with weird chars
        }
        let mut char_pos = start_char;
        while char_pos < chars.len() && lines.len() < app.input_height as usize {
            // Use display width to determine how many chars fit on this line
            let (chars_on_line, _) = chars_for_display_width(&chars[char_pos..], width);
            let line_end = char_pos + chars_on_line;
            let mut spans: Vec<Span<'static>> = Vec::new();
            let mut current_pos = char_pos;

            while current_pos < line_end {
                let in_misspelled = misspelled
                    .iter()
                    .find(|(s, e)| current_pos >= *s && current_pos < *e);

                if let Some(&(word_start, word_end)) = in_misspelled {
                    if current_pos > char_pos && spans.is_empty() {
                        let before_end = word_start.min(line_end);
                        if before_end > char_pos {
                            let text: String = chars[char_pos..before_end].iter().collect();
                            spans.push(Span::raw(text));
                        }
                    }
                    let mis_start = word_start.max(char_pos);
                    let mis_end = word_end.min(line_end);
                    let text: String = chars[mis_start..mis_end].iter().collect();
                    spans.push(Span::styled(text, Style::default().fg(tc.fg_error()).add_modifier(Modifier::BOLD)));
                    current_pos = mis_end;
                } else {
                    let next_mis = misspelled
                        .iter()
                        .filter(|(s, _)| *s > current_pos && *s < line_end)
                        .map(|(s, _)| *s)
                        .min();
                    let chunk_end = next_mis.unwrap_or(line_end);
                    let text: String = chars[current_pos..chunk_end].iter().collect();
                    spans.push(Span::raw(text));
                    current_pos = chunk_end;
                }
            }

            if spans.is_empty() {
                let text: String = chars[char_pos..line_end].iter().collect();
                lines.push(Line::from(text));
            } else {
                lines.push(Line::from(spans));
            }
            char_pos = line_end;
        }
    }

    // Pad remaining lines
    while lines.len() < app.input_height as usize {
        lines.push(Line::from(""));
    }

    Text::from(lines)
}

fn render_confirm_dialog(f: &mut Frame, app: &App) {
    if !app.confirm_dialog.visible {
        return;
    }

    let area = f.size();
    let dialog = &app.confirm_dialog;
    let theme = app.settings.theme;

    // Build button styles with background highlight
    let yes_style = if dialog.yes_selected {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };
    let no_style = if !dialog.yes_selected {
        Style::default().fg(theme.button_selected_fg()).bg(theme.button_selected_bg()).add_modifier(Modifier::BOLD)
    } else {
        Style::default().fg(theme.fg())
    };

    let lines = vec![
        Line::from(""),
        Line::from(Span::styled(dialog.message.clone(), Style::default().fg(theme.fg()))).alignment(Alignment::Center),
        Line::from(""),
        Line::from(vec![
            Span::styled("[ Yes ]", yes_style),
            Span::raw("  "),
            Span::styled("[ No ]", no_style),
        ]).alignment(Alignment::Center),
    ];

    // Calculate dynamic size based on content
    let message_width = dialog.message.chars().count();
    let buttons_width = 17; // "[ Yes ]  [ No ]"
    let content_width = message_width.max(buttons_width);
    let popup_width = ((content_width + 6) as u16).min(area.width.saturating_sub(4)); // +6 for borders and padding
    let popup_height = ((lines.len() + 2) as u16).min(area.height.saturating_sub(2)); // +2 for borders

    let x = area.width.saturating_sub(popup_width) / 2;
    let y = area.height.saturating_sub(popup_height) / 2;

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    let popup_block = Block::default()
        .title(" Confirm ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.fg_error()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

fn render_filter_popup(f: &mut Frame, app: &App) {
    if !app.filter_popup.visible {
        return;
    }

    let area = f.size();
    let filter = &app.filter_popup;
    let theme = app.settings.theme;

    // Small popup in upper right corner
    let popup_width = 40u16.min(area.width);
    let popup_height = 3u16;

    let x = area.width.saturating_sub(popup_width); // Right edge
    let y = 0; // Top edge, no gap

    let popup_area = Rect::new(x, y, popup_width, popup_height);

    // Clear the background
    f.render_widget(ratatui::widgets::Clear, popup_area);

    // Show filter text with cursor
    let mut display_text = filter.filter_text.clone();
    display_text.insert(filter.cursor, '|');

    let lines = vec![
        Line::from(vec![
            Span::styled("Filter: ", Style::default().fg(theme.fg_accent())),
            Span::styled(display_text, Style::default().fg(theme.fg())),
        ]),
    ];

    let popup_block = Block::default()
        .title(" Find [Esc to close] ")
        .borders(Borders::ALL)
        .border_style(Style::default().fg(theme.popup_border()))
        .style(Style::default().bg(theme.popup_bg()));

    let popup_text = Paragraph::new(lines).block(popup_block);

    f.render_widget(popup_text, popup_area);
}

/// Render new unified popup system
fn render_new_popup(f: &mut Frame, app: &mut App) {
    let tc = app.settings.theme;
    if let Some(state) = app.popup_manager.current_mut() {
        popup::console_renderer::render_popup(f, state, &tc);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_insert_char_ascii() {
        let mut input = InputArea::new(3);
        input.insert_char('a');
        input.insert_char('b');
        input.insert_char('c');
        assert_eq!(input.buffer, "abc");
        assert_eq!(input.cursor_position, 3);
    }

    #[test]
    fn test_insert_char_emoji() {
        let mut input = InputArea::new(3);
        input.insert_char('ðŸ˜€');
        assert_eq!(input.buffer, "ðŸ˜€");
        assert_eq!(input.cursor_position, 4); // emoji is 4 bytes

        input.insert_char('a');
        assert_eq!(input.buffer, "ðŸ˜€a");
        assert_eq!(input.cursor_position, 5);
    }

    #[test]
    fn test_insert_char_mixed() {
        let mut input = InputArea::new(3);
        input.insert_char('H');
        input.insert_char('i');
        input.insert_char('ðŸ˜€');
        input.insert_char('!');
        assert_eq!(input.buffer, "HiðŸ˜€!");
        assert_eq!(input.cursor_position, 7); // 2 + 4 + 1 bytes
    }

    #[test]
    fn test_move_cursor_left_ascii() {
        let mut input = InputArea::new(3);
        input.buffer = "abc".to_string();
        input.cursor_position = 3;

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 2);

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0);

        // Should not go below 0
        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0);
    }

    #[test]
    fn test_move_cursor_left_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "aðŸ˜€b".to_string();
        input.cursor_position = 6; // end of string (1 + 4 + 1 bytes)

        input.move_cursor_left(); // move before 'b'
        assert_eq!(input.cursor_position, 5);

        input.move_cursor_left(); // move before emoji (skips all 4 bytes)
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_left(); // move before 'a'
        assert_eq!(input.cursor_position, 0);
    }

    #[test]
    fn test_move_cursor_right_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "aðŸ˜€b".to_string();
        input.cursor_position = 0;

        input.move_cursor_right(); // move after 'a'
        assert_eq!(input.cursor_position, 1);

        input.move_cursor_right(); // move after emoji (skips all 4 bytes)
        assert_eq!(input.cursor_position, 5);

        input.move_cursor_right(); // move after 'b'
        assert_eq!(input.cursor_position, 6);

        // Should not go beyond end
        input.move_cursor_right();
        assert_eq!(input.cursor_position, 6);
    }

    #[test]
    fn test_delete_char_ascii() {
        let mut input = InputArea::new(3);
        input.buffer = "abc".to_string();
        input.cursor_position = 3;

        input.delete_char();
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 2);
    }

    #[test]
    fn test_delete_char_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "aðŸ˜€b".to_string();
        input.cursor_position = 5; // after emoji

        input.delete_char(); // delete emoji
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 1);
    }

    #[test]
    fn test_delete_char_forward_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "aðŸ˜€b".to_string();
        input.cursor_position = 1; // before emoji

        input.delete_char_forward(); // delete emoji
        assert_eq!(input.buffer, "ab");
        assert_eq!(input.cursor_position, 1);
    }

    #[test]
    fn test_cursor_line_with_emoji() {
        let mut input = InputArea::new(3);
        input.width = 10;
        // 5 emojis = 10 display columns (2 per emoji), at width 10 fits on 1 line
        input.buffer = "ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€ðŸ˜€".to_string();
        input.cursor_position = input.buffer.len(); // end

        // 10 columns at width 10 = cursor at end of line 0, wraps to line 1
        assert_eq!(input.cursor_line(), 1);

        // At width 5, 10 columns = 2 full lines, cursor at start of line 2
        input.width = 5;
        assert_eq!(input.cursor_line(), 2);
    }

    #[test]
    fn test_delete_word_before_cursor_with_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "hello ðŸ˜€ðŸ˜€ world".to_string();
        input.cursor_position = input.buffer.len();

        input.delete_word_before_cursor(); // delete "world"
        assert_eq!(input.buffer, "hello ðŸ˜€ðŸ˜€ ");

        // delete_word skips whitespace first, then deletes non-whitespace
        // so this deletes " ðŸ˜€ðŸ˜€" (space + emojis)
        input.delete_word_before_cursor();
        assert_eq!(input.buffer, "hello ");

        input.delete_word_before_cursor(); // delete "hello"
        assert_eq!(input.buffer, "");
    }

    #[test]
    fn test_home_and_end() {
        let mut input = InputArea::new(3);
        input.buffer = "aðŸ˜€b".to_string();
        input.cursor_position = 5;

        input.home();
        assert_eq!(input.cursor_position, 0);

        input.end();
        assert_eq!(input.cursor_position, 6);
    }

    #[test]
    fn test_insert_at_middle_with_emoji() {
        let mut input = InputArea::new(3);
        input.buffer = "ab".to_string();
        input.cursor_position = 1; // between a and b

        input.insert_char('ðŸ˜€');
        assert_eq!(input.buffer, "aðŸ˜€b");
        assert_eq!(input.cursor_position, 5); // 1 + 4 bytes
    }

    #[test]
    fn test_multiple_emojis() {
        let mut input = InputArea::new(3);
        input.insert_char('ðŸŽ‰');
        input.insert_char('ðŸŽŠ');
        input.insert_char('ðŸŽˆ');

        assert_eq!(input.buffer, "ðŸŽ‰ðŸŽŠðŸŽˆ");
        assert_eq!(input.cursor_position, 12); // 3 emojis * 4 bytes each

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 8);

        input.delete_char();
        assert_eq!(input.buffer, "ðŸŽ‰ðŸŽˆ");
        assert_eq!(input.cursor_position, 4);
    }

    #[test]
    fn test_unicode_characters() {
        let mut input = InputArea::new(3);
        // Test various unicode: Chinese, emoji, accented
        input.insert_char('ä¸­');  // 3 bytes
        input.insert_char('ðŸ˜€');  // 4 bytes
        input.insert_char('Ã©');   // 2 bytes

        assert_eq!(input.buffer, "ä¸­ðŸ˜€Ã©");
        assert_eq!(input.cursor_position, 9); // 3 + 4 + 2

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 7); // before Ã©

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 3); // before ðŸ˜€

        input.move_cursor_left();
        assert_eq!(input.cursor_position, 0); // before ä¸­
    }

    #[test]
    fn test_password_encrypt_decrypt() {
        // Test basic encryption/decryption
        let password = "mysecretpassword";
        let encrypted = encrypt_password(password);
        assert!(encrypted.starts_with("ENC:"));
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_password_empty() {
        // Empty password should stay empty
        let encrypted = encrypt_password("");
        assert_eq!(encrypted, "");
        let decrypted = decrypt_password("");
        assert_eq!(decrypted, "");
    }

    #[test]
    fn test_password_plain_fallback() {
        // Plain passwords (not starting with ENC:) should be returned as-is
        let plain = "plainpassword";
        let decrypted = decrypt_password(plain);
        assert_eq!(decrypted, plain);
    }

    #[test]
    fn test_password_special_chars() {
        // Test password with special characters
        let password = "p@$$w0rd!#$%^&*()";
        let encrypted = encrypt_password(password);
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_password_unicode() {
        // Test password with unicode
        let password = "å¯†ç ðŸ”Ð¿Ð°Ñ€Ð¾Ð»ÑŒ";
        let encrypted = encrypt_password(password);
        let decrypted = decrypt_password(&encrypted);
        assert_eq!(decrypted, password);
    }

    #[test]
    fn test_hash_password() {
        let hash = hash_password("test");
        assert_eq!(hash, "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08");
    }

    #[tokio::test]
    async fn test_websocket_auth() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};

        // Start a minimal WebSocket server on a random port
        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        // Expected password hash for "test"
        let server_password = "test";
        let expected_hash = hash_password(server_password);
        println!("Server expects hash: {}", expected_hash);

        // Spawn server task
        let server_hash = expected_hash.clone();
        let server_task = tokio::spawn(async move {
            let (stream, _) = listener.accept().await.unwrap();
            let ws_stream = tokio_tungstenite::accept_async(stream).await.unwrap();
            let (mut ws_sink, mut ws_source) = ws_stream.split();

            while let Some(msg_result) = ws_source.next().await {
                if let Ok(WsRawMessage::Text(text)) = msg_result {
                    println!("Server received: {}", text);
                    if let Ok(ws_msg) = serde_json::from_str::<WsMessage>(&text) {
                        if let WsMessage::AuthRequest { password_hash: client_hash, .. } = ws_msg {
                            println!("Client hash: {}", client_hash);
                            println!("Server hash: {}", server_hash);
                            let auth_success = client_hash == server_hash;
                            println!("Auth success: {}", auth_success);
                            let response = WsMessage::AuthResponse {
                                success: auth_success,
                                error: if auth_success { None } else { Some("Invalid password".to_string()) },
                                username: None,
                                multiuser_mode: false,
                            };
                            let json = serde_json::to_string(&response).unwrap();
                            ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();
                            break;
                        }
                    }
                }
            }
        });

        // Give server time to start
        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // Connect client
        let url = format!("ws://127.0.0.1:{}", port);
        let (ws_stream, _) = connect_async(&url).await.unwrap();
        let (mut ws_sink, mut ws_source) = ws_stream.split();

        // Send auth request with correct password hash
        let client_password = "test";
        let client_hash = hash_password(client_password);
        println!("Client sending hash: {}", client_hash);
        let auth_msg = WsMessage::AuthRequest { password_hash: client_hash, username: None, current_world: None, auth_key: None, request_key: false };
        let json = serde_json::to_string(&auth_msg).unwrap();
        ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();

        // Wait for response
        if let Some(Ok(WsRawMessage::Text(text))) = ws_source.next().await {
            println!("Client received: {}", text);
            let response: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { success, error, .. } = response {
                assert!(success, "Auth should succeed but got error: {:?}", error);
            } else {
                panic!("Expected AuthResponse");
            }
        } else {
            panic!("No response received");
        }

        server_task.abort();
    }

    #[test]
    fn test_world_cycling_all_connected() {
        // Test cycling through multiple connected worlds
        let mut app = App::new();
        app.worlds.clear(); // Remove any default world

        // Create 3 connected worlds with different names
        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // Verify initial state
        assert_eq!(app.worlds[app.current_world_index].name, "alpha");

        // Cycle forward: alpha -> cave
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "After first next_world from alpha, should be on cave");

        // Cycle forward: cave -> zeta
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "After second next_world from cave, should be on zeta");

        // Cycle forward: zeta -> alpha (wrap)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "alpha",
            "After third next_world from zeta, should wrap to alpha");

        // Cycle backward: alpha -> zeta
        app.prev_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "After prev_world from alpha, should be on zeta");

        // Cycle backward: zeta -> cave
        app.prev_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "After prev_world from zeta, should be on cave");
    }

    #[test]
    fn test_world_cycling_with_disconnected() {
        // Test that disconnected worlds without unseen output are skipped
        let mut app = App::new();
        app.worlds.clear();

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_beta = World::new("beta");
        world_beta.connected = false; // Disconnected, no unseen output
        app.worlds.push(world_beta);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        app.worlds.push(world_cave);

        app.current_world_index = 0; // Start on alpha

        // Cycle forward: alpha -> cave (skipping disconnected beta)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "Should skip disconnected beta and go to cave");

        // Cycle forward: cave -> alpha (skipping disconnected beta)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "alpha",
            "Should skip disconnected beta and wrap to alpha");
    }

    #[test]
    fn test_world_cycling_case_insensitive_sort() {
        // Test that world names are sorted case-insensitively
        let mut app = App::new();
        app.worlds.clear();

        let mut world_alpha = World::new("Alpha"); // Capital A
        world_alpha.connected = true;
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave"); // lowercase c
        world_cave.connected = true;
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("Zeta"); // Capital Z
        world_zeta.connected = true;
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on Alpha

        // Should cycle: Alpha -> cave -> Zeta (case-insensitive alphabetical)
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "Case-insensitive sort: Alpha -> cave");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "Zeta",
            "Case-insensitive sort: cave -> Zeta");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "Alpha",
            "Case-insensitive sort: Zeta -> Alpha (wrap)");
    }

    #[test]
    fn test_world_cycling_unseen_first_no_unseen() {
        // Test world_switch_mode=UnseenFirst when no worlds have unseen output
        let mut app = App::new();
        app.worlds.clear();
        app.settings.world_switch_mode = WorldSwitchMode::UnseenFirst;

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        world_alpha.unseen_lines = 0; // No unseen
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        world_cave.unseen_lines = 0; // No unseen
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        world_zeta.unseen_lines = 0; // No unseen
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // With UnseenFirst ON but no unseen, should cycle alphabetically
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "With UnseenFirst but no unseen, should go to cave");

        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "zeta",
            "With UnseenFirst but no unseen, should go to zeta");
    }

    #[test]
    fn test_world_cycling_unseen_first_with_unseen() {
        // Test world_switch_mode=UnseenFirst prioritizes worlds with unseen output
        let mut app = App::new();
        app.worlds.clear();
        app.settings.world_switch_mode = WorldSwitchMode::UnseenFirst;

        let mut world_alpha = World::new("alpha");
        world_alpha.connected = true;
        world_alpha.unseen_lines = 0; // No unseen
        app.worlds.push(world_alpha);

        let mut world_cave = World::new("cave");
        world_cave.connected = true;
        world_cave.unseen_lines = 5; // Has unseen!
        app.worlds.push(world_cave);

        let mut world_zeta = World::new("zeta");
        world_zeta.connected = true;
        world_zeta.unseen_lines = 0; // No unseen
        app.worlds.push(world_zeta);

        app.current_world_index = 0; // Start on alpha

        // With UnseenFirst ON and cave has unseen, should go to cave first
        app.next_world();
        assert_eq!(app.worlds[app.current_world_index].name, "cave",
            "With UnseenFirst, should prioritize cave with unseen output");
    }

    #[test]
    fn test_decode_strips_control_chars() {
        // Test that carriage return is stripped
        let input = b"hello\rworld";
        let result = Encoding::Utf8.decode(input);
        assert!(!result.contains('\r'), "Carriage return should be stripped");
        assert_eq!(result, "helloworld", "CR should be removed, text concatenated");

        // Test that other control characters are stripped but tab/newline kept
        let input = b"a\x01b\tc\nd\x7Fe";
        let result = Encoding::Utf8.decode(input);
        assert_eq!(result, "ab\tc\nde", "Control chars stripped except tab/newline");

        // Test that BEL is stripped in final output
        let input = b"hello\x07world";
        let result = Encoding::Utf8.decode(input);
        assert!(!result.contains('\x07'), "BEL should be stripped in final output");
    }

    #[test]
    fn test_strip_non_sgr_sequences() {
        // Test that SGR (color/style) sequences are kept
        let input = "\x1b[31mred text\x1b[0m";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "\x1b[31mred text\x1b[0m", "SGR sequences should be preserved");

        // Test that cursor position (H) inserts newline
        let input = "first\x1b[10;5Hsecond";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "first\nsecond", "Cursor positioning (H) should insert newline");

        // Test that cursor column (G) inserts space
        let input = "before\x1b[10Gafter";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "before after", "Cursor column (G) should insert space");

        // Test that erase sequences are stripped without separator
        let input = "hello\x1b[2Jworld";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "helloworld", "Erase (J) should be stripped");

        // Test that erase line (K) is stripped
        let input = "hello\x1b[Kworld";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "helloworld", "Erase line (K) should be stripped");

        // Test OSC (window title) sequences are stripped
        let input = "before\x1b]0;Window Title\x07after";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "beforeafter", "OSC sequences should be stripped");

        // Test cursor up/down inserts newline
        let input = "line1\x1b[Aline2";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "line1\nline2", "Cursor up (A) should insert newline");

        // Test @ character (insert character)
        let input = "before\x1b[5@after";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "beforeafter", "Insert character (@) should be stripped");

        // Test ~ character (function key)
        let input = "text\x1b[6~more";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "textmore", "Function key sequences (~) should be stripped");

        // Test that consecutive positioning doesn't add multiple separators
        let input = "text\x1b[H\x1b[Hmore";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "text\nmore", "Consecutive H should only add one newline");

        // Test that malformed CSI sequences don't consume URL text
        // A malformed sequence like ESC[? followed by https:// should not consume the 'h'
        let input = "before\x1b[?https://example.com";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "before\x1b[?https://example.com", "Malformed CSI should preserve URL text");

        // Test that valid private mode sequences are still processed
        let input = "before\x1b[?25hafter";
        let result = strip_non_sgr_sequences(input);
        assert_eq!(result, "beforeafter", "Valid private mode sequence should be stripped");
    }

    #[test]
    fn test_keep_alive_type_cycling() {
        // Test next() cycling
        assert_eq!(KeepAliveType::None.next(), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::Nop.next(), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::Custom.next(), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::Generic.next(), KeepAliveType::None);

        // Test prev() cycling
        assert_eq!(KeepAliveType::None.prev(), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::Nop.prev(), KeepAliveType::None);
        assert_eq!(KeepAliveType::Custom.prev(), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::Generic.prev(), KeepAliveType::Custom);
    }

    #[test]
    fn test_keep_alive_type_name() {
        assert_eq!(KeepAliveType::None.name(), "None");
        assert_eq!(KeepAliveType::Nop.name(), "NOP");
        assert_eq!(KeepAliveType::Custom.name(), "Custom");
        assert_eq!(KeepAliveType::Generic.name(), "Generic");
    }

    #[test]
    fn test_keep_alive_type_from_name() {
        assert_eq!(KeepAliveType::from_name("None"), KeepAliveType::None);
        assert_eq!(KeepAliveType::from_name("none"), KeepAliveType::None);
        assert_eq!(KeepAliveType::from_name("NOP"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name("nop"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name("Custom"), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::from_name("custom"), KeepAliveType::Custom);
        assert_eq!(KeepAliveType::from_name("Generic"), KeepAliveType::Generic);
        assert_eq!(KeepAliveType::from_name("generic"), KeepAliveType::Generic);
        // Unknown should default to Nop
        assert_eq!(KeepAliveType::from_name("unknown"), KeepAliveType::Nop);
        assert_eq!(KeepAliveType::from_name(""), KeepAliveType::Nop);
    }

    #[test]
    fn test_idler_message_filter() {
        // Test that lines containing idler message pattern are detected
        let idler_line = "You don't know how to help commands ###_idler_message_123_###.";
        assert!(idler_line.contains("###_idler_message_") && idler_line.contains("_###"));

        let normal_line = "You say, \"Hello world!\"";
        assert!(!(normal_line.contains("###_idler_message_") && normal_line.contains("_###")));

        // Test partial matches don't trigger
        let partial1 = "###_idler_message_ incomplete";
        assert!(!(partial1.contains("###_idler_message_") && partial1.contains("_###")));

        let partial2 = "incomplete _### suffix only";
        assert!(!(partial2.contains("###_idler_message_") && partial2.contains("_###")));
    }

    #[test]
    fn test_idler_message_replacement() {
        // Test that ##rand## is replaced correctly in custom commands
        let custom_cmd = "look ##rand##";
        let rand_num = 42u32;
        let idler_tag = format!("###_idler_message_{}_###", rand_num);
        let result = custom_cmd.replace("##rand##", &idler_tag);
        assert_eq!(result, "look ###_idler_message_42_###");

        // Test generic command format
        let generic_cmd = format!("help commands ###_idler_message_{}_###", rand_num);
        assert_eq!(generic_cmd, "help commands ###_idler_message_42_###");
    }

    #[test]
    fn test_is_visually_empty() {
        use super::is_visually_empty;

        // Empty string is visually empty
        assert!(is_visually_empty(""));

        // Whitespace-only is visually empty
        assert!(is_visually_empty("   "));
        assert!(is_visually_empty("\t"));
        assert!(is_visually_empty("  \t  "));

        // ANSI codes only are visually empty
        assert!(is_visually_empty("\x1b[0m"));
        assert!(is_visually_empty("\x1b[31m\x1b[0m"));
        assert!(is_visually_empty("\x1b[1;32m"));

        // ANSI codes with whitespace are visually empty
        assert!(is_visually_empty("\x1b[0m   \x1b[31m"));
        assert!(is_visually_empty("  \x1b[0m  "));

        // Visible text is NOT visually empty
        assert!(!is_visually_empty("hello"));
        assert!(!is_visually_empty("  hello  "));
        assert!(!is_visually_empty("\x1b[31mhello\x1b[0m"));
        assert!(!is_visually_empty("a"));
        assert!(!is_visually_empty("\x1b[0m.\x1b[0m"));
    }

    #[test]
    fn test_has_background_color() {
        use super::has_background_color;

        // No background color
        assert!(!has_background_color(""));
        assert!(!has_background_color("hello"));
        assert!(!has_background_color("\x1b[31mred text\x1b[0m"));
        assert!(!has_background_color("\x1b[1;32mbold green\x1b[0m"));

        // Standard background colors (40-47)
        assert!(has_background_color("\x1b[40m"));
        assert!(has_background_color("\x1b[44mblue bg\x1b[0m"));
        assert!(has_background_color("\x1b[47m   \x1b[0m"));

        // Bright background colors (100-107)
        assert!(has_background_color("\x1b[100m"));
        assert!(has_background_color("\x1b[104m"));
        assert!(has_background_color("\x1b[107m"));

        // 256-color background (48;5;N)
        assert!(has_background_color("\x1b[48;5;15m"));
        assert!(has_background_color("\x1b[48;5;15m   \x1b[0m"));
        assert!(has_background_color("\x1b[48;5;255mwhite\x1b[0m"));

        // True color background (48;2;R;G;B)
        assert!(has_background_color("\x1b[48;2;255;255;255m"));
        assert!(has_background_color("\x1b[48;2;0;0;0mblack\x1b[0m"));

        // Combined foreground and background
        assert!(has_background_color("\x1b[31;44mred on blue\x1b[0m"));
        assert!(has_background_color("\x1b[38;5;15;48;5;0m"));

        // Whitespace with background color (ANSI art case)
        assert!(has_background_color("\x1b[48;5;15m                    \x1b[0m"));
    }

    #[test]
    fn test_is_ansi_only_line() {
        use super::is_ansi_only_line;

        // Empty string is NOT ANSI-only (it's just empty)
        assert!(!is_ansi_only_line(""));

        // Whitespace-only is NOT ANSI-only
        assert!(!is_ansi_only_line("   "));

        // Pure ANSI codes without content (garbage that should be filtered)
        assert!(is_ansi_only_line("\x1b[0m"));
        assert!(is_ansi_only_line("\x1b[H\x1b[J"));  // Cursor control garbage
        assert!(is_ansi_only_line("\x1b[31m\x1b[0m"));  // Color codes only
        assert!(is_ansi_only_line("\x1b[0m   \x1b[31m"));  // ANSI + whitespace only (no bg color)

        // Lines with visible content should NOT be filtered
        assert!(!is_ansi_only_line("hello"));
        assert!(!is_ansi_only_line("\x1b[31mhello\x1b[0m"));

        // CRITICAL: Lines with background colors should NOT be filtered even if no visible text
        // This is the ANSI art case - white background with spaces
        assert!(!is_ansi_only_line("\x1b[48;5;15m                    \x1b[0m"));
        assert!(!is_ansi_only_line("\x1b[44m   \x1b[0m"));  // Standard blue bg
        assert!(!is_ansi_only_line("\x1b[100m\x1b[0m"));  // Bright background
        assert!(!is_ansi_only_line("\x1b[48;2;255;255;255m  \x1b[0m"));  // True color bg
    }

    #[test]
    fn test_wrap_urls_with_osc8() {
        use super::wrap_urls_with_osc8;

        // No URLs - return unchanged
        assert_eq!(wrap_urls_with_osc8("hello world"), "hello world");
        assert_eq!(wrap_urls_with_osc8("no links here"), "no links here");

        // Simple HTTP URL - using BEL (0x07) as terminator
        let result = wrap_urls_with_osc8("check http://example.com please");
        assert!(result.contains("\x1b]8;;http://example.com\x07"));
        assert!(result.contains("http://example.com\x1b]8;;\x07"));

        // HTTPS URL
        let result = wrap_urls_with_osc8("visit https://example.com/path");
        assert!(result.contains("\x1b]8;;https://example.com/path\x07"));

        // URL with query parameters
        let result = wrap_urls_with_osc8("link: https://example.com/page?foo=bar&baz=qux");
        assert!(result.contains("foo=bar&baz=qux"));

        // URL followed by punctuation (should not include trailing punctuation)
        let result = wrap_urls_with_osc8("See https://example.com.");
        assert!(result.contains("\x1b]8;;https://example.com\x07"));
        assert!(!result.contains("\x1b]8;;https://example.com.\x07"));

        // URL in quotes
        let result = wrap_urls_with_osc8("Nina says, \"https://tenor.com/view/test\"");
        assert!(result.contains("\x1b]8;;https://tenor.com/view/test\x07"));

        // Multiple URLs
        let result = wrap_urls_with_osc8("http://a.com and https://b.com");
        assert!(result.contains("\x1b]8;;http://a.com\x07"));
        assert!(result.contains("\x1b]8;;https://b.com\x07"));

        // URL with zero-width spaces (U+200B) should have them stripped from OSC 8 URL parameter
        // but preserved in visible text for word breaking
        let url_with_zwsp = "https://example.com/\u{200B}path/\u{200B}to/\u{200B}page";
        let result = wrap_urls_with_osc8(url_with_zwsp);
        // OSC 8 URL parameter should have clean URL without ZWSP
        assert!(result.contains("\x1b]8;;https://example.com/path/to/page\x07"));
        // Visible text should preserve ZWSP for word breaking
        assert!(result.contains("/\u{200B}path/\u{200B}to/\u{200B}page"));

        // URL followed by ANSI color code should stop at ESC, not include the code in URL
        let url_with_ansi = "https://example.com\x1b[0;37m rest";
        let result = wrap_urls_with_osc8(url_with_ansi);
        // URL should end at the ESC, not include the ANSI code
        assert!(result.contains("\x1b]8;;https://example.com\x07"));
        // The ANSI code should be preserved after the OSC 8 closing sequence
        assert!(result.contains("\x1b]8;;\x07\x1b[0;37m"));
    }

    #[test]
    fn test_strip_mud_tag() {
        use super::strip_mud_tag;

        // Basic tag stripping
        assert_eq!(strip_mud_tag("[channel:] hello"), "hello");
        assert_eq!(strip_mud_tag("[chat:] message"), "message");
        assert_eq!(strip_mud_tag("[ooc(player)] text"), "text");

        // With leading whitespace
        assert_eq!(strip_mud_tag("  [channel:] hello"), "  hello");

        // With ANSI color prefix
        assert_eq!(strip_mud_tag("\x1b[31m[channel:] hello"), "\x1b[31mhello");
        assert_eq!(strip_mud_tag("\x1b[1;32m[chat:] text"), "\x1b[1;32mtext");

        // Non-tag brackets should NOT be stripped
        assert_eq!(strip_mud_tag("[hello] world"), "[hello] world");
        assert_eq!(strip_mud_tag("[nochannel] text"), "[nochannel] text");

        // No brackets at start
        assert_eq!(strip_mud_tag("hello world"), "hello world");
        assert_eq!(strip_mud_tag("text [tag:] later"), "text [tag:] later");

        // Empty or only tag
        assert_eq!(strip_mud_tag("[channel:]"), "");
        assert_eq!(strip_mud_tag("[channel:] "), "");
    }

    // ============================================================================
    // Security regression tests
    // ============================================================================

    /// Test: RevokeKey must require authentication (CVE-like: pre-auth key revocation)
    /// An unauthenticated WebSocket client must NOT be able to revoke auth keys.
    #[tokio::test]
    async fn test_security_revoke_key_requires_auth() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};
        use crate::websocket::{WsMessage, WsClientInfo};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        let password_hash = hash_password("testpass");
        let (event_tx, mut event_rx) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, crate::websocket::UserCredential>>> =
            Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));

        // Spawn server handler
        let server_clients = Arc::clone(&clients);
        let server_task = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream,
                1, // client_id
                server_clients,
                password_hash,
                allow_list,
                whitelisted,
                client_addr,
                event_tx,
                false, // not multiuser
                users,
                ban_list,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // Connect as client but do NOT authenticate
        let url = format!("ws://127.0.0.1:{}", port);
        let (ws_stream, _) = connect_async(&url).await.unwrap();
        let (mut ws_sink, mut ws_source) = ws_stream.split();

        // Skip ServerHello
        let _ = ws_source.next().await;

        // Try to send RevokeKey without authenticating
        let revoke_msg = WsMessage::RevokeKey { auth_key: "some_key".to_string() };
        let json = serde_json::to_string(&revoke_msg).unwrap();
        ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();

        // The server should disconnect us (break from loop) since we're not authenticated
        // Wait briefly for the server to process
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        // Check that NO WsKeyRevoke event was sent to the app
        // (the event channel should only have WsClientConnected and WsClientDisconnected)
        let mut found_revoke = false;
        while let Ok(event) = event_rx.try_recv() {
            if let AppEvent::WsKeyRevoke(_, _) = event {
                found_revoke = true;
            }
        }
        assert!(!found_revoke, "RevokeKey should NOT be processed for unauthenticated clients");

        server_task.abort();
    }

    /// Test: Unauthenticated clients cannot send commands
    /// Any non-auth message from an unauthenticated client must be rejected.
    #[tokio::test]
    async fn test_security_unauth_cannot_send_commands() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};
        use crate::websocket::{WsMessage, WsClientInfo};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        let password_hash = hash_password("testpass");
        let (event_tx, mut event_rx) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, crate::websocket::UserCredential>>> =
            Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));

        let server_clients = Arc::clone(&clients);
        let server_task = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 1, server_clients, password_hash,
                allow_list, whitelisted, client_addr, event_tx,
                false, users, ban_list,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        let url = format!("ws://127.0.0.1:{}", port);
        let (ws_stream, _) = connect_async(&url).await.unwrap();
        let (mut ws_sink, _ws_source) = ws_stream.split();

        // Try sending a command without authenticating
        let cmd = WsMessage::SendCommand { world_index: 0, command: "look".to_string() };
        let json = serde_json::to_string(&cmd).unwrap();
        ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();

        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

        // Verify no WsClientMessage was forwarded to app
        let mut found_command = false;
        while let Ok(event) = event_rx.try_recv() {
            if let AppEvent::WsClientMessage(_, msg) = event {
                if let WsMessage::SendCommand { .. } = *msg {
                    found_command = true;
                }
            }
        }
        assert!(!found_command, "Unauthenticated client should NOT be able to send commands");

        server_task.abort();
    }

    /// Test: Failed password auth triggers ban violation
    #[tokio::test]
    async fn test_security_failed_auth_records_violation() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};
        use crate::websocket::{WsMessage, WsClientInfo};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        let password_hash = hash_password("correctpassword");
        let (event_tx, _event_rx) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, crate::websocket::UserCredential>>> =
            Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));

        let server_clients = Arc::clone(&clients);
        let server_task = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 1, server_clients, password_hash,
                allow_list, whitelisted, client_addr, event_tx,
                false, users, ban_list,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        let url = format!("ws://127.0.0.1:{}", port);
        let (ws_stream, _) = connect_async(&url).await.unwrap();
        let (mut ws_sink, mut ws_source) = ws_stream.split();

        // Skip ServerHello
        let _ = ws_source.next().await;

        // Send wrong password
        let wrong_hash = hash_password("wrongpassword");
        let auth_msg = WsMessage::AuthRequest {
            password_hash: wrong_hash,
            username: None,
            current_world: None,
            auth_key: None,
            request_key: false,
        };
        let json = serde_json::to_string(&auth_msg).unwrap();
        ws_sink.send(WsRawMessage::Text(json.into())).await.unwrap();

        // Read response - should be auth failure
        if let Some(Ok(WsRawMessage::Text(text))) = ws_source.next().await {
            let response: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { success, .. } = response {
                assert!(!success, "Auth should fail with wrong password");
            }
        }

        // Note: ban_list violations from localhost are ignored (127.0.0.1 exempt)
        // This test verifies the auth flow rejects bad passwords
        // Ban tracking for non-localhost IPs is verified by the ban_list unit tests

        server_task.abort();
    }

    /// Test: Multiuser auth error messages don't reveal user existence
    /// Both invalid username and invalid password should return the same error.
    #[tokio::test]
    async fn test_security_multiuser_no_user_enumeration() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};
        use crate::websocket::{WsMessage, WsClientInfo, UserCredential};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let addr = listener.local_addr().unwrap();
        let port = addr.port();

        let password_hash = hash_password("serverpass");
        let (event_tx, _event_rx) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();

        // Set up multiuser mode with one user
        let mut users_map = std::collections::HashMap::new();
        users_map.insert("admin".to_string(), UserCredential {
            password_hash: hash_password("adminpass"),
        });
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, UserCredential>>> =
            Arc::new(std::sync::RwLock::new(users_map));

        // We need two connections to test both error cases
        let listener2 = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let port2 = listener2.local_addr().unwrap().port();

        let clients2 = Arc::clone(&clients);
        let users2 = Arc::clone(&users);
        let ban_list2 = ban_list.clone();
        let (event_tx2, _) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let password_hash2 = password_hash.clone();

        let server_clients = Arc::clone(&clients);

        // Server 1: test invalid username
        let server_task1 = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 1, server_clients, password_hash,
                allow_list, whitelisted, client_addr, event_tx,
                true, // multiuser mode
                users, ban_list,
            ).await.ok();
        });

        // Server 2: test wrong password for valid user
        let allow_list2: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted2: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let server_task2 = tokio::spawn(async move {
            let (stream, client_addr) = listener2.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 2, clients2, password_hash2,
                allow_list2, whitelisted2, client_addr, event_tx2,
                true, users2, ban_list2,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        // Test 1: Invalid username
        let url1 = format!("ws://127.0.0.1:{}", port);
        let (ws1, _) = connect_async(&url1).await.unwrap();
        let (mut sink1, mut source1) = ws1.split();
        let _ = source1.next().await; // skip ServerHello

        let auth1 = WsMessage::AuthRequest {
            password_hash: hash_password("anything"),
            username: Some("nonexistent".to_string()),
            current_world: None,
            auth_key: None,
            request_key: false,
        };
        sink1.send(WsRawMessage::Text(serde_json::to_string(&auth1).unwrap().into())).await.unwrap();
        let error1 = if let Some(Ok(WsRawMessage::Text(text))) = source1.next().await {
            let resp: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { error, .. } = resp { error } else { None }
        } else { None };

        // Test 2: Valid username, wrong password
        let url2 = format!("ws://127.0.0.1:{}", port2);
        let (ws2, _) = connect_async(&url2).await.unwrap();
        let (mut sink2, mut source2) = ws2.split();
        let _ = source2.next().await; // skip ServerHello

        let auth2 = WsMessage::AuthRequest {
            password_hash: hash_password("wrongpassword"),
            username: Some("admin".to_string()),
            current_world: None,
            auth_key: None,
            request_key: false,
        };
        sink2.send(WsRawMessage::Text(serde_json::to_string(&auth2).unwrap().into())).await.unwrap();
        let error2 = if let Some(Ok(WsRawMessage::Text(text))) = source2.next().await {
            let resp: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { error, .. } = resp { error } else { None }
        } else { None };

        // Both errors must be identical to prevent user enumeration
        assert_eq!(error1, error2,
            "Invalid username and wrong password must return the same error message \
             to prevent user enumeration. Got: {:?} vs {:?}", error1, error2);

        // Verify the error is generic
        assert_eq!(error1, Some("Authentication failed".to_string()),
            "Error message should be generic 'Authentication failed'");

        server_task1.abort();
        server_task2.abort();
    }

    /// Test: Host header sanitization strips JS injection characters
    /// The host header is injected into HTML templates as a JS string value.
    /// Characters that could break out of the string context must be stripped.
    #[test]
    fn test_security_host_header_sanitization() {
        // These are the dangerous characters for JS string injection
        let malicious_hosts = vec![
            ("example.com\";alert(1);//", "example.com;alert(1);//"),
            ("example.com';alert(1);//", "example.com;alert(1);//"),
            ("example.com`+alert(1)+`", "example.com+alert(1)+"),
            ("example.com\\x22;alert(1)", "example.comx22;alert(1)"),
            ("<script>alert(1)</script>", "scriptalert(1)/script"),
            ("example.com\">", "example.com"),
        ];

        for (input, expected) in malicious_hosts {
            let sanitized = input.replace(['\\', '\'', '"', '`', '<', '>'], "");
            assert_eq!(sanitized, expected,
                "Host header sanitization failed for input: {:?}", input);
        }
    }

    /// Test: Valid HTTP paths don't trigger ban violations
    #[test]
    fn test_security_valid_paths_no_ban() {
        let valid_paths = vec![
            "/", "/index.html", "/style.css", "/app.js",
            "/theme-editor", "/favicon.ico",
        ];

        for path in valid_paths {
            // Verify these paths are in the known set
            // If any of these paths start returning 404, it would be a regression
            let is_valid = matches!(path,
                "/" | "/index.html" | "/style.css" | "/app.js" |
                "/theme-editor" | "/favicon.ico"
            );
            assert!(is_valid, "Path {} should be recognized as valid", path);
        }
    }

    /// Test: BanList localhost exemption
    /// Localhost connections must never be banned (prevents self-lockout)
    #[test]
    fn test_security_localhost_ban_exempt() {
        let ban_list = BanList::new();

        // Record many violations from localhost - should never result in ban
        for _ in 0..20 {
            ban_list.record_violation("127.0.0.1", "test violation");
        }
        assert!(!ban_list.is_banned("127.0.0.1"),
            "127.0.0.1 must never be banned");

        for _ in 0..20 {
            ban_list.record_violation("::1", "test violation");
        }
        assert!(!ban_list.is_banned("::1"),
            "::1 must never be banned");

        for _ in 0..20 {
            ban_list.record_violation("localhost", "test violation");
        }
        assert!(!ban_list.is_banned("localhost"),
            "localhost must never be banned");
    }

    /// Test: BanList bans external IPs after threshold violations
    #[test]
    fn test_security_ban_after_violations() {
        let ban_list = BanList::new();

        // 5 violations should trigger permanent ban for non-localhost
        for i in 0..5 {
            let banned = ban_list.record_violation("10.0.0.1", &format!("violation {}", i));
            if i < 4 {
                // Before 5th violation, may get temp ban at 3
                let _ = banned;
            }
        }
        assert!(ban_list.is_banned("10.0.0.1"),
            "External IP should be banned after 5 violations");
    }

    /// Test: Password hash is deterministic (SHA-256)
    #[test]
    fn test_security_password_hash_deterministic() {
        let hash1 = hash_password("mypassword");
        let hash2 = hash_password("mypassword");
        assert_eq!(hash1, hash2, "Same password must produce same hash");

        let hash3 = hash_password("different");
        assert_ne!(hash1, hash3, "Different passwords must produce different hashes");
    }

    /// Test: Auth key in WsAuthKeyValidation event includes client IP for ban tracking
    #[test]
    fn test_security_auth_key_event_has_ip() {
        // Verify the AppEvent::WsAuthKeyValidation includes a client_ip field
        // This is a compile-time check - if the event doesn't have 3 fields, this won't compile
        let msg = WsMessage::AuthRequest {
            password_hash: String::new(),
            username: None,
            current_world: None,
            auth_key: Some("test_key".to_string()),
            request_key: false,
        };
        let event = AppEvent::WsAuthKeyValidation(1, Box::new(msg), "10.0.0.1".to_string());

        // Verify we can extract the IP from the event
        if let AppEvent::WsAuthKeyValidation(_client_id, _msg, client_ip) = event {
            assert_eq!(client_ip, "10.0.0.1");
        } else {
            panic!("Event should be WsAuthKeyValidation");
        }
    }

    /// Test: WebSocket auth with correct password succeeds
    #[tokio::test]
    async fn test_security_correct_password_auth_succeeds() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::{SinkExt, StreamExt};
        use crate::websocket::{WsMessage, WsClientInfo};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let port = listener.local_addr().unwrap().port();

        let password = "correctpass";
        let password_hash = hash_password(password);
        let (event_tx, _) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, crate::websocket::UserCredential>>> =
            Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));

        let server_clients = Arc::clone(&clients);
        let ph = password_hash.clone();
        let server_task = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 1, server_clients, ph,
                allow_list, whitelisted, client_addr, event_tx,
                false, users, ban_list,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        let url = format!("ws://127.0.0.1:{}", port);
        let (ws, _) = connect_async(&url).await.unwrap();
        let (mut sink, mut source) = ws.split();

        // Skip ServerHello
        let _ = source.next().await;

        let auth = WsMessage::AuthRequest {
            password_hash,
            username: None,
            current_world: None,
            auth_key: None,
            request_key: false,
        };
        sink.send(WsRawMessage::Text(serde_json::to_string(&auth).unwrap().into())).await.unwrap();

        if let Some(Ok(WsRawMessage::Text(text))) = source.next().await {
            let resp: WsMessage = serde_json::from_str(&text).unwrap();
            if let WsMessage::AuthResponse { success, error, .. } = resp {
                assert!(success, "Correct password should succeed, error: {:?}", error);
            } else {
                panic!("Expected AuthResponse");
            }
        } else {
            panic!("No response received");
        }

        server_task.abort();
    }

    /// Test: Allow list IP matching with wildcards
    #[test]
    fn test_security_allow_list_matching() {
        use crate::websocket::is_ip_in_allow_list;

        // Exact match
        assert!(is_ip_in_allow_list("192.168.1.100", &["192.168.1.100".to_string()]));

        // Wildcard match
        assert!(is_ip_in_allow_list("192.168.1.100", &["192.168.1.*".to_string()]));
        assert!(is_ip_in_allow_list("192.168.1.50", &["192.168.*".to_string()]));

        // Non-match
        assert!(!is_ip_in_allow_list("10.0.0.1", &["192.168.1.*".to_string()]));

        // Empty list
        assert!(!is_ip_in_allow_list("192.168.1.100", &[]));

        // Localhost normalization
        assert!(is_ip_in_allow_list("127.0.0.1", &["localhost".to_string()]));
        assert!(is_ip_in_allow_list("::1", &["localhost".to_string()]));
    }

    /// Test: ServerHello is sent before auth (regression: needed for client UI)
    #[tokio::test]
    async fn test_security_server_hello_sent_first() {
        use tokio::net::TcpListener;
        use tokio_tungstenite::{connect_async, tungstenite::Message as WsRawMessage};
        use futures::StreamExt;
        use crate::websocket::{WsMessage, WsClientInfo};
        use std::sync::Arc;
        use tokio::sync::RwLock;

        let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
        let port = listener.local_addr().unwrap().port();

        let (event_tx, _) = tokio::sync::mpsc::channel::<AppEvent>(100);
        let clients: Arc<RwLock<std::collections::HashMap<u64, WsClientInfo>>> =
            Arc::new(RwLock::new(std::collections::HashMap::new()));
        let allow_list: Arc<std::sync::RwLock<Vec<String>>> =
            Arc::new(std::sync::RwLock::new(Vec::new()));
        let whitelisted: Arc<std::sync::RwLock<Option<String>>> =
            Arc::new(std::sync::RwLock::new(None));
        let ban_list = BanList::new();
        let users: Arc<std::sync::RwLock<std::collections::HashMap<String, crate::websocket::UserCredential>>> =
            Arc::new(std::sync::RwLock::new(std::collections::HashMap::new()));

        let server_clients = Arc::clone(&clients);
        let ph = hash_password("test");
        let server_task = tokio::spawn(async move {
            let (stream, client_addr) = listener.accept().await.unwrap();
            crate::websocket::handle_ws_client(
                stream, 1, server_clients, ph,
                allow_list, whitelisted, client_addr, event_tx,
                false, users, ban_list,
            ).await.ok();
        });

        tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;

        let url = format!("ws://127.0.0.1:{}", port);
        let (ws, _) = connect_async(&url).await.unwrap();
        let (_sink, mut source) = ws.split();

        // First message should be ServerHello
        if let Some(Ok(WsRawMessage::Text(text))) = source.next().await {
            let msg: WsMessage = serde_json::from_str(&text).unwrap();
            assert!(matches!(msg, WsMessage::ServerHello { .. }),
                "First message must be ServerHello, got: {:?}", msg);
        } else {
            panic!("No ServerHello received");
        }

        server_task.abort();
    }

    // ========== Regression Tests ==========
    // These tests use the testserver + testharness for end-to-end testing

    use crate::testserver;
    use crate::testharness::{self, TestConfig, TestWorldConfig, TestEvent, TestAction, WaitCondition};

    /// Helper: find a free TCP port
    fn find_free_port() -> u16 {
        let listener = std::net::TcpListener::bind("127.0.0.1:0").unwrap();
        listener.local_addr().unwrap().port()
    }

    #[test]
    fn test_more_mode_add_output_unit() {
        // Test that add_output correctly triggers more-mode after max_lines visual lines
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // 100 short lines, each fits in one visual line
        let data: String = (1..=100).map(|i| format!("fffff{}\n", i)).collect();
        world.add_output(&data, true, &settings, 24, 80, false, true);

        // max_lines = 24 - 2 = 22
        // After 22 visual lines, pause triggers on the 23rd line.
        // Lines 1-22 go to output without triggering (lines_since_pause accumulates).
        // Line 23: lines_since_pause(22) + 1 > 22 â†’ triggers_pause â†’ goes to output, then paused=true.
        // Lines 24-100 (77 lines) go to pending.
        assert!(world.paused, "Should be paused after 100 lines with max_lines=22");
        assert_eq!(world.output_lines.len(), 23,
            "Expected 23 output lines (22 before trigger + 1 triggering), got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 77,
            "Expected 77 pending lines, got {}", world.pending_lines.len());
    }

    #[test]
    fn test_more_mode_long_wrapped_lines_unit() {
        // Test that add_output correctly triggers more-mode with long lines that wrap
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // 50 lines, each ~120 chars (wraps to 2 visual lines at width 80)
        let data: String = (1..=50).map(|i| {
            format!("{}{}\n", "x".repeat(100), format!("LINE{:03}", i))
        }).collect();
        world.add_output(&data, true, &settings, 24, 80, false, true);

        // max_lines = 22. Each line is 107 chars â†’ wraps to ceil(107/80)=2 visual lines.
        // Line 1: lines_since_pause(0) + 2 = 2, not > 22
        // Line 11: lines_since_pause(20) + 2 = 22, not > 22
        // Line 12: lines_since_pause(22) + 2 = 24, > 22 â†’ triggers_pause!
        // So 12 lines go to output (24 visual lines), 38 go to pending.
        assert!(world.paused, "Should be paused with long wrapped lines");
        assert_eq!(world.output_lines.len(), 12,
            "Expected 12 output lines (each wrapping to 2 visual), got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 38,
            "Expected 38 pending lines, got {}", world.pending_lines.len());
    }

    #[test]
    fn test_partial_line_tracking_across_chunks() {
        // Simulate a single long MUD line arriving in multiple TCP chunks.
        // The line is: "fffff1 fffff2 ... fffff100\n" (~1000 bytes)
        // Arriving in 3 chunks without intermediate newlines.
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // Build the full line
        let full_line: String = (1..=100).map(|i| format!("fffff{}", i)).collect::<Vec<_>>().join(" ");
        let full_with_newline = format!("{}\n", full_line);
        let bytes = full_with_newline.as_bytes();

        // Split into 3 roughly equal chunks (no newline until the very end)
        let chunk1 = std::str::from_utf8(&bytes[..333]).unwrap();
        let chunk2 = std::str::from_utf8(&bytes[333..666]).unwrap();
        let chunk3 = std::str::from_utf8(&bytes[666..]).unwrap();

        // Verify chunks don't have intermediate newlines
        assert!(!chunk1.contains('\n'), "chunk1 should not contain newline");
        assert!(!chunk2.contains('\n'), "chunk2 should not contain newline");
        assert!(chunk3.ends_with('\n'), "chunk3 should end with newline");

        // Process each chunk separately (simulating TCP reads)
        world.add_output(chunk1, true, &settings, 48, 80, false, true);
        assert_eq!(world.output_lines.len(), 1, "Chunk 1: should have 1 output line (partial)");
        assert!(!world.partial_line.is_empty(), "Chunk 1: partial_line should be set");

        world.add_output(chunk2, true, &settings, 48, 80, false, true);
        assert_eq!(world.output_lines.len(), 1, "Chunk 2: should STILL have 1 output line (updated partial)");
        assert!(!world.partial_line.is_empty(), "Chunk 2: partial_line should STILL be set (not lost)");

        world.add_output(chunk3, true, &settings, 48, 80, false, true);
        assert_eq!(world.output_lines.len(), 1, "Chunk 3: should STILL have 1 output line (completed)");
        assert!(world.partial_line.is_empty(), "Chunk 3: partial_line should be empty (line complete)");
        assert_eq!(world.pending_lines.len(), 0, "Should have 0 pending lines (just 1 logical line)");

        // Verify the final line content matches the original
        assert_eq!(world.output_lines[0].text, full_line,
            "Output line should be the complete original line");
    }

    #[test]
    fn test_partial_line_many_small_chunks() {
        // Simulate a single long line arriving in many small TCP chunks.
        // Without the fix, each chunk after the 2nd would create a new logical line.
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        let full_line: String = (1..=200).map(|i| format!("w{}", i)).collect::<Vec<_>>().join(" ");
        let full_with_newline = format!("{}\n", full_line);
        let bytes = full_with_newline.as_bytes();

        // Send in 20 small chunks
        let chunk_size = bytes.len() / 20;
        for i in 0..20 {
            let start = i * chunk_size;
            let end = if i == 19 { bytes.len() } else { (i + 1) * chunk_size };
            let chunk = std::str::from_utf8(&bytes[start..end]).unwrap();
            world.add_output(chunk, true, &settings, 48, 80, false, true);
        }

        // Should be exactly 1 logical line, not 10+ fragmented lines
        assert_eq!(world.output_lines.len(), 1,
            "Should have exactly 1 output line, not {} (fragmented by partial bug)",
            world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 0, "Should have 0 pending lines");
        assert_eq!(world.output_lines[0].text, full_line);
    }

    #[test]
    fn test_more_mode_multiple_chunks() {
        // Test that more-mode works correctly when add_output is called multiple times
        // (simulating multiple TCP chunks arriving from the MUD server)
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // Simulate 10 TCP chunks of 100 lines each = 1000 total lines
        for chunk in 0..10 {
            let data: String = (1..=100).map(|i| {
                format!("fffff{}\n", chunk * 100 + i)
            }).collect();
            world.add_output(&data, true, &settings, 48, 80, false, true);
        }

        // max_lines = 46. After 46+1=47 lines, pause triggers.
        // First chunk (100 lines): 47 go to output, 53 go to pending
        // Subsequent chunks: all go to pending (paused is true)
        // Total pending: 53 + 9*100 = 953
        assert!(world.paused, "Should be paused after 1000 lines across 10 chunks");
        assert_eq!(world.output_lines.len(), 47,
            "Expected 47 output lines (max_lines=46, trigger on line 47), got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 953,
            "Expected 953 pending lines, got {}", world.pending_lines.len());
    }

    #[test]
    fn test_more_mode_1000_lines_single_call() {
        // Test that more-mode works with 1000 lines in a single add_output call
        // (simulating a TF #for loop generating all output at once)
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        let data: String = (1..=1000).map(|i| {
            format!("fffff{}\n", i)
        }).collect();
        world.add_output(&data, true, &settings, 48, 80, false, true);

        assert!(world.paused, "Should be paused after 1000 lines");
        assert_eq!(world.output_lines.len(), 47,
            "Expected 47 output lines, got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 953,
            "Expected 953 pending lines, got {}", world.pending_lines.len());
    }

    #[test]
    fn test_more_mode_multi_chunk() {
        // Test that more-mode works correctly when data arrives in multiple TCP chunks.
        // Each chunk is a separate add_output call. The pause trigger must not leak
        // extra lines into output when the triggering line is the last in a chunk.
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // output_height=24, max_lines=22
        // Send 200 lines in chunks of varying sizes
        let all_lines: Vec<String> = (0..200).map(|i| format!("{}\n", i)).collect();

        // Chunk 1: lines 0-22 (23 lines). Line 22 triggers pause (lsp=22, 22+1=23>22).
        // This is the LAST line of the chunk, so pending is empty after the trigger.
        let chunk1: String = all_lines[0..23].concat();
        world.add_output(&chunk1, true, &settings, 24, 80, false, true);

        // After chunk 1: should have 23 output lines and be paused.
        // The key assertion: paused must remain true even though pending is empty.
        assert_eq!(world.output_lines.len(), 23,
            "Chunk 1: Expected 23 output lines, got {}", world.output_lines.len());

        // Chunk 2: lines 23-99 (77 lines). Already paused, all should go to pending.
        let chunk2: String = all_lines[23..100].concat();
        world.add_output(&chunk2, true, &settings, 24, 80, false, true);

        assert!(world.paused, "Should still be paused after chunk 2");
        assert_eq!(world.output_lines.len(), 23,
            "Chunk 2: Expected still 23 output lines, got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 77,
            "Chunk 2: Expected 77 pending lines, got {}", world.pending_lines.len());

        // Chunk 3: lines 100-199 (100 lines). Still paused, all go to pending.
        let chunk3: String = all_lines[100..200].concat();
        world.add_output(&chunk3, true, &settings, 24, 80, false, true);

        assert!(world.paused, "Should still be paused after chunk 3");
        assert_eq!(world.output_lines.len(), 23,
            "Chunk 3: Expected still 23 output lines, got {}", world.output_lines.len());
        assert_eq!(world.pending_lines.len(), 177,
            "Chunk 3: Expected 177 pending lines, got {}", world.pending_lines.len());
    }

    #[test]
    fn test_release_pending_counts_visual_lines() {
        // Test that release_pending counts visual lines, not logical lines.
        // With output_width=80, a 500-char line wraps to ceil(500/80) = 7 visual lines.
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // Create 10 long lines, each ~500 chars (7 visual lines each at width 80)
        let long_word = "x".repeat(500);
        let data: String = (0..10).map(|_| format!("{}\n", long_word)).collect();
        world.add_output(&data, true, &settings, 48, 80, false, true);

        // max_lines = 46. Each line = 7 visual lines.
        // Lines 1-6: 42 visual lines (< 46), go to output
        // Line 7: 42+7=49 > 46, triggers more. But 7 > 46? No, 7 < 46, so normal trigger.
        // Lines 8-10: go to pending
        assert!(world.paused, "Should be paused");

        let output_count = world.output_lines.len();
        let pending_count = world.pending_lines.len();
        assert!(output_count > 0 && pending_count > 0,
            "Should have both output ({}) and pending ({}) lines", output_count, pending_count);

        // Now test release_pending with visual budget of 46 (output_height - 2)
        // Each pending line is 7 visual lines. Budget=46 fits 6 lines (42 visual) or 7 lines (49 visual).
        // Since 42+7=49 > 46, it should stop at 6 lines (the 7th would exceed budget).
        let pending_before = world.pending_lines.len();
        world.release_pending(46, 80);
        let released = pending_before - world.pending_lines.len();

        // Should release 6 lines (42 visual lines fits in 46 budget, 49 would exceed)
        assert!(released <= 7, "Should release at most 7 lines (visual budget), got {}", released);
        assert!(released >= 1, "Should release at least 1 line, got {}", released);
    }

    #[test]
    fn test_oversized_single_line_splits() {
        // Test that a single oversized line gets pre-wrapped into individual visual lines
        // stored as separate OutputLines, so more-mode can paginate with Tab.
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // Create a single very long line: 10000 chars at width 80, max_lines = 46
        // wrap_ansi_line produces ceil(10000/80) = 125 visual lines
        // First 46 go to output_lines, remaining 79 go to pending_lines
        let long_line = "x".repeat(10000) + "\n";
        world.add_output(&long_line, true, &settings, 48, 80, false, true);

        // Should be paused with first max_lines visual lines in output, rest in pending
        assert!(world.paused, "Should be paused");
        assert_eq!(world.output_lines.len(), 46, "First 46 visual lines in output");
        assert_eq!(world.pending_lines.len(), 79, "Remaining 79 visual lines in pending");

        // Each output line should be exactly 1 visual line (pre-wrapped)
        for (i, ol) in world.output_lines.iter().enumerate() {
            let vl = visual_line_count(&ol.text, 80);
            assert_eq!(vl, 1, "Output line {} should be 1 visual line, got {}", i, vl);
        }

        // Tab should release one screenful at a time
        let pending_before = world.pending_lines.len();
        world.release_pending(46, 80);
        assert!(world.pending_lines.len() < pending_before, "Tab should release pending lines");
    }

    #[test]
    fn test_release_pending_visual_lines_mixed() {
        // Test release_pending with a mix of short and long lines
        let mut world = World::new("test");
        let settings = Settings { more_mode_enabled: true, ..Settings::default() };

        // Add 3 short lines to trigger more-mode, then add long lines to pending
        // First fill output to near max_lines
        let short_data: String = (0..45).map(|i| format!("short line {}\n", i)).collect();
        world.add_output(&short_data, true, &settings, 48, 80, false, true);

        // Now add mixed content: 1 short line, then 1 very long line, then 1 short line
        let mixed: String = format!("short\n{}\nafter\n", "x".repeat(500));
        world.add_output(&mixed, true, &settings, 48, 80, false, true);

        assert!(world.paused, "Should be paused");
        let pending = world.pending_lines.len();
        assert!(pending > 0, "Should have pending lines");

        // Release with visual budget of 46
        // "short" = 1 visual line
        // 500-char line = ceil(500/80) = 7 visual lines
        // "after" = 1 visual line
        // total = 9 visual lines < 46, so all should be released
        world.release_pending(46, 80);
        assert_eq!(world.pending_lines.len(), 0,
            "All {} pending lines should fit in visual budget of 46", pending);
    }

    #[test]
    fn test_wrap_ansi_line_no_spaces() {
        // No spaces = hard wrap at character boundary
        let line = "a".repeat(100);
        let lines = wrap_ansi_line(&line, 10);
        assert_eq!(lines.len(), 10, "Should produce 10 visual lines");
        for (i, vl) in lines.iter().enumerate() {
            let stripped = strip_ansi_codes(vl);
            if i < 9 {
                assert_eq!(stripped.len(), 10, "Line {} should be 10 chars", i);
            } else {
                assert_eq!(stripped.len(), 10, "Last line should be 10 chars");
            }
        }
    }

    #[test]
    fn test_wrap_ansi_line_word_boundary() {
        // Word wrapping at width 10:
        //   "aaa bbb ccc ddd eee fff"
        //   Line 1: "aaa bbb " (wraps at space before "ccc")
        //   Line 2: "ccc ddd " (wraps at space before "eee")
        //   Line 3: "eee fff"
        let line = "aaa bbb ccc ddd eee fff";
        let lines = wrap_ansi_line(line, 10);
        assert!(lines.len() >= 2, "Should produce multiple lines, got {}", lines.len());
        // First line should break at word boundary
        let first_stripped = strip_ansi_codes(&lines[0]);
        assert!(first_stripped.starts_with("aaa bbb"),
            "First line should start with 'aaa bbb': {:?}", first_stripped);
    }

    #[test]
    fn test_wrap_ansi_line_with_ansi() {
        // Test ANSI color codes carried across line boundaries
        let line = format!("\x1b[31m{}\x1b[0m", "r".repeat(25));
        let lines = wrap_ansi_line(&line, 10);
        assert_eq!(lines.len(), 3, "Should produce 3 lines");
        // Second line should carry the red color code
        assert!(lines[1].contains("\x1b[31m"),
            "Second line should carry color code: {:?}", lines[1]);
        // First line should end with reset
        assert!(lines[0].ends_with("\x1b[0m"),
            "First line should end with reset: {:?}", lines[0]);
    }

    #[test]
    fn test_wrap_ansi_line_short_passthrough() {
        let line = "hello world";
        let lines = wrap_ansi_line(line, 80);
        assert_eq!(lines.len(), 1);
        // Should contain the original text (plus trailing reset)
        assert!(strip_ansi_codes(&lines[0]).contains("hello world"));
    }

    #[test]
    fn test_wrap_ansi_line_fffff_pattern() {
        // Simulate the actual test case: space-separated fffff words at width 80
        let words: Vec<String> = (0..1000).map(|i| format!("fffff{}", i)).collect();
        let line = words.join(" ");
        let lines = wrap_ansi_line(&line, 80);
        assert!(lines.len() > 1, "Should produce multiple visual lines");
        // Each visual line (except last) should be <= 80 display width
        for (i, vl) in lines.iter().enumerate() {
            let stripped = strip_ansi_codes(vl);
            let dw: usize = stripped.chars().map(|c| unicode_width::UnicodeWidthChar::width(c).unwrap_or(0)).sum();
            assert!(dw <= 80, "Line {} has display width {} (max 80): {:?}",
                i, dw, &stripped[..40.min(stripped.len())]);
        }
        // Verify word boundaries: no line should start with a partial word
        for (i, vl) in lines.iter().enumerate() {
            if i > 0 {
                let stripped = strip_ansi_codes(vl);
                assert!(stripped.starts_with("fffff"),
                    "Line {} should start at a word boundary: {:?}",
                    i, &stripped[..20.min(stripped.len())]);
            }
        }
    }

    #[tokio::test]
    async fn test_regression_more_mode_triggers_on_flood() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood");

        // Start server
        let server = tokio::spawn(testserver::run_server_port(port, scenario));

        // Give server time to bind
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have Connected event
        assert!(events.iter().any(|e| matches!(e, TestEvent::Connected(n) if n == "test")),
            "Expected Connected event");

        // Should have TextReceived events
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert!(text_count > 0, "Expected TextReceived events, got 0");

        // Should have MoreTriggered event (30 lines with output_height=24 should trigger)
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event. Events: {:?}", events);

        // Should have Disconnected event
        assert!(events.iter().any(|e| matches!(e, TestEvent::Disconnected(_))),
            "Expected Disconnected event");

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_more_mode_disabled_no_pause() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,  // Disabled!
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should NOT have MoreTriggered event
        assert!(!events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Should NOT have MoreTriggered with more_mode disabled. Events: {:?}", events);

        // Should still get all 30 lines
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert_eq!(text_count, 30, "Expected 30 TextReceived events, got {}", text_count);

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_activity_count_multiple_worlds() {
        let port1 = find_free_port();
        let port2 = find_free_port();
        let port3 = find_free_port();

        // World 1: idle (we'll be viewing this one)
        // World 2,3: basic output (generates unseen lines)
        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("idle")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));
        let server3 = tokio::spawn(testserver::run_server_port(port3, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world3".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port3,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have UnseenChanged events for worlds 2 and 3 (since we're viewing world 1)
        let unseen_events: Vec<_> = events.iter()
            .filter(|e| matches!(e, TestEvent::UnseenChanged(_, n) if *n > 0))
            .collect();
        assert!(!unseen_events.is_empty(),
            "Expected UnseenChanged events for non-current worlds. Events: {:?}", events);

        // Should have ActivityChanged events
        assert!(events.iter().any(|e| matches!(e, TestEvent::ActivityChanged(n) if *n > 0)),
            "Expected ActivityChanged > 0. Events: {:?}", events);

        server1.abort();
        let _ = server2.await;
        let _ = server3.await;
    }

    #[tokio::test]
    async fn test_regression_unseen_cleared_on_switch() {
        let port1 = find_free_port();
        let port2 = find_free_port();

        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("idle")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let actions = vec![
            // Wait for some text from world2 to generate unseen
            TestAction::WaitForEvent(WaitCondition::TextReceivedCount(3)),
            // Wait a bit more for all output
            TestAction::Sleep(Duration::from_millis(500)),
            // Switch to world2 - should clear unseen
            TestAction::SwitchWorld("world2".to_string()),
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // Should have unseen increased for world2 while viewing world1
        assert!(events.iter().any(|e| matches!(e, TestEvent::UnseenChanged(n, count) if n == "world2" && *count > 0)),
            "Expected UnseenChanged(world2, >0). Events: {:?}", events);

        // Should have WorldSwitched
        assert!(events.iter().any(|e| matches!(e, TestEvent::WorldSwitched(n) if n == "world2")),
            "Expected WorldSwitched(world2)");

        // After switching, unseen should be cleared
        // Find the last UnseenChanged for world2 after WorldSwitched
        let switch_idx = events.iter().position(|e| matches!(e, TestEvent::WorldSwitched(n) if n == "world2"));
        if let Some(idx) = switch_idx {
            let unseen_after: Vec<_> = events[idx..].iter()
                .filter(|e| matches!(e, TestEvent::UnseenChanged(n, _) if n == "world2"))
                .collect();
            if let Some(TestEvent::UnseenChanged(_, count)) = unseen_after.last() {
                assert_eq!(*count, 0, "Unseen should be 0 after switching to world2");
            }
        }

        server1.abort();
        let _ = server2.await;
    }

    #[tokio::test]
    async fn test_regression_auto_login_connect_type() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("auto_login_connect");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: "testuser".to_string(),
                password: "testpass".to_string(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have auto-login sent
        assert!(events.iter().any(|e| matches!(e, TestEvent::AutoLoginSent(_, cmd) if cmd == "connect testuser testpass")),
            "Expected AutoLoginSent with 'connect testuser testpass'. Events: {:?}", events);

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_auto_login_prompt_type() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("auto_login_prompt");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Prompt,
                username: "testuser".to_string(),
                password: "testpass".to_string(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have username sent on first prompt
        assert!(events.iter().any(|e| matches!(e, TestEvent::AutoLoginSent(_, cmd) if cmd == "testuser")),
            "Expected AutoLoginSent with 'testuser'. Events: {:?}", events);

        // Should have password sent on second prompt
        assert!(events.iter().any(|e| matches!(e, TestEvent::AutoLoginSent(_, cmd) if cmd == "testpass")),
            "Expected AutoLoginSent with 'testpass'. Events: {:?}", events);

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_disconnect_detection() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("disconnect_after");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have Connected
        assert!(events.iter().any(|e| matches!(e, TestEvent::Connected(_))),
            "Expected Connected event");

        // Should have TextReceived (at least "Hello!" and "Goodbye!")
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert!(text_count >= 2, "Expected at least 2 TextReceived events, got {}", text_count);

        // Should have Disconnected
        assert!(events.iter().any(|e| matches!(e, TestEvent::Disconnected(_))),
            "Expected Disconnected event");

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_more_mode_500_lines_scroll_through() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood_500");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(30),
        };

        // Build actions: wait for more-mode to trigger, then Tab through all pages
        let mut actions = vec![
            TestAction::WaitForEvent(WaitCondition::MoreTriggered),
            // Wait a moment for all data to arrive
            TestAction::Sleep(Duration::from_millis(500)),
        ];

        // Tab release enough times to drain all pending lines
        // 500 lines / 22 per page = ~23 tabs needed (with margin)
        for _ in 0..30 {
            actions.push(TestAction::TabRelease);
        }

        let events = testharness::run_test_scenario(config, actions).await;

        // Should have MoreTriggered
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event");

        // Should have received all 500 lines
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert_eq!(text_count, 500, "Expected 500 TextReceived events, got {}", text_count);

        // Should have MoreReleased at least once (final release)
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreReleased(_))),
            "Expected MoreReleased event");

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_regression_more_mode_500_lines_jump_to_end() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood_500");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(30),
        };

        let actions = vec![
            TestAction::WaitForEvent(WaitCondition::MoreTriggered),
            // Wait for all data to arrive
            TestAction::Sleep(Duration::from_millis(500)),
            // Jump to end (Escape+j) - release all at once
            TestAction::JumpToEnd,
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // Should have MoreTriggered
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event");

        // Should have received all 500 lines
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert_eq!(text_count, 500, "Expected 500 TextReceived events, got {}", text_count);

        // Should have MoreReleased
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreReleased(_))),
            "Expected MoreReleased event after JumpToEnd");

        let _ = server.await;
    }

    // ========== WebSocket Broadcast Tests ==========

    #[tokio::test]
    async fn test_ws_broadcast_activity_on_unseen() {
        let port1 = find_free_port();
        let port2 = find_free_port();

        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("idle")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Verify WsBroadcastActivity was emitted with count > 0
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastActivity(n) if *n > 0)),
            "Expected WsBroadcastActivity with count > 0. Events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastActivity(_))).collect::<Vec<_>>());

        // Verify WsBroadcastUnseen was emitted for world2 (index 1) with count > 0
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastUnseen(1, n) if *n > 0)),
            "Expected WsBroadcastUnseen(1, >0). WsBroadcastUnseen events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastUnseen(_, _))).collect::<Vec<_>>());

        server1.abort();
        let _ = server2.await;
    }

    #[tokio::test]
    async fn test_ws_broadcast_pending_on_more() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Verify MoreTriggered happened
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event");

        // Verify WsBroadcastPending was emitted with count > 0
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastPending(0, n) if *n > 0)),
            "Expected WsBroadcastPending(0, >0). WsBroadcastPending events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastPending(_, _))).collect::<Vec<_>>());

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_ws_broadcast_released_on_tab() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood_500");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(30),
        };

        let actions = vec![
            TestAction::WaitForEvent(WaitCondition::MoreTriggered),
            TestAction::Sleep(Duration::from_millis(500)),
            TestAction::TabRelease,
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // TabRelease calls World::release_pending directly, not App::release_pending_screenful,
        // so we won't see WsBroadcastReleased from TabRelease. But we should see WsBroadcastPending
        // from the initial flood when lines were added to pending.
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastPending(0, n) if *n > 0)),
            "Expected WsBroadcastPending(0, >0) from initial flood");

        // MoreTriggered should have been emitted
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event");

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_ws_release_pending_from_client() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood_500");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(30),
        };

        let actions = vec![
            TestAction::WaitForEvent(WaitCondition::MoreTriggered),
            TestAction::Sleep(Duration::from_millis(500)),
            // Simulate WS client releasing pending lines
            TestAction::WsReleasePending { world_name: "test".to_string(), count: 22 },
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // WsReleasePending uses App::release_pending_screenful which broadcasts
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastReleased(0, n) if *n > 0)),
            "Expected WsBroadcastReleased(0, >0) from WS client release. Events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastReleased(_, _))).collect::<Vec<_>>());

        // Should also see updated pending count broadcast
        // Find the last WsBroadcastPending - its count should be less than the peak
        let pending_events: Vec<_> = events.iter()
            .filter(|e| matches!(e, TestEvent::WsBroadcastPending(0, _)))
            .collect();
        assert!(pending_events.len() >= 2,
            "Expected at least 2 WsBroadcastPending events (initial flood + post-release). Got: {:?}", pending_events);

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_ws_mark_seen_from_client() {
        let port1 = find_free_port();
        let port2 = find_free_port();

        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("idle")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let actions = vec![
            // Wait for unseen on world2
            TestAction::WaitForEvent(WaitCondition::TextReceivedCount(3)),
            TestAction::Sleep(Duration::from_millis(500)),
            // Simulate WS client marking world2 as seen
            TestAction::WsMarkWorldSeen("world2".to_string()),
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // Should have unseen events for world2 before marking seen
        assert!(events.iter().any(|e| matches!(e, TestEvent::UnseenChanged(n, count) if n == "world2" && *count > 0)),
            "Expected UnseenChanged(world2, >0)");

        // Should have WsBroadcastUnseenCleared for world2 (index 1)
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastUnseenCleared(1))),
            "Expected WsBroadcastUnseenCleared(1). Events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastUnseenCleared(_))).collect::<Vec<_>>());

        // Unseen should be cleared after marking seen
        assert!(events.iter().any(|e| matches!(e, TestEvent::UnseenChanged(n, 0) if n == "world2")),
            "Expected UnseenChanged(world2, 0) after marking seen");

        server1.abort();
        let _ = server2.await;
    }

    #[tokio::test]
    async fn test_ws_send_command_resets_pause() {
        let port = find_free_port();
        let scenario = testserver::get_scenario("more_flood_500");

        let server = tokio::spawn(testserver::run_server_port(port, scenario));
        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![TestWorldConfig {
                name: "test".to_string(),
                host: "127.0.0.1".to_string(),
                port,
                use_ssl: false,
                auto_login_type: AutoConnectType::Connect,
                username: String::new(),
                password: String::new(),
            }],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: true,
            max_duration: Duration::from_secs(30),
        };

        let actions = vec![
            TestAction::WaitForEvent(WaitCondition::MoreTriggered),
            TestAction::Sleep(Duration::from_millis(500)),
            // Send a command via WS - should reset lines_since_pause
            TestAction::WsSendCommand { world_name: "test".to_string(), command: "look".to_string() },
            // Release all pending to get past the pause
            TestAction::JumpToEnd,
        ];

        let events = testharness::run_test_scenario(config, actions).await;

        // MoreTriggered should have happened from the flood
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreTriggered(_, _))),
            "Expected MoreTriggered event");

        // MoreReleased should have happened from JumpToEnd
        assert!(events.iter().any(|e| matches!(e, TestEvent::MoreReleased(_))),
            "Expected MoreReleased event after JumpToEnd");

        // All 500 lines should have been received
        let text_count = events.iter().filter(|e| matches!(e, TestEvent::TextReceived(_, _))).count();
        assert_eq!(text_count, 500, "Expected 500 TextReceived events, got {}", text_count);

        let _ = server.await;
    }

    #[tokio::test]
    async fn test_ws_activity_count_multi_world() {
        let port1 = find_free_port();
        let port2 = find_free_port();
        let port3 = find_free_port();

        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("idle")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));
        let server3 = tokio::spawn(testserver::run_server_port(port3, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world3".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port3,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should see WsBroadcastActivity(2) at peak when both world2 and world3 have unseen
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastActivity(2))),
            "Expected WsBroadcastActivity(2). Activity events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastActivity(_))).collect::<Vec<_>>());

        server1.abort();
        let _ = server2.await;
        let _ = server3.await;
    }

    #[tokio::test]
    async fn test_ws_broadcast_server_data_routing() {
        let port1 = find_free_port();
        let port2 = find_free_port();

        let server1 = tokio::spawn(testserver::run_server_port(port1, testserver::get_scenario("basic_output")));
        let server2 = tokio::spawn(testserver::run_server_port(port2, testserver::get_scenario("basic_output")));

        tokio::time::sleep(Duration::from_millis(100)).await;

        let config = TestConfig {
            worlds: vec![
                TestWorldConfig {
                    name: "world1".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port1,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
                TestWorldConfig {
                    name: "world2".to_string(),
                    host: "127.0.0.1".to_string(),
                    port: port2,
                    use_ssl: false,
                    auto_login_type: AutoConnectType::Connect,
                    username: String::new(),
                    password: String::new(),
                },
            ],
            output_height: 24,
            output_width: 80,
            more_mode_enabled: false,
            max_duration: Duration::from_secs(10),
        };

        let events = testharness::run_test_scenario(config, vec![]).await;

        // Should have WsBroadcastServerData for world1 (index 0)
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastServerData(0))),
            "Expected WsBroadcastServerData(0). ServerData events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastServerData(_))).collect::<Vec<_>>());

        // Should have WsBroadcastServerData for world2 (index 1)
        assert!(events.iter().any(|e| matches!(e, TestEvent::WsBroadcastServerData(1))),
            "Expected WsBroadcastServerData(1). ServerData events: {:?}",
            events.iter().filter(|e| matches!(e, TestEvent::WsBroadcastServerData(_))).collect::<Vec<_>>());

        let _ = server1.await;
        let _ = server2.await;
    }

    /// Structural comparison test: verify that the JS INTERNAL_COMMANDS list in app.js
    /// matches the command strings handled by Rust's parse_command().
    /// This catches drift when commands are added to Rust but not to JS (or vice versa).
    #[test]
    fn test_command_parity_js_vs_rust() {
        // --- Extract JS INTERNAL_COMMANDS from app.js ---
        let app_js = std::fs::read_to_string("src/web/app.js")
            .expect("Failed to read src/web/app.js");

        // Find the INTERNAL_COMMANDS array
        let start_marker = "const INTERNAL_COMMANDS = [";
        let start_pos = app_js.find(start_marker)
            .expect("Could not find INTERNAL_COMMANDS in app.js");
        let after_start = &app_js[start_pos + start_marker.len()..];
        let end_pos = after_start.find(']')
            .expect("Could not find closing ] for INTERNAL_COMMANDS");
        let array_content = &after_start[..end_pos];

        // Parse the comma-separated quoted strings
        let mut js_commands: Vec<String> = Vec::new();
        for part in array_content.split(',') {
            let trimmed = part.trim().trim_matches('\'').trim_matches('"');
            if !trimmed.is_empty() {
                js_commands.push(trimmed.to_lowercase());
            }
        }
        js_commands.sort();
        js_commands.dedup();

        // --- Build expected command list from Rust parse_command() ---
        // These are the command strings (without /) that parse_command() matches on.
        // When adding a new command to parse_command(), add it here too.
        let mut rust_commands: Vec<String> = vec![
            "help", "version", "quit", "reload", "setup", "web", "actions",
            "connections", "l", "worlds", "world", "connect", "disconnect", "dc",
            "flush", "menu", "send", "keepalive", "gag", "ban", "unban",
            "testmusic", "dump", "notify", "addworld", "edit", "tag", "tags",
            "dict", "urban", "translate", "tr",
        ].into_iter().map(|s| s.to_string()).collect();
        rust_commands.sort();
        rust_commands.dedup();

        // --- Compare ---
        let js_set: std::collections::HashSet<&str> = js_commands.iter().map(|s| s.as_str()).collect();
        let rust_set: std::collections::HashSet<&str> = rust_commands.iter().map(|s| s.as_str()).collect();

        let missing_from_js: Vec<&&str> = rust_set.difference(&js_set).collect();
        let extra_in_js: Vec<&&str> = js_set.difference(&rust_set).collect();

        assert!(missing_from_js.is_empty() && extra_in_js.is_empty(),
            "Command parity mismatch between Rust parse_command() and JS INTERNAL_COMMANDS!\n\
             Missing from JS (present in Rust): {:?}\n\
             Extra in JS (not in Rust): {:?}\n\
             \n\
             To fix: update INTERNAL_COMMANDS in src/web/app.js and rust_commands in this test.",
            missing_from_js, extra_in_js);
    }
}
